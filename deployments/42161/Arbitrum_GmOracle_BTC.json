{
  "address": "0x35bcD530EbF2d8Ed852C2ac97c2A2b71a19845c3",
  "abi": [
    {
      "type": "constructor",
      "inputs": [
        {
          "name": "_reader",
          "type": "address",
          "internalType": "contract IGmxReader"
        },
        {
          "name": "_indexTokenAggregator",
          "type": "address",
          "internalType": "contract IAggregator"
        },
        {
          "name": "_shortTokenAggregator",
          "type": "address",
          "internalType": "contract IAggregator"
        },
        {
          "name": "_market",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_indexToken",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_dataStore",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_desc",
          "type": "string",
          "internalType": "string"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "dataStore",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "decimals",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint8",
          "internalType": "uint8"
        }
      ],
      "stateMutability": "pure"
    },
    {
      "type": "function",
      "name": "expansionFactorIndex",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "expansionFactorShort",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "get",
      "inputs": [
        {
          "name": "",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        },
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "indexAggregator",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IAggregator"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "name",
      "inputs": [
        {
          "name": "",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "string",
          "internalType": "string"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "peek",
      "inputs": [
        {
          "name": "",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        },
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "peekSpot",
      "inputs": [
        {
          "name": "data",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "rate",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "reader",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IGmxReader"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "shortAggregator",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IAggregator"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "symbol",
      "inputs": [
        {
          "name": "",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "string",
          "internalType": "string"
        }
      ],
      "stateMutability": "view"
    }
  ],
  "bytecode": "0x6101c0604052348015610010575f5ffd5b506040516111e43803806111e483398101604081905261002f9161034e565b6001600160a01b03878116608081905287821660a052868216610100528482166101605283821661012081905260405163714af34b60e01b8152600481019190915291861660248301525f9163714af34b90604401608060405180830381865afa15801561009f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906100c39190610453565b8051604082015160608301516001600160a01b039081166101a0529081166101805290811661014052610160519192506100fd9116610237565b60a0516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561013b573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061015f91906104d7565b61016a90601e610512565b6101749190610512565b61017f90600a610614565b60c0526101a051610198906001600160a01b0316610237565b610100516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156101d7573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906101fb91906104d7565b61020690601e610512565b6102109190610512565b61021b90600a610614565b60e0525f61022983826106a6565b505050505050505050610776565b60408051600481526024810182526020810180516001600160e01b031663313ce56760e01b17905290515f91829182916001600160a01b0386169161027c9190610760565b5f60405180830381855afa9150503d805f81146102b4576040519150601f19603f3d011682016040523d82523d5f602084013e6102b9565b606091505b50915091508180156102cc575080516020145b6102d75760126102eb565b808060200190518101906102eb91906104d7565b949350505050565b6001600160a01b0381168114610307575f5ffd5b50565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f191681016001600160401b03811182821017156103465761034661030a565b604052919050565b5f5f5f5f5f5f5f60e0888a031215610364575f5ffd5b875161036f816102f3565b6020890151909750610380816102f3565b6040890151909650610391816102f3565b60608901519095506103a2816102f3565b60808901519094506103b3816102f3565b60a08901519093506103c4816102f3565b60c08901519092506001600160401b038111156103df575f5ffd5b8801601f81018a136103ef575f5ffd5b80516001600160401b038111156104085761040861030a565b61041b601f8201601f191660200161031e565b8181528b602083850101111561042f575f5ffd5b8160208401602083015e5f6020838301015280935050505092959891949750929550565b5f6080828403128015610464575f5ffd5b50604051608081016001600160401b03811182821017156104875761048761030a565b6040528251610495816102f3565b815260208301516104a5816102f3565b602082015260408301516104b8816102f3565b604082015260608301516104cb816102f3565b60608201529392505050565b5f602082840312156104e7575f5ffd5b815160ff811681146104f7575f5ffd5b9392505050565b634e487b7160e01b5f52601160045260245ffd5b60ff828116828216039081111561052b5761052b6104fe565b92915050565b6001815b600184111561056c57808504811115610550576105506104fe565b600184161561055e57908102905b60019390931c928002610535565b935093915050565b5f826105825750600161052b565b8161058e57505f61052b565b81600181146105a457600281146105ae576105ca565b600191505061052b565b60ff8411156105bf576105bf6104fe565b50506001821b61052b565b5060208310610133831016604e8410600b84101617156105ed575081810a61052b565b6105f95f198484610531565b805f190482111561060c5761060c6104fe565b029392505050565b5f6104f760ff841683610574565b600181811c9082168061063657607f821691505b60208210810361065457634e487b7160e01b5f52602260045260245ffd5b50919050565b601f8211156106a157805f5260205f20601f840160051c8101602085101561067f5750805b601f840160051c820191505b8181101561069e575f815560010161068b565b50505b505050565b81516001600160401b038111156106bf576106bf61030a565b6106d3816106cd8454610622565b8461065a565b6020601f821160018114610705575f83156106ee5750848201515b5f19600385901b1c1916600184901b17845561069e565b5f84815260208120601f198516915b828110156107345787850151825560209485019460019092019101610714565b508482101561075157868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b5f82518060208501845e5f920191825250919050565b60805160a05160c05160e05161010051610120516101405161016051610180516101a0516109d661080e5f395f61055901525f61052a01525f6104fb01525f6104cc01525f818161016001526104a001525f818161012101526103e401525f818160d801526103c301525f81816101ae015261031501525f8181610187015261033601525f8181610208015261047101526109d65ff3fe608060405234801561000f575f5ffd5b50600436106100cf575f3560e01c8063c699c4d61161007d578063d568866c11610058578063d568866c146101d0578063d6d7d5251461022a578063eeb8a8d31461022a575f5ffd5b8063c699c4d6146101d0578063d39bbef0146101f0578063d4fc42c614610203575f5ffd5b8063660d0d67116100ad578063660d0d671461015b578063baf4276214610182578063bd5736b4146101a9575f5ffd5b8063224a2b6f146100d3578063313ce5671461010d57806347f63cf61461011c575b5f5ffd5b6100fa7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b60405160128152602001610104565b6101437f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610104565b6101437f000000000000000000000000000000000000000000000000000000000000000081565b6101437f000000000000000000000000000000000000000000000000000000000000000081565b6100fa7f000000000000000000000000000000000000000000000000000000000000000081565b6101e36101de3660046106c5565b610254565b6040516101049190610733565b6100fa6101fe3660046106c5565b6102e7565b6101437f000000000000000000000000000000000000000000000000000000000000000081565b61023d6102383660046106c5565b6102fa565b604080519215158352602083019190915201610104565b60605f805461026290610768565b80601f016020809104026020016040519081016040528092919081815260200182805461028e90610768565b80156102d95780601f106102b0576101008083540402835291602001916102d9565b820191905f5260205f20905b8154815290600101906020018083116102bc57829003601f168201915b505050505090505b92915050565b5f6102f283836102fa565b949350505050565b5f5f6001610306610311565b915091509250929050565b5f5f7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166350d25bcd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610390573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906103b491906107a0565b6103be91906107b7565b90505f7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166350d25bcd6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561043e573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061046291906107a0565b61046c91906107b7565b90505f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663095ce6c57f000000000000000000000000000000000000000000000000000000000000000060405180608001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316815250604051806040016040528088815260200188815250604051806040016040528089815260200189815250604051806040016040528089815260200189815250604051602001610604906020808252601a908201527f4d41585f504e4c5f464143544f525f464f525f54524144455253000000000000604082015260600190565b604051602081830303815290604052805190602001205f6040518863ffffffff1660e01b815260040161063d97969594939291906107da565b6101a060405180830381865afa158015610659573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061067d91906108cb565b50905061069e73af298d050e4395d69670b12b7f41000000000000826106a6565b935050505090565b5f816106b9576365244e4e5f526004601cfd5b50808206151591040190565b5f5f602083850312156106d6575f5ffd5b823567ffffffffffffffff8111156106ec575f5ffd5b8301601f810185136106fc575f5ffd5b803567ffffffffffffffff811115610712575f5ffd5b856020828401011115610723575f5ffd5b6020919091019590945092505050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b600181811c9082168061077c57607f821691505b60208210810361079a57634e487b7160e01b5f52602260045260245ffd5b50919050565b5f602082840312156107b0575f5ffd5b5051919050565b80820281158282048414176102e157634e487b7160e01b5f52601160045260245ffd5b5f6101a0820190506001600160a01b03891682526001600160a01b0388511660208301526001600160a01b0360208901511660408301526001600160a01b0360408901511660608301526001600160a01b03606089015116608083015261084e60a083018880518252602090810151910152565b855160e08301526020860151610100830152845161012083015260208501516101408301528361016083015261088961018083018415159052565b98975050505050505050565b604051610180810167ffffffffffffffff811182821017156108c557634e487b7160e01b5f52604160045260245ffd5b60405290565b5f5f8284036101a08112156108de575f5ffd5b83519250610180601f19820112156108f4575f5ffd5b506108fd610895565b602084810151825260408086015191830191909152606080860151918301919091526080808601519183019190915260a0808601519183019190915260c0808601519183019190915260e0808601519183019190915261010080860151918301919091526101208086015191830191909152610140808601519183019190915261016080860151918301919091526101809094015193810193909352509290915056fea26469706673582212206436176832df6c0e3dfbc6aaab1b85c5bd60dbd166a68ea82d8665e38523866d64736f6c634300081c0033",
  "args_data": "0x00000000000000000000000065a6cc451baff7e7b4fdab4157763ab4b6b44d0e0000000000000000000000006ce185860a4963106506c203335a2910413708e900000000000000000000000050834f3163758fcc1df9973b6e91f0f0f0434ad300000000000000000000000047c031236e19d024b42f8ae6780e44a5731707030000000000000000000000002f2a2543b76a4166549f7aab2e75bef0aefc5b0f000000000000000000000000fd70de6b91282d8017aa4e741e9ae325cab992d800000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000009676d4254432f5553440000000000000000000000000000000000000000000000",
  "tx_hash": "0x11836a90459807238363488f064ab249debad53f909acc60c196e54463f69ba5",
  "args": [
    "0x65A6CC451BAfF7e7B4FDAb4157763aB4b6b44D0E",
    "0x6ce185860a4963106506C203335A2910413708e9",
    "0x50834F3163758fcC1Df9973b6e91f0F0F0434aD3",
    "0x47c031236e19d024b42f8AE6780E44A573170703",
    "0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f",
    "0xFD70de6b91282D8017aA4E741e9Ae325CAb992d8",
    "gmBTC/USD"
  ],
  "data": "0x6101c0604052348015610010575f5ffd5b506040516111e43803806111e483398101604081905261002f9161034e565b6001600160a01b03878116608081905287821660a052868216610100528482166101605283821661012081905260405163714af34b60e01b8152600481019190915291861660248301525f9163714af34b90604401608060405180830381865afa15801561009f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906100c39190610453565b8051604082015160608301516001600160a01b039081166101a0529081166101805290811661014052610160519192506100fd9116610237565b60a0516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561013b573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061015f91906104d7565b61016a90601e610512565b6101749190610512565b61017f90600a610614565b60c0526101a051610198906001600160a01b0316610237565b610100516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156101d7573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906101fb91906104d7565b61020690601e610512565b6102109190610512565b61021b90600a610614565b60e0525f61022983826106a6565b505050505050505050610776565b60408051600481526024810182526020810180516001600160e01b031663313ce56760e01b17905290515f91829182916001600160a01b0386169161027c9190610760565b5f60405180830381855afa9150503d805f81146102b4576040519150601f19603f3d011682016040523d82523d5f602084013e6102b9565b606091505b50915091508180156102cc575080516020145b6102d75760126102eb565b808060200190518101906102eb91906104d7565b949350505050565b6001600160a01b0381168114610307575f5ffd5b50565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f191681016001600160401b03811182821017156103465761034661030a565b604052919050565b5f5f5f5f5f5f5f60e0888a031215610364575f5ffd5b875161036f816102f3565b6020890151909750610380816102f3565b6040890151909650610391816102f3565b60608901519095506103a2816102f3565b60808901519094506103b3816102f3565b60a08901519093506103c4816102f3565b60c08901519092506001600160401b038111156103df575f5ffd5b8801601f81018a136103ef575f5ffd5b80516001600160401b038111156104085761040861030a565b61041b601f8201601f191660200161031e565b8181528b602083850101111561042f575f5ffd5b8160208401602083015e5f6020838301015280935050505092959891949750929550565b5f6080828403128015610464575f5ffd5b50604051608081016001600160401b03811182821017156104875761048761030a565b6040528251610495816102f3565b815260208301516104a5816102f3565b602082015260408301516104b8816102f3565b604082015260608301516104cb816102f3565b60608201529392505050565b5f602082840312156104e7575f5ffd5b815160ff811681146104f7575f5ffd5b9392505050565b634e487b7160e01b5f52601160045260245ffd5b60ff828116828216039081111561052b5761052b6104fe565b92915050565b6001815b600184111561056c57808504811115610550576105506104fe565b600184161561055e57908102905b60019390931c928002610535565b935093915050565b5f826105825750600161052b565b8161058e57505f61052b565b81600181146105a457600281146105ae576105ca565b600191505061052b565b60ff8411156105bf576105bf6104fe565b50506001821b61052b565b5060208310610133831016604e8410600b84101617156105ed575081810a61052b565b6105f95f198484610531565b805f190482111561060c5761060c6104fe565b029392505050565b5f6104f760ff841683610574565b600181811c9082168061063657607f821691505b60208210810361065457634e487b7160e01b5f52602260045260245ffd5b50919050565b601f8211156106a157805f5260205f20601f840160051c8101602085101561067f5750805b601f840160051c820191505b8181101561069e575f815560010161068b565b50505b505050565b81516001600160401b038111156106bf576106bf61030a565b6106d3816106cd8454610622565b8461065a565b6020601f821160018114610705575f83156106ee5750848201515b5f19600385901b1c1916600184901b17845561069e565b5f84815260208120601f198516915b828110156107345787850151825560209485019460019092019101610714565b508482101561075157868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b5f82518060208501845e5f920191825250919050565b60805160a05160c05160e05161010051610120516101405161016051610180516101a0516109d661080e5f395f61055901525f61052a01525f6104fb01525f6104cc01525f818161016001526104a001525f818161012101526103e401525f818160d801526103c301525f81816101ae015261031501525f8181610187015261033601525f8181610208015261047101526109d65ff3fe608060405234801561000f575f5ffd5b50600436106100cf575f3560e01c8063c699c4d61161007d578063d568866c11610058578063d568866c146101d0578063d6d7d5251461022a578063eeb8a8d31461022a575f5ffd5b8063c699c4d6146101d0578063d39bbef0146101f0578063d4fc42c614610203575f5ffd5b8063660d0d67116100ad578063660d0d671461015b578063baf4276214610182578063bd5736b4146101a9575f5ffd5b8063224a2b6f146100d3578063313ce5671461010d57806347f63cf61461011c575b5f5ffd5b6100fa7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b60405160128152602001610104565b6101437f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610104565b6101437f000000000000000000000000000000000000000000000000000000000000000081565b6101437f000000000000000000000000000000000000000000000000000000000000000081565b6100fa7f000000000000000000000000000000000000000000000000000000000000000081565b6101e36101de3660046106c5565b610254565b6040516101049190610733565b6100fa6101fe3660046106c5565b6102e7565b6101437f000000000000000000000000000000000000000000000000000000000000000081565b61023d6102383660046106c5565b6102fa565b604080519215158352602083019190915201610104565b60605f805461026290610768565b80601f016020809104026020016040519081016040528092919081815260200182805461028e90610768565b80156102d95780601f106102b0576101008083540402835291602001916102d9565b820191905f5260205f20905b8154815290600101906020018083116102bc57829003601f168201915b505050505090505b92915050565b5f6102f283836102fa565b949350505050565b5f5f6001610306610311565b915091509250929050565b5f5f7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166350d25bcd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610390573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906103b491906107a0565b6103be91906107b7565b90505f7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166350d25bcd6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561043e573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061046291906107a0565b61046c91906107b7565b90505f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663095ce6c57f000000000000000000000000000000000000000000000000000000000000000060405180608001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316815250604051806040016040528088815260200188815250604051806040016040528089815260200189815250604051806040016040528089815260200189815250604051602001610604906020808252601a908201527f4d41585f504e4c5f464143544f525f464f525f54524144455253000000000000604082015260600190565b604051602081830303815290604052805190602001205f6040518863ffffffff1660e01b815260040161063d97969594939291906107da565b6101a060405180830381865afa158015610659573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061067d91906108cb565b50905061069e73af298d050e4395d69670b12b7f41000000000000826106a6565b935050505090565b5f816106b9576365244e4e5f526004601cfd5b50808206151591040190565b5f5f602083850312156106d6575f5ffd5b823567ffffffffffffffff8111156106ec575f5ffd5b8301601f810185136106fc575f5ffd5b803567ffffffffffffffff811115610712575f5ffd5b856020828401011115610723575f5ffd5b6020919091019590945092505050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b600181811c9082168061077c57607f821691505b60208210810361079a57634e487b7160e01b5f52602260045260245ffd5b50919050565b5f602082840312156107b0575f5ffd5b5051919050565b80820281158282048414176102e157634e487b7160e01b5f52601160045260245ffd5b5f6101a0820190506001600160a01b03891682526001600160a01b0388511660208301526001600160a01b0360208901511660408301526001600160a01b0360408901511660608301526001600160a01b03606089015116608083015261084e60a083018880518252602090810151910152565b855160e08301526020860151610100830152845161012083015260208501516101408301528361016083015261088961018083018415159052565b98975050505050505050565b604051610180810167ffffffffffffffff811182821017156108c557634e487b7160e01b5f52604160045260245ffd5b60405290565b5f5f8284036101a08112156108de575f5ffd5b83519250610180601f19820112156108f4575f5ffd5b506108fd610895565b602084810151825260408086015191830191909152606080860151918301919091526080808601519183019190915260a0808601519183019190915260c0808601519183019190915260e0808601519183019190915261010080860151918301919091526101208086015191830191909152610140808601519183019190915261016080860151918301919091526101809094015193810193909352509290915056fea26469706673582212206436176832df6c0e3dfbc6aaab1b85c5bd60dbd166a68ea82d8665e38523866d64736f6c634300081c003300000000000000000000000065a6cc451baff7e7b4fdab4157763ab4b6b44d0e0000000000000000000000006ce185860a4963106506c203335a2910413708e900000000000000000000000050834f3163758fcc1df9973b6e91f0f0f0434ad300000000000000000000000047c031236e19d024b42f8ae6780e44a5731707030000000000000000000000002f2a2543b76a4166549f7aab2e75bef0aefc5b0f000000000000000000000000fd70de6b91282d8017aa4e741e9ae325cab992d800000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000009676d4254432f5553440000000000000000000000000000000000000000000000",
  "artifact_path": "GmOracleWithAggregator.sol",
  "artifact_full_path": "GmOracleWithAggregator.sol:GmOracleWithAggregator",
  "standardJsonInput": {
    "language": "Solidity",
    "sources": {
      "src/oracles/GmOracleWithAggregator.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC20} from \"@BoringSolidity/interfaces/IERC20.sol\";\nimport {BoringERC20} from \"@BoringSolidity/libraries/BoringERC20.sol\";\nimport {FixedPointMathLib} from \"@solady/utils/FixedPointMathLib.sol\";\nimport {IOracle} from \"/interfaces/IOracle.sol\";\nimport {IAggregator} from \"/interfaces/IAggregator.sol\";\nimport {IGmxV2Market, IGmxV2Price, IGmxReader} from \"/interfaces/IGmxV2.sol\";\n\ncontract GmOracleWithAggregator is IOracle {\n    using BoringERC20 for IERC20;\n    bytes32 private constant PNL_TYPE = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_TRADERS\"));\n    IGmxReader public immutable reader;\n    IAggregator public immutable indexAggregator;\n    uint256 public immutable expansionFactorIndex;\n    uint256 public immutable expansionFactorShort;\n    IAggregator public immutable shortAggregator;\n    address public immutable dataStore;\n    address immutable marketToken;\n    address immutable indexToken;\n    address immutable longToken;\n    address immutable shortToken;\n\n    string private desc;\n\n    constructor(\n        IGmxReader _reader,\n        IAggregator _indexTokenAggregator,\n        IAggregator _shortTokenAggregator,\n        address _market,\n        address _indexToken,\n        address _dataStore,\n        string memory _desc\n    ) {\n        reader = _reader;\n        indexAggregator = _indexTokenAggregator;\n        shortAggregator = _shortTokenAggregator;\n        indexToken = _indexToken;\n        dataStore = _dataStore;\n        IGmxV2Market.Props memory props = _reader.getMarket(_dataStore, _market);\n        (marketToken, , longToken, shortToken) = (props.marketToken, props.indexToken, props.longToken, props.shortToken);\n\n        // GMX uses an internal precision of 1e30\n        expansionFactorIndex = 10 ** (30 - indexAggregator.decimals() - IERC20(indexToken).safeDecimals());\n        expansionFactorShort = 10 ** (30 - shortAggregator.decimals() - IERC20(shortToken).safeDecimals());\n        desc = _desc;\n    }\n\n    function decimals() external pure returns (uint8) {\n        return uint8(18);\n    }\n\n    function _get() internal view returns (uint256 lpPrice) {\n        uint256 indexTokenPrice = uint256(indexAggregator.latestAnswer()) * expansionFactorIndex;\n        uint256 shortTokenPrice = uint256(shortAggregator.latestAnswer()) * expansionFactorShort;\n\n        (int256 price, ) = reader.getMarketTokenPrice(\n            dataStore,\n            IGmxV2Market.Props(marketToken, indexToken, longToken, shortToken),\n            IGmxV2Price.Props(indexTokenPrice, indexTokenPrice),\n            IGmxV2Price.Props(indexTokenPrice, indexTokenPrice),\n            IGmxV2Price.Props(shortTokenPrice, shortTokenPrice),\n            PNL_TYPE,\n            false\n        );\n\n        // GMX uses an internal precision of 1e30\n        lpPrice = FixedPointMathLib.divUp(1e18 * 1e30, uint256(price));\n    }\n\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return desc;\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return desc;\n    }\n}\n"
      },
      "dependencies/BoringSolidity-1.0.0/contracts/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    // transfer and tranferFrom have been removed, because they don't work on all tokens (some aren't ERC20 complaint).\n    // By removing them you can't accidentally use them.\n    // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).\n    // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ninterface IStrictERC20 {\n    // This is the strict ERC20 interface. Don't use this, certainly not if you don't control the ERC20 token you're calling.\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
      },
      "dependencies/BoringSolidity-1.0.0/contracts/libraries/BoringERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\n// solhint-disable avoid-low-level-calls\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)\n    bytes4 private constant SIG_TOTALSUPPLY = 0x18160ddd; // balanceOf(address)\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n        if (data.length >= 64) {\n            return abi.decode(data, (string));\n        } else if (data.length == 32) {\n            uint8 i = 0;\n            while (i < 32 && data[i] != 0) {\n                i++;\n            }\n            bytes memory bytesArray = new bytes(i);\n            for (i = 0; i < 32 && data[i] != 0; i++) {\n                bytesArray[i] = data[i];\n            }\n            return string(bytesArray);\n        } else {\n            return \"???\";\n        }\n    }\n\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token symbol.\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token name.\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (uint8) Token decimals.\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    /// @notice Provides a gas-optimized balance check to avoid a redundant extcodesize check in addition to the returndatasize check.\n    /// @param token The address of the ERC-20 token.\n    /// @param to The address of the user to check.\n    /// @return amount The token amount.\n    function safeBalanceOf(IERC20 token, address to) internal view returns (uint256 amount) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_BALANCE_OF, to));\n        require(success && data.length >= 32, \"BoringERC20: BalanceOf failed\");\n        amount = abi.decode(data, (uint256));\n    }\n\n    /// @notice Provides a gas-optimized totalSupply to avoid a redundant extcodesize check in addition to the returndatasize check.\n    /// @param token The address of the ERC-20 token.\n    /// @return totalSupply The token totalSupply.\n    function safeTotalSupply(IERC20 token) internal view returns (uint256 totalSupply) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_TOTALSUPPLY));\n        require(success && data.length >= 32, \"BoringERC20: totalSupply failed\");\n        totalSupply = abi.decode(data, (uint256));\n    }\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\n    }\n}\n"
      },
      "dependencies/solady-0.0.281/src/utils/FixedPointMathLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if gt(x, div(not(0), y)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if iszero(eq(div(z, y), x)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := add(iszero(iszero(mod(z, WAD))), div(z, WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(mul(y, eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    /// Note: This function is an approximation.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) ≈ 135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s ≈ 6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549…`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            (int256 wad, int256 p) = (int256(WAD), x);\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `a * b == x * y`, with full precision.\n    function fullMulEq(uint256 a, uint256 b, uint256 x, uint256 y)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(mul(a, b), mul(x, y)), eq(mulmod(x, y, not(0)), mulmod(a, b, not(0))))\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure `z` is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    z :=\n                        mul(\n                            // Divide [p1 p0] by the factors of two.\n                            // Shift in bits from `p1` into `p0`. For this we need\n                            // to flip `t` such that it is `2**256 / t`.\n                            or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                        )\n                    break\n                }\n                z := div(z, d)\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Behavior is undefined if `d` is zero or the final result cannot fit in 256 bits.\n    /// Performs the full 512 bit calculation regardless.\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(z, lt(mm, z)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            z :=\n                mul(\n                    or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                    mul(sub(2, mul(d, inv)), inv)\n                )\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        z = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / 2 ** n)` with full precision.\n    /// Throws if result overflows a uint256.\n    /// Credit to Philogy under MIT license:\n    /// https://github.com/SorellaLabs/angstrom/blob/main/contracts/src/libraries/X128MathLib.sol\n    function fullMulDivN(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let k := and(n, 0xff) // `n`, cleaned.\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0 ¦ p1_1 | z_0  ¦ z_1 |\n                    // Final:  |   0  ¦ p1_0 | p1_1 ¦ z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(k, p1)) {\n                        z := add(shl(sub(256, k), p1), shr(k, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(and(n, 0xff), z)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }\n\n    /// @dev Returns `x`, the modular multiplicative inverse of `a`, such that `(a * x) % n == 1`.\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256 x) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let g := n\n            let r := mod(a, n)\n            for { let y := 1 } 1 {} {\n                let q := div(g, r)\n                let t := g\n                g := r\n                r := sub(t, mul(r, q))\n                let u := x\n                x := y\n                y := sub(u, mul(y, q))\n                if iszero(r) { break }\n            }\n            x := mul(eq(g, 1), add(x, mul(slt(x, 0), n)))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`, rounded down.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, rounded down.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`, rounded down.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`, rounded down.\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { z := mul(z, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards zero.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards negative infinity.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = (uint256(x) + uint256(x >> 255)) ^ uint256(x >> 255);\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, gt(x, y)), sub(y, x)), gt(x, y))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, sgt(x, y)), sub(y, x)), sgt(x, y))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`,\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`.\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\n        internal\n        pure\n        returns (int256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b - a),\n                uint256(t - begin), uint256(end - begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a - b),\n                uint256(t - begin), uint256(end - begin)));\n        }\n    }\n\n    /// @dev Returns if `x` is an even number. Some people may need this.\n    function isEven(uint256 x) internal pure returns (bool) {\n        return x & uint256(1) == uint256(0);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n"
      },
      "src/interfaces/IOracle.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IOracle {\n    function decimals() external view returns (uint8);\n\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\n\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\n\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\n\n    function symbol(bytes calldata data) external view returns (string memory);\n\n    function name(bytes calldata data) external view returns (string memory);\n}\n"
      },
      "src/interfaces/IAggregator.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IAggregator {\n    function decimals() external view returns (uint8);\n\n    function latestAnswer() external view returns (int256 answer);\n\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n\ninterface IAggregatorWithMeta is IAggregator {\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n}\n"
      },
      "src/interfaces/IGmxV2.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.0;\n\n// @title Deposit\n// @dev Struct for deposits\ninterface IGmxV2Deposit {\n    /** @dev CreateDepositParams struct used in createDeposit to avoid stack\n     * too deep errors\n     *\n     * @param receiver the address to send the market tokens to\n     * @param callbackContract the callback contract\n     * @param uiFeeReceiver the ui fee receiver\n     * @param market the market to deposit into\n     * @param minMarketTokens the minimum acceptable number of liquidity tokens\n     * @param shouldUnwrapNativeToken whether to unwrap the native token when\n     * sending funds back to the user in case the deposit gets cancelled\n     * @param executionFee the execution fee for keepers\n     * @param callbackGasLimit the gas limit for the callbackContract\n     */\n    struct CreateDepositParams {\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address initialLongToken;\n        address initialShortToken;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n        uint256 minMarketTokens;\n        bool shouldUnwrapNativeToken;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    // @dev there is a limit on the number of fields a struct can have when being passed\n    // or returned as a memory variable which can cause \"Stack too deep\" errors\n    // use sub-structs to avoid this issue\n    // @param addresses address values\n    // @param numbers number values\n    // @param flags boolean values\n    struct Props {\n        Addresses addresses;\n        Numbers numbers;\n        Flags flags;\n    }\n\n    // @param account the account depositing liquidity\n    // @param receiver the address to send the liquidity tokens to\n    // @param callbackContract the callback contract\n    // @param uiFeeReceiver the ui fee receiver\n    // @param market the market to deposit to\n    struct Addresses {\n        address account;\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address initialLongToken;\n        address initialShortToken;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n    }\n\n    // @param initialLongTokenAmount the amount of long tokens to deposit\n    // @param initialShortTokenAmount the amount of short tokens to deposit\n    // @param minMarketTokens the minimum acceptable number of liquidity tokens\n    // sending funds back to the user in case the deposit gets cancelled\n    // @param executionFee the execution fee for keepers\n    // @param callbackGasLimit the gas limit for the callbackContract\n    struct Numbers {\n        uint256 initialLongTokenAmount;\n        uint256 initialShortTokenAmount;\n        uint256 minMarketTokens;\n        uint256 updatedAtTime;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    // @param shouldUnwrapNativeToken whether to unwrap the native token when\n    struct Flags {\n        bool shouldUnwrapNativeToken;\n    }\n}\n\ninterface IGmxV2Withdrawal {\n    /**\n     * @param receiver The address that will receive the withdrawal tokens.\n     * @param callbackContract The contract that will be called back.\n     * @param market The market on which the withdrawal will be executed.\n     * @param minLongTokenAmount The minimum amount of long tokens that must be withdrawn.\n     * @param minShortTokenAmount The minimum amount of short tokens that must be withdrawn.\n     * @param shouldUnwrapNativeToken Whether the native token should be unwrapped when executing the withdrawal.\n     * @param executionFee The execution fee for the withdrawal.\n     * @param callbackGasLimit The gas limit for calling the callback contract.\n     */\n    struct CreateWithdrawalParams {\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n        uint256 minLongTokenAmount;\n        uint256 minShortTokenAmount;\n        bool shouldUnwrapNativeToken;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    // @dev there is a limit on the number of fields a struct can have when being passed\n    // or returned as a memory variable which can cause \"Stack too deep\" errors\n    // use sub-structs to avoid this issue\n    // @param addresses address values\n    // @param numbers number values\n    // @param flags boolean values\n    struct Props {\n        Addresses addresses;\n        Numbers numbers;\n        Flags flags;\n    }\n\n     // @param account The account to withdraw for.\n     // @param receiver The address that will receive the withdrawn tokens.\n     // @param callbackContract The contract that will be called back.\n     // @param uiFeeReceiver The ui fee receiver.\n     // @param market The market on which the withdrawal will be executed.\n    struct Addresses {\n        address account;\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n    }\n\n     // @param marketTokenAmount The amount of market tokens that will be withdrawn.\n     // @param minLongTokenAmount The minimum amount of long tokens that must be withdrawn.\n     // @param minShortTokenAmount The minimum amount of short tokens that must be withdrawn.\n     // @param executionFee The execution fee for the withdrawal.\n     // @param callbackGasLimit The gas limit for calling the callback contract.\n    struct Numbers {\n        uint256 marketTokenAmount;\n        uint256 minLongTokenAmount;\n        uint256 minShortTokenAmount;\n        uint256 updatedAtTime;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    // @param shouldUnwrapNativeToken whether to unwrap the native token when\n    struct Flags {\n        bool shouldUnwrapNativeToken;\n    }\n}\n\ninterface IGmxV2EventUtils {\n    struct EmitPositionDecreaseParams {\n        bytes32 key;\n        address account;\n        address market;\n        address collateralToken;\n        bool isLong;\n    }\n\n    struct EventLogData {\n        AddressItems addressItems;\n        UintItems uintItems;\n        IntItems intItems;\n        BoolItems boolItems;\n        Bytes32Items bytes32Items;\n        BytesItems bytesItems;\n        StringItems stringItems;\n    }\n\n    struct AddressItems {\n        AddressKeyValue[] items;\n        AddressArrayKeyValue[] arrayItems;\n    }\n\n    struct UintItems {\n        UintKeyValue[] items;\n        UintArrayKeyValue[] arrayItems;\n    }\n\n    struct IntItems {\n        IntKeyValue[] items;\n        IntArrayKeyValue[] arrayItems;\n    }\n\n    struct BoolItems {\n        BoolKeyValue[] items;\n        BoolArrayKeyValue[] arrayItems;\n    }\n\n    struct Bytes32Items {\n        Bytes32KeyValue[] items;\n        Bytes32ArrayKeyValue[] arrayItems;\n    }\n\n    struct BytesItems {\n        BytesKeyValue[] items;\n        BytesArrayKeyValue[] arrayItems;\n    }\n\n    struct StringItems {\n        StringKeyValue[] items;\n        StringArrayKeyValue[] arrayItems;\n    }\n\n    struct AddressKeyValue {\n        string key;\n        address value;\n    }\n\n    struct AddressArrayKeyValue {\n        string key;\n        address[] value;\n    }\n\n    struct UintKeyValue {\n        string key;\n        uint256 value;\n    }\n\n    struct UintArrayKeyValue {\n        string key;\n        uint256[] value;\n    }\n\n    struct IntKeyValue {\n        string key;\n        int256 value;\n    }\n\n    struct IntArrayKeyValue {\n        string key;\n        int256[] value;\n    }\n\n    struct BoolKeyValue {\n        string key;\n        bool value;\n    }\n\n    struct BoolArrayKeyValue {\n        string key;\n        bool[] value;\n    }\n\n    struct Bytes32KeyValue {\n        string key;\n        bytes32 value;\n    }\n\n    struct Bytes32ArrayKeyValue {\n        string key;\n        bytes32[] value;\n    }\n\n    struct BytesKeyValue {\n        string key;\n        bytes value;\n    }\n\n    struct BytesArrayKeyValue {\n        string key;\n        bytes[] value;\n    }\n\n    struct StringKeyValue {\n        string key;\n        string value;\n    }\n\n    struct StringArrayKeyValue {\n        string key;\n        string[] value;\n    }\n}\n\ninterface IGmxV2Market {\n    // @param marketToken address of the market token for the market\n    // @param indexToken address of the index token for the market\n    // @param longToken address of the long token for the market\n    // @param shortToken address of the short token for the market\n    // @param data for any additional data\n    struct Props {\n        address marketToken;\n        address indexToken;\n        address longToken;\n        address shortToken;\n    }\n}\n\n// @title Price\n// @dev Struct for prices\ninterface IGmxV2Price {\n    // @param min the min price\n    // @param max the max price\n    struct Props {\n        uint256 min;\n        uint256 max;\n    }\n}\n\n// @title MarketPoolInfo\ninterface IGmxV2MarketPoolValueInfo {\n    // @dev struct to avoid stack too deep errors for the getPoolValue call\n    // @param value the pool value\n    // @param longTokenAmount the amount of long token in the pool\n    // @param shortTokenAmount the amount of short token in the pool\n    // @param longTokenUsd the USD value of the long tokens in the pool\n    // @param shortTokenUsd the USD value of the short tokens in the pool\n    // @param totalBorrowingFees the total pending borrowing fees for the market\n    // @param borrowingFeePoolFactor the pool factor for borrowing fees\n    // @param impactPoolAmount the amount of tokens in the impact pool\n    // @param longPnl the pending pnl of long positions\n    // @param shortPnl the pending pnl of short positions\n    // @param netPnl the net pnl of long and short positions\n    struct Props {\n        int256 poolValue;\n        int256 longPnl;\n        int256 shortPnl;\n        int256 netPnl;\n        uint256 longTokenAmount;\n        uint256 shortTokenAmount;\n        uint256 longTokenUsd;\n        uint256 shortTokenUsd;\n        uint256 totalBorrowingFees;\n        uint256 borrowingFeePoolFactor;\n        uint256 impactPoolAmount;\n        uint256 lentImpactPoolAmount;\n    }\n}\n\n// @title IDepositCallbackReceiver\n// @dev interface for a deposit callback contract\ninterface IGmxV2DepositCallbackReceiver {\n    // @dev called after a deposit execution\n    // @param key the key of the deposit\n    // @param deposit the deposit that was executed\n    function afterDepositExecution(\n        bytes32 key,\n        IGmxV2Deposit.Props memory deposit,\n        IGmxV2EventUtils.EventLogData memory eventData\n    ) external;\n\n    // @dev called after a deposit cancellation\n    // @param key the key of the deposit\n    // @param deposit the deposit that was cancelled\n    function afterDepositCancellation(\n        bytes32 key,\n        IGmxV2Deposit.Props memory deposit,\n        IGmxV2EventUtils.EventLogData memory eventData\n    ) external;\n}\n\n// @title IWithdrawalCallbackReceiver\n// @dev interface for a withdrawal callback contract\ninterface IGmxV2WithdrawalCallbackReceiver {\n    // @dev called after a withdrawal execution\n    // @param key the key of the withdrawal\n    // @param withdrawal the withdrawal that was executed\n    function afterWithdrawalExecution(\n        bytes32 key,\n        IGmxV2Withdrawal.Props memory withdrawal,\n        IGmxV2EventUtils.EventLogData memory eventData\n    ) external;\n\n    // @dev called after a withdrawal cancellation\n    // @param key the key of the withdrawal\n    // @param withdrawal the withdrawal that was cancelled\n    function afterWithdrawalCancellation(\n        bytes32 key,\n        IGmxV2Withdrawal.Props memory withdrawal,\n        IGmxV2EventUtils.EventLogData memory eventData\n    ) external;\n}\n\ninterface IGmxDataStore {\n    function containsBytes32(bytes32 setKey, bytes32 value) external view returns (bool);\n\n    function roleStore() external view returns (IGmxRoleStore);\n\n    function getBool(bytes32 key) external view returns (bool);\n}\n\ninterface IGmxRoleStore {\n    function hasRole(address account, bytes32 roleKey) external view returns (bool);\n}\n\ninterface IGmxReader {\n    function getMarket(address dataStore, address key) external view returns (IGmxV2Market.Props memory);\n\n    // @dev get the market token's price\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longTokenPrice the price of the long token\n    // @param shortTokenPrice the price of the short token\n    // @param indexTokenPrice the price of the index token\n    // @param maximize whether to maximize or minimize the market token price\n    // @return returns (the market token's price, MarketPoolValueInfo.Props)\n    function getMarketTokenPrice(\n        address dataStore,\n        IGmxV2Market.Props memory market,\n        IGmxV2Price.Props memory indexTokenPrice,\n        IGmxV2Price.Props memory longTokenPrice,\n        IGmxV2Price.Props memory shortTokenPrice,\n        bytes32 pnlFactorType,\n        bool maximize\n    ) external view returns (int256, IGmxV2MarketPoolValueInfo.Props memory);\n}\n\ninterface IGmxV2ExchangeRouter {\n    function dataStore() external view returns (address);\n\n    function sendWnt(address receiver, uint256 amount) external payable;\n\n    function sendTokens(address token, address receiver, uint256 amount) external payable;\n\n    function depositHandler() external view returns (address);\n\n    function withdrawalHandler() external view returns (address);\n\n    function createDeposit(IGmxV2Deposit.CreateDepositParams calldata params) external payable returns (bytes32);\n\n    function createWithdrawal(IGmxV2Withdrawal.CreateWithdrawalParams calldata params) external payable returns (bytes32);\n\n    function cancelWithdrawal(bytes32 key) external payable;\n\n    function cancelDeposit(bytes32 key) external payable;\n}\n\ninterface IGmxV2DepositHandler {\n    function depositVault() external view returns (address);\n\n    function dataStore() external view returns (address);\n}\n\ninterface IGmxV2WithdrawalHandler {\n    function withdrawalVault() external view returns (address);\n}\n"
      }
    },
    "settings": {
      "remappings": [
        "/=src/",
        "forge-std/=dependencies/forge-std-1.9.5/src/",
        "halmos-cheatcodes/=dependencies/halmos-cheatcodes-7328abe/src/",
        "@openzeppelin/contracts/=dependencies/openzeppelin-contracts-5.0.2/contracts/",
        "@openzeppelin/contracts-upgradeable/=dependencies/openzeppelin-contracts-upgradeable-5.0.2/contracts/",
        "@BoringSolidity/=dependencies/BoringSolidity-1.0.0/contracts/",
        "@solady/=dependencies/solady-0.0.281/src/",
        "@solmate/=dependencies/solmate-6.2.0/src/",
        "@excessivelySafeCall/=dependencies/ExcessivelySafeCall-0.0.1/src/",
        "@safe-contracts/=dependencies/safe-contracts-1.3.0/contracts/",
        "@fuzzlib/=dependencies/fuzzlib-0.0.1/src/",
        "@abracadabra-oft-v1/=dependencies/abracadabra-oft-v1-0.0.1/src/",
        "@prb/math/=dependencies/prb-math-4.1.0/src/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 400
      },
      "metadata": {
        "useLiteralContent": false,
        "bytecodeHash": "ipfs",
        "appendCBOR": true
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode.object",
            "evm.bytecode.sourceMap",
            "evm.bytecode.linkReferences",
            "evm.deployedBytecode.object",
            "evm.deployedBytecode.sourceMap",
            "evm.deployedBytecode.linkReferences",
            "evm.deployedBytecode.immutableReferences",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "evmVersion": "cancun",
      "viaIR": false,
      "libraries": {}
    }
  },
  "compiler": "0.8.28+commit.7893614a"
}