{
  "address": "0xBFc0C2ec046cE4f0e8778afF3A0de159d921b3C2",
  "abi": [
    {
      "type": "constructor",
      "inputs": [
        {
          "name": "glpManager_",
          "type": "address",
          "internalType": "contract IGmxGlpManager"
        },
        {
          "name": "glp_",
          "type": "address",
          "internalType": "contract IERC20"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "decimals",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint8",
          "internalType": "uint8"
        }
      ],
      "stateMutability": "pure"
    },
    {
      "type": "function",
      "name": "get",
      "inputs": [
        {
          "name": "",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        },
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "glp",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IERC20"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "glpManager",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IGmxGlpManager"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "name",
      "inputs": [
        {
          "name": "",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "string",
          "internalType": "string"
        }
      ],
      "stateMutability": "pure"
    },
    {
      "type": "function",
      "name": "peek",
      "inputs": [
        {
          "name": "",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        },
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "peekSpot",
      "inputs": [
        {
          "name": "data",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "rate",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "symbol",
      "inputs": [
        {
          "name": "",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "string",
          "internalType": "string"
        }
      ],
      "stateMutability": "pure"
    }
  ],
  "bytecode": "0x60c060405234801561000f575f5ffd5b5060405161050438038061050483398101604081905261002e9161005c565b6001600160a01b039182166080521660a052610094565b6001600160a01b0381168114610059575f5ffd5b50565b5f5f6040838503121561006d575f5ffd5b825161007881610045565b602084015190925061008981610045565b809150509250929050565b60805160a0516104426100c25f395f818160a2015261029b01525f81816101b1015261023001526104425ff3fe608060405234801561000f575f5ffd5b5060043610610085575f3560e01c8063d568866c11610058578063d568866c1461013b578063d6d7d52514610182578063eeb8a8d314610182578063fa6db1bc146101ac575f5ffd5b8063313ce5671461008957806378a207ee1461009d578063c699c4d6146100dc578063d39bbef01461011a575b5f5ffd5b604051601281526020015b60405180910390f35b6100c47f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610094565b61010d6100ea366004610352565b505060408051808201909152600781526611d3140bd554d160ca1b602082015290565b60405161009491906103c0565b61012d610128366004610352565b6101d3565b604051908152602001610094565b61010d610149366004610352565b505060408051808201909152601181527f474d58204c5020555344204f7261636c65000000000000000000000000000000602082015290565b610195610190366004610352565b6101e6565b604080519215158352602083019190915201610094565b6100c47f000000000000000000000000000000000000000000000000000000000000000081565b5f6101de83836101e6565b949350505050565b5f5f60016101f26101fd565b915091509250929050565b60405163019c8a3b60e11b81525f6004820181905290610320906c0c9f2c9cd04674edea40000000906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690630339147690602401602060405180830381865afa158015610275573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061029991906103f5565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156102f5573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061031991906103f5565b9190610325565b905090565b828202831584820484141782026103435763ad251c275f526004601cfd5b81810615159190040192915050565b5f5f60208385031215610363575f5ffd5b823567ffffffffffffffff811115610379575f5ffd5b8301601f81018513610389575f5ffd5b803567ffffffffffffffff81111561039f575f5ffd5b8560208284010111156103b0575f5ffd5b6020919091019590945092505050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b5f60208284031215610405575f5ffd5b505191905056fea26469706673582212203ee0dcbf0017b0d04102c9c6a2971040047ab65a5582365833d8f5ad4a2ba51564736f6c634300081c0033",
  "args_data": "0x0000000000000000000000003963ffc9dff443c2a94f21b129d429891e32ec180000000000000000000000004277f8f2c384827b5273592ff7cebd9f2c1ac258",
  "tx_hash": "0x95e4b4ee700e9ca88d1715a7ee323c5bb3fc9cdc9617ea5f6fb531723cca607a",
  "args": [
    "0x3963FfC9dff443c2A94f21b129D429891E32ec18",
    "0x4277f8F2c384827B5273592FF7CeBd9f2C1ac258"
  ],
  "data": "0x60c060405234801561000f575f5ffd5b5060405161050438038061050483398101604081905261002e9161005c565b6001600160a01b039182166080521660a052610094565b6001600160a01b0381168114610059575f5ffd5b50565b5f5f6040838503121561006d575f5ffd5b825161007881610045565b602084015190925061008981610045565b809150509250929050565b60805160a0516104426100c25f395f818160a2015261029b01525f81816101b1015261023001526104425ff3fe608060405234801561000f575f5ffd5b5060043610610085575f3560e01c8063d568866c11610058578063d568866c1461013b578063d6d7d52514610182578063eeb8a8d314610182578063fa6db1bc146101ac575f5ffd5b8063313ce5671461008957806378a207ee1461009d578063c699c4d6146100dc578063d39bbef01461011a575b5f5ffd5b604051601281526020015b60405180910390f35b6100c47f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610094565b61010d6100ea366004610352565b505060408051808201909152600781526611d3140bd554d160ca1b602082015290565b60405161009491906103c0565b61012d610128366004610352565b6101d3565b604051908152602001610094565b61010d610149366004610352565b505060408051808201909152601181527f474d58204c5020555344204f7261636c65000000000000000000000000000000602082015290565b610195610190366004610352565b6101e6565b604080519215158352602083019190915201610094565b6100c47f000000000000000000000000000000000000000000000000000000000000000081565b5f6101de83836101e6565b949350505050565b5f5f60016101f26101fd565b915091509250929050565b60405163019c8a3b60e11b81525f6004820181905290610320906c0c9f2c9cd04674edea40000000906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690630339147690602401602060405180830381865afa158015610275573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061029991906103f5565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156102f5573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061031991906103f5565b9190610325565b905090565b828202831584820484141782026103435763ad251c275f526004601cfd5b81810615159190040192915050565b5f5f60208385031215610363575f5ffd5b823567ffffffffffffffff811115610379575f5ffd5b8301601f81018513610389575f5ffd5b803567ffffffffffffffff81111561039f575f5ffd5b8560208284010111156103b0575f5ffd5b6020919091019590945092505050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b5f60208284031215610405575f5ffd5b505191905056fea26469706673582212203ee0dcbf0017b0d04102c9c6a2971040047ab65a5582365833d8f5ad4a2ba51564736f6c634300081c00330000000000000000000000003963ffc9dff443c2a94f21b129d429891e32ec180000000000000000000000004277f8f2c384827b5273592ff7cebd9f2c1ac258",
  "artifact_path": "GlpOracle.sol",
  "artifact_full_path": "GlpOracle.sol:GlpOracle",
  "standardJsonInput": {
    "language": "Solidity",
    "sources": {
      "src/oracles/GlpOracle.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC20} from \"@BoringSolidity/interfaces/IERC20.sol\";\nimport {FixedPointMathLib} from \"@solady/utils/FixedPointMathLib.sol\";\nimport {IOracle} from \"/interfaces/IOracle.sol\";\nimport {IGmxGlpManager} from \"/interfaces/IGmxV1.sol\";\n\ncontract GlpOracle is IOracle {\n    using FixedPointMathLib for uint256;\n\n    IGmxGlpManager public immutable glpManager;\n    IERC20 public immutable glp;\n\n    constructor(IGmxGlpManager glpManager_, IERC20 glp_) {\n        glpManager = glpManager_;\n        glp = glp_;\n    }\n\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    function _get() internal view returns (uint256) {\n        return glp.totalSupply().mulDivUp(1e30, glpManager.getAum(false));\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"GMX LP USD Oracle\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"GLP/USD\";\n    }\n}\n"
      },
      "dependencies/BoringSolidity-1.0.0/contracts/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    // transfer and tranferFrom have been removed, because they don't work on all tokens (some aren't ERC20 complaint).\n    // By removing them you can't accidentally use them.\n    // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).\n    // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ninterface IStrictERC20 {\n    // This is the strict ERC20 interface. Don't use this, certainly not if you don't control the ERC20 token you're calling.\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
      },
      "dependencies/solady-0.0.281/src/utils/FixedPointMathLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if gt(x, div(not(0), y)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if iszero(eq(div(z, y), x)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := add(iszero(iszero(mod(z, WAD))), div(z, WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(mul(y, eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    /// Note: This function is an approximation.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) ≈ 135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s ≈ 6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549…`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            (int256 wad, int256 p) = (int256(WAD), x);\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `a * b == x * y`, with full precision.\n    function fullMulEq(uint256 a, uint256 b, uint256 x, uint256 y)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(mul(a, b), mul(x, y)), eq(mulmod(x, y, not(0)), mulmod(a, b, not(0))))\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure `z` is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    z :=\n                        mul(\n                            // Divide [p1 p0] by the factors of two.\n                            // Shift in bits from `p1` into `p0`. For this we need\n                            // to flip `t` such that it is `2**256 / t`.\n                            or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                        )\n                    break\n                }\n                z := div(z, d)\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Behavior is undefined if `d` is zero or the final result cannot fit in 256 bits.\n    /// Performs the full 512 bit calculation regardless.\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(z, lt(mm, z)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            z :=\n                mul(\n                    or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                    mul(sub(2, mul(d, inv)), inv)\n                )\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        z = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / 2 ** n)` with full precision.\n    /// Throws if result overflows a uint256.\n    /// Credit to Philogy under MIT license:\n    /// https://github.com/SorellaLabs/angstrom/blob/main/contracts/src/libraries/X128MathLib.sol\n    function fullMulDivN(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let k := and(n, 0xff) // `n`, cleaned.\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0 ¦ p1_1 | z_0  ¦ z_1 |\n                    // Final:  |   0  ¦ p1_0 | p1_1 ¦ z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(k, p1)) {\n                        z := add(shl(sub(256, k), p1), shr(k, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(and(n, 0xff), z)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }\n\n    /// @dev Returns `x`, the modular multiplicative inverse of `a`, such that `(a * x) % n == 1`.\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256 x) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let g := n\n            let r := mod(a, n)\n            for { let y := 1 } 1 {} {\n                let q := div(g, r)\n                let t := g\n                g := r\n                r := sub(t, mul(r, q))\n                let u := x\n                x := y\n                y := sub(u, mul(y, q))\n                if iszero(r) { break }\n            }\n            x := mul(eq(g, 1), add(x, mul(slt(x, 0), n)))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`, rounded down.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, rounded down.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`, rounded down.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`, rounded down.\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { z := mul(z, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards zero.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards negative infinity.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = (uint256(x) + uint256(x >> 255)) ^ uint256(x >> 255);\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, gt(x, y)), sub(y, x)), gt(x, y))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, sgt(x, y)), sub(y, x)), sgt(x, y))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`,\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`.\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\n        internal\n        pure\n        returns (int256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b - a),\n                uint256(t - begin), uint256(end - begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a - b),\n                uint256(t - begin), uint256(end - begin)));\n        }\n    }\n\n    /// @dev Returns if `x` is an even number. Some people may need this.\n    function isEven(uint256 x) internal pure returns (bool) {\n        return x & uint256(1) == uint256(0);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n"
      },
      "src/interfaces/IOracle.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IOracle {\n    function decimals() external view returns (uint8);\n\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\n\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\n\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\n\n    function symbol(bytes calldata data) external view returns (string memory);\n\n    function name(bytes calldata data) external view returns (string memory);\n}\n"
      },
      "src/interfaces/IGmxV1.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC20} from \"@BoringSolidity/interfaces/IERC20.sol\";\n\ninterface IGmxVault {\n    event BuyUSDG(address account, address token, uint256 tokenAmount, uint256 usdgAmount, uint256 feeBasisPoints);\n    event ClosePosition(\n        bytes32 key,\n        uint256 size,\n        uint256 collateral,\n        uint256 averagePrice,\n        uint256 entryFundingRate,\n        uint256 reserveAmount,\n        int256 realisedPnl\n    );\n    event CollectMarginFees(address token, uint256 feeUsd, uint256 feeTokens);\n    event CollectSwapFees(address token, uint256 feeUsd, uint256 feeTokens);\n    event DecreaseGuaranteedUsd(address token, uint256 amount);\n    event DecreasePoolAmount(address token, uint256 amount);\n    event DecreasePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        uint256 collateralDelta,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 price,\n        uint256 fee\n    );\n    event DecreaseReservedAmount(address token, uint256 amount);\n    event DecreaseUsdgAmount(address token, uint256 amount);\n    event DirectPoolDeposit(address token, uint256 amount);\n    event IncreaseGuaranteedUsd(address token, uint256 amount);\n    event IncreasePoolAmount(address token, uint256 amount);\n    event IncreasePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        uint256 collateralDelta,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 price,\n        uint256 fee\n    );\n    event IncreaseReservedAmount(address token, uint256 amount);\n    event IncreaseUsdgAmount(address token, uint256 amount);\n    event LiquidatePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        bool isLong,\n        uint256 size,\n        uint256 collateral,\n        uint256 reserveAmount,\n        int256 realisedPnl,\n        uint256 markPrice\n    );\n    event SellUSDG(address account, address token, uint256 usdgAmount, uint256 tokenAmount, uint256 feeBasisPoints);\n    event Swap(\n        address account,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 amountOutAfterFees,\n        uint256 feeBasisPoints\n    );\n    event UpdateFundingRate(address token, uint256 fundingRate);\n    event UpdatePnl(bytes32 key, bool hasProfit, uint256 delta);\n    event UpdatePosition(\n        bytes32 key,\n        uint256 size,\n        uint256 collateral,\n        uint256 averagePrice,\n        uint256 entryFundingRate,\n        uint256 reserveAmount,\n        int256 realisedPnl\n    );\n\n    function BASIS_POINTS_DIVISOR() external view returns (uint256);\n\n    function FUNDING_RATE_PRECISION() external view returns (uint256);\n\n    function MAX_FEE_BASIS_POINTS() external view returns (uint256);\n\n    function MAX_FUNDING_RATE_FACTOR() external view returns (uint256);\n\n    function MAX_LIQUIDATION_FEE_USD() external view returns (uint256);\n\n    function MIN_FUNDING_RATE_INTERVAL() external view returns (uint256);\n\n    function MIN_LEVERAGE() external view returns (uint256);\n\n    function PRICE_PRECISION() external view returns (uint256);\n\n    function USDG_DECIMALS() external view returns (uint256);\n\n    function addRouter(address _router) external;\n\n    function adjustForDecimals(uint256 _amount, address _tokenDiv, address _tokenMul) external view returns (uint256);\n\n    function allWhitelistedTokens(uint256) external view returns (address);\n\n    function allWhitelistedTokensLength() external view returns (uint256);\n\n    function approvedRouters(address, address) external view returns (bool);\n\n    function bufferAmounts(address) external view returns (uint256);\n\n    function buyUSDG(address _token, address _receiver) external returns (uint256);\n\n    function clearTokenConfig(address _token) external;\n\n    function cumulativeFundingRates(address) external view returns (uint256);\n\n    function decreasePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver\n    ) external returns (uint256);\n\n    function directPoolDeposit(address _token) external;\n\n    function errorController() external view returns (address);\n\n    function errors(uint256) external view returns (string memory);\n\n    function feeReserves(address) external view returns (uint256);\n\n    function fundingInterval() external view returns (uint256);\n\n    function fundingRateFactor() external view returns (uint256);\n\n    function getDelta(\n        address _indexToken,\n        uint256 _size,\n        uint256 _averagePrice,\n        bool _isLong,\n        uint256 _lastIncreasedTime\n    ) external view returns (bool, uint256);\n\n    function getFeeBasisPoints(\n        address _token,\n        uint256 _usdgDelta,\n        uint256 _feeBasisPoints,\n        uint256 _taxBasisPoints,\n        bool _increment\n    ) external view returns (uint256);\n\n    function getFundingFee(address _token, uint256 _size, uint256 _entryFundingRate) external view returns (uint256);\n\n    function getGlobalShortDelta(address _token) external view returns (bool, uint256);\n\n    function getMaxPrice(address _token) external view returns (uint256);\n\n    function getMinPrice(address _token) external view returns (uint256);\n\n    function getNextAveragePrice(\n        address _indexToken,\n        uint256 _size,\n        uint256 _averagePrice,\n        bool _isLong,\n        uint256 _nextPrice,\n        uint256 _sizeDelta,\n        uint256 _lastIncreasedTime\n    ) external view returns (uint256);\n\n    function getNextFundingRate(address _token) external view returns (uint256);\n\n    function getNextGlobalShortAveragePrice(address _indexToken, uint256 _nextPrice, uint256 _sizeDelta) external view returns (uint256);\n\n    function getPosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) external view returns (uint256, uint256, uint256, uint256, uint256, uint256, bool, uint256);\n\n    function getPositionDelta(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) external view returns (bool, uint256);\n\n    function getPositionFee(uint256 _sizeDelta) external view returns (uint256);\n\n    function getPositionKey(address _account, address _collateralToken, address _indexToken, bool _isLong) external pure returns (bytes32);\n\n    function getPositionLeverage(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) external view returns (uint256);\n\n    function getRedemptionAmount(address _token, uint256 _usdgAmount) external view returns (uint256);\n\n    function getRedemptionCollateral(address _token) external view returns (uint256);\n\n    function getRedemptionCollateralUsd(address _token) external view returns (uint256);\n\n    function getTargetUsdgAmount(address _token) external view returns (uint256);\n\n    function getUtilisation(address _token) external view returns (uint256);\n\n    function globalShortAveragePrices(address) external view returns (uint256);\n\n    function globalShortSizes(address) external view returns (uint256);\n\n    function gov() external view returns (address);\n\n    function guaranteedUsd(address) external view returns (uint256);\n\n    function hasDynamicFees() external view returns (bool);\n\n    function inManagerMode() external view returns (bool);\n\n    function inPrivateLiquidationMode() external view returns (bool);\n\n    function includeAmmPrice() external view returns (bool);\n\n    function increasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong) external;\n\n    function initialize(\n        address _router,\n        address _usdg,\n        address _priceFeed,\n        uint256 _liquidationFeeUsd,\n        uint256 _fundingRateFactor,\n        uint256 _stableFundingRateFactor\n    ) external;\n\n    function isInitialized() external view returns (bool);\n\n    function isLeverageEnabled() external view returns (bool);\n\n    function isLiquidator(address) external view returns (bool);\n\n    function isManager(address) external view returns (bool);\n\n    function isSwapEnabled() external view returns (bool);\n\n    function lastFundingTimes(address) external view returns (uint256);\n\n    function liquidatePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong,\n        address _feeReceiver\n    ) external;\n\n    function liquidationFeeUsd() external view returns (uint256);\n\n    function marginFeeBasisPoints() external view returns (uint256);\n\n    function maxGasPrice() external view returns (uint256);\n\n    function maxLeverage() external view returns (uint256);\n\n    function maxUsdgAmounts(address) external view returns (uint256);\n\n    function minProfitBasisPoints(address) external view returns (uint256);\n\n    function minProfitTime() external view returns (uint256);\n\n    function mintBurnFeeBasisPoints() external view returns (uint256);\n\n    function poolAmounts(address) external view returns (uint256);\n\n    function positions(\n        bytes32\n    )\n        external\n        view\n        returns (\n            uint256 size,\n            uint256 collateral,\n            uint256 averagePrice,\n            uint256 entryFundingRate,\n            uint256 reserveAmount,\n            int256 realisedPnl,\n            uint256 lastIncreasedTime\n        );\n\n    function priceFeed() external view returns (address);\n\n    function removeRouter(address _router) external;\n\n    function reservedAmounts(address) external view returns (uint256);\n\n    function router() external view returns (address);\n\n    function sellUSDG(address _token, address _receiver) external returns (uint256);\n\n    function setBufferAmount(address _token, uint256 _amount) external;\n\n    function setError(uint256 _errorCode, string memory _error) external;\n\n    function setErrorController(address _errorController) external;\n\n    function setFees(\n        uint256 _taxBasisPoints,\n        uint256 _stableTaxBasisPoints,\n        uint256 _mintBurnFeeBasisPoints,\n        uint256 _swapFeeBasisPoints,\n        uint256 _stableSwapFeeBasisPoints,\n        uint256 _marginFeeBasisPoints,\n        uint256 _liquidationFeeUsd,\n        uint256 _minProfitTime,\n        bool _hasDynamicFees\n    ) external;\n\n    function setFundingRate(uint256 _fundingInterval, uint256 _fundingRateFactor, uint256 _stableFundingRateFactor) external;\n\n    function setGov(address _gov) external;\n\n    function setInManagerMode(bool _inManagerMode) external;\n\n    function setInPrivateLiquidationMode(bool _inPrivateLiquidationMode) external;\n\n    function setIsLeverageEnabled(bool _isLeverageEnabled) external;\n\n    function setIsSwapEnabled(bool _isSwapEnabled) external;\n\n    function setLiquidator(address _liquidator, bool _isActive) external;\n\n    function setManager(address _manager, bool _isManager) external;\n\n    function setMaxGasPrice(uint256 _maxGasPrice) external;\n\n    function setMaxLeverage(uint256 _maxLeverage) external;\n\n    function setPriceFeed(address _priceFeed) external;\n\n    function setTokenConfig(\n        address _token,\n        uint256 _tokenDecimals,\n        uint256 _tokenWeight,\n        uint256 _minProfitBps,\n        uint256 _maxUsdgAmount,\n        bool _isStable,\n        bool _isShortable\n    ) external;\n\n    function setUsdgAmount(address _token, uint256 _amount) external;\n\n    function shortableTokens(address) external view returns (bool);\n\n    function stableFundingRateFactor() external view returns (uint256);\n\n    function stableSwapFeeBasisPoints() external view returns (uint256);\n\n    function stableTaxBasisPoints() external view returns (uint256);\n\n    function stableTokens(address) external view returns (bool);\n\n    function swap(address _tokenIn, address _tokenOut, address _receiver) external returns (uint256);\n\n    function swapFeeBasisPoints() external view returns (uint256);\n\n    function taxBasisPoints() external view returns (uint256);\n\n    function tokenBalances(address) external view returns (uint256);\n\n    function tokenDecimals(address) external view returns (uint256);\n\n    function tokenToUsdMin(address _token, uint256 _tokenAmount) external view returns (uint256);\n\n    function tokenWeights(address) external view returns (uint256);\n\n    function totalTokenWeights() external view returns (uint256);\n\n    function updateCumulativeFundingRate(address _token) external;\n\n    function upgradeVault(address _newVault, address _token, uint256 _amount) external;\n\n    function usdToToken(address _token, uint256 _usdAmount, uint256 _price) external view returns (uint256);\n\n    function usdToTokenMax(address _token, uint256 _usdAmount) external view returns (uint256);\n\n    function usdToTokenMin(address _token, uint256 _usdAmount) external view returns (uint256);\n\n    function usdg() external view returns (address);\n\n    function usdgAmounts(address) external view returns (uint256);\n\n    function useSwapPricing() external view returns (bool);\n\n    function validateLiquidation(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong,\n        bool _raise\n    ) external view returns (uint256, uint256);\n\n    function whitelistedTokenCount() external view returns (uint256);\n\n    function whitelistedTokens(address) external view returns (bool);\n\n    function withdrawFees(address _token, address _receiver) external returns (uint256);\n}\n\ninterface IGmxVester {\n    function rewardTracker() external view returns (address);\n\n    function claimForAccount(address _account, address _receiver) external returns (uint256);\n\n    function claimable(address _account) external view returns (uint256);\n\n    function setHasMaxVestableAmount(bool _hasMaxVestableAmount) external;\n\n    function cumulativeClaimAmounts(address _account) external view returns (uint256);\n\n    function claimedAmounts(address _account) external view returns (uint256);\n\n    function pairAmounts(address _account) external view returns (uint256);\n\n    function getVestedAmount(address _account) external view returns (uint256);\n\n    function transferredAverageStakedAmounts(address _account) external view returns (uint256);\n\n    function transferredCumulativeRewards(address _account) external view returns (uint256);\n\n    function cumulativeRewardDeductions(address _account) external view returns (uint256);\n\n    function bonusRewards(address _account) external view returns (uint256);\n\n    function transferStakeValues(address _sender, address _receiver) external;\n\n    function setTransferredAverageStakedAmounts(address _account, uint256 _amount) external;\n\n    function setTransferredCumulativeRewards(address _account, uint256 _amount) external;\n\n    function setCumulativeRewardDeductions(address _account, uint256 _amount) external;\n\n    function setBonusRewards(address _account, uint256 _amount) external;\n\n    function getMaxVestableAmount(address _account) external view returns (uint256);\n\n    function getCombinedAverageStakedAmount(address _account) external view returns (uint256);\n\n    function deposit(uint256 _amount) external;\n\n    function withdraw() external;\n\n    function claim() external returns (uint256);\n\n    function getTotalVested(address _account) external view returns (uint256);\n\n    function balances(address account) external view returns (uint256);\n}\n\ninterface IVaultPriceFeed {\n    function adjustmentBasisPoints(address _token) external view returns (uint256);\n\n    function isAdjustmentAdditive(address _token) external view returns (bool);\n\n    function setAdjustment(address _token, bool _isAdditive, uint256 _adjustmentBps) external;\n\n    function setUseV2Pricing(bool _useV2Pricing) external;\n\n    function setIsAmmEnabled(bool _isEnabled) external;\n\n    function setIsSecondaryPriceEnabled(bool _isEnabled) external;\n\n    function setSpreadBasisPoints(address _token, uint256 _spreadBasisPoints) external;\n\n    function setSpreadThresholdBasisPoints(uint256 _spreadThresholdBasisPoints) external;\n\n    function setFavorPrimaryPrice(bool _favorPrimaryPrice) external;\n\n    function setPriceSampleSpace(uint256 _priceSampleSpace) external;\n\n    function setMaxStrictPriceDeviation(uint256 _maxStrictPriceDeviation) external;\n\n    function getPrice(address _token, bool _maximise, bool _includeAmmPrice, bool _useSwapPricing) external view returns (uint256);\n\n    function getAmmPrice(address _token) external view returns (uint256);\n\n    function getPrimaryPrice(address _token, bool _maximise) external view returns (uint256);\n}\n\ninterface IGmxRewardDistributor {\n    function pendingRewards() external view returns (uint256);\n\n    function distribute() external returns (uint256);\n}\n\ninterface IGmxRewardRouterV2 {\n    type VotingPowerType is uint8;\n\n    event StakeGlp(address account, uint256 amount);\n    event StakeGmx(address account, address token, uint256 amount);\n    event UnstakeGlp(address account, uint256 amount);\n    event UnstakeGmx(address account, address token, uint256 amount);\n\n    function BASIS_POINTS_DIVISOR() external view returns (uint256);\n\n    function acceptTransfer(address _sender) external;\n\n    function batchCompoundForAccounts(address[] memory _accounts) external;\n\n    function batchStakeGmxForAccount(address[] memory _accounts, uint256[] memory _amounts) external;\n\n    function bnGmx() external view returns (address);\n\n    function bonusGmxTracker() external view returns (address);\n\n    function claim() external;\n\n    function claimEsGmx() external;\n\n    function claimFees() external;\n\n    function compound() external;\n\n    function compoundForAccount(address _account) external;\n\n    function esGmx() external view returns (address);\n\n    function feeGlpTracker() external view returns (address);\n\n    function feeGmxTracker() external view returns (address);\n\n    function glp() external view returns (address);\n\n    function glpManager() external view returns (address);\n\n    function glpVester() external view returns (address);\n\n    function gmx() external view returns (address);\n\n    function gmxVester() external view returns (address);\n\n    function gov() external view returns (address);\n\n    function govToken() external view returns (address);\n\n    function handleRewards(\n        bool shouldClaimGmx,\n        bool shouldStakeGmx,\n        bool shouldClaimEsGmx,\n        bool shouldStakeEsGmx,\n        bool shouldStakeMultiplierPoints,\n        bool shouldClaimWeth,\n        bool shouldConvertWethToEth\n    ) external;\n\n    function inStrictTransferMode() external view returns (bool);\n\n    function initialize(\n        address _weth,\n        address _gmx,\n        address _esGmx,\n        address _bnGmx,\n        address _glp,\n        address _stakedGmxTracker,\n        address _bonusGmxTracker,\n        address _feeGmxTracker,\n        address _feeGlpTracker,\n        address _stakedGlpTracker,\n        address _glpManager,\n        address _gmxVester,\n        address _glpVester,\n        address _govToken\n    ) external;\n\n    function isInitialized() external view returns (bool);\n\n    function maxBoostBasisPoints() external view returns (uint256);\n\n    function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns (uint256);\n\n    function mintAndStakeGlpETH(uint256 _minUsdg, uint256 _minGlp) external payable returns (uint256);\n\n    function pendingReceivers(address) external view returns (address);\n\n    function setGov(address _gov) external;\n\n    function setInStrictTransferMode(bool _inStrictTransferMode) external;\n\n    function setMaxBoostBasisPoints(uint256 _maxBoostBasisPoints) external;\n\n    function setVotingPowerType(VotingPowerType _votingPowerType) external;\n\n    function signalTransfer(address _receiver) external;\n\n    function stakeEsGmx(uint256 _amount) external;\n\n    function stakeGmx(uint256 _amount) external;\n\n    function stakeGmxForAccount(address _account, uint256 _amount) external;\n\n    function stakedGlpTracker() external view returns (address);\n\n    function stakedGmxTracker() external view returns (address);\n\n    function unstakeAndRedeemGlp(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);\n\n    function unstakeAndRedeemGlpETH(uint256 _glpAmount, uint256 _minOut, address payable _receiver) external returns (uint256);\n\n    function unstakeEsGmx(uint256 _amount) external;\n\n    function unstakeGmx(uint256 _amount) external;\n\n    function votingPowerType() external view returns (VotingPowerType);\n\n    function weth() external view returns (address);\n\n    function withdrawToken(address _token, address _account, uint256 _amount) external;\n}\n\ninterface IGmxRewardTracker {\n    function rewardToken() external view returns (address);\n\n    function depositBalances(address _account, address _depositToken) external view returns (uint256);\n\n    function stakedAmounts(address _account) external view returns (uint256);\n\n    function updateRewards() external;\n\n    function stake(address _depositToken, uint256 _amount) external;\n\n    function stakeForAccount(address _fundingAccount, address _account, address _depositToken, uint256 _amount) external;\n\n    function unstake(address _depositToken, uint256 _amount) external;\n\n    function unstakeForAccount(address _account, address _depositToken, uint256 _amount, address _receiver) external;\n\n    function tokensPerInterval() external view returns (uint256);\n\n    function claim(address _receiver) external returns (uint256);\n\n    function claimForAccount(address _account, address _receiver) external returns (uint256);\n\n    function claimable(address _account) external view returns (uint256);\n\n    function averageStakedAmounts(address _account) external view returns (uint256);\n\n    function cumulativeRewards(address _account) external view returns (uint256);\n}\n\ninterface IGmxStakedGlp {\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    function allowances(address, address) external view returns (uint256);\n\n    function approve(address _spender, uint256 _amount) external returns (bool);\n\n    function balanceOf(address _account) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function feeGlpTracker() external view returns (address);\n\n    function glp() external view returns (address);\n\n    function glpManager() external view returns (address);\n\n    function name() external view returns (string memory);\n\n    function stakedGlpTracker() external view returns (address);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\n\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool);\n}\n\ninterface IGmxGlpRewardRouter {\n    event StakeGlp(address account, uint256 amount);\n    event StakeGmx(address account, address token, uint256 amount);\n    event UnstakeGlp(address account, uint256 amount);\n    event UnstakeGmx(address account, address token, uint256 amount);\n\n    function acceptTransfer(address _sender) external;\n\n    function batchCompoundForAccounts(address[] memory _accounts) external;\n\n    function batchStakeGmxForAccount(address[] memory _accounts, uint256[] memory _amounts) external;\n\n    function claim() external;\n\n    function claimEsGmx() external;\n\n    function claimFees() external;\n\n    function compound() external;\n\n    function compoundForAccount(address _account) external;\n\n    function feeGlpTracker() external view returns (address);\n\n    function glp() external view returns (address);\n\n    function glpManager() external view returns (address);\n\n    function gov() external view returns (address);\n\n    function handleRewards(\n        bool shouldClaimGmx,\n        bool shouldStakeGmx,\n        bool shouldClaimEsGmx,\n        bool shouldStakeEsGmx,\n        bool shouldStakeMultiplierPoints,\n        bool shouldClaimWeth,\n        bool shouldConvertWethToEth\n    ) external;\n\n    function initialize(\n        address _weth,\n        address _gmx,\n        address _esGmx,\n        address _bnGmx,\n        address _glp,\n        address _stakedGmxTracker,\n        address _bonusGmxTracker,\n        address _feeGmxTracker,\n        address _feeGlpTracker,\n        address _stakedGlpTracker,\n        address _glpManager,\n        address _gmxVester,\n        address _glpVester\n    ) external;\n\n    function isInitialized() external view returns (bool);\n\n    function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns (uint256);\n\n    function mintAndStakeGlpETH(uint256 _minUsdg, uint256 _minGlp) external payable returns (uint256);\n\n    function pendingReceivers(address) external view returns (address);\n\n    function setGov(address _gov) external;\n\n    function signalTransfer(address _receiver) external;\n\n    function stakeEsGmx(uint256 _amount) external;\n\n    function stakeGmx(uint256 _amount) external;\n\n    function stakeGmxForAccount(address _account, uint256 _amount) external;\n\n    function stakedGlpTracker() external view returns (address);\n\n    function stakedGmxTracker() external view returns (address);\n\n    function unstakeAndRedeemGlp(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);\n\n    function unstakeAndRedeemGlpETH(uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);\n\n    function unstakeEsGmx(uint256 _amount) external;\n\n    function unstakeGmx(uint256 _amount) external;\n\n    function withdrawToken(address _token, address _account, uint256 _amount) external;\n}\n\ninterface IGmxGlpManager {\n    event AddLiquidity(\n        address account,\n        address token,\n        uint256 amount,\n        uint256 aumInUsdg,\n        uint256 glpSupply,\n        uint256 usdgAmount,\n        uint256 mintAmount\n    );\n    event RemoveLiquidity(\n        address account,\n        address token,\n        uint256 glpAmount,\n        uint256 aumInUsdg,\n        uint256 glpSupply,\n        uint256 usdgAmount,\n        uint256 amountOut\n    );\n\n    function BASIS_POINTS_DIVISOR() external view returns (uint256);\n\n    function GLP_PRECISION() external view returns (uint256);\n\n    function MAX_COOLDOWN_DURATION() external view returns (uint256);\n\n    function PRICE_PRECISION() external view returns (uint256);\n\n    function USDG_DECIMALS() external view returns (uint256);\n\n    function addLiquidity(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns (uint256);\n\n    function addLiquidityForAccount(\n        address _fundingAccount,\n        address _account,\n        address _token,\n        uint256 _amount,\n        uint256 _minUsdg,\n        uint256 _minGlp\n    ) external returns (uint256);\n\n    function aumAddition() external view returns (uint256);\n\n    function aumDeduction() external view returns (uint256);\n\n    function cooldownDuration() external view returns (uint256);\n\n    function getAum(bool maximise) external view returns (uint256);\n\n    function getAumInUsdg(bool maximise) external view returns (uint256);\n\n    function getAums() external view returns (uint256[] memory);\n\n    function getGlobalShortAveragePrice(address _token) external view returns (uint256);\n\n    function getGlobalShortDelta(address _token, uint256 _price, uint256 _size) external view returns (uint256, bool);\n\n    function getPrice(bool _maximise) external view returns (uint256);\n\n    function glp() external view returns (address);\n\n    function gov() external view returns (address);\n\n    function inPrivateMode() external view returns (bool);\n\n    function isHandler(address) external view returns (bool);\n\n    function lastAddedAt(address) external view returns (uint256);\n\n    function removeLiquidity(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);\n\n    function removeLiquidityForAccount(\n        address _account,\n        address _tokenOut,\n        uint256 _glpAmount,\n        uint256 _minOut,\n        address _receiver\n    ) external returns (uint256);\n\n    function setAumAdjustment(uint256 _aumAddition, uint256 _aumDeduction) external;\n\n    function setCooldownDuration(uint256 _cooldownDuration) external;\n\n    function setGov(address _gov) external;\n\n    function setHandler(address _handler, bool _isActive) external;\n\n    function setInPrivateMode(bool _inPrivateMode) external;\n\n    function setShortsTracker(address _shortsTracker) external;\n\n    function setShortsTrackerAveragePriceWeight(uint256 _shortsTrackerAveragePriceWeight) external;\n\n    function shortsTracker() external view returns (address);\n\n    function shortsTrackerAveragePriceWeight() external view returns (uint256);\n\n    function usdg() external view returns (address);\n\n    function vault() external view returns (address);\n}\n\ninterface IGmxGlpRewardHandler {\n    function harvest() external;\n\n    function swapRewards(\n        uint256 amountOutMin,\n        IERC20 rewardToken,\n        IERC20 outputToken,\n        address recipient,\n        bytes calldata data\n    ) external returns (uint256 amountOut);\n\n    function setFeeParameters(address _feeCollector, uint8 _feePercent) external;\n\n    function setRewardTokenEnabled(IERC20 token, bool enabled) external;\n\n    function setSwappingTokenOutEnabled(IERC20 token, bool enabled) external;\n\n    function setAllowedSwappingRecipient(address recipient, bool enabled) external;\n\n    function setRewardRouter(IGmxRewardRouterV2 _rewardRouter) external;\n\n    function setSwapper(address _swapper) external;\n\n    function unstakeGmx(uint256 amount, uint256 amountTransferToFeeCollector) external;\n\n    function unstakeEsGmxAndVest(uint256 amount, uint256 glpVesterDepositAmount, uint256 gmxVesterDepositAmount) external;\n\n    function withdrawFromVesting(bool withdrawFromGlpVester, bool withdrawFromGmxVester, bool stake) external;\n\n    function claimVestedGmx(bool withdrawFromGlpVester, bool withdrawFromGmxVester, bool stake, bool transferToFeeCollecter) external;\n}\n"
      }
    },
    "settings": {
      "remappings": [
        "/=src/",
        "forge-std/=dependencies/forge-std-1.9.5/src/",
        "halmos-cheatcodes/=dependencies/halmos-cheatcodes-7328abe/src/",
        "@openzeppelin/contracts/=dependencies/openzeppelin-contracts-5.0.2/contracts/",
        "@openzeppelin/contracts-upgradeable/=dependencies/openzeppelin-contracts-upgradeable-5.0.2/contracts/",
        "@BoringSolidity/=dependencies/BoringSolidity-1.0.0/contracts/",
        "@solady/=dependencies/solady-0.0.281/src/",
        "@solmate/=dependencies/solmate-6.2.0/src/",
        "@excessivelySafeCall/=dependencies/ExcessivelySafeCall-0.0.1/src/",
        "@safe-contracts/=dependencies/safe-contracts-1.3.0/contracts/",
        "@fuzzlib/=dependencies/fuzzlib-0.0.1/src/",
        "@abracadabra-oft-v1/=dependencies/abracadabra-oft-v1-0.0.1/src/",
        "@prb/math/=dependencies/prb-math-4.1.0/src/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 400
      },
      "metadata": {
        "useLiteralContent": false,
        "bytecodeHash": "ipfs",
        "appendCBOR": true
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode.object",
            "evm.bytecode.sourceMap",
            "evm.bytecode.linkReferences",
            "evm.deployedBytecode.object",
            "evm.deployedBytecode.sourceMap",
            "evm.deployedBytecode.linkReferences",
            "evm.deployedBytecode.immutableReferences",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "evmVersion": "cancun",
      "viaIR": false,
      "libraries": {}
    }
  },
  "compiler": "0.8.28+commit.7893614a"
}