{
  "address": "0x7D594cBa55D6359bd02403Fb9ADd3569D5F03DC7",
  "abi": [
    {
      "type": "constructor",
      "inputs": [
        {
          "name": "_stakingToken",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_lockingBoostMultiplerInBips",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "_rewardsDuration",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "_lockDuration",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "_owner",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "addReward",
      "inputs": [
        {
          "name": "rewardToken",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "balanceOf",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "balances",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "tuple",
          "internalType": "struct LockingMultiRewards.Balances",
          "components": [
            {
              "name": "unlocked",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "locked",
              "type": "uint256",
              "internalType": "uint256"
            }
          ]
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "earned",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "rewardToken",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "epoch",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getRewards",
      "inputs": [],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "lastLockIndex",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "index",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "lastTimeRewardApplicable",
      "inputs": [
        {
          "name": "rewardToken",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "lock",
      "inputs": [
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "lockingDeadline",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "lockDuration",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "locked",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "lockedSupply",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "lockingBoostMultiplerInBips",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "maxLocks",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "minLockAmount",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "nextEpoch",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "nextUnlockTime",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "notifyRewardAmount",
      "inputs": [
        {
          "name": "rewardToken",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "minRemainingTime",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "operators",
      "inputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "owner",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "pause",
      "inputs": [],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "paused",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "processExpiredLocks",
      "inputs": [
        {
          "name": "users",
          "type": "address[]",
          "internalType": "address[]"
        },
        {
          "name": "lockIndexes",
          "type": "uint256[]",
          "internalType": "uint256[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "recover",
      "inputs": [
        {
          "name": "tokenAddress",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "tokenAmount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "remainingEpochTime",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "rewardData",
      "inputs": [
        {
          "name": "token",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "tuple",
          "internalType": "struct LockingMultiRewards.Reward",
          "components": [
            {
              "name": "periodFinish",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "rewardRate",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "rewardPerTokenStored",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "exists",
              "type": "bool",
              "internalType": "bool"
            },
            {
              "name": "lastUpdateTime",
              "type": "uint248",
              "internalType": "uint248"
            }
          ]
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "rewardPerToken",
      "inputs": [
        {
          "name": "rewardToken",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "rewardTokens",
      "inputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "rewardTokensLength",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "rewards",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "token",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "rewardsDuration",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "rewardsForDuration",
      "inputs": [
        {
          "name": "rewardToken",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "setMinLockAmount",
      "inputs": [
        {
          "name": "_minLockAmount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setOperator",
      "inputs": [
        {
          "name": "operator",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "enable",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "stake",
      "inputs": [
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "stakeFor",
      "inputs": [
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "lock_",
          "type": "bool",
          "internalType": "bool"
        },
        {
          "name": "lockingDeadline",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "stakeLocked",
      "inputs": [
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "lockingDeadline",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "stakingToken",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "stakingTokenBalance",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "totalSupply",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "transferOwnership",
      "inputs": [
        {
          "name": "newOwner",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "unlocked",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "unlockedSupply",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "unpause",
      "inputs": [],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "userLocks",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "tuple[]",
          "internalType": "struct LockingMultiRewards.LockedBalance[]",
          "components": [
            {
              "name": "amount",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "unlockTime",
              "type": "uint256",
              "internalType": "uint256"
            }
          ]
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "userLocksLength",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "userRewardLock",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "tuple",
          "internalType": "struct LockingMultiRewards.RewardLock",
          "components": [
            {
              "name": "items",
              "type": "tuple[]",
              "internalType": "struct LockingMultiRewards.RewardLockItem[]",
              "components": [
                {
                  "name": "token",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256",
                  "internalType": "uint256"
                }
              ]
            },
            {
              "name": "unlockTime",
              "type": "uint256",
              "internalType": "uint256"
            }
          ]
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "userRewardPerTokenPaid",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "token",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "withdraw",
      "inputs": [
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "withdrawWithRewards",
      "inputs": [
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "event",
      "name": "LogLockIndexChanged",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "fromIndex",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        },
        {
          "name": "toIndex",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "LogLocked",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        },
        {
          "name": "unlockTime",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        },
        {
          "name": "lockCount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "LogRecovered",
      "inputs": [
        {
          "name": "token",
          "type": "address",
          "indexed": false,
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "LogRewardAdded",
      "inputs": [
        {
          "name": "reward",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "LogRewardLockCreated",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "unlockTime",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "LogRewardLocked",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "rewardsToken",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "reward",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "LogRewardPaid",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "rewardsToken",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "reward",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "LogRewardsDurationUpdated",
      "inputs": [
        {
          "name": "token",
          "type": "address",
          "indexed": false,
          "internalType": "address"
        },
        {
          "name": "newDuration",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "LogSetMinLockAmount",
      "inputs": [
        {
          "name": "previous",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        },
        {
          "name": "current",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "LogStaked",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "LogUnlocked",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        },
        {
          "name": "index",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "LogWithdrawn",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "OperatorChanged",
      "inputs": [
        {
          "name": "",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "",
          "type": "bool",
          "indexed": false,
          "internalType": "bool"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "OwnershipTransferred",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "newOwner",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "Paused",
      "inputs": [
        {
          "name": "account",
          "type": "address",
          "indexed": false,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "Unpaused",
      "inputs": [
        {
          "name": "account",
          "type": "address",
          "indexed": false,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "error",
      "name": "EnforcedPause",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrExpired",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrInsufficientRemainingTime",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrInvalidBoostMultiplier",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrInvalidDurationRatio",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrInvalidLockDuration",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrInvalidLockIndex",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrInvalidRewardDuration",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrInvalidTokenAddress",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrInvalidUser",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrLengthMismatch",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrLockAmountTooSmall",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrLockNotExpired",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrMaxRewardsExceeded",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrMaxUserLocksExceeded",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrNoLocks",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrNotEnoughReward",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrNotExpired",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrRewardAlreadyExists",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrSkimmingTooMuch",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrZeroAmount",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ExpectedPause",
      "inputs": []
    },
    {
      "type": "error",
      "name": "Unauthorized",
      "inputs": []
    }
  ],
  "bytecode": "0x610120604052348015610010575f80fd5b5060405161296d38038061296d83398101604081905261002f91610179565b6002805460ff19169055612710841161005b5760405163f4cf51e960e01b815260040160405180910390fd5b62093a8082101561007f57604051632b55877560e11b815260040160405180910390fd5b620151808310156100a357604051631c7d3c2560e31b815260040160405180910390fd5b6100ad83836101db565b156100cb57604051630a7559b160e11b815260040160405180910390fd5b6100d481610114565b6001600160a01b0385166101005260a084905260c083905260e08290526100fb83836101ee565b610106906001610201565b608052506102269350505050565b5f80546001600160a01b0319166001600160a01b03831690811782556040519091907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a350565b80516001600160a01b0381168114610174575f80fd5b919050565b5f805f805f60a0868803121561018d575f80fd5b6101968661015e565b602087015160408801516060890151929750909550935091506101bb6080870161015e565b90509295509295909350565b634e487b7160e01b5f52601260045260245ffd5b5f826101e9576101e96101c7565b500690565b5f826101fc576101fc6101c7565b500490565b8082018082111561022057634e487b7160e01b5f52601160045260245ffd5b92915050565b60805160a05160c05160e051610100516126bd6102b05f395f81816105f401528181610b0a01528181610d4701528181610d910152611bda01525f8181610357015261165401525f81816104ab015281816108e801528181610f21015261157e01525f818161066901528181610a140152610e8a01525f81816105900152611a4b01526126bd5ff3fe608060405234801561000f575f80fd5b5060043610610325575f3560e01c80637bb7bed1116101a8578063aea0e78b116100f3578063d72d7c7c1161009e578063f2fde38b11610079578063f2fde38b146107eb578063f8737bc0146107fe578063fbfd68b314610806578063fd3d27b814610825575f80fd5b8063d72d7c7c146107a6578063e70b9e27146107ae578063f1229777146107d8575f80fd5b8063ca5c7b91116100ce578063ca5c7b911461074a578063cbf9fe5f14610753578063d1846d0c1461077e575f80fd5b8063aea0e78b14610712578063bf199e621461071a578063c28aa3d814610722575f80fd5b80639c9b2e2111610153578063a3cd8ac41161012e578063a3cd8ac4146106cc578063a694fc3a146106df578063ab1e426f146106f2575f80fd5b80639c9b2e2114610693578063a0061423146106a6578063a117e65c146106b9575f80fd5b80638da5cb5b116101835780638da5cb5b146106525780638e80d22114610664578063900cf0cf1461068b575f80fd5b80637bb7bed11461062e5780638456cb59146106415780638caaa27114610649575f80fd5b80632e1a7d4d116102735780635705ae431161021e5780636d6c0009116101f95780636d6c00091461058b5780637035ab98146105b257806370a08231146105dc57806372f702f3146105ef575f80fd5b80635705ae431461055a5780635c975abb1461056d578063638634ee14610578575f80fd5b806348e5d9f81161024e57806348e5d9f8146104d5578063498de63a14610534578063558a729714610547575f80fd5b80632e1a7d4d14610493578063386a9525146104a65780633f4ba83a146104cd575f80fd5b80631338736f116102d357806318160ddd116102ae57806318160ddd14610418578063211dc32d1461042057806327e235e314610433575f80fd5b80631338736f146103c057806313e7c9d8146103d357806317b18c8914610405575f80fd5b80630684f553116103035780630684f5531461039157806308804275146103a45780630f68ae40146103ad575f80fd5b80630259ef581461032957806304554443146103525780630572b0cc14610387575b5f80fd5b61033c610337366004612265565b61082e565b604051610349919061227e565b60405180910390f35b6103797f000000000000000000000000000000000000000000000000000000000000000081565b604051908152602001610349565b61038f6108b3565b005b61037961039f366004612265565b6108c7565b610379600d5481565b61038f6103bb3660046122d5565b610913565b61038f6103ce3660046122ec565b61097d565b6103f56103e1366004612265565b60016020525f908152604090205460ff1681565b6040519015158152602001610349565b61038f6104133660046122ec565b6109f9565b610379610a0e565b61037961042e36600461230c565b610a5c565b610486610441366004612265565b604080518082019091525f8082526020820152506001600160a01b03165f90815260046020908152604091829020825180840190935280548352600101549082015290565b604051610349919061233d565b61038f6104a13660046122d5565b610a80565b6103797f000000000000000000000000000000000000000000000000000000000000000081565b61038f610b69565b6104e86104e3366004612265565b610b9a565b60405161034991905f60a0820190508251825260208301516020830152604083015160408301526060830151151560608301526001600160f81b03608084015116608083015292915050565b61038f610542366004612363565b610c35565b61038f6105553660046123a4565b610c95565b61038f6105683660046123cc565b610d1c565b60025460ff166103f5565b610379610586366004612265565b610e41565b6103797f000000000000000000000000000000000000000000000000000000000000000081565b6103796105c036600461230c565b600760209081525f928352604080842090915290825290205481565b6103796105ea366004612265565b610e64565b6106167f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610349565b61061661063c3660046122d5565b610ec5565b61038f610eed565b610379600e5481565b5f54610616906001600160a01b031681565b6103797f000000000000000000000000000000000000000000000000000000000000000081565b610379610f1e565b61038f6106a1366004612265565b610f54565b61038f6106b4366004612450565b610f89565b61038f6106c73660046122d5565b61130c565b61038f6106da36600461254a565b61131e565b61038f6106ed3660046122d5565b6114b9565b610705610700366004612265565b6114ce565b604051610349919061257a565b61037961157b565b600a54610379565b610379610730366004612265565b6001600160a01b03165f9081526005602052604090205490565b610379600b5481565b610379610761366004612265565b6001600160a01b03165f9081526004602052604090206001015490565b61037961078c366004612265565b6001600160a01b03165f9081526004602052604090205490565b6103796115af565b6103796107bc36600461230c565b600860209081525f928352604080842090915290825290205481565b6103796107e6366004612265565b6115c3565b61038f6107f9366004612265565b6115de565b610379611651565b610379610814366004612265565b60096020525f908152604090205481565b610379600c5481565b6001600160a01b0381165f908152600560209081526040808320805482518185028101850190935280835260609492939192909184015b828210156108a8578382905f5260205f2090600202016040518060400160405290815f820154815260200160018201548152505081526020019060010190610865565b505050509050919050565b6108bc3361167b565b6108c5336116e6565b565b6001600160a01b0381165f9081526003602052604081206001015461090d907f000000000000000000000000000000000000000000000000000000000000000090612603565b92915050565b5f546001600160a01b0316331461093c576040516282b42960e81b815260040160405180910390fd5b600d5460408051918252602082018390527f3d33373e68f7f425ee72b228a9ad73001d4387d8d7980f14fb3cfdffe7dad889910160405180910390a1600d55565b61098561193e565b815f036109a557604051631820a52b60e21b815260040160405180910390fd5b6109ae3361167b565b335f90815260046020526040812080548492906109cc90849061261a565b9250508190555081600c5f8282546109e4919061261a565b909155506109f59050338383611962565b5050565b610a0161193e565b6109f53383600184611bad565b5f6127107f0000000000000000000000000000000000000000000000000000000000000000600b54610a409190612603565b610a4a919061262d565b600c54610a57919061264c565b905090565b5f610a7983610a6a85610e64565b84610a74866115c3565b611cc0565b9392505050565b805f03610aa057604051631820a52b60e21b815260040160405180910390fd5b610aa93361167b565b335f9081526004602052604081208054839290610ac790849061261a565b9250508190555080600c5f828254610adf919061261a565b9250508190555080600e5f828254610af7919061261a565b90915550610b3190506001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163383611d4c565b60405181815233907fe0535c2eb3e1755a11a8ee1dba6e7b72ea1487e87be0d02fca7c1038eaacbd5c9060200160405180910390a250565b5f546001600160a01b03163314610b92576040516282b42960e81b815260040160405180910390fd5b6108c5611d95565b610bd26040518060a001604052805f81526020015f81526020015f81526020015f151581526020015f6001600160f81b031681525090565b506001600160a01b03165f90815260036020818152604092839020835160a0810185528154815260018201549281019290925260028101549382019390935291015460ff81161515606083015261010090046001600160f81b0316608082015290565b335f9081526001602052604090205460ff16158015610c5e57505f546001600160a01b03163314155b15610c7b576040516282b42960e81b815260040160405180910390fd5b610c8361193e565b610c8f84848484611bad565b50505050565b5f546001600160a01b03163314610cbe576040516282b42960e81b815260040160405180910390fd5b6001600160a01b0382165f81815260016020908152604091829020805460ff191685151590811790915591519182527f193de8d500b5cb7b720089b258a39e9c1d0b840019a73ae7c51c3f9101732b02910160405180910390a25050565b5f546001600160a01b03163314610d45576040516282b42960e81b815260040160405180910390fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316826001600160a01b0316148015610dc45750600e54610db76001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001630611de7565b610dc1919061261a565b81115b15610de2576040516329c42e1760e21b815260040160405180910390fd5b5f54610dfb906001600160a01b03848116911683611d4c565b604080516001600160a01b0384168152602081018390527f2ecbdc877534d6cf5048feb3873780484f0544dadb27fa1d7c7f85262164cb92910160405180910390a15050565b6001600160a01b0381165f9081526003602052604081205461090d904290611e1a565b6001600160a01b0381165f908152600460205260408120600181015461271090610eaf907f000000000000000000000000000000000000000000000000000000000000000090612603565b610eb9919061262d565b8154610a79919061264c565b600a8181548110610ed4575f80fd5b5f918252602090912001546001600160a01b0316905081565b5f546001600160a01b03163314610f16576040516282b42960e81b815260040160405180910390fd5b6108c5611e2f565b5f7f0000000000000000000000000000000000000000000000000000000000000000610f4a814261262d565b610a579190612603565b5f546001600160a01b03163314610f7d576040516282b42960e81b815260040160405180910390fd5b610f8681611e6c565b50565b335f9081526001602052604090205460ff16158015610fb257505f546001600160a01b03163314155b15610fcf576040516282b42960e81b815260040160405180910390fd5b82518114610ff05760405163ab3a7f9960e01b815260040160405180910390fd5b610ff983611f5f565b5f5b8351811015610c8f575f8482815181106110175761101761265f565b6020908102919091018101516001600160a01b0381165f908152600483526040808220600590945281208054929450919003611066576040516304ed977960e01b815260040160405180910390fd5b5f8686868181106110795761107961265f565b90506020020135905060095f856001600160a01b03166001600160a01b031681526020019081526020015f2054811480156110b5575081546001105b156110d357604051635b9b850b60e01b815260040160405180910390fd5b428282815481106110e6576110e661265f565b905f5260205f209060020201600101541115611115576040516327a22e9760e21b815260040160405180910390fd5b5f8282815481106111285761112861265f565b5f918252602082206002909102015484549092506111489060019061261a565b6001600160a01b0387165f90815260096020526040902054909150819003611185576001600160a01b0386165f9081526009602052604090208390555b8083146112285783818154811061119e5761119e61265f565b905f5260205f2090600202018484815481106111bc576111bc61265f565b5f918252602090912082546002909202019081556001918201549101556040516001600160a01b038716907fc867cead03921f926f197726d0c3f6a8f763f949778e8b63ad246ae7a5fa08fb9061121f9084908790918252602082015260400190565b60405180910390a25b8380548061123857611238612673565b5f8281526020812060025f19909301928302018181556001018190559155600c805484929061126890849061264c565b9250508190555081600b5f828254611280919061261a565b90915550508454829086905f9061129890849061264c565b9250508190555081856001015f8282546112b2919061261a565b909155505060408051838152602081018590526001600160a01b038816917f547cf2b25861a7cc4fcc2d7e863af13d10e4c871fdae73418a4999aaad573e3a910160405180910390a2866001019650505050505050610ffb565b61131581610a80565b610f86336116e6565b335f9081526001602052604090205460ff1615801561134757505f546001600160a01b03163314155b15611364576040516282b42960e81b815260040160405180910390fd5b6001600160a01b0383165f908152600360208190526040909120015460ff166113a0576040516336e175d760e01b815260040160405180910390fd5b6113a8612003565b6113bd6001600160a01b038416333085612053565b6001600160a01b0383165f908152600360205260408120906113dd61157b565b90505f6113ea428361261a565b90508381101561140c57604051620787c360ed1b815260040160405180910390fd5b82544210156114315760018301546114249082612603565b61142e908661264c565b94505b8085101561145257604051634a350da760e11b815260040160405180910390fd5b61145c818661262d565b600184015560038301805460ff16610100426001600160f81b0316021790558183556040518581527fc08e24329ac6ca989fa71d633536a170f3965594760cc27617606c8ce170d1d39060200160405180910390a1505050505050565b6114c161193e565b610f8633825f5f19611bad565b60408051808201825260608082525f60208084018290526001600160a01b038616825260068152848220855181549283028101850187529586018281529495949093859391928592909185015b82821015611562575f848152602090819020604080518082019091526002850290910180546001600160a01b0316825260019081015482840152908352909201910161151b565b5050505081526020016001820154815250509050919050565b5f7f00000000000000000000000000000000000000000000000000000000000000006115a5610f1e565b610a57919061264c565b5f426115b961157b565b610a57919061261a565b5f61090d826115d184610e41565b6115d9610a0e565b6120ab565b5f546001600160a01b03163314611607576040516282b42960e81b815260040160405180910390fd5b5f80546001600160a01b0319166001600160a01b0383169081178255604051909133917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a350565b5f7f00000000000000000000000000000000000000000000000000000000000000006115a561157b565b5f61168582610e64565b90505f611690610a0e565b90505f5b600a54811015610c8f575f600a82815481106116b2576116b261265f565b5f918252602090912001546001600160a01b031690506116dd8585836116d88188612177565b6121d5565b50600101611694565b6001600160a01b0381165f90815260066020526040902060018101548154429091118015919061175e5761171861157b565b600184018190556040519081526001600160a01b038516907f0cbdeed31ff34ef6a8c9d36d5be1efe4bcfbb4f12d946e93850e41054f711f9f9060200160405180910390a25b5f5b600a54811015611937575f600a828154811061177e5761177e61265f565b5f918252602080832091909101546001600160a01b0389811684526008835260408085209190921680855292528220805492905591508383101561187c575f865f0184815481106117d1576117d161265f565b905f5260205f2090600202019050851561185d57600181018054908390558015611857576118096001600160a01b0385168a83611d4c565b836001600160a01b0316896001600160a01b03167fdd58858d94d0be6876ebdfd817f0f8e9e1de4c7e88fffba2aae4e7b3a7e1cd598360405161184e91815260200190565b60405180910390a35b50611876565b81816001015f828254611870919061264c565b90915550505b506118e0565b6001600160a01b038781165f90815260066020908152604080832081518083019092528685168252818301868152815460018082018455928652939094209151600290930290910180546001600160a01b0319169290941691909117835590519101555b816001600160a01b0316876001600160a01b03167f995d621b93347fcb679648de29cd317d4dc633a070befad0fe8feaacb861d7df8360405161192591815260200190565b60405180910390a35050600101611760565b5050505050565b60025460ff16156108c55760405163d93c066560e01b815260040160405180910390fd5b4281101561198357604051630992d5df60e41b815260040160405180910390fd5b6001600160a01b0383165f908152600460205260408120906119a3611651565b6001600160a01b0386165f908152600960209081526040808320546005909252822054600186018054949550919390928892916119e190849061264c565b9250508190555085600b5f8282546119f9919061264c565b9091555050801580611a4457506001600160a01b0387165f908152600560205260409020805484919084908110611a3257611a3261265f565b905f5260205f20906002020160010154105b15611b0a577f00000000000000000000000000000000000000000000000000000000000000008103611a89576040516387adcff360e01b815260040160405180910390fd5b600d54861015611aac576040516391fbd38160e01b815260040160405180910390fd5b6001600160a01b0387165f818152600560209081526040808320815180830183528b81528084018981528254600181810185559387528587209251600290910290920191825551908201559383526009909152902082905501611b58565b6001600160a01b0387165f908152600560205260409020805487919084908110611b3657611b3661265f565b905f5260205f2090600202015f015f828254611b52919061264c565b90915550505b60408051878152602081018590529081018290526001600160a01b038816907f509e788e234b4b878b1737858029dc05d8bc68a8a909a5b5f0b4f51ff8fa55059060600160405180910390a250505050505050565b825f03611bcd57604051631820a52b60e21b815260040160405180910390fd5b611c026001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016333086612053565b82600e5f828254611c13919061264c565b90915550611c2290508461167b565b8115611c3857611c33848483611962565b610c8f565b6001600160a01b0384165f9081526004602052604081208054859290611c5f90849061264c565b9250508190555082600c5f828254611c77919061264c565b90915550506040518381526001600160a01b038516907f56b2fb41a9acac73203c4c159f5cca6ff3bfa8f53e8cd40d6c682404b0adde3d9060200160405180910390a250505050565b6001600160a01b038085165f9081526007602090815260408083209386168352929052908120548190611cf3908461261a565b6001600160a01b038088165f90815260086020908152604080832093891683529290522054909150670de0b6b3a7640000611d2e8388612603565b611d38919061262d565b611d42919061264c565b9695505050505050565b81601452806034526fa9059cbb0000000000000000000000005f5260205f604460105f875af13d1560015f51141716611d8c576390b8ec185f526004601cfd5b5f603452505050565b611d9d612227565b6002805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b5f816014526f70a082310000000000000000000000005f5260208060246010865afa601f3d111660205102905092915050565b5f818310611e285781610a79565b5090919050565b611e3761193e565b6002805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258611dca3390565b6001600160a01b038116611e93576040516336e175d760e01b815260040160405180910390fd5b6001600160a01b0381165f908152600360208190526040909120015460ff1615611ed057604051632e4227db60e01b815260040160405180910390fd5b600a5460041901611ef457604051639297c10960e01b815260040160405180910390fd5b600a805460018181019092557fc65a7bb8d6351c1cf70c95a316cc6a92839c986682d98bc35f958f4883f9d2a80180546001600160a01b039093166001600160a01b0319909316831790555f918252600360208190526040909220909101805460ff19169091179055565b5f611f68610a0e565b90505f5b600a54811015611ffe575f600a8281548110611f8a57611f8a61265f565b5f9182526020822001546001600160a01b03169150611fa98285612177565b90505f5b8551811015611ff0575f868281518110611fc957611fc961265f565b60200260200101519050611fe781611fe083610e64565b86866121d5565b50600101611fad565b508260010192505050611f6c565b505050565b5f61200c610a0e565b90505f5b600a548110156109f55761204a600a82815481106120305761203061265f565b5f918252602090912001546001600160a01b031683612177565b50600101612010565b60405181606052826040528360601b602c526f23b872dd000000000000000000000000600c5260205f6064601c5f895af13d1560015f5114171661209e57637939f4245f526004601cfd5b5f60605260405250505050565b5f815f036120d457506001600160a01b0383165f90815260036020526040902060020154610a79565b6001600160a01b0384165f908152600360208190526040822001546121079061010090046001600160f81b03168561261a565b6001600160a01b0386165f908152600360205260408120600101549192509084906121329084612603565b61214490670de0b6b3a7640000612603565b61214e919061262d565b6001600160a01b0387165f90815260036020526040902060020154909150611d4290829061264c565b5f8061218284610e41565b905061218f8482856120ab565b6001600160a01b039094165f908152600360208190526040909120600281018690550180546001600160f81b039092166101000260ff9092169190911790555090919050565b6121e184848484611cc0565b6001600160a01b039485165f8181526008602090815260408083209690981680835295815287822093909355908152600782528581209381529290529290209190915550565b60025460ff166108c557604051638dfc202b60e01b815260040160405180910390fd5b80356001600160a01b0381168114612260575f80fd5b919050565b5f60208284031215612275575f80fd5b610a798261224a565b602080825282518282018190525f918401906040840190835b818110156122ca576122b483855180518252602090810151910152565b6020939093019260409290920191600101612297565b509095945050505050565b5f602082840312156122e5575f80fd5b5035919050565b5f80604083850312156122fd575f80fd5b50508035926020909101359150565b5f806040838503121561231d575f80fd5b6123268361224a565b91506123346020840161224a565b90509250929050565b81518152602080830151908201526040810161090d565b80358015158114612260575f80fd5b5f805f8060808587031215612376575f80fd5b61237f8561224a565b93506020850135925061239460408601612354565b9396929550929360600135925050565b5f80604083850312156123b5575f80fd5b6123be8361224a565b915061233460208401612354565b5f80604083850312156123dd575f80fd5b6123e68361224a565b946020939093013593505050565b634e487b7160e01b5f52604160045260245ffd5b5f8083601f840112612418575f80fd5b50813567ffffffffffffffff81111561242f575f80fd5b6020830191508360208260051b8501011115612449575f80fd5b9250929050565b5f805f60408486031215612462575f80fd5b833567ffffffffffffffff811115612478575f80fd5b8401601f81018613612488575f80fd5b803567ffffffffffffffff8111156124a2576124a26123f4565b8060051b604051601f19603f830116810181811067ffffffffffffffff821117156124cf576124cf6123f4565b6040529182526020818401810192908101898411156124ec575f80fd5b6020850194505b83851015612512576125048561224a565b8152602094850194016124f3565b509550505050602084013567ffffffffffffffff811115612531575f80fd5b61253d86828701612408565b9497909650939450505050565b5f805f6060848603121561255c575f80fd5b6125658461224a565b95602085013595506040909401359392505050565b602080825282516040838301528051606084018190525f929190910190829060808501905b808310156125d85783516001600160a01b038151168352602081015160208401525060408201915060208401935060018301925061259f565b506020860151604086015280935050505092915050565b634e487b7160e01b5f52601160045260245ffd5b808202811582820484141761090d5761090d6125ef565b8181038181111561090d5761090d6125ef565b5f8261264757634e487b7160e01b5f52601260045260245ffd5b500490565b8082018082111561090d5761090d6125ef565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52603160045260245ffdfea2646970667358221220690d5eda7418bb54042085f3b95cc2de5cfe0626bb72e32c3285d46a7873956564736f6c634300081a0033000000000000000000000000fea7a6a0b346362bf88a9e4a88416b77a57d6c2a00000000000000000000000000000000000000000000000000000000000075300000000000000000000000000000000000000000000000000000000000093a80000000000000000000000000000000000000000000000000000000000077f880000000000000000000000000fb3485c2e209a5cfbdc1447674256578f1a80ee3",
  "args_data": "0x000000000000000000000000fea7a6a0b346362bf88a9e4a88416b77a57d6c2a00000000000000000000000000000000000000000000000000000000000075300000000000000000000000000000000000000000000000000000000000093a80000000000000000000000000000000000000000000000000000000000077f880000000000000000000000000fb3485c2e209a5cfbdc1447674256578f1a80ee3",
  "tx_hash": "0x02bebfe947a6995ddba747bcfd21ae6fec937729d874b77e865a87f096d56c2f",
  "args": [
    "0xA71A021EF66B03E45E0d85590432DFCfa1b7174C"
  ],
  "data": "0xf2fde38b000000000000000000000000a71a021ef66b03e45e0d85590432dfcfa1b7174c",
  "artifact_path": "LockingMultiRewards.sol",
  "artifact_full_path": "LockingMultiRewards.sol:LockingMultiRewards",
  "standardJsonInput": {
    "language": "Solidity",
    "sources": {
      "src/staking/LockingMultiRewards.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {Pausable} from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport {SafeTransferLib} from \"@solady/utils/SafeTransferLib.sol\";\nimport {OwnableOperators} from \"/mixins/OwnableOperators.sol\";\nimport {MathLib} from \"/libraries/MathLib.sol\";\n\n/// @notice A staking contract that distributes multiple rewards to stakers.\n/// Stakers can lock their tokens for a period of time to get a boost on their rewards.\n/// @author Based from Curve Finance's MultiRewards contract https://github.com/curvefi/multi-rewards/blob/master/contracts/MultiRewards.sol\n/// @author Based from Ellipsis Finance's EpsStaker https://github.com/ellipsis-finance/ellipsis/blob/master/contracts/EpsStaker.sol\n/// @author Based from Convex Finance's CvxLockerV2 https://github.com/convex-eth/platform/blob/main/contracts/contracts/CvxLockerV2.sol\ncontract LockingMultiRewards is OwnableOperators, Pausable {\n    using SafeTransferLib for address;\n\n    event LogRewardAdded(uint256 reward);\n    event LogStaked(address indexed user, uint256 amount);\n    event LogLocked(address indexed user, uint256 amount, uint256 unlockTime, uint256 lockCount);\n    event LogUnlocked(address indexed user, uint256 amount, uint256 index);\n    event LogLockIndexChanged(address indexed user, uint256 fromIndex, uint256 toIndex);\n    event LogWithdrawn(address indexed user, uint256 amount);\n    event LogRewardLockCreated(address indexed user, uint256 unlockTime);\n    event LogRewardLocked(address indexed user, address indexed rewardsToken, uint256 reward);\n    event LogRewardPaid(address indexed user, address indexed rewardsToken, uint256 reward);\n    event LogRewardsDurationUpdated(address token, uint256 newDuration);\n    event LogRecovered(address token, uint256 amount);\n    event LogSetMinLockAmount(uint256 previous, uint256 current);\n\n    error ErrZeroAmount();\n    error ErrRewardAlreadyExists();\n    error ErrInvalidTokenAddress();\n    error ErrMaxUserLocksExceeded();\n    error ErrNotExpired();\n    error ErrInvalidUser();\n    error ErrLockAmountTooSmall();\n    error ErrLengthMismatch();\n    error ErrNoLocks();\n    error ErrLockNotExpired();\n    error ErrMaxRewardsExceeded();\n    error ErrSkimmingTooMuch();\n    error ErrInvalidLockIndex();\n    error ErrNotEnoughReward();\n    error ErrInvalidDurationRatio();\n    error ErrInvalidBoostMultiplier();\n    error ErrInvalidLockDuration();\n    error ErrInvalidRewardDuration();\n    error ErrInsufficientRemainingTime();\n    error ErrExpired();\n\n    struct Reward {\n        uint256 periodFinish;\n        uint256 rewardRate;\n        uint256 rewardPerTokenStored;\n        bool exists;\n        uint248 lastUpdateTime;\n    }\n\n    struct Balances {\n        uint256 unlocked;\n        uint256 locked;\n    }\n\n    struct LockedBalance {\n        uint256 amount;\n        uint256 unlockTime;\n    }\n\n    struct RewardLockItem {\n        address token;\n        uint256 amount;\n    }\n\n    struct RewardLock {\n        RewardLockItem[] items;\n        uint256 unlockTime;\n    }\n\n    uint256 internal constant BIPS = 10_000;\n    uint256 internal constant MAX_NUM_REWARDS = 5;\n    uint256 internal constant MIN_LOCK_DURATION = 1 weeks;\n    uint256 internal constant MIN_REWARDS_DURATION = 1 days;\n\n    uint256 public immutable maxLocks;\n    uint256 public immutable lockingBoostMultiplerInBips;\n    uint256 public immutable rewardsDuration;\n    uint256 public immutable lockDuration;\n    address public immutable stakingToken;\n\n    mapping(address token => Reward info) internal _rewardData;\n    mapping(address user => Balances balances) internal _balances;\n    mapping(address user => LockedBalance[] locks) internal _userLocks;\n    mapping(address user => RewardLock rewardLock) internal _userRewardLock;\n\n    mapping(address user => mapping(address token => uint256 amount)) public userRewardPerTokenPaid;\n    mapping(address user => mapping(address token => uint256 amount)) public rewards;\n    mapping(address user => uint256 index) public lastLockIndex;\n\n    address[] public rewardTokens;\n\n    uint256 public lockedSupply; // all locked boosted deposits\n    uint256 public unlockedSupply; // all unlocked unboosted deposits\n    uint256 public minLockAmount; // minimum amount allowed to lock\n    uint256 public stakingTokenBalance; // total staking token balance\n\n    ///\n    /// @dev Constructor\n    /// @param _stakingToken The token that is being staked\n    /// @param _owner The owner of the contract\n    /// @param _lockingBoostMultiplerInBips The multiplier for the locking boost. 30000 means if you stake 100, you get 300 locked\n    /// @param _rewardsDuration The duration of the rewards period in seconds, should be 7 days by default.\n    /// @param _lockDuration The duration of the lock period in seconds, should be 13 weeks by default.\n    constructor(\n        address _stakingToken,\n        uint256 _lockingBoostMultiplerInBips,\n        uint256 _rewardsDuration,\n        uint256 _lockDuration,\n        address _owner\n    ) {\n        if (_lockingBoostMultiplerInBips <= BIPS) {\n            revert ErrInvalidBoostMultiplier();\n        }\n\n        if (_lockDuration < MIN_LOCK_DURATION) {\n            revert ErrInvalidLockDuration();\n        }\n\n        if (_rewardsDuration < MIN_REWARDS_DURATION) {\n            revert ErrInvalidRewardDuration();\n        }\n\n        if (_lockDuration % _rewardsDuration != 0) {\n            revert ErrInvalidDurationRatio();\n        }\n\n        _initializeOwner(_owner);\n\n        stakingToken = _stakingToken;\n        lockingBoostMultiplerInBips = _lockingBoostMultiplerInBips;\n        rewardsDuration = _rewardsDuration;\n        lockDuration = _lockDuration;\n\n        // locks are combined into the same `rewardsDuration` epoch. So, if\n        // a user stake with locking every `rewardsDuration` this should reach the\n        // maximum number of possible simultaneous because the first lock gets expired,\n        // freeing up a slot.\n        maxLocks = (_lockDuration / _rewardsDuration) + 1;\n    }\n\n    /// @notice Stakes the given amount of tokens for the given user.\n    /// @param amount The amount of tokens to stake\n    function stake(uint256 amount) public whenNotPaused {\n        _stakeFor(msg.sender, amount, false, type(uint256).max);\n    }\n\n    function stakeLocked(uint256 amount, uint256 lockingDeadline) public whenNotPaused {\n        _stakeFor(msg.sender, amount, true, lockingDeadline);\n    }\n\n    /// @notice Locks an existing unlocked balance.\n    function lock(uint256 amount, uint256 lockingDeadline) public whenNotPaused {\n        if (amount == 0) {\n            revert ErrZeroAmount();\n        }\n\n        _updateRewardsForUser(msg.sender);\n\n        _balances[msg.sender].unlocked -= amount;\n        unlockedSupply -= amount;\n\n        _createLock(msg.sender, amount, lockingDeadline);\n    }\n\n    /// @notice Withdraws the given amount of unlocked tokens for the given user.\n    /// @param amount The amount of unlocked tokens to withdraw\n    function withdraw(uint256 amount) public virtual {\n        if (amount == 0) {\n            revert ErrZeroAmount();\n        }\n\n        _updateRewardsForUser(msg.sender);\n\n        _balances[msg.sender].unlocked -= amount;\n        unlockedSupply -= amount;\n\n        stakingTokenBalance -= amount;\n        stakingToken.safeTransfer(msg.sender, amount);\n\n        emit LogWithdrawn(msg.sender, amount);\n    }\n\n    function withdrawWithRewards(uint256 amount) public virtual {\n        withdraw(amount);\n        _getRewards(msg.sender);\n    }\n\n    function getRewards() public virtual {\n        _updateRewardsForUser(msg.sender);\n        _getRewards(msg.sender);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    /// VIEWS\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    function rewardData(address token) external view returns (Reward memory) {\n        return _rewardData[token];\n    }\n\n    function rewardsForDuration(address rewardToken) external view returns (uint256) {\n        return _rewardData[rewardToken].rewardRate * rewardsDuration;\n    }\n\n    function rewardTokensLength() external view returns (uint256) {\n        return rewardTokens.length;\n    }\n\n    function balances(address user) external view returns (Balances memory) {\n        return _balances[user];\n    }\n\n    function userRewardLock(address user) external view returns (RewardLock memory) {\n        return _userRewardLock[user];\n    }\n\n    function userLocks(address user) external view returns (LockedBalance[] memory) {\n        return _userLocks[user];\n    }\n\n    function userLocksLength(address user) external view returns (uint256) {\n        return _userLocks[user].length;\n    }\n\n    function locked(address user) external view returns (uint256) {\n        return _balances[user].locked;\n    }\n\n    function unlocked(address user) external view returns (uint256) {\n        return _balances[user].unlocked;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return unlockedSupply + ((lockedSupply * lockingBoostMultiplerInBips) / BIPS);\n    }\n\n    function balanceOf(address user) public view returns (uint256) {\n        Balances storage bal = _balances[user];\n        return bal.unlocked + ((bal.locked * lockingBoostMultiplerInBips) / BIPS);\n    }\n\n    /// @dev Calculates when the next unlock event will occur given the current epoch.\n    /// It ensures that the unlock timing coincides with the intervals at which rewards are distributed.\n    /// If the current time is within an ongoing reward interval, the function establishes the\n    /// unlock period to begin at the next epoch.\n    /// So, if you stake at week 1 + 4 days, you will be able to unlock at the end of week 14.\n    // |    week -1   |    week 1    |    week 2    |      ...     |    week 13   |    week 14   |\n    // |--------------|--------------|--------------|--------------|--------------|--------------|\n    // |                   ^ block.timestamp                                      |\n    // |                             ^ lock starts (adjusted)                                    ^ unlock ends (nextUnlockTime)\n    function nextUnlockTime() public view returns (uint256) {\n        return nextEpoch() + lockDuration;\n    }\n\n    function epoch() public view returns (uint256) {\n        return (block.timestamp / rewardsDuration) * rewardsDuration;\n    }\n\n    function nextEpoch() public view returns (uint256) {\n        return epoch() + rewardsDuration;\n    }\n\n    function remainingEpochTime() public view returns (uint256) {\n        return nextEpoch() - block.timestamp;\n    }\n\n    function lastTimeRewardApplicable(address rewardToken) public view returns (uint256) {\n        return MathLib.min(block.timestamp, _rewardData[rewardToken].periodFinish);\n    }\n\n    function rewardPerToken(address rewardToken) public view returns (uint256) {\n        return _rewardPerToken(rewardToken, lastTimeRewardApplicable(rewardToken), totalSupply());\n    }\n\n    function earned(address user, address rewardToken) public view returns (uint256) {\n        return _earned(user, balanceOf(user), rewardToken, rewardPerToken(rewardToken));\n    }\n\n    function _earned(address user, uint256 balance_, address rewardToken, uint256 rewardPerToken_) internal view returns (uint256) {\n        uint256 pendingUserRewardsPerToken = rewardPerToken_ - userRewardPerTokenPaid[user][rewardToken];\n        return ((balance_ * pendingUserRewardsPerToken) / 1e18) + rewards[user][rewardToken];\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    /// ADMIN\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    function addReward(address rewardToken) public virtual onlyOwner {\n        _addReward(rewardToken);\n    }\n\n    function setMinLockAmount(uint256 _minLockAmount) external onlyOwner {\n        emit LogSetMinLockAmount(minLockAmount, _minLockAmount);\n        minLockAmount = _minLockAmount;\n    }\n\n    /// @notice This function can recover any token except for the staking token beyond the balance necessary for rewards.\n    /// WARNING: Use this function with caution to ensure it does not affect the reward mechanism.\n    function recover(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        // In case it's the staking token, allow to skim the excess\n        if (tokenAddress == stakingToken && tokenAmount > stakingToken.balanceOf(address(this)) - stakingTokenBalance) {\n            revert ErrSkimmingTooMuch();\n        }\n\n        tokenAddress.safeTransfer(owner, tokenAmount);\n        emit LogRecovered(tokenAddress, tokenAmount);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    /// EMERGENCY FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    /// OPERATORS\n    //////////////////////////////////////////////////////////////////////////////////////////////\n\n    function stakeFor(address account, uint256 amount, bool lock_, uint256 lockingDeadline) external onlyOperators whenNotPaused {\n        _stakeFor(account, amount, lock_, lockingDeadline);\n    }\n\n    /// @notice Distribute new rewards to the stakers\n    /// @param rewardToken The address of the reward token\n    /// @param amount The amount of reward tokens to distribute\n    /// @param minRemainingTime The minimum remaining time for the current reward period\n    /// Used to avoid distributing rewards on a lower period than the expected one.\n    /// Example: If the reward period is 7 days, and there are 2 days left, `minRemainingTime` higher than\n    /// 2 days will revert the transaction.\n    /// To ignore this check, set `minRemainingTime` to 0.\n    function notifyRewardAmount(address rewardToken, uint256 amount, uint minRemainingTime) public onlyOperators {\n        if (!_rewardData[rewardToken].exists) {\n            revert ErrInvalidTokenAddress();\n        }\n\n        _updateRewards();\n        rewardToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        Reward storage reward = _rewardData[rewardToken];\n\n        uint256 _nextEpoch = nextEpoch();\n        uint256 _remainingRewardTime = _nextEpoch - block.timestamp;\n\n        if (_remainingRewardTime < minRemainingTime) {\n            revert ErrInsufficientRemainingTime();\n        }\n\n        // Take the remainder of the current rewards and add it to the amount for the next period\n        if (block.timestamp < reward.periodFinish) {\n            amount += _remainingRewardTime * reward.rewardRate;\n        }\n\n        // avoid `rewardRate` being 0\n        if (amount < _remainingRewardTime) {\n            revert ErrNotEnoughReward();\n        }\n\n        reward.rewardRate = amount / _remainingRewardTime;\n        reward.lastUpdateTime = uint248(block.timestamp);\n        reward.periodFinish = _nextEpoch;\n\n        emit LogRewardAdded(amount);\n    }\n\n    /// @notice Updates the balances of the given user and lock indexes\n    // Should be called once a `rewardDuration` (for example, every week)\n    function processExpiredLocks(address[] memory users, uint256[] calldata lockIndexes) external onlyOperators {\n        if (users.length != lockIndexes.length) {\n            revert ErrLengthMismatch();\n        }\n\n        _updateRewardsForUsers(users);\n\n        // Release all expired users' locks\n        for (uint256 i; i < users.length; ) {\n            address user = users[i];\n            Balances storage bal = _balances[user];\n            LockedBalance[] storage locks = _userLocks[user];\n\n            if (locks.length == 0) {\n                revert ErrNoLocks();\n            }\n\n            uint256 index = lockIndexes[i];\n\n            // Prevents processing `lastLockIndex` out of order\n            if (index == lastLockIndex[user] && locks.length > 1) {\n                revert ErrInvalidLockIndex();\n            }\n\n            // prohibit releasing non-expired locks\n            if (locks[index].unlockTime > block.timestamp) {\n                revert ErrLockNotExpired();\n            }\n\n            uint256 amount = locks[index].amount;\n            uint256 lastIndex = locks.length - 1;\n\n            /// Last lock index changed place with the one we just swapped.\n            if (lastLockIndex[user] == lastIndex) {\n                lastLockIndex[user] = index;\n            }\n\n            if (index != lastIndex) {\n                locks[index] = locks[lastIndex];\n                emit LogLockIndexChanged(user, lastIndex, index);\n            }\n\n            locks.pop();\n\n            unlockedSupply += amount;\n            lockedSupply -= amount;\n\n            bal.unlocked += amount;\n            bal.locked -= amount;\n\n            emit LogUnlocked(user, amount, index);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    /// INTERNALS\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    function _rewardPerToken(address rewardToken, uint256 lastTimeRewardApplicable_, uint256 totalSupply_) internal view returns (uint256) {\n        if (totalSupply_ == 0) {\n            return _rewardData[rewardToken].rewardPerTokenStored;\n        }\n\n        uint256 timeElapsed = lastTimeRewardApplicable_ - _rewardData[rewardToken].lastUpdateTime;\n        uint256 pendingRewardsPerToken = (timeElapsed * _rewardData[rewardToken].rewardRate * 1e18) / totalSupply_;\n\n        return _rewardData[rewardToken].rewardPerTokenStored + pendingRewardsPerToken;\n    }\n\n    function _stakeFor(address account, uint256 amount, bool lock_, uint256 lockingDeadline) internal {\n        if (amount == 0) {\n            revert ErrZeroAmount();\n        }\n\n        // This staking contract isn't using balanceOf, so it's safe to transfer immediately\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        stakingTokenBalance += amount;\n\n        _updateRewardsForUser(account);\n\n        if (lock_) {\n            _createLock(account, amount, lockingDeadline);\n        } else {\n            _balances[account].unlocked += amount;\n            unlockedSupply += amount;\n\n            emit LogStaked(account, amount);\n        }\n    }\n\n    function _addReward(address rewardToken) internal {\n        if (rewardToken == address(0)) {\n            revert ErrInvalidTokenAddress();\n        }\n\n        if (_rewardData[rewardToken].exists) {\n            revert ErrRewardAlreadyExists();\n        }\n\n        if (rewardTokens.length == MAX_NUM_REWARDS) {\n            revert ErrMaxRewardsExceeded();\n        }\n\n        rewardTokens.push(rewardToken);\n        _rewardData[rewardToken].exists = true;\n    }\n\n    function _createLock(address user, uint256 amount, uint256 lockingDeadline) internal {\n        if (lockingDeadline < block.timestamp) {\n            revert ErrExpired();\n        }\n\n        Balances storage bal = _balances[user];\n        uint256 _nextUnlockTime = nextUnlockTime();\n        uint256 _lastLockIndex = lastLockIndex[user];\n        uint256 lockCount = _userLocks[user].length;\n\n        bal.locked += amount;\n        lockedSupply += amount;\n\n        // Add to current lock if it's the same unlock time or the first one\n        // userLocks is sorted by unlockTime, so the last lock is the most recent one\n        if (lockCount == 0 || _userLocks[user][_lastLockIndex].unlockTime < _nextUnlockTime) {\n            // Limit the number of locks per user to avoid too much gas costs per user\n            // when looping through the locks\n            if (lockCount == maxLocks) {\n                revert ErrMaxUserLocksExceeded();\n            }\n\n            if (amount < minLockAmount) {\n                revert ErrLockAmountTooSmall();\n            }\n\n            _userLocks[user].push(LockedBalance({amount: amount, unlockTime: _nextUnlockTime}));\n            lastLockIndex[user] = lockCount;\n\n            unchecked {\n                ++lockCount;\n            }\n        }\n        /// It's the same reward period, so we just add the amount to the current lock\n        else {\n            _userLocks[user][_lastLockIndex].amount += amount;\n        }\n\n        emit LogLocked(user, amount, _nextUnlockTime, lockCount);\n    }\n\n    /// @dev Update the global accumulated rewards from the last update to this point,\n    /// in relation with the `totalSupply`\n    ///\n    /// The idea is to allow everyone that are currently part of that supply to get their allocated\n    /// reward share.\n    ///\n    /// Each user's reward share is taking in account when `rewards[user][token] = _earned(...)`\n    /// is called. And only updated when a user is interacting with `stake`, `lock`, `withdraw`\n    /// or `getRewards`.\n    ///\n    /// Otherwise, if it's yet-to-be-updated, it's going to get considered as part of the pending\n    /// yet-to-receive rewards in the `earned` function.\n    function _updateRewardsGlobal(address token_, uint256 totalSupply_) internal returns (uint256 rewardPerToken_) {\n        uint256 lastTimeRewardApplicable_ = lastTimeRewardApplicable(token_);\n        rewardPerToken_ = _rewardPerToken(token_, lastTimeRewardApplicable_, totalSupply_);\n\n        _rewardData[token_].rewardPerTokenStored = rewardPerToken_;\n        _rewardData[token_].lastUpdateTime = uint248(lastTimeRewardApplicable_); // safe to cast as this will never overflow\n    }\n\n    function _udpateUserRewards(address user_, uint256 balance_, address token_, uint256 rewardPerToken_) internal {\n        rewards[user_][token_] = _earned(user_, balance_, token_, rewardPerToken_);\n        userRewardPerTokenPaid[user_][token_] = rewardPerToken_;\n    }\n\n    /// @dev Simplest version of updating rewards. Mainly used by `notifyRewardAmount`.\n    /// where we don't need to update any particular user but the global state for\n    /// each reward tokens only.\n    function _updateRewards() internal {\n        uint256 totalSupply_ = totalSupply();\n\n        for (uint256 i; i < rewardTokens.length; ) {\n            _updateRewardsGlobal(rewardTokens[i], totalSupply_);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev More gas efficient version of `_updateRewards` when we\n    /// only need to update the rewards for a single user.\n    function _updateRewardsForUser(address user) internal {\n        uint256 balance = balanceOf(user);\n        uint256 totalSupply_ = totalSupply();\n\n        for (uint256 i; i < rewardTokens.length; ) {\n            address token = rewardTokens[i];\n            _udpateUserRewards(user, balance, token, _updateRewardsGlobal(token, totalSupply_));\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev `_updateRewardsForUser` for multiple users.\n    function _updateRewardsForUsers(address[] memory users) internal {\n        uint256 totalSupply_ = totalSupply();\n\n        for (uint256 i; i < rewardTokens.length; ) {\n            address token = rewardTokens[i];\n            uint256 rewardPerToken_ = _updateRewardsGlobal(token, totalSupply_);\n\n            // Record each user's rewards\n            for (uint256 j; j < users.length; ) {\n                address user = users[j];\n                _udpateUserRewards(user, balanceOf(user), token, rewardPerToken_);\n\n                unchecked {\n                    ++j;\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Claim unlocked rewards or create a new reward lock that\n    // makes them available the next epoch\n    function _getRewards(address user) internal {\n        RewardLock storage _rewardLock = _userRewardLock[user];\n\n        // first ever lock is always expired because `unlockTime` is 0\n        // unlock time is aligned to epoch\n        bool expired = _rewardLock.unlockTime <= block.timestamp;\n\n        // cache the length here since the loop will be modifying the array\n        uint256 rewardItemLength = _rewardLock.items.length;\n\n        // expired lock\n        // existing lock items will be reused\n        if (expired) {\n            _rewardLock.unlockTime = nextEpoch();\n            emit LogRewardLockCreated(user, _rewardLock.unlockTime);\n        }\n\n        for (uint256 i; i < rewardTokens.length; ) {\n            address rewardToken = rewardTokens[i];\n            uint256 rewardAmount = rewards[user][rewardToken];\n\n            // in all scenario, reset the reward amount immediately\n            rewards[user][rewardToken] = 0;\n\n            // don't assume the rewardTokens array is always the same length as the items array\n            // as new reward tokens can be added by the owner\n            if (i < rewardItemLength) {\n                RewardLockItem storage item = _rewardLock.items[i];\n\n                // expired lock, claim existing unlocked rewards if any\n                if (expired) {\n                    uint256 amount = item.amount;\n\n                    // since this current lock is expired and that item index\n                    // matches the reward index, override the current amount\n                    // with the new locked amount.\n                    item.amount = rewardAmount;\n\n                    // use cached amount\n                    if (amount > 0) {\n                        rewardToken.safeTransfer(user, amount);\n                        emit LogRewardPaid(user, rewardToken, amount);\n                    }\n                } else {\n                    // not expired, just add to the existing lock\n                    item.amount += rewardAmount;\n                }\n            }\n            // new reward token, create a new lock item\n            // could mean it's adding to an existing lock or creating a new one\n            else {\n                _userRewardLock[user].items.push(RewardLockItem({token: rewardToken, amount: rewardAmount}));\n            }\n\n            emit LogRewardLocked(user, rewardToken, rewardAmount);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
      },
      "dependencies/openzeppelin-contracts-5.0.2/contracts/utils/Pausable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
      },
      "dependencies/solady-0.0.231/src/utils/SafeTransferLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\n/// - For ERC20s, this implementation won't check that a token has code,\n///   responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The Permit2 operation has failed.\n    error Permit2Failed();\n\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\n    error Permit2AmountOverflow();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\n\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// @dev The canonical Permit2 address.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success :=\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x34, 0) // Store 0 for the `amount`.\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                mstore(0x34, amount) // Store back the original `amount`.\n                // Retry the approval, reverting upon failure.\n                if iszero(\n                    and(\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    )\n                ) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\n    /// Reverts upon failure.\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }\n\n    /// @dev Permit a user to spend a given amount of\n    /// another user's tokens via native EIP-2612 permit if possible, falling\n    /// back to Permit2 if native permit fails or is not implemented on the token.\n    function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `1` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Simple permit on the Permit2 contract.\n    function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"
      },
      "src/mixins/OwnableOperators.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/// @title OwnableOperators\n/// @dev must call `_initializeOwner` to initialize owner\ncontract OwnableOperators {\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n    event OperatorChanged(address indexed, bool);\n\n    error Unauthorized();\n\n    address public owner;\n    mapping(address => bool) public operators;\n\n    modifier onlyOwner() virtual {\n        if(msg.sender != owner) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    modifier onlyOperators() {\n        if (!operators[msg.sender] && msg.sender != owner) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// Admin\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function setOperator(address operator, bool enable) external onlyOwner {\n        operators[operator] = enable;\n        emit OperatorChanged(operator, enable);\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        owner = newOwner;\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// Internals\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _initializeOwner(address _owner) internal {\n        owner = _owner;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function _checkOwner() internal view {\n        if (msg.sender != owner) {\n            revert Unauthorized();\n        }\n    }\n}\n"
      },
      "src/libraries/MathLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nlibrary MathLib {\n    function max(uint256[] memory values) internal pure returns (uint256) {\n        uint256 maxValue = values[0];\n        for (uint256 i = 1; i < values.length; i++) {\n            if (values[i] > maxValue) {\n                maxValue = values[i];\n            }\n        }\n        return maxValue;\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    function min(uint256[] memory values) internal pure returns (uint256) {\n        uint256 minValue = values[0];\n        for (uint256 i = 1; i < values.length; i++) {\n            if (values[i] < minValue) {\n                minValue = values[i];\n            }\n        }\n        return minValue;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function subWithZeroFloor(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : 0;\n    }\n}\n"
      },
      "dependencies/openzeppelin-contracts-5.0.2/contracts/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      }
    },
    "settings": {
      "remappings": [
        "/=src/",
        "forge-std/=dependencies/forge-std-1.9.2/src/",
        "halmos-cheatcodes/=dependencies/halmos-cheatcodes-3ca0e11/src/",
        "@openzeppelin/contracts/=dependencies/openzeppelin-contracts-5.0.2/contracts/",
        "@openzeppelin/contracts-upgradeable/=dependencies/openzeppelin-contracts-upgradeable-5.0.2/contracts/",
        "@BoringSolidity/=dependencies/BoringSolidity-1.0.0/contracts/",
        "@solady/=dependencies/solady-0.0.231/src/",
        "@solmate/=dependencies/solmate-6.2.0/src/",
        "@excessivelySafeCall/=dependencies/ExcessivelySafeCall-0.0.1/src/",
        "@safe-contracts/=dependencies/safe-contracts-1.3.0/contracts/",
        "@fuzzlib/=dependencies/fuzzlib-0.0.1/src/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 400
      },
      "metadata": {
        "useLiteralContent": false,
        "bytecodeHash": "ipfs",
        "appendCBOR": true
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "evmVersion": "shanghai",
      "viaIR": false,
      "libraries": {}
    }
  },
  "compiler": "0.8.26+commit.8a97fa7a"
}