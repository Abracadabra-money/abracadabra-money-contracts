{
  "address": "0xeA06aC85984AFCbD4B6C6d0E46dBEb06f11313a6",
  "abi": [
    {
      "type": "constructor",
      "inputs": [
        {
          "name": "_box",
          "type": "address",
          "internalType": "contract IBentoBoxLite"
        },
        {
          "name": "_gmxVault",
          "type": "address",
          "internalType": "contract IGmxVault"
        },
        {
          "name": "_magicGLP",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_mim",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_sGLP",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "glpManager",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_glpRewardRouter",
          "type": "address",
          "internalType": "contract IGmxGlpRewardRouter"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "box",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IBentoBoxLite"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "glpRewardRouter",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IGmxGlpRewardRouter"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "gmxVault",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IGmxVault"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "magicGLP",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "mim",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "sGLP",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "swap",
      "inputs": [
        {
          "name": "recipient",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "shareToMin",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "shareFrom",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "data",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "extraShare",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "shareReturned",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "error",
      "name": "ErrSwapFailed",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrTokenNotSupported",
      "inputs": []
    }
  ],
  "bytecode": "0x610140604052348015610010575f5ffd5b50604051610c39380380610c3983398101604081905261002f91610202565b6001600160a01b0380881660805286811661012081905286821660c05285821660a0528482166101005290821660e05260408051630421583b60e11b815290515f9291630842b0769160048083019260209291908290030181865afa15801561009a573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906100be9190610299565b90505f5b8181101561017557604051630e468baf60e41b8152600481018290525f906001600160a01b038a169063e468baf090602401602060405180830381865afa15801561010f573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061013391906102b0565b905060a0516001600160a01b0316816001600160a01b031603610156575061016d565b61016b6001600160a01b038216865f19610198565b505b6001016100c2565b5061018b6001600160a01b038516875f19610198565b50505050505050506102d2565b81601452806034526f095ea7b30000000000000000000000005f5260205f604460105f875af18060015f5114166101e157803d853b1517106101e157633e3f8f735f526004601cfd5b505f603452505050565b6001600160a01b03811681146101ff575f5ffd5b50565b5f5f5f5f5f5f5f60e0888a031215610218575f5ffd5b8751610223816101eb565b6020890151909750610234816101eb565b6040890151909650610245816101eb565b6060890151909550610256816101eb565b6080890151909450610267816101eb565b60a0890151909350610278816101eb565b60c0890151909250610289816101eb565b8091505092959891949750929550565b5f602082840312156102a9575f5ffd5b5051919050565b5f602082840312156102c0575f5ffd5b81516102cb816101eb565b9392505050565b60805160a05160c05160e05161010051610120516108e46103555f395f61013c01525f61011501525f81816083015261041c01525f818161018b015281816104d1015261055301525f818160ee015281816101d5015281816102b4015261033101525f818160c70152818161021f015281816104a6015261057b01526108e45ff3fe608060405234801561000f575f5ffd5b506004361061007a575f3560e01c8063a8d7741211610058578063a8d7741214610110578063b3b3453e14610137578063b691d78c1461015e578063f3bdf25714610186575f5ffd5b8063686722311461007e578063754215a1146100c25780639f67679e146100e9575b5f5ffd5b6100a57f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b6100a57f000000000000000000000000000000000000000000000000000000000000000081565b6100a57f000000000000000000000000000000000000000000000000000000000000000081565b6100a57f000000000000000000000000000000000000000000000000000000000000000081565b6100a57f000000000000000000000000000000000000000000000000000000000000000081565b61017161016c3660046106bf565b6101ad565b604080519283526020830191909152016100b9565b6100a57f000000000000000000000000000000000000000000000000000000000000000081565b5f808080806101be86880188610763565b60405163097da6d360e41b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152306024830181905260448301525f6064830152608482018d905293965091945092507f0000000000000000000000000000000000000000000000000000000000000000909116906397da6d309060a40160408051808303815f875af1158015610266573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061028a919061083a565b5050604051636eb1769f60e11b81523060048201526001600160a01b0383811660248301525f19917f00000000000000000000000000000000000000000000000000000000000000009091169063dd62ed3e90604401602060405180830381865afa1580156102fb573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061031f919061085c565b14610359576103596001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016835f19610622565b5f826001600160a01b0316826040516103729190610873565b5f604051808303815f865af19150503d805f81146103ab576040519150601f19603f3d011682016040523d82523d5f602084013e6103b0565b606091505b50509050806103d25760405163fc3116c160e01b815260040160405180910390fd5b5f6103e66001600160a01b03861630610675565b60405163364e231160e01b81526001600160a01b038781166004830152602482018390525f6044830181905260648301529192507f00000000000000000000000000000000000000000000000000000000000000009091169063364e2311906084016020604051808303815f875af1158015610464573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610488919061085c565b604051636e553f6560e01b8152600481018290526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660248301529192507f000000000000000000000000000000000000000000000000000000000000000090911690636e553f65906044016020604051808303815f875af1158015610519573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061053d919061085c565b60405162ae511b60e21b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660048301527f0000000000000000000000000000000000000000000000000000000000000000811660248301819052908f166044830152606482018390525f60848301529192506302b9446c9060a40160408051808303815f875af11580156105df573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610603919061083a565b965061061190508b87610889565b965050505050509550959350505050565b81601452806034526f095ea7b30000000000000000000000005f5260205f604460105f875af18060015f51141661066b57803d853b15171061066b57633e3f8f735f526004601cfd5b505f603452505050565b5f816014526f70a082310000000000000000000000005f5260208060246010865afa601f3d111660205102905092915050565b6001600160a01b03811681146106bc575f5ffd5b50565b5f5f5f5f5f608086880312156106d3575f5ffd5b85356106de816106a8565b94506020860135935060408601359250606086013567ffffffffffffffff811115610707575f5ffd5b8601601f81018813610717575f5ffd5b803567ffffffffffffffff81111561072d575f5ffd5b88602082840101111561073e575f5ffd5b959894975092955050506020019190565b634e487b7160e01b5f52604160045260245ffd5b5f5f5f60608486031215610775575f5ffd5b8335610780816106a8565b92506020840135610790816106a8565b9150604084013567ffffffffffffffff8111156107ab575f5ffd5b8401601f810186136107bb575f5ffd5b803567ffffffffffffffff8111156107d5576107d561074f565b604051601f8201601f19908116603f0116810167ffffffffffffffff811182821017156108045761080461074f565b60405281815282820160200188101561081b575f5ffd5b816020840160208301375f602083830101528093505050509250925092565b5f5f6040838503121561084b575f5ffd5b505080516020909101519092909150565b5f6020828403121561086c575f5ffd5b5051919050565b5f82518060208501845e5f920191825250919050565b818103818111156108a857634e487b7160e01b5f52601160045260245ffd5b9291505056fea26469706673582212201ccf43ca2d87cc28456af9d7c4166e3167fbe208ea47167d867e505e5fd5a59264736f6c634300081c0033",
  "args_data": "0x0000000000000000000000007c8fef8ea9b1fe46a7689bfb8149341c90431d38000000000000000000000000489ee077994b6658eafa855c308275ead8097c4a00000000000000000000000085667409a723684fe1e57dd1abde8d88c2f54214000000000000000000000000fea7a6a0b346362bf88a9e4a88416b77a57d6c2a0000000000000000000000005402b5f40310bded796c7d0f3ff6683f5c0cffdf0000000000000000000000003963ffc9dff443c2a94f21b129d429891e32ec18000000000000000000000000b95db5b167d75e6d04227cfffa61069348d271f5",
  "tx_hash": "0xbb3c82f88e31d60a36709e59f351015c13d99214300d783e9c5113e4d439e57b",
  "args": [
    "0x7C8FeF8eA9b1fE46A7689bfb8149341C90431D38",
    "0x489ee077994B6658eAfA855C308275EAd8097C4A",
    "0x85667409a723684Fe1e57Dd1ABDe8D88C2f54214",
    "0xFEa7a6a0B346362BF88A9e4A88416B77a57D6c2A",
    "0x5402B5F40310bDED796c7D0F3FF6683f5C0cFfdf",
    "0x3963FfC9dff443c2A94f21b129D429891E32ec18",
    "0xB95DB5B167D75e6d04227CfFFA61069348d271F5"
  ],
  "data": "0x610140604052348015610010575f5ffd5b50604051610c39380380610c3983398101604081905261002f91610202565b6001600160a01b0380881660805286811661012081905286821660c05285821660a0528482166101005290821660e05260408051630421583b60e11b815290515f9291630842b0769160048083019260209291908290030181865afa15801561009a573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906100be9190610299565b90505f5b8181101561017557604051630e468baf60e41b8152600481018290525f906001600160a01b038a169063e468baf090602401602060405180830381865afa15801561010f573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061013391906102b0565b905060a0516001600160a01b0316816001600160a01b031603610156575061016d565b61016b6001600160a01b038216865f19610198565b505b6001016100c2565b5061018b6001600160a01b038516875f19610198565b50505050505050506102d2565b81601452806034526f095ea7b30000000000000000000000005f5260205f604460105f875af18060015f5114166101e157803d853b1517106101e157633e3f8f735f526004601cfd5b505f603452505050565b6001600160a01b03811681146101ff575f5ffd5b50565b5f5f5f5f5f5f5f60e0888a031215610218575f5ffd5b8751610223816101eb565b6020890151909750610234816101eb565b6040890151909650610245816101eb565b6060890151909550610256816101eb565b6080890151909450610267816101eb565b60a0890151909350610278816101eb565b60c0890151909250610289816101eb565b8091505092959891949750929550565b5f602082840312156102a9575f5ffd5b5051919050565b5f602082840312156102c0575f5ffd5b81516102cb816101eb565b9392505050565b60805160a05160c05160e05161010051610120516108e46103555f395f61013c01525f61011501525f81816083015261041c01525f818161018b015281816104d1015261055301525f818160ee015281816101d5015281816102b4015261033101525f818160c70152818161021f015281816104a6015261057b01526108e45ff3fe608060405234801561000f575f5ffd5b506004361061007a575f3560e01c8063a8d7741211610058578063a8d7741214610110578063b3b3453e14610137578063b691d78c1461015e578063f3bdf25714610186575f5ffd5b8063686722311461007e578063754215a1146100c25780639f67679e146100e9575b5f5ffd5b6100a57f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b6100a57f000000000000000000000000000000000000000000000000000000000000000081565b6100a57f000000000000000000000000000000000000000000000000000000000000000081565b6100a57f000000000000000000000000000000000000000000000000000000000000000081565b6100a57f000000000000000000000000000000000000000000000000000000000000000081565b61017161016c3660046106bf565b6101ad565b604080519283526020830191909152016100b9565b6100a57f000000000000000000000000000000000000000000000000000000000000000081565b5f808080806101be86880188610763565b60405163097da6d360e41b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152306024830181905260448301525f6064830152608482018d905293965091945092507f0000000000000000000000000000000000000000000000000000000000000000909116906397da6d309060a40160408051808303815f875af1158015610266573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061028a919061083a565b5050604051636eb1769f60e11b81523060048201526001600160a01b0383811660248301525f19917f00000000000000000000000000000000000000000000000000000000000000009091169063dd62ed3e90604401602060405180830381865afa1580156102fb573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061031f919061085c565b14610359576103596001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016835f19610622565b5f826001600160a01b0316826040516103729190610873565b5f604051808303815f865af19150503d805f81146103ab576040519150601f19603f3d011682016040523d82523d5f602084013e6103b0565b606091505b50509050806103d25760405163fc3116c160e01b815260040160405180910390fd5b5f6103e66001600160a01b03861630610675565b60405163364e231160e01b81526001600160a01b038781166004830152602482018390525f6044830181905260648301529192507f00000000000000000000000000000000000000000000000000000000000000009091169063364e2311906084016020604051808303815f875af1158015610464573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610488919061085c565b604051636e553f6560e01b8152600481018290526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660248301529192507f000000000000000000000000000000000000000000000000000000000000000090911690636e553f65906044016020604051808303815f875af1158015610519573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061053d919061085c565b60405162ae511b60e21b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660048301527f0000000000000000000000000000000000000000000000000000000000000000811660248301819052908f166044830152606482018390525f60848301529192506302b9446c9060a40160408051808303815f875af11580156105df573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610603919061083a565b965061061190508b87610889565b965050505050509550959350505050565b81601452806034526f095ea7b30000000000000000000000005f5260205f604460105f875af18060015f51141661066b57803d853b15171061066b57633e3f8f735f526004601cfd5b505f603452505050565b5f816014526f70a082310000000000000000000000005f5260208060246010865afa601f3d111660205102905092915050565b6001600160a01b03811681146106bc575f5ffd5b50565b5f5f5f5f5f608086880312156106d3575f5ffd5b85356106de816106a8565b94506020860135935060408601359250606086013567ffffffffffffffff811115610707575f5ffd5b8601601f81018813610717575f5ffd5b803567ffffffffffffffff81111561072d575f5ffd5b88602082840101111561073e575f5ffd5b959894975092955050506020019190565b634e487b7160e01b5f52604160045260245ffd5b5f5f5f60608486031215610775575f5ffd5b8335610780816106a8565b92506020840135610790816106a8565b9150604084013567ffffffffffffffff8111156107ab575f5ffd5b8401601f810186136107bb575f5ffd5b803567ffffffffffffffff8111156107d5576107d561074f565b604051601f8201601f19908116603f0116810167ffffffffffffffff811182821017156108045761080461074f565b60405281815282820160200188101561081b575f5ffd5b816020840160208301375f602083830101528093505050509250925092565b5f5f6040838503121561084b575f5ffd5b505080516020909101519092909150565b5f6020828403121561086c575f5ffd5b5051919050565b5f82518060208501845e5f920191825250919050565b818103818111156108a857634e487b7160e01b5f52601160045260245ffd5b9291505056fea26469706673582212201ccf43ca2d87cc28456af9d7c4166e3167fbe208ea47167d867e505e5fd5a59264736f6c634300081c00330000000000000000000000007c8fef8ea9b1fe46a7689bfb8149341c90431d38000000000000000000000000489ee077994b6658eafa855c308275ead8097c4a00000000000000000000000085667409a723684fe1e57dd1abde8d88c2f54214000000000000000000000000fea7a6a0b346362bf88a9e4a88416b77a57d6c2a0000000000000000000000005402b5f40310bded796c7d0f3ff6683f5c0cffdf0000000000000000000000003963ffc9dff443c2a94f21b129d429891e32ec18000000000000000000000000b95db5b167d75e6d04227cfffa61069348d271f5",
  "artifact_path": "MagicGlpLevSwapper.sol",
  "artifact_full_path": "MagicGlpLevSwapper.sol:MagicGlpLevSwapper",
  "standardJsonInput": {
    "language": "Solidity",
    "sources": {
      "src/swappers/MagicGlpLevSwapper.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// solhint-disable avoid-low-level-calls\npragma solidity >=0.8.0;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeTransferLib} from \"@solady/utils/SafeTransferLib.sol\";\nimport {IBentoBoxLite} from \"/interfaces/IBentoBoxV1.sol\";\nimport {ILevSwapperV2} from \"/interfaces/ILevSwapperV2.sol\";\nimport {IERC4626} from \"/interfaces/IERC4626.sol\";\nimport {IGmxGlpRewardRouter, IGmxVault} from \"/interfaces/IGmxV1.sol\";\n\ncontract MagicGlpLevSwapper is ILevSwapperV2 {\n    using SafeTransferLib for address;\n\n    error ErrSwapFailed();\n    error ErrTokenNotSupported();\n\n    IBentoBoxLite public immutable box;\n    address public immutable mim;\n    address public immutable magicGLP;\n    IGmxGlpRewardRouter public immutable glpRewardRouter;\n    address public immutable sGLP;\n    IGmxVault public immutable gmxVault;\n\n    constructor(\n        IBentoBoxLite _box,\n        IGmxVault _gmxVault,\n        address _magicGLP,\n        address _mim,\n        address _sGLP,\n        address glpManager,\n        IGmxGlpRewardRouter _glpRewardRouter\n    ) {\n        box = _box;\n        gmxVault = _gmxVault;\n        magicGLP = _magicGLP;\n        mim = _mim;\n        sGLP = _sGLP;\n        glpRewardRouter = _glpRewardRouter;\n\n        uint256 len = _gmxVault.allWhitelistedTokensLength();\n        for (uint256 i = 0; i < len; i++) {\n            address token = _gmxVault.allWhitelistedTokens(i);\n            if (token == mim) continue;\n            token.safeApprove(glpManager, type(uint256).max);\n        }\n\n        _sGLP.safeApprove(address(_magicGLP), type(uint256).max);\n    }\n\n    /// @inheritdoc ILevSwapperV2\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom,\n        bytes calldata data\n    ) external override returns (uint256 extraShare, uint256 shareReturned) {\n        (address token, address to, bytes memory swapData) = abi.decode(data, (address, address, bytes));\n\n        box.withdraw(mim, address(this), address(this), 0, shareFrom);\n\n        if (IERC20Metadata(mim).allowance(address(this), to) != type(uint256).max) {\n            mim.safeApprove(to, type(uint256).max);\n        }\n        \n        // MIM -> Token\n        (bool success, ) = to.call(swapData);\n        if (!success) {\n            revert ErrSwapFailed();\n        }\n\n        uint256 _amount = token.balanceOf(address(this));\n\n        _amount = glpRewardRouter.mintAndStakeGlp(address(token), _amount, 0, 0);\n        _amount = IERC4626(address(magicGLP)).deposit(_amount, address(box));\n\n        (, shareReturned) = box.deposit(magicGLP, address(box), recipient, _amount, 0);\n\n        extraShare = shareReturned - shareToMin;\n    }\n}\n"
      },
      "dependencies/openzeppelin-contracts-5.0.2/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
      },
      "dependencies/solady-0.0.281/src/utils/SafeTransferLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\nlibrary SafeTransferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The ERC20 `totalSupply` query has failed.\n    error TotalSupplyQueryFailed();\n\n    /// @dev The Permit2 operation has failed.\n    error Permit2Failed();\n\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\n    error Permit2AmountOverflow();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\n\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// @dev The canonical Permit2 address.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                success := lt(or(iszero(extcodesize(token)), returndatasize()), success)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x34, 0) // Store 0 for the `amount`.\n                    mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                    pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                    mstore(0x34, amount) // Store back the original `amount`.\n                    // Retry the approval, reverting upon failure.\n                    success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    if iszero(and(eq(mload(0x00), 1), success)) {\n                        // Check the `extcodesize` again just in case the token selfdestructs lol.\n                        if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                            mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                            revert(0x1c, 0x04)\n                        }\n                    }\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Returns the total supply of the `token`.\n    /// Reverts if the token does not exist or does not implement `totalSupply()`.\n    function totalSupply(address token) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x18160ddd) // `totalSupply()`.\n            if iszero(\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), token, 0x1c, 0x04, 0x00, 0x20))\n            ) {\n                mstore(0x00, 0x54cd9435) // `TotalSupplyQueryFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\n    /// Reverts upon failure.\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(\n                and(\n                    call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00),\n                    lt(iszero(extcodesize(token)), exists) // Token has code and Permit2 exists.\n                )\n            ) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }\n\n    /// @dev Permit a user to spend a given amount of\n    /// another user's tokens via native EIP-2612 permit if possible, falling\n    /// back to Permit2 if native permit fails or is not implemented on the token.\n    function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `1` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Simple permit on the Permit2 contract.\n    function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero( // Revert if token does not have code, or if the call fails.\n            mul(extcodesize(token), call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00))) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"
      },
      "src/interfaces/IBentoBoxV1.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC20} from \"@BoringSolidity/interfaces/IERC20.sol\";\nimport {Rebase} from \"@BoringSolidity/libraries/BoringRebase.sol\";\nimport {IStrategy} from \"/interfaces/IStrategy.sol\";\n\ninterface IFlashBorrower {\n    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.\n    /// @param sender The address of the invoker of this flashloan.\n    /// @param token The address of the token that is loaned.\n    /// @param amount of the `token` that is loaned.\n    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.\n    /// @param data Additional data that was passed to the flashloan function.\n    function onFlashLoan(address sender, IERC20 token, uint256 amount, uint256 fee, bytes calldata data) external;\n}\n\ninterface IBatchFlashBorrower {\n    /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.\n    /// @param sender The address of the invoker of this flashloan.\n    /// @param tokens Array of addresses for ERC-20 tokens that is loaned.\n    /// @param amounts A one-to-one map to `tokens` that is loaned.\n    /// @param fees A one-to-one map to `tokens` that needs to be paid on top for each loan. Needs to be the same token.\n    /// @param data Additional data that was passed to the flashloan function.\n    function onBatchFlashLoan(\n        address sender,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        uint256[] calldata fees,\n        bytes calldata data\n    ) external;\n}\n\ninterface IBentoBoxV1 {\n    function balanceOf(IERC20, address) external view returns (uint256);\n\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\n\n    function batchFlashLoan(\n        IBatchFlashBorrower borrower,\n        address[] calldata receivers,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n\n    function claimOwnership() external;\n\n    function flashLoan(IFlashBorrower borrower, address receiver, IERC20 token, uint256 amount, bytes calldata data) external;\n\n    function deploy(address masterContract, bytes calldata data, bool useCreate2) external payable returns (address);\n\n    function deposit(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    function harvest(IERC20 token, bool balance, uint256 maxChangeAmount) external;\n\n    function masterContractApproved(address, address) external view returns (bool);\n\n    function masterContractOf(address) external view returns (address);\n\n    function nonces(address) external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function pendingOwner() external view returns (address);\n\n    function pendingStrategy(IERC20) external view returns (IStrategy);\n\n    function permitToken(IERC20 token, address from, address to, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    function registerProtocol() external;\n\n    function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) external;\n\n    function setStrategy(IERC20 token, IStrategy newStrategy) external;\n\n    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;\n\n    function strategy(IERC20) external view returns (IStrategy);\n\n    function strategyData(IERC20) external view returns (uint64 strategyStartDate, uint64 targetPercentage, uint128 balance);\n\n    function toAmount(IERC20 token, uint256 share, bool roundUp) external view returns (uint256 amount);\n\n    function toShare(IERC20 token, uint256 amount, bool roundUp) external view returns (uint256 share);\n\n    function totals(IERC20) external view returns (Rebase memory totals_);\n\n    function transfer(IERC20 token, address from, address to, uint256 share) external;\n\n    function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) external;\n\n    function transferOwnership(address newOwner, bool direct, bool renounce) external;\n\n    function whitelistMasterContract(address masterContract, bool approved) external;\n\n    function whitelistedMasterContracts(address) external view returns (bool);\n\n    function withdraw(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n}\n\ninterface IBentoBoxLite {\n    function deposit(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    function balanceOf(address, address) external view returns (uint256);\n\n    function toAmount(address token, uint256 share, bool roundUp) external view returns (uint256 amount);\n\n    function toShare(address token, uint256 amount, bool roundUp) external view returns (uint256 share);\n\n    function transfer(address token, address from, address to, uint256 share) external;\n}\n"
      },
      "src/interfaces/ILevSwapperV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ILevSwapperV2 {\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom,\n        bytes calldata data\n    ) external returns (uint256 extraShare, uint256 shareReturned);\n}\n"
      },
      "src/interfaces/IERC4626.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n\n/// @notice Tokenized Vaults with a single underlying EIP-20 token.\ninterface IERC4626 {\n    function decimals() external view returns (uint8 decimals);\n    \n    /// @notice The address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n    function asset() external view returns (address assetTokenAddress);\n\n    /// @notice Total amount of the underlying asset that is “managed” by Vault.\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /// @notice The amount of shares that the Vault would exchange for the amount of assets provided, in an ideal scenario where all the conditions are met.\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice The amount of assets that the Vault would exchange for the amount of shares provided, in an ideal scenario where all the conditions are met.\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Maximum amount of the underlying asset that can be deposited into the Vault for the receiver, through a deposit call.\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given current on-chain conditions.\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Mints shares Vault shares to receiver by depositing exactly assets of underlying tokens.\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /// @notice Maximum amount of shares that can be minted from the Vault for the receiver, through a mint call.\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given current on-chain conditions.\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Mints exactly shares Vault shares to receiver by depositing assets of underlying tokens.\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /// @notice Maximum amount of the underlying asset that can be withdrawn from the owner balance in the Vault, through a withdraw call.\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block, given current on-chain conditions.\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /// @notice Maximum amount of Vault shares that can be redeemed from the owner balance in the Vault, through a redeem call.\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block, given current on-chain conditions.\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n    event Withdraw(address indexed caller, address indexed receiver, address indexed owner, uint256 assets, uint256 shares);\n}\n"
      },
      "src/interfaces/IGmxV1.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC20} from \"@BoringSolidity/interfaces/IERC20.sol\";\n\ninterface IGmxVault {\n    event BuyUSDG(address account, address token, uint256 tokenAmount, uint256 usdgAmount, uint256 feeBasisPoints);\n    event ClosePosition(\n        bytes32 key,\n        uint256 size,\n        uint256 collateral,\n        uint256 averagePrice,\n        uint256 entryFundingRate,\n        uint256 reserveAmount,\n        int256 realisedPnl\n    );\n    event CollectMarginFees(address token, uint256 feeUsd, uint256 feeTokens);\n    event CollectSwapFees(address token, uint256 feeUsd, uint256 feeTokens);\n    event DecreaseGuaranteedUsd(address token, uint256 amount);\n    event DecreasePoolAmount(address token, uint256 amount);\n    event DecreasePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        uint256 collateralDelta,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 price,\n        uint256 fee\n    );\n    event DecreaseReservedAmount(address token, uint256 amount);\n    event DecreaseUsdgAmount(address token, uint256 amount);\n    event DirectPoolDeposit(address token, uint256 amount);\n    event IncreaseGuaranteedUsd(address token, uint256 amount);\n    event IncreasePoolAmount(address token, uint256 amount);\n    event IncreasePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        uint256 collateralDelta,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 price,\n        uint256 fee\n    );\n    event IncreaseReservedAmount(address token, uint256 amount);\n    event IncreaseUsdgAmount(address token, uint256 amount);\n    event LiquidatePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        bool isLong,\n        uint256 size,\n        uint256 collateral,\n        uint256 reserveAmount,\n        int256 realisedPnl,\n        uint256 markPrice\n    );\n    event SellUSDG(address account, address token, uint256 usdgAmount, uint256 tokenAmount, uint256 feeBasisPoints);\n    event Swap(\n        address account,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 amountOutAfterFees,\n        uint256 feeBasisPoints\n    );\n    event UpdateFundingRate(address token, uint256 fundingRate);\n    event UpdatePnl(bytes32 key, bool hasProfit, uint256 delta);\n    event UpdatePosition(\n        bytes32 key,\n        uint256 size,\n        uint256 collateral,\n        uint256 averagePrice,\n        uint256 entryFundingRate,\n        uint256 reserveAmount,\n        int256 realisedPnl\n    );\n\n    function BASIS_POINTS_DIVISOR() external view returns (uint256);\n\n    function FUNDING_RATE_PRECISION() external view returns (uint256);\n\n    function MAX_FEE_BASIS_POINTS() external view returns (uint256);\n\n    function MAX_FUNDING_RATE_FACTOR() external view returns (uint256);\n\n    function MAX_LIQUIDATION_FEE_USD() external view returns (uint256);\n\n    function MIN_FUNDING_RATE_INTERVAL() external view returns (uint256);\n\n    function MIN_LEVERAGE() external view returns (uint256);\n\n    function PRICE_PRECISION() external view returns (uint256);\n\n    function USDG_DECIMALS() external view returns (uint256);\n\n    function addRouter(address _router) external;\n\n    function adjustForDecimals(uint256 _amount, address _tokenDiv, address _tokenMul) external view returns (uint256);\n\n    function allWhitelistedTokens(uint256) external view returns (address);\n\n    function allWhitelistedTokensLength() external view returns (uint256);\n\n    function approvedRouters(address, address) external view returns (bool);\n\n    function bufferAmounts(address) external view returns (uint256);\n\n    function buyUSDG(address _token, address _receiver) external returns (uint256);\n\n    function clearTokenConfig(address _token) external;\n\n    function cumulativeFundingRates(address) external view returns (uint256);\n\n    function decreasePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver\n    ) external returns (uint256);\n\n    function directPoolDeposit(address _token) external;\n\n    function errorController() external view returns (address);\n\n    function errors(uint256) external view returns (string memory);\n\n    function feeReserves(address) external view returns (uint256);\n\n    function fundingInterval() external view returns (uint256);\n\n    function fundingRateFactor() external view returns (uint256);\n\n    function getDelta(\n        address _indexToken,\n        uint256 _size,\n        uint256 _averagePrice,\n        bool _isLong,\n        uint256 _lastIncreasedTime\n    ) external view returns (bool, uint256);\n\n    function getFeeBasisPoints(\n        address _token,\n        uint256 _usdgDelta,\n        uint256 _feeBasisPoints,\n        uint256 _taxBasisPoints,\n        bool _increment\n    ) external view returns (uint256);\n\n    function getFundingFee(address _token, uint256 _size, uint256 _entryFundingRate) external view returns (uint256);\n\n    function getGlobalShortDelta(address _token) external view returns (bool, uint256);\n\n    function getMaxPrice(address _token) external view returns (uint256);\n\n    function getMinPrice(address _token) external view returns (uint256);\n\n    function getNextAveragePrice(\n        address _indexToken,\n        uint256 _size,\n        uint256 _averagePrice,\n        bool _isLong,\n        uint256 _nextPrice,\n        uint256 _sizeDelta,\n        uint256 _lastIncreasedTime\n    ) external view returns (uint256);\n\n    function getNextFundingRate(address _token) external view returns (uint256);\n\n    function getNextGlobalShortAveragePrice(address _indexToken, uint256 _nextPrice, uint256 _sizeDelta) external view returns (uint256);\n\n    function getPosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) external view returns (uint256, uint256, uint256, uint256, uint256, uint256, bool, uint256);\n\n    function getPositionDelta(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) external view returns (bool, uint256);\n\n    function getPositionFee(uint256 _sizeDelta) external view returns (uint256);\n\n    function getPositionKey(address _account, address _collateralToken, address _indexToken, bool _isLong) external pure returns (bytes32);\n\n    function getPositionLeverage(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) external view returns (uint256);\n\n    function getRedemptionAmount(address _token, uint256 _usdgAmount) external view returns (uint256);\n\n    function getRedemptionCollateral(address _token) external view returns (uint256);\n\n    function getRedemptionCollateralUsd(address _token) external view returns (uint256);\n\n    function getTargetUsdgAmount(address _token) external view returns (uint256);\n\n    function getUtilisation(address _token) external view returns (uint256);\n\n    function globalShortAveragePrices(address) external view returns (uint256);\n\n    function globalShortSizes(address) external view returns (uint256);\n\n    function gov() external view returns (address);\n\n    function guaranteedUsd(address) external view returns (uint256);\n\n    function hasDynamicFees() external view returns (bool);\n\n    function inManagerMode() external view returns (bool);\n\n    function inPrivateLiquidationMode() external view returns (bool);\n\n    function includeAmmPrice() external view returns (bool);\n\n    function increasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong) external;\n\n    function initialize(\n        address _router,\n        address _usdg,\n        address _priceFeed,\n        uint256 _liquidationFeeUsd,\n        uint256 _fundingRateFactor,\n        uint256 _stableFundingRateFactor\n    ) external;\n\n    function isInitialized() external view returns (bool);\n\n    function isLeverageEnabled() external view returns (bool);\n\n    function isLiquidator(address) external view returns (bool);\n\n    function isManager(address) external view returns (bool);\n\n    function isSwapEnabled() external view returns (bool);\n\n    function lastFundingTimes(address) external view returns (uint256);\n\n    function liquidatePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong,\n        address _feeReceiver\n    ) external;\n\n    function liquidationFeeUsd() external view returns (uint256);\n\n    function marginFeeBasisPoints() external view returns (uint256);\n\n    function maxGasPrice() external view returns (uint256);\n\n    function maxLeverage() external view returns (uint256);\n\n    function maxUsdgAmounts(address) external view returns (uint256);\n\n    function minProfitBasisPoints(address) external view returns (uint256);\n\n    function minProfitTime() external view returns (uint256);\n\n    function mintBurnFeeBasisPoints() external view returns (uint256);\n\n    function poolAmounts(address) external view returns (uint256);\n\n    function positions(\n        bytes32\n    )\n        external\n        view\n        returns (\n            uint256 size,\n            uint256 collateral,\n            uint256 averagePrice,\n            uint256 entryFundingRate,\n            uint256 reserveAmount,\n            int256 realisedPnl,\n            uint256 lastIncreasedTime\n        );\n\n    function priceFeed() external view returns (address);\n\n    function removeRouter(address _router) external;\n\n    function reservedAmounts(address) external view returns (uint256);\n\n    function router() external view returns (address);\n\n    function sellUSDG(address _token, address _receiver) external returns (uint256);\n\n    function setBufferAmount(address _token, uint256 _amount) external;\n\n    function setError(uint256 _errorCode, string memory _error) external;\n\n    function setErrorController(address _errorController) external;\n\n    function setFees(\n        uint256 _taxBasisPoints,\n        uint256 _stableTaxBasisPoints,\n        uint256 _mintBurnFeeBasisPoints,\n        uint256 _swapFeeBasisPoints,\n        uint256 _stableSwapFeeBasisPoints,\n        uint256 _marginFeeBasisPoints,\n        uint256 _liquidationFeeUsd,\n        uint256 _minProfitTime,\n        bool _hasDynamicFees\n    ) external;\n\n    function setFundingRate(uint256 _fundingInterval, uint256 _fundingRateFactor, uint256 _stableFundingRateFactor) external;\n\n    function setGov(address _gov) external;\n\n    function setInManagerMode(bool _inManagerMode) external;\n\n    function setInPrivateLiquidationMode(bool _inPrivateLiquidationMode) external;\n\n    function setIsLeverageEnabled(bool _isLeverageEnabled) external;\n\n    function setIsSwapEnabled(bool _isSwapEnabled) external;\n\n    function setLiquidator(address _liquidator, bool _isActive) external;\n\n    function setManager(address _manager, bool _isManager) external;\n\n    function setMaxGasPrice(uint256 _maxGasPrice) external;\n\n    function setMaxLeverage(uint256 _maxLeverage) external;\n\n    function setPriceFeed(address _priceFeed) external;\n\n    function setTokenConfig(\n        address _token,\n        uint256 _tokenDecimals,\n        uint256 _tokenWeight,\n        uint256 _minProfitBps,\n        uint256 _maxUsdgAmount,\n        bool _isStable,\n        bool _isShortable\n    ) external;\n\n    function setUsdgAmount(address _token, uint256 _amount) external;\n\n    function shortableTokens(address) external view returns (bool);\n\n    function stableFundingRateFactor() external view returns (uint256);\n\n    function stableSwapFeeBasisPoints() external view returns (uint256);\n\n    function stableTaxBasisPoints() external view returns (uint256);\n\n    function stableTokens(address) external view returns (bool);\n\n    function swap(address _tokenIn, address _tokenOut, address _receiver) external returns (uint256);\n\n    function swapFeeBasisPoints() external view returns (uint256);\n\n    function taxBasisPoints() external view returns (uint256);\n\n    function tokenBalances(address) external view returns (uint256);\n\n    function tokenDecimals(address) external view returns (uint256);\n\n    function tokenToUsdMin(address _token, uint256 _tokenAmount) external view returns (uint256);\n\n    function tokenWeights(address) external view returns (uint256);\n\n    function totalTokenWeights() external view returns (uint256);\n\n    function updateCumulativeFundingRate(address _token) external;\n\n    function upgradeVault(address _newVault, address _token, uint256 _amount) external;\n\n    function usdToToken(address _token, uint256 _usdAmount, uint256 _price) external view returns (uint256);\n\n    function usdToTokenMax(address _token, uint256 _usdAmount) external view returns (uint256);\n\n    function usdToTokenMin(address _token, uint256 _usdAmount) external view returns (uint256);\n\n    function usdg() external view returns (address);\n\n    function usdgAmounts(address) external view returns (uint256);\n\n    function useSwapPricing() external view returns (bool);\n\n    function validateLiquidation(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong,\n        bool _raise\n    ) external view returns (uint256, uint256);\n\n    function whitelistedTokenCount() external view returns (uint256);\n\n    function whitelistedTokens(address) external view returns (bool);\n\n    function withdrawFees(address _token, address _receiver) external returns (uint256);\n}\n\ninterface IGmxVester {\n    function rewardTracker() external view returns (address);\n\n    function claimForAccount(address _account, address _receiver) external returns (uint256);\n\n    function claimable(address _account) external view returns (uint256);\n\n    function setHasMaxVestableAmount(bool _hasMaxVestableAmount) external;\n\n    function cumulativeClaimAmounts(address _account) external view returns (uint256);\n\n    function claimedAmounts(address _account) external view returns (uint256);\n\n    function pairAmounts(address _account) external view returns (uint256);\n\n    function getVestedAmount(address _account) external view returns (uint256);\n\n    function transferredAverageStakedAmounts(address _account) external view returns (uint256);\n\n    function transferredCumulativeRewards(address _account) external view returns (uint256);\n\n    function cumulativeRewardDeductions(address _account) external view returns (uint256);\n\n    function bonusRewards(address _account) external view returns (uint256);\n\n    function transferStakeValues(address _sender, address _receiver) external;\n\n    function setTransferredAverageStakedAmounts(address _account, uint256 _amount) external;\n\n    function setTransferredCumulativeRewards(address _account, uint256 _amount) external;\n\n    function setCumulativeRewardDeductions(address _account, uint256 _amount) external;\n\n    function setBonusRewards(address _account, uint256 _amount) external;\n\n    function getMaxVestableAmount(address _account) external view returns (uint256);\n\n    function getCombinedAverageStakedAmount(address _account) external view returns (uint256);\n\n    function deposit(uint256 _amount) external;\n\n    function withdraw() external;\n\n    function claim() external returns (uint256);\n\n    function getTotalVested(address _account) external view returns (uint256);\n\n    function balances(address account) external view returns (uint256);\n}\n\ninterface IVaultPriceFeed {\n    function adjustmentBasisPoints(address _token) external view returns (uint256);\n\n    function isAdjustmentAdditive(address _token) external view returns (bool);\n\n    function setAdjustment(address _token, bool _isAdditive, uint256 _adjustmentBps) external;\n\n    function setUseV2Pricing(bool _useV2Pricing) external;\n\n    function setIsAmmEnabled(bool _isEnabled) external;\n\n    function setIsSecondaryPriceEnabled(bool _isEnabled) external;\n\n    function setSpreadBasisPoints(address _token, uint256 _spreadBasisPoints) external;\n\n    function setSpreadThresholdBasisPoints(uint256 _spreadThresholdBasisPoints) external;\n\n    function setFavorPrimaryPrice(bool _favorPrimaryPrice) external;\n\n    function setPriceSampleSpace(uint256 _priceSampleSpace) external;\n\n    function setMaxStrictPriceDeviation(uint256 _maxStrictPriceDeviation) external;\n\n    function getPrice(address _token, bool _maximise, bool _includeAmmPrice, bool _useSwapPricing) external view returns (uint256);\n\n    function getAmmPrice(address _token) external view returns (uint256);\n\n    function getPrimaryPrice(address _token, bool _maximise) external view returns (uint256);\n}\n\ninterface IGmxRewardDistributor {\n    function pendingRewards() external view returns (uint256);\n\n    function distribute() external returns (uint256);\n}\n\ninterface IGmxRewardRouterV2 {\n    type VotingPowerType is uint8;\n\n    event StakeGlp(address account, uint256 amount);\n    event StakeGmx(address account, address token, uint256 amount);\n    event UnstakeGlp(address account, uint256 amount);\n    event UnstakeGmx(address account, address token, uint256 amount);\n\n    function BASIS_POINTS_DIVISOR() external view returns (uint256);\n\n    function acceptTransfer(address _sender) external;\n\n    function batchCompoundForAccounts(address[] memory _accounts) external;\n\n    function batchStakeGmxForAccount(address[] memory _accounts, uint256[] memory _amounts) external;\n\n    function bnGmx() external view returns (address);\n\n    function bonusGmxTracker() external view returns (address);\n\n    function claim() external;\n\n    function claimEsGmx() external;\n\n    function claimFees() external;\n\n    function compound() external;\n\n    function compoundForAccount(address _account) external;\n\n    function esGmx() external view returns (address);\n\n    function feeGlpTracker() external view returns (address);\n\n    function feeGmxTracker() external view returns (address);\n\n    function glp() external view returns (address);\n\n    function glpManager() external view returns (address);\n\n    function glpVester() external view returns (address);\n\n    function gmx() external view returns (address);\n\n    function gmxVester() external view returns (address);\n\n    function gov() external view returns (address);\n\n    function govToken() external view returns (address);\n\n    function handleRewards(\n        bool shouldClaimGmx,\n        bool shouldStakeGmx,\n        bool shouldClaimEsGmx,\n        bool shouldStakeEsGmx,\n        bool shouldStakeMultiplierPoints,\n        bool shouldClaimWeth,\n        bool shouldConvertWethToEth\n    ) external;\n\n    function inStrictTransferMode() external view returns (bool);\n\n    function initialize(\n        address _weth,\n        address _gmx,\n        address _esGmx,\n        address _bnGmx,\n        address _glp,\n        address _stakedGmxTracker,\n        address _bonusGmxTracker,\n        address _feeGmxTracker,\n        address _feeGlpTracker,\n        address _stakedGlpTracker,\n        address _glpManager,\n        address _gmxVester,\n        address _glpVester,\n        address _govToken\n    ) external;\n\n    function isInitialized() external view returns (bool);\n\n    function maxBoostBasisPoints() external view returns (uint256);\n\n    function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns (uint256);\n\n    function mintAndStakeGlpETH(uint256 _minUsdg, uint256 _minGlp) external payable returns (uint256);\n\n    function pendingReceivers(address) external view returns (address);\n\n    function setGov(address _gov) external;\n\n    function setInStrictTransferMode(bool _inStrictTransferMode) external;\n\n    function setMaxBoostBasisPoints(uint256 _maxBoostBasisPoints) external;\n\n    function setVotingPowerType(VotingPowerType _votingPowerType) external;\n\n    function signalTransfer(address _receiver) external;\n\n    function stakeEsGmx(uint256 _amount) external;\n\n    function stakeGmx(uint256 _amount) external;\n\n    function stakeGmxForAccount(address _account, uint256 _amount) external;\n\n    function stakedGlpTracker() external view returns (address);\n\n    function stakedGmxTracker() external view returns (address);\n\n    function unstakeAndRedeemGlp(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);\n\n    function unstakeAndRedeemGlpETH(uint256 _glpAmount, uint256 _minOut, address payable _receiver) external returns (uint256);\n\n    function unstakeEsGmx(uint256 _amount) external;\n\n    function unstakeGmx(uint256 _amount) external;\n\n    function votingPowerType() external view returns (VotingPowerType);\n\n    function weth() external view returns (address);\n\n    function withdrawToken(address _token, address _account, uint256 _amount) external;\n}\n\ninterface IGmxRewardTracker {\n    function rewardToken() external view returns (address);\n\n    function depositBalances(address _account, address _depositToken) external view returns (uint256);\n\n    function stakedAmounts(address _account) external view returns (uint256);\n\n    function updateRewards() external;\n\n    function stake(address _depositToken, uint256 _amount) external;\n\n    function stakeForAccount(address _fundingAccount, address _account, address _depositToken, uint256 _amount) external;\n\n    function unstake(address _depositToken, uint256 _amount) external;\n\n    function unstakeForAccount(address _account, address _depositToken, uint256 _amount, address _receiver) external;\n\n    function tokensPerInterval() external view returns (uint256);\n\n    function claim(address _receiver) external returns (uint256);\n\n    function claimForAccount(address _account, address _receiver) external returns (uint256);\n\n    function claimable(address _account) external view returns (uint256);\n\n    function averageStakedAmounts(address _account) external view returns (uint256);\n\n    function cumulativeRewards(address _account) external view returns (uint256);\n}\n\ninterface IGmxStakedGlp {\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    function allowances(address, address) external view returns (uint256);\n\n    function approve(address _spender, uint256 _amount) external returns (bool);\n\n    function balanceOf(address _account) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function feeGlpTracker() external view returns (address);\n\n    function glp() external view returns (address);\n\n    function glpManager() external view returns (address);\n\n    function name() external view returns (string memory);\n\n    function stakedGlpTracker() external view returns (address);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\n\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool);\n}\n\ninterface IGmxGlpRewardRouter {\n    event StakeGlp(address account, uint256 amount);\n    event StakeGmx(address account, address token, uint256 amount);\n    event UnstakeGlp(address account, uint256 amount);\n    event UnstakeGmx(address account, address token, uint256 amount);\n\n    function acceptTransfer(address _sender) external;\n\n    function batchCompoundForAccounts(address[] memory _accounts) external;\n\n    function batchStakeGmxForAccount(address[] memory _accounts, uint256[] memory _amounts) external;\n\n    function claim() external;\n\n    function claimEsGmx() external;\n\n    function claimFees() external;\n\n    function compound() external;\n\n    function compoundForAccount(address _account) external;\n\n    function feeGlpTracker() external view returns (address);\n\n    function glp() external view returns (address);\n\n    function glpManager() external view returns (address);\n\n    function gov() external view returns (address);\n\n    function handleRewards(\n        bool shouldClaimGmx,\n        bool shouldStakeGmx,\n        bool shouldClaimEsGmx,\n        bool shouldStakeEsGmx,\n        bool shouldStakeMultiplierPoints,\n        bool shouldClaimWeth,\n        bool shouldConvertWethToEth\n    ) external;\n\n    function initialize(\n        address _weth,\n        address _gmx,\n        address _esGmx,\n        address _bnGmx,\n        address _glp,\n        address _stakedGmxTracker,\n        address _bonusGmxTracker,\n        address _feeGmxTracker,\n        address _feeGlpTracker,\n        address _stakedGlpTracker,\n        address _glpManager,\n        address _gmxVester,\n        address _glpVester\n    ) external;\n\n    function isInitialized() external view returns (bool);\n\n    function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns (uint256);\n\n    function mintAndStakeGlpETH(uint256 _minUsdg, uint256 _minGlp) external payable returns (uint256);\n\n    function pendingReceivers(address) external view returns (address);\n\n    function setGov(address _gov) external;\n\n    function signalTransfer(address _receiver) external;\n\n    function stakeEsGmx(uint256 _amount) external;\n\n    function stakeGmx(uint256 _amount) external;\n\n    function stakeGmxForAccount(address _account, uint256 _amount) external;\n\n    function stakedGlpTracker() external view returns (address);\n\n    function stakedGmxTracker() external view returns (address);\n\n    function unstakeAndRedeemGlp(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);\n\n    function unstakeAndRedeemGlpETH(uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);\n\n    function unstakeEsGmx(uint256 _amount) external;\n\n    function unstakeGmx(uint256 _amount) external;\n\n    function withdrawToken(address _token, address _account, uint256 _amount) external;\n}\n\ninterface IGmxGlpManager {\n    event AddLiquidity(\n        address account,\n        address token,\n        uint256 amount,\n        uint256 aumInUsdg,\n        uint256 glpSupply,\n        uint256 usdgAmount,\n        uint256 mintAmount\n    );\n    event RemoveLiquidity(\n        address account,\n        address token,\n        uint256 glpAmount,\n        uint256 aumInUsdg,\n        uint256 glpSupply,\n        uint256 usdgAmount,\n        uint256 amountOut\n    );\n\n    function BASIS_POINTS_DIVISOR() external view returns (uint256);\n\n    function GLP_PRECISION() external view returns (uint256);\n\n    function MAX_COOLDOWN_DURATION() external view returns (uint256);\n\n    function PRICE_PRECISION() external view returns (uint256);\n\n    function USDG_DECIMALS() external view returns (uint256);\n\n    function addLiquidity(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns (uint256);\n\n    function addLiquidityForAccount(\n        address _fundingAccount,\n        address _account,\n        address _token,\n        uint256 _amount,\n        uint256 _minUsdg,\n        uint256 _minGlp\n    ) external returns (uint256);\n\n    function aumAddition() external view returns (uint256);\n\n    function aumDeduction() external view returns (uint256);\n\n    function cooldownDuration() external view returns (uint256);\n\n    function getAum(bool maximise) external view returns (uint256);\n\n    function getAumInUsdg(bool maximise) external view returns (uint256);\n\n    function getAums() external view returns (uint256[] memory);\n\n    function getGlobalShortAveragePrice(address _token) external view returns (uint256);\n\n    function getGlobalShortDelta(address _token, uint256 _price, uint256 _size) external view returns (uint256, bool);\n\n    function getPrice(bool _maximise) external view returns (uint256);\n\n    function glp() external view returns (address);\n\n    function gov() external view returns (address);\n\n    function inPrivateMode() external view returns (bool);\n\n    function isHandler(address) external view returns (bool);\n\n    function lastAddedAt(address) external view returns (uint256);\n\n    function removeLiquidity(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);\n\n    function removeLiquidityForAccount(\n        address _account,\n        address _tokenOut,\n        uint256 _glpAmount,\n        uint256 _minOut,\n        address _receiver\n    ) external returns (uint256);\n\n    function setAumAdjustment(uint256 _aumAddition, uint256 _aumDeduction) external;\n\n    function setCooldownDuration(uint256 _cooldownDuration) external;\n\n    function setGov(address _gov) external;\n\n    function setHandler(address _handler, bool _isActive) external;\n\n    function setInPrivateMode(bool _inPrivateMode) external;\n\n    function setShortsTracker(address _shortsTracker) external;\n\n    function setShortsTrackerAveragePriceWeight(uint256 _shortsTrackerAveragePriceWeight) external;\n\n    function shortsTracker() external view returns (address);\n\n    function shortsTrackerAveragePriceWeight() external view returns (uint256);\n\n    function usdg() external view returns (address);\n\n    function vault() external view returns (address);\n}\n\ninterface IGmxGlpRewardHandler {\n    function harvest() external;\n\n    function swapRewards(\n        uint256 amountOutMin,\n        IERC20 rewardToken,\n        IERC20 outputToken,\n        address recipient,\n        bytes calldata data\n    ) external returns (uint256 amountOut);\n\n    function setFeeParameters(address _feeCollector, uint8 _feePercent) external;\n\n    function setRewardTokenEnabled(IERC20 token, bool enabled) external;\n\n    function setSwappingTokenOutEnabled(IERC20 token, bool enabled) external;\n\n    function setAllowedSwappingRecipient(address recipient, bool enabled) external;\n\n    function setRewardRouter(IGmxRewardRouterV2 _rewardRouter) external;\n\n    function setSwapper(address _swapper) external;\n\n    function unstakeGmx(uint256 amount, uint256 amountTransferToFeeCollector) external;\n\n    function unstakeEsGmxAndVest(uint256 amount, uint256 glpVesterDepositAmount, uint256 gmxVesterDepositAmount) external;\n\n    function withdrawFromVesting(bool withdrawFromGlpVester, bool withdrawFromGmxVester, bool stake) external;\n\n    function claimVestedGmx(bool withdrawFromGlpVester, bool withdrawFromGmxVester, bool stake, bool transferToFeeCollecter) external;\n}\n"
      },
      "dependencies/openzeppelin-contracts-5.0.2/contracts/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "dependencies/BoringSolidity-1.0.0/contracts/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    // transfer and tranferFrom have been removed, because they don't work on all tokens (some aren't ERC20 complaint).\n    // By removing them you can't accidentally use them.\n    // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).\n    // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ninterface IStrictERC20 {\n    // This is the strict ERC20 interface. Don't use this, certainly not if you don't control the ERC20 token you're calling.\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
      },
      "dependencies/BoringSolidity-1.0.0/contracts/libraries/BoringRebase.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport {BoringMath, BoringMath128} from \"./BoringMath.sol\";\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\n/// @notice A rebasing library using overflow-/underflow-safe math.\nlibrary RebaseLibrary {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = (elastic * total.base) / total.elastic;\n            if (roundUp && (base * total.elastic) / total.base < elastic) {\n                base++;\n            }\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = (base * total.elastic) / total.base;\n            if (roundUp && (elastic * total.base) / total.elastic < base) {\n                elastic++;\n            }\n        }\n    }\n\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\n    /// @return (Rebase) The new total.\n    /// @return base in relationship to `elastic`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 base) {\n        base = toBase(total, elastic, roundUp);\n        total.elastic += elastic.to128();\n        total.base += base.to128();\n        return (total, base);\n    }\n\n    /// @notice Sub `base` from `total` and update `total.elastic`.\n    /// @return (Rebase) The new total.\n    /// @return elastic in relationship to `base`.\n    function sub(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 elastic) {\n        elastic = toElastic(total, base, roundUp);\n        total.elastic -= elastic.to128();\n        total.base -= base.to128();\n        return (total, elastic);\n    }\n\n    /// @notice Add `elastic` and `base` to `total`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic += elastic.to128();\n        total.base += base.to128();\n        return total;\n    }\n\n    /// @notice Subtract `elastic` and `base` to `total`.\n    function sub(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic -= elastic.to128();\n        total.base -= base.to128();\n        return total;\n    }\n\n    /// @notice Add `elastic` to `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic += elastic.to128();\n    }\n\n    /// @notice Subtract `elastic` from `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic -= elastic.to128();\n    }\n}\n"
      },
      "src/interfaces/IStrategy.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IStrategy {\n    function skim(uint256 amount) external;\n\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\n\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\n\n    function exit(uint256 balance) external returns (int256 amountAdded);\n}\n"
      },
      "dependencies/BoringSolidity-1.0.0/contracts/libraries/BoringMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nlibrary BoringMath {\n    error ErrOverflow();\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function to32(uint256 a) internal pure returns (uint32) {\n        if (a > type(uint32).max) {\n            revert ErrOverflow();\n        }\n        return uint32(a);\n    }\n\n    function to40(uint256 a) internal pure returns (uint40) {\n        if (a > type(uint40).max) {\n            revert ErrOverflow();\n        }\n        return uint40(a);\n    }\n\n    function to64(uint256 a) internal pure returns (uint64) {\n        if (a > type(uint64).max) {\n            revert ErrOverflow();\n        }\n        return uint64(a);\n    }\n\n    function to112(uint256 a) internal pure returns (uint112) {\n        if (a > type(uint112).max) {\n            revert ErrOverflow();\n        }\n        return uint112(a);\n    }\n\n    function to128(uint256 a) internal pure returns (uint128) {\n        if (a > type(uint128).max) {\n            revert ErrOverflow();\n        }\n        return uint128(a);\n    }\n\n    function to208(uint256 a) internal pure returns (uint208) {\n        if (a > type(uint208).max) {\n            revert ErrOverflow();\n        }\n        return uint208(a);\n    }\n\n    function to216(uint256 a) internal pure returns (uint216) {\n        if (a > type(uint216).max) {\n            revert ErrOverflow();\n        }\n        return uint216(a);\n    }\n\n    function to224(uint256 a) internal pure returns (uint224) {\n        if (a > type(uint224).max) {\n            revert ErrOverflow();\n        }\n        return uint224(a);\n    }\n}\n\nlibrary BoringMath32 {\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a + b;\n    }\n\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a - b;\n    }\n\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a * b;\n    }\n\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a / b;\n    }\n}\n\nlibrary BoringMath64 {\n    function add(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a + b;\n    }\n\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a - b;\n    }\n\n    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a * b;\n    }\n\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a / b;\n    }\n}\n\nlibrary BoringMath112 {\n    function add(uint112 a, uint112 b) internal pure returns (uint112) {\n        return a + b;\n    }\n\n    function sub(uint112 a, uint112 b) internal pure returns (uint112) {\n        return a - b;\n    }\n\n    function mul(uint112 a, uint112 b) internal pure returns (uint112) {\n        return a * b;\n    }\n\n    function div(uint112 a, uint112 b) internal pure returns (uint112) {\n        return a / b;\n    }\n}\n\nlibrary BoringMath128 {\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\n        return a + b;\n    }\n\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\n        return a - b;\n    }\n\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\n        return a * b;\n    }\n\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\n        return a / b;\n    }\n}\n\nlibrary BoringMath224 {\n    function add(uint224 a, uint224 b) internal pure returns (uint224) {\n        return a + b;\n    }\n\n    function sub(uint224 a, uint224 b) internal pure returns (uint224) {\n        return a - b;\n    }\n\n    function mul(uint224 a, uint224 b) internal pure returns (uint224) {\n        return a * b;\n    }\n\n    function div(uint224 a, uint224 b) internal pure returns (uint224) {\n        return a / b;\n    }\n}\n"
      }
    },
    "settings": {
      "remappings": [
        "/=src/",
        "forge-std/=dependencies/forge-std-1.9.5/src/",
        "halmos-cheatcodes/=dependencies/halmos-cheatcodes-7328abe/src/",
        "@openzeppelin/contracts/=dependencies/openzeppelin-contracts-5.0.2/contracts/",
        "@openzeppelin/contracts-upgradeable/=dependencies/openzeppelin-contracts-upgradeable-5.0.2/contracts/",
        "@BoringSolidity/=dependencies/BoringSolidity-1.0.0/contracts/",
        "@solady/=dependencies/solady-0.0.281/src/",
        "@solmate/=dependencies/solmate-6.2.0/src/",
        "@excessivelySafeCall/=dependencies/ExcessivelySafeCall-0.0.1/src/",
        "@safe-contracts/=dependencies/safe-contracts-1.3.0/contracts/",
        "@fuzzlib/=dependencies/fuzzlib-0.0.1/src/",
        "@abracadabra-oft-v1/=dependencies/abracadabra-oft-v1-0.0.1/src/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 400
      },
      "metadata": {
        "useLiteralContent": false,
        "bytecodeHash": "ipfs",
        "appendCBOR": true
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode.object",
            "evm.bytecode.sourceMap",
            "evm.bytecode.linkReferences",
            "evm.deployedBytecode.object",
            "evm.deployedBytecode.sourceMap",
            "evm.deployedBytecode.linkReferences",
            "evm.deployedBytecode.immutableReferences",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "evmVersion": "cancun",
      "viaIR": false,
      "libraries": {}
    }
  },
  "compiler": "0.8.28+commit.7893614a"
}