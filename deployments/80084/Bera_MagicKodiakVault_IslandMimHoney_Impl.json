{
  "address": "0xcC8e53F298a8141C27E23a40D57893868A542C66",
  "abi": [
    {
      "type": "constructor",
      "inputs": [
        {
          "name": "__asset",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "DOMAIN_SEPARATOR",
      "inputs": [],
      "outputs": [
        {
          "name": "result",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "ZERO_LOCKTIME",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "_totalAssets",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "allowance",
      "inputs": [
        {
          "name": "owner",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "spender",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "result",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "approve",
      "inputs": [
        {
          "name": "spender",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "asset",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "balanceOf",
      "inputs": [
        {
          "name": "owner",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "result",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "convertToAssets",
      "inputs": [
        {
          "name": "shares",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "assets",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "convertToShares",
      "inputs": [
        {
          "name": "assets",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "shares",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "decimals",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint8",
          "internalType": "uint8"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "deposit",
      "inputs": [
        {
          "name": "assets",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "to",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "shares",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "distributeRewards",
      "inputs": [
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "harvest",
      "inputs": [
        {
          "name": "harvester",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "initialize",
      "inputs": [
        {
          "name": "_owner",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_staking",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "maxDeposit",
      "inputs": [
        {
          "name": "to",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "maxAssets",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "maxMint",
      "inputs": [
        {
          "name": "to",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "maxShares",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "maxRedeem",
      "inputs": [
        {
          "name": "owner",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "maxShares",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "maxWithdraw",
      "inputs": [
        {
          "name": "owner",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "maxAssets",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "mint",
      "inputs": [
        {
          "name": "shares",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "to",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "assets",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "name",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "string",
          "internalType": "string"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "nonces",
      "inputs": [
        {
          "name": "owner",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "result",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "operators",
      "inputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "owner",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "permit",
      "inputs": [
        {
          "name": "owner",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "spender",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "value",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "deadline",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "v",
          "type": "uint8",
          "internalType": "uint8"
        },
        {
          "name": "r",
          "type": "bytes32",
          "internalType": "bytes32"
        },
        {
          "name": "s",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "previewDeposit",
      "inputs": [
        {
          "name": "assets",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "shares",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "previewMint",
      "inputs": [
        {
          "name": "shares",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "assets",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "previewRedeem",
      "inputs": [
        {
          "name": "shares",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "assets",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "previewWithdraw",
      "inputs": [
        {
          "name": "assets",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "shares",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "proxiableUUID",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "redeem",
      "inputs": [
        {
          "name": "shares",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "to",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "owner",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "assets",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setOperator",
      "inputs": [
        {
          "name": "operator",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "enable",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setStaking",
      "inputs": [
        {
          "name": "_staking",
          "type": "address",
          "internalType": "contract IKodiakVaultStaking"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "staking",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IKodiakVaultStaking"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "symbol",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "string",
          "internalType": "string"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "totalAssets",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "totalSupply",
      "inputs": [],
      "outputs": [
        {
          "name": "result",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "transfer",
      "inputs": [
        {
          "name": "to",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "transferFrom",
      "inputs": [
        {
          "name": "from",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "to",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "transferOwnership",
      "inputs": [
        {
          "name": "newOwner",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "upgradeToAndCall",
      "inputs": [
        {
          "name": "newImplementation",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "data",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [],
      "stateMutability": "payable"
    },
    {
      "type": "function",
      "name": "version",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint64",
          "internalType": "uint64"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "withdraw",
      "inputs": [
        {
          "name": "assets",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "to",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "owner",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "shares",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "event",
      "name": "Approval",
      "inputs": [
        {
          "name": "owner",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "spender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "Deposit",
      "inputs": [
        {
          "name": "by",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "owner",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "assets",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        },
        {
          "name": "shares",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "Initialized",
      "inputs": [
        {
          "name": "version",
          "type": "uint64",
          "indexed": false,
          "internalType": "uint64"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "LogStakingChanged",
      "inputs": [
        {
          "name": "staking",
          "type": "address",
          "indexed": false,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "OperatorChanged",
      "inputs": [
        {
          "name": "",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "",
          "type": "bool",
          "indexed": false,
          "internalType": "bool"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "OwnershipTransferred",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "newOwner",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "Transfer",
      "inputs": [
        {
          "name": "from",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "to",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "Upgraded",
      "inputs": [
        {
          "name": "implementation",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "Withdraw",
      "inputs": [
        {
          "name": "by",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "to",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "owner",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "assets",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        },
        {
          "name": "shares",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "error",
      "name": "AllowanceOverflow",
      "inputs": []
    },
    {
      "type": "error",
      "name": "AllowanceUnderflow",
      "inputs": []
    },
    {
      "type": "error",
      "name": "DepositMoreThanMax",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InsufficientAllowance",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InsufficientBalance",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidInitialization",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidPermit",
      "inputs": []
    },
    {
      "type": "error",
      "name": "MintMoreThanMax",
      "inputs": []
    },
    {
      "type": "error",
      "name": "NotInitializing",
      "inputs": []
    },
    {
      "type": "error",
      "name": "PermitExpired",
      "inputs": []
    },
    {
      "type": "error",
      "name": "RedeemMoreThanMax",
      "inputs": []
    },
    {
      "type": "error",
      "name": "TotalSupplyOverflow",
      "inputs": []
    },
    {
      "type": "error",
      "name": "Unauthorized",
      "inputs": []
    },
    {
      "type": "error",
      "name": "UnauthorizedCallContext",
      "inputs": []
    },
    {
      "type": "error",
      "name": "UpgradeFailed",
      "inputs": []
    },
    {
      "type": "error",
      "name": "WithdrawMoreThanMax",
      "inputs": []
    }
  ],
  "bytecode": "0x60c0604052306080523480156012575f80fd5b50604051612245380380612245833981016040819052602f91603f565b6001600160a01b031660a052606a565b5f60208284031215604e575f80fd5b81516001600160a01b03811681146063575f80fd5b9392505050565b60805160a05161217b6100ca5f395f81816103ed015281816107ec01528181610ca501528181610f55015281816110ad015281816110e30152818161177e0152818161182e0152611a7f01525f8181610d2d0152610e0e015261217b5ff3fe608060405260043610610267575f3560e01c806359974e3811610143578063b460af94116100c2578063ce96cb7711610087578063dd62ed3e11610062578063dd62ed3e14610776578063ef8b30f7146107aa578063f2fde38b146107c9575f80fd5b8063ce96cb7714610719578063d505accf14610738578063d905777e14610757575f80fd5b8063b460af94146106a8578063ba087652146106c7578063c63d75b614610425578063c6e6f592146106e6578063ce04bebb14610705575f80fd5b80638ff39099116101085780638ff39099146105e757806394bf804d1461060657806395d89b4114610625578063a9059cbb1461066a578063b3d7f6b914610689575f80fd5b806359974e38146105285780636e553f651461054757806370a08231146105665780637ecebe00146105975780638da5cb5b146105c8575f80fd5b80633644e515116101e95780634cf088d9116101ae57806352d1902d1161018957806352d1902d146104c857806354fd4d50146104dc578063558a729714610509575f80fd5b80634cf088d9146104835780634ead459d146104a25780634f1ef286146104b5575f80fd5b80633644e515146103cb57806338d52e0f146103df578063402d267d14610425578063485cc955146104455780634cdad50614610464575f80fd5b80630e5c011e1161022f5780630e5c011e1461031b57806313e7c9d81461033c57806318160ddd1461036a57806323b872dd14610386578063313ce567146103a5575f80fd5b806301e1d1141461026b57806306fdde031461028d57806307a2d13a146102ae578063095ea7b3146102cd5780630a28a477146102fc575b5f80fd5b348015610276575f80fd5b505f545b6040519081526020015b60405180910390f35b348015610298575f80fd5b506102a16107e8565b6040516102849190611bba565b3480156102b9575f80fd5b5061027a6102c8366004611bec565b610890565b3480156102d8575f80fd5b506102ec6102e7366004611c17565b6108d4565b6040519015158152602001610284565b348015610307575f80fd5b5061027a610316366004611bec565b610924565b348015610326575f80fd5b5061033a610335366004611c41565b61095b565b005b348015610347575f80fd5b506102ec610356366004611c41565b60026020525f908152604090205460ff1681565b348015610375575f80fd5b506805345cdf77eb68f44c5461027a565b348015610391575f80fd5b506102ec6103a0366004611c5c565b610b0c565b3480156103b0575f80fd5b506103b9610bc6565b60405160ff9091168152602001610284565b3480156103d6575f80fd5b5061027a610bdc565b3480156103ea575f80fd5b507f00000000000000000000000000000000000000000000000000000000000000005b6040516001600160a01b039091168152602001610284565b348015610430575f80fd5b5061027a61043f366004611c41565b505f1990565b348015610450575f80fd5b5061033a61045f366004611c9a565b610c58565b34801561046f575f80fd5b5061027a61047e366004611bec565b610d21565b34801561048e575f80fd5b5060035461040d906001600160a01b031681565b3480156104ad575f80fd5b5061027a5f81565b61033a6104c3366004611cd1565b610d2b565b3480156104d3575f80fd5b5061027a610e0b565b3480156104e7575f80fd5b506104f0610e68565b60405167ffffffffffffffff9091168152602001610284565b348015610514575f80fd5b5061033a610523366004611d51565b610e79565b348015610533575f80fd5b5061033a610542366004611bec565b610f01565b348015610552575f80fd5b5061027a610561366004611d81565b611049565b348015610571575f80fd5b5061027a610580366004611c41565b6387a211a2600c9081525f91909152602090205490565b3480156105a2575f80fd5b5061027a6105b1366004611c41565b6338377508600c9081525f91909152602090205490565b3480156105d3575f80fd5b5060015461040d906001600160a01b031681565b3480156105f2575f80fd5b5061033a610601366004611c41565b611061565b348015610611575f80fd5b5061027a610620366004611d81565b61115f565b348015610630575f80fd5b5060408051808201909152601181527f4d616769634b6f6469616b205661756c7400000000000000000000000000000060208201526102a1565b348015610675575f80fd5b506102ec610684366004611c17565b611177565b348015610694575f80fd5b5061027a6106a3366004611bec565b6111ee565b3480156106b3575f80fd5b5061027a6106c2366004611da4565b61121b565b3480156106d2575f80fd5b5061027a6106e1366004611da4565b611251565b3480156106f1575f80fd5b5061027a610700366004611bec565b611287565b348015610710575f80fd5b5061027a5f5481565b348015610724575f80fd5b5061027a610733366004611c41565b6112b4565b348015610743575f80fd5b5061033a610752366004611de3565b6112d1565b348015610762575f80fd5b5061027a610771366004611c41565b611453565b348015610781575f80fd5b5061027a610790366004611c9a565b602052637f5e9f20600c9081525f91909152603490205490565b3480156107b5575f80fd5b5061027a6107c4366004611bec565b61146c565b3480156107d4575f80fd5b5061033a6107e3366004611c41565b611476565b60607f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166306fdde036040518163ffffffff1660e01b81526004015f60405180830381865afa158015610845573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405261086c9190810190611e99565b60405160200161087c9190611f2a565b604051602081830303815290604052905090565b5f61089d565b9392505050565b5f610896836108aa5f5490565b6108b5906001611f6a565b6108cf6108c96805345cdf77eb68f44c5490565b60010190565b6114eb565b5f82602052637f5e9f20600c52335f52816034600c2055815f52602c5160601c337f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560205fa35060015b92915050565b5f61092f565b611579565b5f610896836109456805345cdf77eb68f44c5490565b610950906001611f6a565b61092a6108c95f5490565b335f9081526002602052604090205460ff1615801561098557506001546001600160a01b03163314155b156109a2576040516282b42960e81b815260040160405180910390fd5b60035f9054906101000a90046001600160a01b03166001600160a01b0316633d18b9126040518163ffffffff1660e01b81526004015f604051808303815f875af11580156109f2573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610a199190810190611fdf565b50600354604080516304bb6c9360e21b815290515f926001600160a01b0316916312edb24c91600480830192869291908290030181865afa158015610a60573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610a879190810190612075565b90505f5b8151811015610b0757610aff83610acd30858581518110610aae57610aae612105565b60200260200101516001600160a01b03166115a590919063ffffffff16565b848481518110610adf57610adf612105565b60200260200101516001600160a01b03166115d89092919063ffffffff16565b600101610a8b565b505050565b5f8360601b33602052637f5e9f208117600c526034600c2080546001810115610b4a5780851115610b44576313be252b5f526004601cfd5b84810382555b50506387a211a28117600c526020600c20805480851115610b725763f4d678b85f526004601cfd5b84810382555050835f526020600c208381540181555082602052600c5160601c8160601c7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef602080a3505060019392505050565b5f610bd1565b905090565b610bcc5f6012612119565b5f80610be66107e8565b8051906020012090506040517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f81528160208201527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6604082015246606082015230608082015260a081209250505090565b63409feecd198054600382558015610c8e5760018160011c14303b10610c855763f92ee8a95f526004601cfd5b818160ff1b1b91505b50610c9883611621565b610ccd6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016835f1961166c565b600380546001600160a01b0319166001600160a01b0384161790558015610b07576002815560016020527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2602080a1505050565b5f61091e82610890565b7f0000000000000000000000000000000000000000000000000000000000000000308103610d6057639f03a0265f526004601cfd5b610d69846116ac565b8360601b60601c93506352d1902d6001527f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80602060016004601d895afa5114610dbb576355299b496001526004601dfd5b847fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f38a28490558115610e0557604051828482375f388483885af4610e03573d5f823e3d81fd5b505b50505050565b5f7f0000000000000000000000000000000000000000000000000000000000000000308114610e4157639f03a0265f526004601cfd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc91505090565b5f610bcc63409feecd195460011c90565b6001546001600160a01b03163314610ea3576040516282b42960e81b815260040160405180910390fd5b6001600160a01b0382165f81815260026020908152604091829020805460ff191685151590811790915591519182527f193de8d500b5cb7b720089b258a39e9c1d0b840019a73ae7c51c3f9101732b02910160405180910390a25050565b335f9081526002602052604090205460ff16158015610f2b57506001546001600160a01b03163314155b15610f48576040516282b42960e81b815260040160405180910390fd5b610f7d6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163330846116b7565b60035f9054906101000a90046001600160a01b03166001600160a01b031663298360a96040518163ffffffff1660e01b81526004015f604051808303815f87803b158015610fc9575f80fd5b505af1158015610fdb573d5f803e3d5ffd5b50506003546040516317b18c8960e01b8152600481018590525f60248201526001600160a01b0390911692506317b18c8991506044015f604051808303815f87803b158015611028575f80fd5b505af115801561103a573d5f803e3d5ffd5b50505f80549093019092555050565b5f6110538361146c565b905061091e33838584611718565b6001546001600160a01b0316331461108b576040516282b42960e81b815260040160405180910390fd5b6003546001600160a01b0316156110d6576003546110d6906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811691165f61166c565b61110b6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016825f1961166c565b600380546001600160a01b0319166001600160a01b0383169081179091556040519081527f8c4817d5539aae7173c3c7db99c99c5533c0b4047930a875b721aa113774fb689060200160405180910390a150565b5f611169836111ee565b905061091e33838386611718565b5f6387a211a2600c52335f526020600c2080548084111561119f5763f4d678b85f526004601cfd5b83810382555050825f526020600c208281540181555081602052600c5160601c337fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef602080a350600192915050565b5f80610896836111fc5f5490565b611207906001611f6a565b61092a6108c96805345cdf77eb68f44c5490565b5f611225826112b4565b8411156112395761123963936941fc61170f565b61124284610924565b90506108963384848785611731565b5f61125b82611453565b84111561126f5761126f634656425a61170f565b61127884610d21565b90506108963384848488611731565b5f806108968361129e6805345cdf77eb68f44c5490565b6112a9906001611f6a565b6108cf6108c95f5490565b6387a211a2600c9081525f82815260209091205461091e90610890565b5f6112da6107e8565b805190602001209050844211156112f857631a15a3cc5f526004601cfd5b6040518860601b60601c98508760601b60601c975065383775081901600e52885f526020600c2080547f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f83528360208401527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6604084015246606084015230608084015260a08320602e527f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c983528a60208401528960408401528860608401528060808401528760a084015260c08320604e526042602c205f528660ff16602052856040528460605260208060805f60015afa8b3d51146114005763ddafbaef5f526004601cfd5b0190556303faf4f960a51b88176040526034602c2087905587897f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925602060608501a360405250505f606052505050505050565b6387a211a2600c9081525f82815260209091205461091e565b5f61091e82611287565b6001546001600160a01b031633146114a0576040516282b42960e81b815260040160405180910390fd5b600180546001600160a01b0319166001600160a01b03831690811790915560405133907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a350565b82820281838583041485151702611572575f198385098181108201900382848609835f0384168285116115255763ae47f7025f526004601cfd5b93849004938382119092035f839003839004600101029203041760026003830281188084028203028084028203028084028203028084028203028084028203028084029091030202610896565b0492915050565b5f6115858484846114eb565b9050818385091561089657600101806108965763ae47f7025f526004601cfd5b5f816014526f70a082310000000000000000000000005f5260208060246010865afa601f3d111660205102905092915050565b81601452806034526fa9059cbb0000000000000000000000005f5260205f604460105f875af13d1560015f51141716611618576390b8ec185f526004601cfd5b5f603452505050565b600180546001600160a01b0319166001600160a01b0383169081179091556040515f907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a350565b81601452806034526f095ea7b30000000000000000000000005f5260205f604460105f875af13d1560015f5114171661161857633e3f8f735f526004601cfd5b6116b461174d565b50565b60405181606052826040528360601b602c526f23b872dd000000000000000000000000600c5260205f6064601c5f895af13d1560015f5114171661170257637939f4245f526004601cfd5b5f60605260405250505050565b805f526004601cfd5b61172484848484611779565b505f805490910190555050565b61173e85858585856117f1565b505f8054919091039055505050565b6001546001600160a01b03163314611777576040516282b42960e81b815260040160405180910390fd5b565b6117a57f00000000000000000000000000000000000000000000000000000000000000008530856116b7565b6117af8382611896565b815f52806020525f1960601c8381168582167fdcbc1c05240f31ff3ad067ef1ee35ce4997762752e3a095284754544f4c709d760405fa350610e058282611912565b826001600160a01b0316856001600160a01b031614611815576118158386836119d7565b61181f8282611a15565b6118298382611b24565b6118547f000000000000000000000000000000000000000000000000000000000000000085846115d8565b815f52806020525f1960601c8381168582168783167ffbde797d201c681b91056529119e0b02407c7bb96a4a2c75c01fc9667232c8db60405fa4505050505050565b6805345cdf77eb68f44c54818101818110156118b95763e5cfe9575f526004601cfd5b806805345cdf77eb68f44c5550506387a211a2600c52815f526020600c208181540181555080602052600c5160601c5f7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef602080a35050565b60035f9054906101000a90046001600160a01b03166001600160a01b031663298360a96040518163ffffffff1660e01b81526004015f604051808303815f87803b15801561195e575f80fd5b505af1158015611970573d5f803e3d5ffd5b50506003546040516317b18c8960e01b8152600481018690525f60248201526001600160a01b0390911692506317b18c8991506044015f604051808303815f87803b1580156119bd575f80fd5b505af11580156119cf573d5f803e3d5ffd5b505050505050565b81602052637f5e9f20600c52825f526034600c2080546001810115610e035780831115611a0b576313be252b5f526004601cfd5b9190910390555050565b60035f9054906101000a90046001600160a01b03166001600160a01b031663298360a96040518163ffffffff1660e01b81526004015f604051808303815f87803b158015611a61575f80fd5b505af1158015611a73573d5f803e3d5ffd5b505050505f82611ab5307f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166115a590919063ffffffff16565b611abf9190612132565b6003546040516317b18c8960e01b8152600481018390525f60248201529192506001600160a01b0316906317b18c89906044015f604051808303815f87803b158015611b09575f80fd5b505af1158015611b1b573d5f803e3d5ffd5b50505050505050565b6387a211a2600c52815f526020600c20805480831115611b4b5763f4d678b85f526004601cfd5b82900390556805345cdf77eb68f44c805482900390555f8181526001600160a01b0383167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef602083a35050565b5f5b83811015611bb2578181015183820152602001611b9a565b50505f910152565b602081525f8251806020840152611bd8816040850160208701611b98565b601f01601f19169190910160400192915050565b5f60208284031215611bfc575f80fd5b5035919050565b6001600160a01b03811681146116b4575f80fd5b5f8060408385031215611c28575f80fd5b8235611c3381611c03565b946020939093013593505050565b5f60208284031215611c51575f80fd5b813561089681611c03565b5f805f60608486031215611c6e575f80fd5b8335611c7981611c03565b92506020840135611c8981611c03565b929592945050506040919091013590565b5f8060408385031215611cab575f80fd5b8235611cb681611c03565b91506020830135611cc681611c03565b809150509250929050565b5f805f60408486031215611ce3575f80fd5b8335611cee81611c03565b9250602084013567ffffffffffffffff811115611d09575f80fd5b8401601f81018613611d19575f80fd5b803567ffffffffffffffff811115611d2f575f80fd5b866020828401011115611d40575f80fd5b939660209190910195509293505050565b5f8060408385031215611d62575f80fd5b8235611d6d81611c03565b915060208301358015158114611cc6575f80fd5b5f8060408385031215611d92575f80fd5b823591506020830135611cc681611c03565b5f805f60608486031215611db6575f80fd5b833592506020840135611dc881611c03565b91506040840135611dd881611c03565b809150509250925092565b5f805f805f805f60e0888a031215611df9575f80fd5b8735611e0481611c03565b96506020880135611e1481611c03565b95506040880135945060608801359350608088013560ff81168114611e37575f80fd5b9699959850939692959460a0840135945060c09093013592915050565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff81118282101715611e9157611e91611e54565b604052919050565b5f60208284031215611ea9575f80fd5b815167ffffffffffffffff811115611ebf575f80fd5b8201601f81018413611ecf575f80fd5b805167ffffffffffffffff811115611ee957611ee9611e54565b611efc601f8201601f1916602001611e68565b818152856020838501011115611f10575f80fd5b611f21826020830160208601611b98565b95945050505050565b644d6167696360d81b81525f8251611f49816005850160208701611b98565b9190910160050192915050565b634e487b7160e01b5f52601160045260245ffd5b8082018082111561091e5761091e611f56565b6001841115611fb457808504811115611f9857611f98611f56565b6001841615611fa657908102905b60019390931c928002611f7d565b935093915050565b5f67ffffffffffffffff821115611fd557611fd5611e54565b5060051b60200190565b5f60208284031215611fef575f80fd5b815167ffffffffffffffff811115612005575f80fd5b8201601f81018413612015575f80fd5b805161202861202382611fbc565b611e68565b8082825260208201915060208360051b850101925086831115612049575f80fd5b6020840193505b8284101561206b578351825260209384019390910190612050565b9695505050505050565b5f60208284031215612085575f80fd5b815167ffffffffffffffff81111561209b575f80fd5b8201601f810184136120ab575f80fd5b80516120b961202382611fbc565b8082825260208201915060208360051b8501019250868311156120da575f80fd5b6020840193505b8284101561206b5783516120f481611c03565b8252602093840193909101906120e1565b634e487b7160e01b5f52603260045260245ffd5b60ff818116838216019081111561091e5761091e611f56565b8181038181111561091e5761091e611f5656fea2646970667358221220914c8e2e218a5dc5e3017f1c9fdedc478cbdb671d50c8e3b9ade750c5d52447b64736f6c634300081a0033",
  "args_data": "0x00000000000000000000000074e852a4f88bfbeff01275bb95d5ed77f2967d12",
  "tx_hash": "0x05bd36172946a4b95cd0239ffc941771a22d5699b753dcfafb2465d3c4cc31f1",
  "args": [
    "0x74E852a4f88bfbEff01275bB95d5ed77f2967d12"
  ],
  "data": "0x60c0604052306080523480156012575f80fd5b50604051612245380380612245833981016040819052602f91603f565b6001600160a01b031660a052606a565b5f60208284031215604e575f80fd5b81516001600160a01b03811681146063575f80fd5b9392505050565b60805160a05161217b6100ca5f395f81816103ed015281816107ec01528181610ca501528181610f55015281816110ad015281816110e30152818161177e0152818161182e0152611a7f01525f8181610d2d0152610e0e015261217b5ff3fe608060405260043610610267575f3560e01c806359974e3811610143578063b460af94116100c2578063ce96cb7711610087578063dd62ed3e11610062578063dd62ed3e14610776578063ef8b30f7146107aa578063f2fde38b146107c9575f80fd5b8063ce96cb7714610719578063d505accf14610738578063d905777e14610757575f80fd5b8063b460af94146106a8578063ba087652146106c7578063c63d75b614610425578063c6e6f592146106e6578063ce04bebb14610705575f80fd5b80638ff39099116101085780638ff39099146105e757806394bf804d1461060657806395d89b4114610625578063a9059cbb1461066a578063b3d7f6b914610689575f80fd5b806359974e38146105285780636e553f651461054757806370a08231146105665780637ecebe00146105975780638da5cb5b146105c8575f80fd5b80633644e515116101e95780634cf088d9116101ae57806352d1902d1161018957806352d1902d146104c857806354fd4d50146104dc578063558a729714610509575f80fd5b80634cf088d9146104835780634ead459d146104a25780634f1ef286146104b5575f80fd5b80633644e515146103cb57806338d52e0f146103df578063402d267d14610425578063485cc955146104455780634cdad50614610464575f80fd5b80630e5c011e1161022f5780630e5c011e1461031b57806313e7c9d81461033c57806318160ddd1461036a57806323b872dd14610386578063313ce567146103a5575f80fd5b806301e1d1141461026b57806306fdde031461028d57806307a2d13a146102ae578063095ea7b3146102cd5780630a28a477146102fc575b5f80fd5b348015610276575f80fd5b505f545b6040519081526020015b60405180910390f35b348015610298575f80fd5b506102a16107e8565b6040516102849190611bba565b3480156102b9575f80fd5b5061027a6102c8366004611bec565b610890565b3480156102d8575f80fd5b506102ec6102e7366004611c17565b6108d4565b6040519015158152602001610284565b348015610307575f80fd5b5061027a610316366004611bec565b610924565b348015610326575f80fd5b5061033a610335366004611c41565b61095b565b005b348015610347575f80fd5b506102ec610356366004611c41565b60026020525f908152604090205460ff1681565b348015610375575f80fd5b506805345cdf77eb68f44c5461027a565b348015610391575f80fd5b506102ec6103a0366004611c5c565b610b0c565b3480156103b0575f80fd5b506103b9610bc6565b60405160ff9091168152602001610284565b3480156103d6575f80fd5b5061027a610bdc565b3480156103ea575f80fd5b507f00000000000000000000000000000000000000000000000000000000000000005b6040516001600160a01b039091168152602001610284565b348015610430575f80fd5b5061027a61043f366004611c41565b505f1990565b348015610450575f80fd5b5061033a61045f366004611c9a565b610c58565b34801561046f575f80fd5b5061027a61047e366004611bec565b610d21565b34801561048e575f80fd5b5060035461040d906001600160a01b031681565b3480156104ad575f80fd5b5061027a5f81565b61033a6104c3366004611cd1565b610d2b565b3480156104d3575f80fd5b5061027a610e0b565b3480156104e7575f80fd5b506104f0610e68565b60405167ffffffffffffffff9091168152602001610284565b348015610514575f80fd5b5061033a610523366004611d51565b610e79565b348015610533575f80fd5b5061033a610542366004611bec565b610f01565b348015610552575f80fd5b5061027a610561366004611d81565b611049565b348015610571575f80fd5b5061027a610580366004611c41565b6387a211a2600c9081525f91909152602090205490565b3480156105a2575f80fd5b5061027a6105b1366004611c41565b6338377508600c9081525f91909152602090205490565b3480156105d3575f80fd5b5060015461040d906001600160a01b031681565b3480156105f2575f80fd5b5061033a610601366004611c41565b611061565b348015610611575f80fd5b5061027a610620366004611d81565b61115f565b348015610630575f80fd5b5060408051808201909152601181527f4d616769634b6f6469616b205661756c7400000000000000000000000000000060208201526102a1565b348015610675575f80fd5b506102ec610684366004611c17565b611177565b348015610694575f80fd5b5061027a6106a3366004611bec565b6111ee565b3480156106b3575f80fd5b5061027a6106c2366004611da4565b61121b565b3480156106d2575f80fd5b5061027a6106e1366004611da4565b611251565b3480156106f1575f80fd5b5061027a610700366004611bec565b611287565b348015610710575f80fd5b5061027a5f5481565b348015610724575f80fd5b5061027a610733366004611c41565b6112b4565b348015610743575f80fd5b5061033a610752366004611de3565b6112d1565b348015610762575f80fd5b5061027a610771366004611c41565b611453565b348015610781575f80fd5b5061027a610790366004611c9a565b602052637f5e9f20600c9081525f91909152603490205490565b3480156107b5575f80fd5b5061027a6107c4366004611bec565b61146c565b3480156107d4575f80fd5b5061033a6107e3366004611c41565b611476565b60607f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166306fdde036040518163ffffffff1660e01b81526004015f60405180830381865afa158015610845573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405261086c9190810190611e99565b60405160200161087c9190611f2a565b604051602081830303815290604052905090565b5f61089d565b9392505050565b5f610896836108aa5f5490565b6108b5906001611f6a565b6108cf6108c96805345cdf77eb68f44c5490565b60010190565b6114eb565b5f82602052637f5e9f20600c52335f52816034600c2055815f52602c5160601c337f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560205fa35060015b92915050565b5f61092f565b611579565b5f610896836109456805345cdf77eb68f44c5490565b610950906001611f6a565b61092a6108c95f5490565b335f9081526002602052604090205460ff1615801561098557506001546001600160a01b03163314155b156109a2576040516282b42960e81b815260040160405180910390fd5b60035f9054906101000a90046001600160a01b03166001600160a01b0316633d18b9126040518163ffffffff1660e01b81526004015f604051808303815f875af11580156109f2573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610a199190810190611fdf565b50600354604080516304bb6c9360e21b815290515f926001600160a01b0316916312edb24c91600480830192869291908290030181865afa158015610a60573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610a879190810190612075565b90505f5b8151811015610b0757610aff83610acd30858581518110610aae57610aae612105565b60200260200101516001600160a01b03166115a590919063ffffffff16565b848481518110610adf57610adf612105565b60200260200101516001600160a01b03166115d89092919063ffffffff16565b600101610a8b565b505050565b5f8360601b33602052637f5e9f208117600c526034600c2080546001810115610b4a5780851115610b44576313be252b5f526004601cfd5b84810382555b50506387a211a28117600c526020600c20805480851115610b725763f4d678b85f526004601cfd5b84810382555050835f526020600c208381540181555082602052600c5160601c8160601c7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef602080a3505060019392505050565b5f610bd1565b905090565b610bcc5f6012612119565b5f80610be66107e8565b8051906020012090506040517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f81528160208201527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6604082015246606082015230608082015260a081209250505090565b63409feecd198054600382558015610c8e5760018160011c14303b10610c855763f92ee8a95f526004601cfd5b818160ff1b1b91505b50610c9883611621565b610ccd6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016835f1961166c565b600380546001600160a01b0319166001600160a01b0384161790558015610b07576002815560016020527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2602080a1505050565b5f61091e82610890565b7f0000000000000000000000000000000000000000000000000000000000000000308103610d6057639f03a0265f526004601cfd5b610d69846116ac565b8360601b60601c93506352d1902d6001527f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80602060016004601d895afa5114610dbb576355299b496001526004601dfd5b847fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f38a28490558115610e0557604051828482375f388483885af4610e03573d5f823e3d81fd5b505b50505050565b5f7f0000000000000000000000000000000000000000000000000000000000000000308114610e4157639f03a0265f526004601cfd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc91505090565b5f610bcc63409feecd195460011c90565b6001546001600160a01b03163314610ea3576040516282b42960e81b815260040160405180910390fd5b6001600160a01b0382165f81815260026020908152604091829020805460ff191685151590811790915591519182527f193de8d500b5cb7b720089b258a39e9c1d0b840019a73ae7c51c3f9101732b02910160405180910390a25050565b335f9081526002602052604090205460ff16158015610f2b57506001546001600160a01b03163314155b15610f48576040516282b42960e81b815260040160405180910390fd5b610f7d6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163330846116b7565b60035f9054906101000a90046001600160a01b03166001600160a01b031663298360a96040518163ffffffff1660e01b81526004015f604051808303815f87803b158015610fc9575f80fd5b505af1158015610fdb573d5f803e3d5ffd5b50506003546040516317b18c8960e01b8152600481018590525f60248201526001600160a01b0390911692506317b18c8991506044015f604051808303815f87803b158015611028575f80fd5b505af115801561103a573d5f803e3d5ffd5b50505f80549093019092555050565b5f6110538361146c565b905061091e33838584611718565b6001546001600160a01b0316331461108b576040516282b42960e81b815260040160405180910390fd5b6003546001600160a01b0316156110d6576003546110d6906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811691165f61166c565b61110b6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016825f1961166c565b600380546001600160a01b0319166001600160a01b0383169081179091556040519081527f8c4817d5539aae7173c3c7db99c99c5533c0b4047930a875b721aa113774fb689060200160405180910390a150565b5f611169836111ee565b905061091e33838386611718565b5f6387a211a2600c52335f526020600c2080548084111561119f5763f4d678b85f526004601cfd5b83810382555050825f526020600c208281540181555081602052600c5160601c337fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef602080a350600192915050565b5f80610896836111fc5f5490565b611207906001611f6a565b61092a6108c96805345cdf77eb68f44c5490565b5f611225826112b4565b8411156112395761123963936941fc61170f565b61124284610924565b90506108963384848785611731565b5f61125b82611453565b84111561126f5761126f634656425a61170f565b61127884610d21565b90506108963384848488611731565b5f806108968361129e6805345cdf77eb68f44c5490565b6112a9906001611f6a565b6108cf6108c95f5490565b6387a211a2600c9081525f82815260209091205461091e90610890565b5f6112da6107e8565b805190602001209050844211156112f857631a15a3cc5f526004601cfd5b6040518860601b60601c98508760601b60601c975065383775081901600e52885f526020600c2080547f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f83528360208401527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6604084015246606084015230608084015260a08320602e527f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c983528a60208401528960408401528860608401528060808401528760a084015260c08320604e526042602c205f528660ff16602052856040528460605260208060805f60015afa8b3d51146114005763ddafbaef5f526004601cfd5b0190556303faf4f960a51b88176040526034602c2087905587897f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925602060608501a360405250505f606052505050505050565b6387a211a2600c9081525f82815260209091205461091e565b5f61091e82611287565b6001546001600160a01b031633146114a0576040516282b42960e81b815260040160405180910390fd5b600180546001600160a01b0319166001600160a01b03831690811790915560405133907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a350565b82820281838583041485151702611572575f198385098181108201900382848609835f0384168285116115255763ae47f7025f526004601cfd5b93849004938382119092035f839003839004600101029203041760026003830281188084028203028084028203028084028203028084028203028084028203028084029091030202610896565b0492915050565b5f6115858484846114eb565b9050818385091561089657600101806108965763ae47f7025f526004601cfd5b5f816014526f70a082310000000000000000000000005f5260208060246010865afa601f3d111660205102905092915050565b81601452806034526fa9059cbb0000000000000000000000005f5260205f604460105f875af13d1560015f51141716611618576390b8ec185f526004601cfd5b5f603452505050565b600180546001600160a01b0319166001600160a01b0383169081179091556040515f907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a350565b81601452806034526f095ea7b30000000000000000000000005f5260205f604460105f875af13d1560015f5114171661161857633e3f8f735f526004601cfd5b6116b461174d565b50565b60405181606052826040528360601b602c526f23b872dd000000000000000000000000600c5260205f6064601c5f895af13d1560015f5114171661170257637939f4245f526004601cfd5b5f60605260405250505050565b805f526004601cfd5b61172484848484611779565b505f805490910190555050565b61173e85858585856117f1565b505f8054919091039055505050565b6001546001600160a01b03163314611777576040516282b42960e81b815260040160405180910390fd5b565b6117a57f00000000000000000000000000000000000000000000000000000000000000008530856116b7565b6117af8382611896565b815f52806020525f1960601c8381168582167fdcbc1c05240f31ff3ad067ef1ee35ce4997762752e3a095284754544f4c709d760405fa350610e058282611912565b826001600160a01b0316856001600160a01b031614611815576118158386836119d7565b61181f8282611a15565b6118298382611b24565b6118547f000000000000000000000000000000000000000000000000000000000000000085846115d8565b815f52806020525f1960601c8381168582168783167ffbde797d201c681b91056529119e0b02407c7bb96a4a2c75c01fc9667232c8db60405fa4505050505050565b6805345cdf77eb68f44c54818101818110156118b95763e5cfe9575f526004601cfd5b806805345cdf77eb68f44c5550506387a211a2600c52815f526020600c208181540181555080602052600c5160601c5f7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef602080a35050565b60035f9054906101000a90046001600160a01b03166001600160a01b031663298360a96040518163ffffffff1660e01b81526004015f604051808303815f87803b15801561195e575f80fd5b505af1158015611970573d5f803e3d5ffd5b50506003546040516317b18c8960e01b8152600481018690525f60248201526001600160a01b0390911692506317b18c8991506044015f604051808303815f87803b1580156119bd575f80fd5b505af11580156119cf573d5f803e3d5ffd5b505050505050565b81602052637f5e9f20600c52825f526034600c2080546001810115610e035780831115611a0b576313be252b5f526004601cfd5b9190910390555050565b60035f9054906101000a90046001600160a01b03166001600160a01b031663298360a96040518163ffffffff1660e01b81526004015f604051808303815f87803b158015611a61575f80fd5b505af1158015611a73573d5f803e3d5ffd5b505050505f82611ab5307f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166115a590919063ffffffff16565b611abf9190612132565b6003546040516317b18c8960e01b8152600481018390525f60248201529192506001600160a01b0316906317b18c89906044015f604051808303815f87803b158015611b09575f80fd5b505af1158015611b1b573d5f803e3d5ffd5b50505050505050565b6387a211a2600c52815f526020600c20805480831115611b4b5763f4d678b85f526004601cfd5b82900390556805345cdf77eb68f44c805482900390555f8181526001600160a01b0383167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef602083a35050565b5f5b83811015611bb2578181015183820152602001611b9a565b50505f910152565b602081525f8251806020840152611bd8816040850160208701611b98565b601f01601f19169190910160400192915050565b5f60208284031215611bfc575f80fd5b5035919050565b6001600160a01b03811681146116b4575f80fd5b5f8060408385031215611c28575f80fd5b8235611c3381611c03565b946020939093013593505050565b5f60208284031215611c51575f80fd5b813561089681611c03565b5f805f60608486031215611c6e575f80fd5b8335611c7981611c03565b92506020840135611c8981611c03565b929592945050506040919091013590565b5f8060408385031215611cab575f80fd5b8235611cb681611c03565b91506020830135611cc681611c03565b809150509250929050565b5f805f60408486031215611ce3575f80fd5b8335611cee81611c03565b9250602084013567ffffffffffffffff811115611d09575f80fd5b8401601f81018613611d19575f80fd5b803567ffffffffffffffff811115611d2f575f80fd5b866020828401011115611d40575f80fd5b939660209190910195509293505050565b5f8060408385031215611d62575f80fd5b8235611d6d81611c03565b915060208301358015158114611cc6575f80fd5b5f8060408385031215611d92575f80fd5b823591506020830135611cc681611c03565b5f805f60608486031215611db6575f80fd5b833592506020840135611dc881611c03565b91506040840135611dd881611c03565b809150509250925092565b5f805f805f805f60e0888a031215611df9575f80fd5b8735611e0481611c03565b96506020880135611e1481611c03565b95506040880135945060608801359350608088013560ff81168114611e37575f80fd5b9699959850939692959460a0840135945060c09093013592915050565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff81118282101715611e9157611e91611e54565b604052919050565b5f60208284031215611ea9575f80fd5b815167ffffffffffffffff811115611ebf575f80fd5b8201601f81018413611ecf575f80fd5b805167ffffffffffffffff811115611ee957611ee9611e54565b611efc601f8201601f1916602001611e68565b818152856020838501011115611f10575f80fd5b611f21826020830160208601611b98565b95945050505050565b644d6167696360d81b81525f8251611f49816005850160208701611b98565b9190910160050192915050565b634e487b7160e01b5f52601160045260245ffd5b8082018082111561091e5761091e611f56565b6001841115611fb457808504811115611f9857611f98611f56565b6001841615611fa657908102905b60019390931c928002611f7d565b935093915050565b5f67ffffffffffffffff821115611fd557611fd5611e54565b5060051b60200190565b5f60208284031215611fef575f80fd5b815167ffffffffffffffff811115612005575f80fd5b8201601f81018413612015575f80fd5b805161202861202382611fbc565b611e68565b8082825260208201915060208360051b850101925086831115612049575f80fd5b6020840193505b8284101561206b578351825260209384019390910190612050565b9695505050505050565b5f60208284031215612085575f80fd5b815167ffffffffffffffff81111561209b575f80fd5b8201601f810184136120ab575f80fd5b80516120b961202382611fbc565b8082825260208201915060208360051b8501019250868311156120da575f80fd5b6020840193505b8284101561206b5783516120f481611c03565b8252602093840193909101906120e1565b634e487b7160e01b5f52603260045260245ffd5b60ff818116838216019081111561091e5761091e611f56565b8181038181111561091e5761091e611f5656fea2646970667358221220914c8e2e218a5dc5e3017f1c9fdedc478cbdb671d50c8e3b9ade750c5d52447b64736f6c634300081a003300000000000000000000000074e852a4f88bfbeff01275bb95d5ed77f2967d12",
  "artifact_path": "MagicKodiakVault.sol",
  "artifact_full_path": "MagicKodiakVault.sol:MagicKodiakVault",
  "standardJsonInput": {
    "language": "Solidity",
    "sources": {
      "src/tokens/MagicKodiakVault.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {UUPSUpgradeable} from \"@solady/utils/UUPSUpgradeable.sol\";\nimport {Initializable} from \"@solady/utils/Initializable.sol\";\nimport {SafeTransferLib} from \"@solady/utils/SafeTransferLib.sol\";\nimport {OwnableOperators} from \"/mixins/OwnableOperators.sol\";\nimport {ERC4626} from \"/tokens/ERC4626.sol\";\nimport {IKodiakVaultV1, IKodiakVaultStaking} from \"/interfaces/IKodiak.sol\";\n\ncontract MagicKodiakVault is ERC4626, OwnableOperators, UUPSUpgradeable, Initializable {\n    using SafeTransferLib for address;\n\n    event LogStakingChanged(address staking);\n    uint256 public constant ZERO_LOCKTIME = 0;\n\n    address private immutable _asset;\n\n    IKodiakVaultStaking public staking;\n\n    constructor(address __asset) {\n        _asset = __asset;\n    }\n\n    function initialize(address _owner, address _staking) public initializer {\n        _initializeOwner(_owner);\n\n        _asset.safeApprove(address(_staking), type(uint256).max);\n        staking = IKodiakVaultStaking(_staking);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Views\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function version() public view returns (uint64) {\n        return _getInitializedVersion();\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return string(abi.encodePacked(\"Magic\", IKodiakVaultV1(_asset).name()));\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return \"MagicKodiak Vault\";\n    }\n\n    function asset() public view virtual override returns (address) {\n        return _asset;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Operators\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function harvest(address harvester) external onlyOperators {\n        staking.getReward();\n\n        address[] memory rewards = staking.getAllRewardTokens();\n        for (uint256 i = 0; i < rewards.length; i++) {\n            rewards[i].safeTransfer(harvester, rewards[i].balanceOf(address(this)));\n        }\n    }\n\n    function distributeRewards(uint256 amount) external onlyOperators {\n        _asset.safeTransferFrom(msg.sender, address(this), amount);\n        staking.withdrawLockedAll();\n        staking.stakeLocked(amount, ZERO_LOCKTIME);\n\n        unchecked {\n            _totalAssets += amount;\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Admin\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function setStaking(IKodiakVaultStaking _staking) external onlyOwner {\n        if (address(staking) != address(0)) {\n            _asset.safeApprove(address(staking), 0);\n        }\n\n        _asset.safeApprove(address(_staking), type(uint256).max);\n\n        staking = _staking;\n        emit LogStakingChanged(address(_staking));\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Internals\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function _afterDeposit(uint256 assets, uint256 /* shares */) internal override {\n        staking.withdrawLockedAll();\n        staking.stakeLocked(assets, ZERO_LOCKTIME);\n    }\n\n    function _beforeWithdraw(uint256 assets, uint256 /* shares */) internal override {\n        staking.withdrawLockedAll();\n        uint amount = _asset.balanceOf(address(this)) - assets;\n        staking.stakeLocked(amount, ZERO_LOCKTIME);\n    }\n\n    function _authorizeUpgrade(address /*newImplementation*/) internal virtual override {\n        _checkOwner();\n    }\n}\n"
      },
      "lib/solady/src/utils/UUPSUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice UUPS proxy mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/UUPSUpgradeable.sol)\n/// @author Modified from OpenZeppelin\n/// (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/utils/UUPSUpgradeable.sol)\n///\n/// @dev Note:\n/// - This implementation is intended to be used with ERC1967 proxies.\n/// See: `LibClone.deployERC1967` and related functions.\n/// - This implementation is NOT compatible with legacy OpenZeppelin proxies\n/// which do not store the implementation at `_ERC1967_IMPLEMENTATION_SLOT`.\nabstract contract UUPSUpgradeable {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The upgrade failed.\n    error UpgradeFailed();\n\n    /// @dev The call is from an unauthorized call context.\n    error UnauthorizedCallContext();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         IMMUTABLES                         */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev For checking if the context is a delegate call.\n    uint256 private immutable __self = uint256(uint160(address(this)));\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                           EVENTS                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Emitted when the proxy's implementation is upgraded.\n    event Upgraded(address indexed implementation);\n\n    /// @dev `keccak256(bytes(\"Upgraded(address)\"))`.\n    uint256 private constant _UPGRADED_EVENT_SIGNATURE =\n        0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          STORAGE                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The ERC-1967 storage slot for the implementation in the proxy.\n    /// `uint256(keccak256(\"eip1967.proxy.implementation\")) - 1`.\n    bytes32 internal constant _ERC1967_IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      UUPS OPERATIONS                       */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Please override this function to check if `msg.sender` is authorized\n    /// to upgrade the proxy to `newImplementation`, reverting if not.\n    /// ```\n    ///     function _authorizeUpgrade(address) internal override onlyOwner {}\n    /// ```\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /// @dev Returns the storage slot used by the implementation,\n    /// as specified in [ERC1822](https://eips.ethereum.org/EIPS/eip-1822).\n    ///\n    /// Note: The `notDelegated` modifier prevents accidental upgrades to\n    /// an implementation that is a proxy contract.\n    function proxiableUUID() public view virtual notDelegated returns (bytes32) {\n        // This function must always return `_ERC1967_IMPLEMENTATION_SLOT` to comply with ERC1967.\n        return _ERC1967_IMPLEMENTATION_SLOT;\n    }\n\n    /// @dev Upgrades the proxy's implementation to `newImplementation`.\n    /// Emits a {Upgraded} event.\n    ///\n    /// Note: Passing in empty `data` skips the delegatecall to `newImplementation`.\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        /// @solidity memory-safe-assembly\n        assembly {\n            newImplementation := shr(96, shl(96, newImplementation)) // Clears upper 96 bits.\n            mstore(0x01, 0x52d1902d) // `proxiableUUID()`.\n            let s := _ERC1967_IMPLEMENTATION_SLOT\n            // Check if `newImplementation` implements `proxiableUUID` correctly.\n            if iszero(eq(mload(staticcall(gas(), newImplementation, 0x1d, 0x04, 0x01, 0x20)), s)) {\n                mstore(0x01, 0x55299b49) // `UpgradeFailed()`.\n                revert(0x1d, 0x04)\n            }\n            // Emit the {Upgraded} event.\n            log2(codesize(), 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\n            sstore(s, newImplementation) // Updates the implementation.\n\n            // Perform a delegatecall to `newImplementation` if `data` is non-empty.\n            if data.length {\n                // Forwards the `data` to `newImplementation` via delegatecall.\n                let m := mload(0x40)\n                calldatacopy(m, data.offset, data.length)\n                if iszero(delegatecall(gas(), newImplementation, m, data.length, codesize(), 0x00))\n                {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n        }\n    }\n\n    /// @dev Requires that the execution is performed through a proxy.\n    modifier onlyProxy() {\n        uint256 s = __self;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // To enable use cases with an immutable default implementation in the bytecode,\n            // (see: ERC6551Proxy), we don't require that the proxy address must match the\n            // value stored in the implementation slot, which may not be initialized.\n            if eq(s, address()) {\n                mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }\n\n    /// @dev Requires that the execution is NOT performed via delegatecall.\n    /// This is the opposite of `onlyProxy`.\n    modifier notDelegated() {\n        uint256 s = __self;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(s, address())) {\n                mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }\n}\n"
      },
      "lib/solady/src/utils/Initializable.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Initializable mixin for the upgradeable contracts.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Initializable.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/proxy/utils/Initializable.sol)\nabstract contract Initializable {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The contract is already initialized.\n    error InvalidInitialization();\n\n    /// @dev The contract is not initializing.\n    error NotInitializing();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                           EVENTS                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Triggered when the contract has been initialized.\n    event Initialized(uint64 version);\n\n    /// @dev `keccak256(bytes(\"Initialized(uint64)\"))`.\n    bytes32 private constant _INTIALIZED_EVENT_SIGNATURE =\n        0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          STORAGE                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The default initializable slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_INITIALIZABLE_SLOT\")))))`.\n    ///\n    /// Bits Layout:\n    /// - [0]     `initializing`\n    /// - [1..64] `initializedVersion`\n    bytes32 private constant _INITIALIZABLE_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffbf601132;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         OPERATIONS                         */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Override to return a custom storage slot if required.\n    function _initializableSlot() internal pure virtual returns (bytes32) {\n        return _INITIALIZABLE_SLOT;\n    }\n\n    /// @dev Guards an initializer function so that it can be invoked at most once.\n    ///\n    /// You can guard a function with `onlyInitializing` such that it can be called\n    /// through a function guarded with `initializer`.\n    ///\n    /// This is similar to `reinitializer(1)`, except that in the context of a constructor,\n    /// an `initializer` guarded function can be invoked multiple times.\n    /// This can be useful during testing and is not expected to be used in production.\n    ///\n    /// Emits an {Initialized} event.\n    modifier initializer() virtual {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let i := sload(s)\n            // Set `initializing` to 1, `initializedVersion` to 1.\n            sstore(s, 3)\n            // If `!(initializing == 0 && initializedVersion == 0)`.\n            if i {\n                // If `!(address(this).code.length == 0 && initializedVersion == 1)`.\n                if iszero(lt(extcodesize(address()), eq(shr(1, i), 1))) {\n                    mstore(0x00, 0xf92ee8a9) // `InvalidInitialization()`.\n                    revert(0x1c, 0x04)\n                }\n                s := shl(shl(255, i), s) // Skip initializing if `initializing == 1`.\n            }\n        }\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if s {\n                // Set `initializing` to 0, `initializedVersion` to 1.\n                sstore(s, 2)\n                // Emit the {Initialized} event.\n                mstore(0x20, 1)\n                log1(0x20, 0x20, _INTIALIZED_EVENT_SIGNATURE)\n            }\n        }\n    }\n\n    /// @dev Guards an reinitialzer function so that it can be invoked at most once.\n    ///\n    /// You can guard a function with `onlyInitializing` such that it can be called\n    /// through a function guarded with `reinitializer`.\n    ///\n    /// Emits an {Initialized} event.\n    modifier reinitializer(uint64 version) virtual {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            version := and(version, 0xffffffffffffffff) // Clean upper bits.\n            let i := sload(s)\n            // If `initializing == 1 || initializedVersion >= version`.\n            if iszero(lt(and(i, 1), lt(shr(1, i), version))) {\n                mstore(0x00, 0xf92ee8a9) // `InvalidInitialization()`.\n                revert(0x1c, 0x04)\n            }\n            // Set `initializing` to 1, `initializedVersion` to `version`.\n            sstore(s, or(1, shl(1, version)))\n        }\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Set `initializing` to 0, `initializedVersion` to `version`.\n            sstore(s, shl(1, version))\n            // Emit the {Initialized} event.\n            mstore(0x20, version)\n            log1(0x20, 0x20, _INTIALIZED_EVENT_SIGNATURE)\n        }\n    }\n\n    /// @dev Guards a function such that it can only be called in the scope\n    /// of a function guarded with `initializer` or `reinitializer`.\n    modifier onlyInitializing() virtual {\n        _checkInitializing();\n        _;\n    }\n\n    /// @dev Reverts if the contract is not initializing.\n    function _checkInitializing() internal view virtual {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(and(1, sload(s))) {\n                mstore(0x00, 0xd7e6bcf8) // `NotInitializing()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Locks any future initializations by setting the initialized version to `2**64 - 1`.\n    ///\n    /// Calling this in the constructor will prevent the contract from being initialized\n    /// or reinitialized. It is recommended to use this to lock implementation contracts\n    /// that are designed to be called through proxies.\n    ///\n    /// Emits an {Initialized} event the first time it is successfully called.\n    function _disableInitializers() internal virtual {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let i := sload(s)\n            if and(i, 1) {\n                mstore(0x00, 0xf92ee8a9) // `InvalidInitialization()`.\n                revert(0x1c, 0x04)\n            }\n            let uint64max := shr(192, s) // Computed to save bytecode.\n            if iszero(eq(shr(1, i), uint64max)) {\n                // Set `initializing` to 0, `initializedVersion` to `2**64 - 1`.\n                sstore(s, shl(1, uint64max))\n                // Emit the {Initialized} event.\n                mstore(0x20, uint64max)\n                log1(0x20, 0x20, _INTIALIZED_EVENT_SIGNATURE)\n            }\n        }\n    }\n\n    /// @dev Returns the highest version that has been initialized.\n    function _getInitializedVersion() internal view virtual returns (uint64 version) {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            version := shr(1, sload(s))\n        }\n    }\n\n    /// @dev Returns whether the contract is currently initializing.\n    function _isInitializing() internal view virtual returns (bool result) {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(1, sload(s))\n        }\n    }\n}\n"
      },
      "lib/solady/src/utils/SafeTransferLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\n/// - For ERC20s, this implementation won't check that a token has code,\n///   responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The Permit2 operation has failed.\n    error Permit2Failed();\n\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\n    error Permit2AmountOverflow();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\n\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// @dev The canonical Permit2 address.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success :=\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x34, 0) // Store 0 for the `amount`.\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                mstore(0x34, amount) // Store back the original `amount`.\n                // Retry the approval, reverting upon failure.\n                if iszero(\n                    and(\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    )\n                ) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\n    /// Reverts upon failure.\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }\n\n    /// @dev Permit a user to spend a given amount of\n    /// another user's tokens via native EIP-2612 permit if possible, falling\n    /// back to Permit2 if native permit fails or is not implemented on the token.\n    function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `1` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Simple permit on the Permit2 contract.\n    function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"
      },
      "src/mixins/OwnableOperators.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/// @title OwnableOperators\n/// @dev must call `_initializeOwner` to initialize owner\ncontract OwnableOperators {\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n    event OperatorChanged(address indexed, bool);\n\n    error Unauthorized();\n\n    address public owner;\n    mapping(address => bool) public operators;\n\n    modifier onlyOwner() virtual {\n        if(msg.sender != owner) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    modifier onlyOperators() {\n        if (!operators[msg.sender] && msg.sender != owner) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// Admin\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function setOperator(address operator, bool enable) external onlyOwner {\n        operators[operator] = enable;\n        emit OperatorChanged(operator, enable);\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        owner = newOwner;\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// Internals\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _initializeOwner(address _owner) internal {\n        owner = _owner;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function _checkOwner() internal view {\n        if (msg.sender != owner) {\n            revert Unauthorized();\n        }\n    }\n}\n"
      },
      "src/tokens/ERC4626.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\nimport {IERC20Metadata} from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\nimport {ERC4626 as BaseERC4626} from \"@solady/tokens/ERC4626.sol\";\n\nabstract contract ERC4626 is BaseERC4626 {\n    uint256 public _totalAssets;\n\n    function totalAssets() public view override returns (uint256) {\n        return _totalAssets;\n    }\n\n    function _deposit(address by, address to, uint256 assets, uint256 shares) internal virtual override {\n        super._deposit(by, to, assets, shares);\n        unchecked {\n            _totalAssets += assets;\n        }\n    }\n\n    function _withdraw(address by, address to, address owner, uint256 assets, uint256 shares) internal virtual override {\n        super._withdraw(by, to, owner, assets, shares);\n        unchecked {\n            _totalAssets -= assets;\n        }\n    }\n\n    function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual override {}\n\n    function _afterDeposit(uint256 assets, uint256 shares) internal virtual override {}\n}\n"
      },
      "src/interfaces/IKodiak.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\ninterface IKodiakVaultV1 {\n    function name() external view returns (string memory);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function totalSupply() external view returns (uint256);\n\n    function getUnderlyingBalancesAtPrice(uint160 sqrtRatioX96) external view returns (uint256 amount0Current, uint256 amount1Current);\n\n    function getUnderlyingBalances() external view returns (uint256 amount0Current, uint256 amount1Current);\n}\n\ninterface IKodiakVaultStaking {\n    function earned(address account) external view returns (uint256[] memory new_earned);\n\n    function emergencyWithdraw(bytes32 kek_id) external;\n\n    function getAllRewardTokens() external view returns (address[] memory);\n\n    function rewardTokens(uint i) external view returns (address);\n\n    function getReward() external returns (uint256[] memory);\n\n    function rewardsPerToken() external view returns (uint256[] memory newRewardsPerTokenStored);\n\n    function stakeLocked(uint256 liquidity, uint256 secs) external;\n\n    function withdrawLockedAll() external;\n}\n\ninterface IKodiakV1RouterStaking {\n    function addLiquidity(\n        IKodiakVaultV1 pool,\n        uint256 amount0Max,\n        uint256 amount1Max,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        uint256 amountSharesMin,\n        address receiver\n    ) external returns (uint256 amount0, uint256 amount1, uint256 mintAmount);\n\n    function addLiquidityETH(\n        IKodiakVaultV1 pool,\n        uint256 amount0Max,\n        uint256 amount1Max,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        uint256 amountSharesMin,\n        address receiver\n    ) external payable returns (uint256 amount0, uint256 amount1, uint256 mintAmount);\n\n    function removeLiquidity(\n        IKodiakVaultV1 pool,\n        uint256 burnAmount,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        address receiver\n    ) external returns (uint256 amount0, uint256 amount1, uint128 liquidityBurned);\n\n    function removeLiquidityETH(\n        IKodiakVaultV1 pool,\n        uint256 burnAmount,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        address payable receiver\n    ) external returns (uint256 amount0, uint256 amount1, uint128 liquidityBurned);\n}\n"
      },
      "lib/openzeppelin-contracts/contracts/interfaces/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n"
      },
      "lib/solady/src/tokens/ERC4626.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {ERC20} from \"./ERC20.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\n/// @notice Simple ERC4626 tokenized Vault implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC4626.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The default underlying decimals.\n    uint8 internal constant _DEFAULT_UNDERLYING_DECIMALS = 18;\n\n    /// @dev The default decimals offset.\n    uint8 internal constant _DEFAULT_DECIMALS_OFFSET = 0;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Cannot deposit more than the max limit.\n    error DepositMoreThanMax();\n\n    /// @dev Cannot mint more than the max limit.\n    error MintMoreThanMax();\n\n    /// @dev Cannot withdraw more than the max limit.\n    error WithdrawMoreThanMax();\n\n    /// @dev Cannot redeem more than the max limit.\n    error RedeemMoreThanMax();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                           EVENTS                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Emitted during a mint call or deposit call.\n    event Deposit(address indexed by, address indexed owner, uint256 assets, uint256 shares);\n\n    /// @dev Emitted during a withdraw call or redeem call.\n    event Withdraw(\n        address indexed by,\n        address indexed to,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @dev `keccak256(bytes(\"Deposit(address,address,uint256,uint256)\"))`.\n    uint256 private constant _DEPOSIT_EVENT_SIGNATURE =\n        0xdcbc1c05240f31ff3ad067ef1ee35ce4997762752e3a095284754544f4c709d7;\n\n    /// @dev `keccak256(bytes(\"Withdraw(address,address,address,uint256,uint256)\"))`.\n    uint256 private constant _WITHDRAW_EVENT_SIGNATURE =\n        0xfbde797d201c681b91056529119e0b02407c7bb96a4a2c75c01fc9667232c8db;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                     ERC4626 CONSTANTS                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev To be overridden to return the address of the underlying asset.\n    ///\n    /// - MUST be an ERC20 token contract.\n    /// - MUST NOT revert.\n    function asset() public view virtual returns (address);\n\n    /// @dev To be overridden to return the number of decimals of the underlying asset.\n    /// Default: 18.\n    ///\n    /// - MUST NOT revert.\n    function _underlyingDecimals() internal view virtual returns (uint8) {\n        return _DEFAULT_UNDERLYING_DECIMALS;\n    }\n\n    /// @dev Override to return a non-zero value to make the inflation attack even more unfeasible.\n    /// Only used when {_useVirtualShares} returns true.\n    /// Default: 0.\n    ///\n    /// - MUST NOT revert.\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return _DEFAULT_DECIMALS_OFFSET;\n    }\n\n    /// @dev Returns whether virtual shares will be used to mitigate the inflation attack.\n    /// See: https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3706\n    /// Override to return true or false.\n    /// Default: true.\n    ///\n    /// - MUST NOT revert.\n    function _useVirtualShares() internal view virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Returns the decimals places of the token.\n    ///\n    /// - MUST NOT revert.\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        if (!_useVirtualShares()) return _underlyingDecimals();\n        return _underlyingDecimals() + _decimalsOffset();\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                ASSET DECIMALS GETTER HELPER                */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Helper function to get the decimals of the underlying asset.\n    /// Useful for setting the return value of `_underlyingDecimals` during initialization.\n    /// If the retrieval succeeds, `success` will be true, and `result` will hold the result.\n    /// Otherwise, `success` will be false, and `result` will be zero.\n    ///\n    /// Example usage:\n    /// ```\n    /// (bool success, uint8 result) = _tryGetAssetDecimals(underlying);\n    /// _decimals = success ? result : _DEFAULT_UNDERLYING_DECIMALS;\n    /// ```\n    function _tryGetAssetDecimals(address underlying)\n        internal\n        view\n        returns (bool success, uint8 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the function selector of `decimals()`.\n            mstore(0x00, 0x313ce567)\n            // Arguments are evaluated last to first.\n            success :=\n                and(\n                    // Returned value is less than 256, at left-padded to 32 bytes.\n                    and(lt(mload(0x00), 0x100), gt(returndatasize(), 0x1f)),\n                    // The staticcall succeeds.\n                    staticcall(gas(), underlying, 0x1c, 0x04, 0x00, 0x20)\n                )\n            result := mul(mload(0x00), success)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      ACCOUNTING LOGIC                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the total amount of the underlying asset managed by the Vault.\n    ///\n    /// - SHOULD include any compounding that occurs from the yield.\n    /// - MUST be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT revert.\n    function totalAssets() public view virtual returns (uint256 assets) {\n        assets = SafeTransferLib.balanceOf(asset(), address(this));\n    }\n\n    /// @dev Returns the amount of shares that the Vault will exchange for the amount of\n    /// assets provided, in an ideal scenario where all conditions are met.\n    ///\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT show any variations depending on the caller.\n    /// - MUST NOT reflect slippage or other on-chain conditions, during the actual exchange.\n    /// - MUST NOT revert.\n    ///\n    /// Note: This calculation MAY NOT reflect the \"per-user\" price-per-share, and instead\n    /// should reflect the \"average-user's\" price-per-share, i.e. what the average user should\n    /// expect to see when exchanging to and from.\n    function convertToShares(uint256 assets) public view virtual returns (uint256 shares) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return _eitherIsZero(assets, supply)\n                ? _initialConvertToShares(assets)\n                : FixedPointMathLib.fullMulDiv(assets, supply, totalAssets());\n        }\n        uint256 o = _decimalsOffset();\n        if (o == uint256(0)) {\n            return FixedPointMathLib.fullMulDiv(assets, totalSupply() + 1, _inc(totalAssets()));\n        }\n        return FixedPointMathLib.fullMulDiv(assets, totalSupply() + 10 ** o, _inc(totalAssets()));\n    }\n\n    /// @dev Returns the amount of assets that the Vault will exchange for the amount of\n    /// shares provided, in an ideal scenario where all conditions are met.\n    ///\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT show any variations depending on the caller.\n    /// - MUST NOT reflect slippage or other on-chain conditions, during the actual exchange.\n    /// - MUST NOT revert.\n    ///\n    /// Note: This calculation MAY NOT reflect the \"per-user\" price-per-share, and instead\n    /// should reflect the \"average-user's\" price-per-share, i.e. what the average user should\n    /// expect to see when exchanging to and from.\n    function convertToAssets(uint256 shares) public view virtual returns (uint256 assets) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return supply == uint256(0)\n                ? _initialConvertToAssets(shares)\n                : FixedPointMathLib.fullMulDiv(shares, totalAssets(), supply);\n        }\n        uint256 o = _decimalsOffset();\n        if (o == uint256(0)) {\n            return FixedPointMathLib.fullMulDiv(shares, totalAssets() + 1, _inc(totalSupply()));\n        }\n        return FixedPointMathLib.fullMulDiv(shares, totalAssets() + 1, totalSupply() + 10 ** o);\n    }\n\n    /// @dev Allows an on-chain or off-chain user to simulate the effects of their deposit\n    /// at the current block, given current on-chain conditions.\n    ///\n    /// - MUST return as close to and no more than the exact amount of Vault shares that\n    ///   will be minted in a deposit call in the same transaction, i.e. deposit should\n    ///   return the same or more shares as `previewDeposit` if call in the same transaction.\n    /// - MUST NOT account for deposit limits like those returned from `maxDeposit` and should\n    ///   always act as if the deposit will be accepted, regardless of approvals, etc.\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of this.\n    /// - MUST not revert.\n    ///\n    /// Note: Any unfavorable discrepancy between `convertToShares` and `previewDeposit` SHOULD\n    /// be considered slippage in share price or some other type of condition, meaning\n    /// the depositor will lose assets by depositing.\n    function previewDeposit(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = convertToShares(assets);\n    }\n\n    /// @dev Allows an on-chain or off-chain user to simulate the effects of their mint\n    /// at the current block, given current on-chain conditions.\n    ///\n    /// - MUST return as close to and no fewer than the exact amount of assets that\n    ///   will be deposited in a mint call in the same transaction, i.e. mint should\n    ///   return the same or fewer assets as `previewMint` if called in the same transaction.\n    /// - MUST NOT account for mint limits like those returned from `maxMint` and should\n    ///   always act as if the mint will be accepted, regardless of approvals, etc.\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of this.\n    /// - MUST not revert.\n    ///\n    /// Note: Any unfavorable discrepancy between `convertToAssets` and `previewMint` SHOULD\n    /// be considered slippage in share price or some other type of condition,\n    /// meaning the depositor will lose assets by minting.\n    function previewMint(uint256 shares) public view virtual returns (uint256 assets) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return supply == uint256(0)\n                ? _initialConvertToAssets(shares)\n                : FixedPointMathLib.fullMulDivUp(shares, totalAssets(), supply);\n        }\n        uint256 o = _decimalsOffset();\n        if (o == uint256(0)) {\n            return FixedPointMathLib.fullMulDivUp(shares, totalAssets() + 1, _inc(totalSupply()));\n        }\n        return FixedPointMathLib.fullMulDivUp(shares, totalAssets() + 1, totalSupply() + 10 ** o);\n    }\n\n    /// @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal\n    /// at the current block, given the current on-chain conditions.\n    ///\n    /// - MUST return as close to and no fewer than the exact amount of Vault shares that\n    ///   will be burned in a withdraw call in the same transaction, i.e. withdraw should\n    ///   return the same or fewer shares as `previewWithdraw` if call in the same transaction.\n    /// - MUST NOT account for withdrawal limits like those returned from `maxWithdraw` and should\n    ///   always act as if the withdrawal will be accepted, regardless of share balance, etc.\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of this.\n    /// - MUST not revert.\n    ///\n    /// Note: Any unfavorable discrepancy between `convertToShares` and `previewWithdraw` SHOULD\n    /// be considered slippage in share price or some other type of condition,\n    /// meaning the depositor will lose assets by depositing.\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256 shares) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return _eitherIsZero(assets, supply)\n                ? _initialConvertToShares(assets)\n                : FixedPointMathLib.fullMulDivUp(assets, supply, totalAssets());\n        }\n        uint256 o = _decimalsOffset();\n        if (o == uint256(0)) {\n            return FixedPointMathLib.fullMulDivUp(assets, totalSupply() + 1, _inc(totalAssets()));\n        }\n        return FixedPointMathLib.fullMulDivUp(assets, totalSupply() + 10 ** o, _inc(totalAssets()));\n    }\n\n    /// @dev Allows an on-chain or off-chain user to simulate the effects of their redemption\n    /// at the current block, given current on-chain conditions.\n    ///\n    /// - MUST return as close to and no more than the exact amount of assets that\n    ///   will be withdrawn in a redeem call in the same transaction, i.e. redeem should\n    ///   return the same or more assets as `previewRedeem` if called in the same transaction.\n    /// - MUST NOT account for redemption limits like those returned from `maxRedeem` and should\n    ///   always act as if the redemption will be accepted, regardless of approvals, etc.\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of this.\n    /// - MUST NOT revert.\n    ///\n    /// Note: Any unfavorable discrepancy between `convertToAssets` and `previewRedeem` SHOULD\n    /// be considered slippage in share price or some other type of condition,\n    /// meaning the depositor will lose assets by depositing.\n    function previewRedeem(uint256 shares) public view virtual returns (uint256 assets) {\n        assets = convertToAssets(shares);\n    }\n\n    /// @dev Private helper to return if either value is zero.\n    function _eitherIsZero(uint256 a, uint256 b) private pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := or(iszero(a), iszero(b))\n        }\n    }\n\n    /// @dev Private helper to return `x + 1` without the overflow check.\n    /// Used for computing the denominator input to `FixedPointMathLib.fullMulDiv(a, b, x + 1)`.\n    /// When `x == type(uint256).max`, we get `x + 1 == 0` (mod 2**256 - 1),\n    /// and `FixedPointMathLib.fullMulDiv` will revert as the denominator is zero.\n    function _inc(uint256 x) private pure returns (uint256) {\n        unchecked {\n            return x + 1;\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*              DEPOSIT / WITHDRAWAL LIMIT LOGIC              */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the maximum amount of the underlying asset that can be deposited\n    /// into the Vault for `to`, via a deposit call.\n    ///\n    /// - MUST return a limited value if `to` is subject to some deposit limit.\n    /// - MUST return `2**256-1` if there is no maximum limit.\n    /// - MUST NOT revert.\n    function maxDeposit(address to) public view virtual returns (uint256 maxAssets) {\n        to = to; // Silence unused variable warning.\n        maxAssets = type(uint256).max;\n    }\n\n    /// @dev Returns the maximum amount of the Vault shares that can be minter for `to`,\n    /// via a mint call.\n    ///\n    /// - MUST return a limited value if `to` is subject to some mint limit.\n    /// - MUST return `2**256-1` if there is no maximum limit.\n    /// - MUST NOT revert.\n    function maxMint(address to) public view virtual returns (uint256 maxShares) {\n        to = to; // Silence unused variable warning.\n        maxShares = type(uint256).max;\n    }\n\n    /// @dev Returns the maximum amount of the underlying asset that can be withdrawn\n    /// from the `owner`'s balance in the Vault, via a withdraw call.\n    ///\n    /// - MUST return a limited value if `owner` is subject to some withdrawal limit or timelock.\n    /// - MUST NOT revert.\n    function maxWithdraw(address owner) public view virtual returns (uint256 maxAssets) {\n        maxAssets = convertToAssets(balanceOf(owner));\n    }\n\n    /// @dev Returns the maximum amount of Vault shares that can be redeemed\n    /// from the `owner`'s balance in the Vault, via a redeem call.\n    ///\n    /// - MUST return a limited value if `owner` is subject to some withdrawal limit or timelock.\n    /// - MUST return `balanceOf(owner)` otherwise.\n    /// - MUST NOT revert.\n    function maxRedeem(address owner) public view virtual returns (uint256 maxShares) {\n        maxShares = balanceOf(owner);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                 DEPOSIT / WITHDRAWAL LOGIC                 */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Mints `shares` Vault shares to `to` by depositing exactly `assets`\n    /// of underlying tokens.\n    ///\n    /// - MUST emit the {Deposit} event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault\n    ///   contract before the deposit execution, and are accounted for during deposit.\n    /// - MUST revert if all of `assets` cannot be deposited, such as due to deposit limit,\n    ///   slippage, insufficient approval, etc.\n    ///\n    /// Note: Most implementations will require pre-approval of the Vault with the\n    /// Vault's underlying `asset` token.\n    function deposit(uint256 assets, address to) public virtual returns (uint256 shares) {\n        if (assets > maxDeposit(to)) _revert(0xb3c61a83); // `DepositMoreThanMax()`.\n        shares = previewDeposit(assets);\n        _deposit(msg.sender, to, assets, shares);\n    }\n\n    /// @dev Mints exactly `shares` Vault shares to `to` by depositing `assets`\n    /// of underlying tokens.\n    ///\n    /// - MUST emit the {Deposit} event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault\n    ///   contract before the mint execution, and are accounted for during mint.\n    /// - MUST revert if all of `shares` cannot be deposited, such as due to deposit limit,\n    ///   slippage, insufficient approval, etc.\n    ///\n    /// Note: Most implementations will require pre-approval of the Vault with the\n    /// Vault's underlying `asset` token.\n    function mint(uint256 shares, address to) public virtual returns (uint256 assets) {\n        if (shares > maxMint(to)) _revert(0x6a695959); // `MintMoreThanMax()`.\n        assets = previewMint(shares);\n        _deposit(msg.sender, to, assets, shares);\n    }\n\n    /// @dev Burns `shares` from `owner` and sends exactly `assets` of underlying tokens to `to`.\n    ///\n    /// - MUST emit the {Withdraw} event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault\n    ///   contract before the withdraw execution, and are accounted for during withdraw.\n    /// - MUST revert if all of `assets` cannot be withdrawn, such as due to withdrawal limit,\n    ///   slippage, insufficient balance, etc.\n    ///\n    /// Note: Some implementations will require pre-requesting to the Vault before a withdrawal\n    /// may be performed. Those methods should be performed separately.\n    function withdraw(uint256 assets, address to, address owner)\n        public\n        virtual\n        returns (uint256 shares)\n    {\n        if (assets > maxWithdraw(owner)) _revert(0x936941fc); // `WithdrawMoreThanMax()`.\n        shares = previewWithdraw(assets);\n        _withdraw(msg.sender, to, owner, assets, shares);\n    }\n\n    /// @dev Burns exactly `shares` from `owner` and sends `assets` of underlying tokens to `to`.\n    ///\n    /// - MUST emit the {Withdraw} event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault\n    ///   contract before the redeem execution, and are accounted for during redeem.\n    /// - MUST revert if all of shares cannot be redeemed, such as due to withdrawal limit,\n    ///   slippage, insufficient balance, etc.\n    ///\n    /// Note: Some implementations will require pre-requesting to the Vault before a redeem\n    /// may be performed. Those methods should be performed separately.\n    function redeem(uint256 shares, address to, address owner)\n        public\n        virtual\n        returns (uint256 assets)\n    {\n        if (shares > maxRedeem(owner)) _revert(0x4656425a); // `RedeemMoreThanMax()`.\n        assets = previewRedeem(shares);\n        _withdraw(msg.sender, to, owner, assets, shares);\n    }\n\n    /// @dev Internal helper for reverting efficiently.\n    function _revert(uint256 s) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, s)\n            revert(0x1c, 0x04)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      INTERNAL HELPERS                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev For deposits and mints.\n    ///\n    /// Emits a {Deposit} event.\n    function _deposit(address by, address to, uint256 assets, uint256 shares) internal virtual {\n        SafeTransferLib.safeTransferFrom(asset(), by, address(this), assets);\n        _mint(to, shares);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Emit the {Deposit} event.\n            mstore(0x00, assets)\n            mstore(0x20, shares)\n            let m := shr(96, not(0))\n            log3(0x00, 0x40, _DEPOSIT_EVENT_SIGNATURE, and(m, by), and(m, to))\n        }\n        _afterDeposit(assets, shares);\n    }\n\n    /// @dev For withdrawals and redemptions.\n    ///\n    /// Emits a {Withdraw} event.\n    function _withdraw(address by, address to, address owner, uint256 assets, uint256 shares)\n        internal\n        virtual\n    {\n        if (by != owner) _spendAllowance(owner, by, shares);\n        _beforeWithdraw(assets, shares);\n        _burn(owner, shares);\n        SafeTransferLib.safeTransfer(asset(), to, assets);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Emit the {Withdraw} event.\n            mstore(0x00, assets)\n            mstore(0x20, shares)\n            let m := shr(96, not(0))\n            log4(0x00, 0x40, _WITHDRAW_EVENT_SIGNATURE, and(m, by), and(m, to), and(m, owner))\n        }\n    }\n\n    /// @dev Internal conversion function (from assets to shares) to apply when the Vault is empty.\n    /// Only used when {_useVirtualShares} returns false.\n    ///\n    /// Note: Make sure to keep this function consistent with {_initialConvertToAssets}\n    /// when overriding it.\n    function _initialConvertToShares(uint256 assets)\n        internal\n        view\n        virtual\n        returns (uint256 shares)\n    {\n        shares = assets;\n    }\n\n    /// @dev Internal conversion function (from shares to assets) to apply when the Vault is empty.\n    /// Only used when {_useVirtualShares} returns false.\n    ///\n    /// Note: Make sure to keep this function consistent with {_initialConvertToShares}\n    /// when overriding it.\n    function _initialConvertToAssets(uint256 shares)\n        internal\n        view\n        virtual\n        returns (uint256 assets)\n    {\n        assets = shares;\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                     HOOKS TO OVERRIDE                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Hook that is called before any withdrawal or redemption.\n    function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    /// @dev Hook that is called after any deposit or mint.\n    function _afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}\n"
      },
      "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
      },
      "lib/solady/src/tokens/ERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple ERC20 + EIP-2612 implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\n///\n/// @dev Note:\n/// - The ERC20 standard allows minting and transferring to and from the zero address,\n///   minting and transferring zero tokens, as well as self-approvals.\n///   For performance, this implementation WILL NOT revert for such actions.\n///   Please add any checks with overrides if desired.\n/// - The `permit` function uses the ecrecover precompile (0x1).\n///\n/// If you are overriding:\n/// - NEVER violate the ERC20 invariant:\n///   the total sum of all balances must be equal to `totalSupply()`.\n/// - Check that the overridden function is actually used in the function you want to\n///   change the behavior of. Much of the code has been manually inlined for performance.\nabstract contract ERC20 {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The total supply has overflowed.\n    error TotalSupplyOverflow();\n\n    /// @dev The allowance has overflowed.\n    error AllowanceOverflow();\n\n    /// @dev The allowance has underflowed.\n    error AllowanceUnderflow();\n\n    /// @dev Insufficient balance.\n    error InsufficientBalance();\n\n    /// @dev Insufficient allowance.\n    error InsufficientAllowance();\n\n    /// @dev The permit is invalid.\n    error InvalidPermit();\n\n    /// @dev The permit has expired.\n    error PermitExpired();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                           EVENTS                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          STORAGE                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The storage slot for the total supply.\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\n\n    /// @dev The balance slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\n\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\n    /// ```\n    ///     mstore(0x20, spender)\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\n    /// ```\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\n\n    /// @dev The nonce slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.\n    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 private constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev `keccak256(\"1\")`.\n    bytes32 private constant _VERSION_HASH =\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    /// @dev `keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")`.\n    bytes32 private constant _PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       ERC20 METADATA                       */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the name of the token.\n    function name() public view virtual returns (string memory);\n\n    /// @dev Returns the symbol of the token.\n    function symbol() public view virtual returns (string memory);\n\n    /// @dev Returns the decimals places of the token.\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                           ERC20                            */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the amount of tokens in existence.\n    function totalSupply() public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_TOTAL_SUPPLY_SLOT)\n        }\n    }\n\n    /// @dev Returns the amount of tokens owned by `owner`.\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n    ///\n    /// Emits a {Approval} event.\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\n        }\n        return true;\n    }\n\n    /// @dev Transfer `amount` tokens from the caller to `to`.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    ///\n    /// Emits a {Transfer} event.\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(msg.sender, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @dev Transfers `amount` tokens from `from` to `to`.\n    ///\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\n    ///\n    /// Emits a {Transfer} event.\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(from, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            // Compute the allowance slot and load its value.\n            mstore(0x20, caller())\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowance_ := sload(allowanceSlot)\n            // If the allowance is not the maximum uint256 value.\n            if add(allowance_, 1) {\n                // Revert if the amount to be transferred exceeds the allowance.\n                if gt(amount, allowance_) {\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated allowance.\n                sstore(allowanceSlot, sub(allowance_, amount))\n            }\n            // Compute the balance slot and load its value.\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(from, to, amount);\n        return true;\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          EIP-2612                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev For more performance, override to return the constant value\n    /// of `keccak256(bytes(name()))` if `name()` will never change.\n    function _constantNameHash() internal view virtual returns (bytes32 result) {}\n\n    /// @dev Returns the current nonce for `owner`.\n    /// This value is used to compute the signature for EIP-2612 permit.\n    function nonces(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the nonce slot and load its value.\n            mstore(0x0c, _NONCES_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\n    /// authorized by a signed approval by `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the block timestamp is greater than `deadline`.\n            if gt(timestamp(), deadline) {\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\n                revert(0x1c, 0x04)\n            }\n            let m := mload(0x40) // Grab the free memory pointer.\n            // Clean the upper 96 bits.\n            owner := shr(96, shl(96, owner))\n            spender := shr(96, shl(96, spender))\n            // Compute the nonce slot and load its value.\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\n            mstore(0x00, owner)\n            let nonceSlot := keccak256(0x0c, 0x20)\n            let nonceValue := sload(nonceSlot)\n            // Prepare the domain separator.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), _VERSION_HASH)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            mstore(0x2e, keccak256(m, 0xa0))\n            // Prepare the struct hash.\n            mstore(m, _PERMIT_TYPEHASH)\n            mstore(add(m, 0x20), owner)\n            mstore(add(m, 0x40), spender)\n            mstore(add(m, 0x60), value)\n            mstore(add(m, 0x80), nonceValue)\n            mstore(add(m, 0xa0), deadline)\n            mstore(0x4e, keccak256(m, 0xc0))\n            // Prepare the ecrecover calldata.\n            mstore(0x00, keccak256(0x2c, 0x42))\n            mstore(0x20, and(0xff, v))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)\n            // If the ecrecover fails, the returndatasize will be 0x00,\n            // `owner` will be checked if it equals the hash at 0x00,\n            // which evaluates to false (i.e. 0), and we will revert.\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\n            // `owner` will be compared against the returned address at 0x20.\n            if iszero(eq(mload(returndatasize()), owner)) {\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\n                revert(0x1c, 0x04)\n            }\n            // Increment and store the updated nonce.\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\n            // Compute the allowance slot and store the value.\n            // The `owner` is already at slot 0x20.\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\n            sstore(keccak256(0x2c, 0x34), value)\n            // Emit the {Approval} event.\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Grab the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), _VERSION_HASH)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                  INTERNAL MINT FUNCTIONS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _mint(address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\n            // Revert if the total supply overflows.\n            if lt(totalSupplyAfter, totalSupplyBefore) {\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(address(0), to, amount);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                  INTERNAL BURN FUNCTIONS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _burn(address from, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, from)\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Subtract and store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\n            // Emit the {Transfer} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\n        }\n        _afterTokenTransfer(from, address(0), amount);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Moves `amount` of tokens from `from` to `to`.\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and load its value.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowance_ := sload(allowanceSlot)\n            // If the allowance is not the maximum uint256 value.\n            if add(allowance_, 1) {\n                // Revert if the amount to be transferred exceeds the allowance.\n                if gt(amount, allowance_) {\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated allowance.\n                sstore(allowanceSlot, sub(allowance_, amount))\n            }\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let owner_ := shl(96, owner)\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                     HOOKS TO OVERRIDE                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Hook that is called before any transfer of tokens.\n    /// This includes minting and burning.\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /// @dev Hook that is called after any transfer of tokens.\n    /// This includes minting and burning.\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
      },
      "lib/solady/src/utils/FixedPointMathLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(y, gt(x, div(not(0), y))) {\n                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(y, gt(x, div(not(0), y))) {\n                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(and(iszero(iszero(y)), eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    /// Note: This function is an approximation.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18)  135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (- ln 2,  ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s  6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            int256 wad = int256(WAD);\n            int256 p = x;\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `result` as `p0` to save gas.\n            result := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(result, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(result, lt(mm, result))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure the result is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    result :=\n                        mul(\n                            // Divide [p1 p0] by the factors of two.\n                            // Shift in bits from `p1` into `p0`. For this we need\n                            // to flip `t` such that it is `2**256 / t`.\n                            or(\n                                mul(sub(p1, gt(r, result)), add(div(sub(0, t), t), 1)),\n                                div(sub(result, r), t)\n                            ),\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                        )\n                    break\n                }\n                result := div(result, d)\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Behavior is undefined if `d` is zero or the final result cannot fit in 256 bits.\n    /// Performs the full 512 bit calculation regardless.\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(result, lt(mm, result)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            result :=\n                mul(\n                    or(mul(sub(p1, gt(r, result)), add(div(sub(0, t), t), 1)), div(sub(result, r), t)),\n                    mul(sub(2, mul(d, inv)), inv)\n                )\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\n        result = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                result := add(result, 1)\n                if iszero(result) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`, rounded down.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, rounded down.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`, rounded down.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`, rounded down.\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { result := mul(result, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards zero.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards negative infinity.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(sar(255, x), add(sar(255, x), x))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(mul(xor(sub(y, x), sub(x, y)), gt(x, y)), sub(y, x))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(mul(xor(sub(y, x), sub(x, y)), sgt(x, y)), sub(y, x))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`,\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (begin > end) {\n            t = ~t;\n            begin = ~begin;\n            end = ~end;\n        }\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`.\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\n        internal\n        pure\n        returns (int256)\n    {\n        if (begin > end) {\n            t = int256(~uint256(t));\n            begin = int256(~uint256(begin));\n            end = int256(~uint256(end));\n        }\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b) - uint256(a),\n                uint256(t) - uint256(begin), uint256(end) - uint256(begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a) - uint256(b),\n                uint256(t) - uint256(begin), uint256(end) - uint256(begin)));\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n"
      },
      "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      }
    },
    "settings": {
      "remappings": [
        "/=src/",
        "forge-std/=lib/forge-std/src/",
        "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
        "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
        "@BoringSolidity/=lib/BoringSolidity/contracts/",
        "@solady/=lib/solady/src/",
        "@solmate/=lib/solmate/src/",
        "@excessivelySafeCall/=lib/ExcessivelySafeCall/src/",
        "@safe-contracts/=lib/safe-contracts/contracts/",
        "@fuzzlib/=lib/fuzzlib/src/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 400
      },
      "metadata": {
        "useLiteralContent": false,
        "bytecodeHash": "ipfs",
        "appendCBOR": true
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "evmVersion": "shanghai",
      "viaIR": false,
      "libraries": {}
    }
  },
  "compiler": "0.8.26+commit.8a97fa7a"
}