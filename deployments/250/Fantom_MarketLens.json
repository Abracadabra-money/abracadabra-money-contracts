{
  "address": "0xd83D745203Eb041396bE5413e1720AaAa536Ed9D",
  "abi": [
    {
      "type": "function",
      "name": "availableSkim",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        }
      ],
      "outputs": [
        {
          "name": "share",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "availableSkim",
      "inputs": [],
      "outputs": [
        {
          "name": "share",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getBorrowFee",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getCollateralPrice",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getHealthFactor",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        },
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "isStable",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getInterestPerYear",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint64",
          "internalType": "uint64"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getLiquidationFee",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getMarketInfoCauldronV2",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "tuple",
          "internalType": "struct MarketLens.MarketInfo",
          "components": [
            {
              "name": "cauldron",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "borrowFee",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "maximumCollateralRatio",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "liquidationFee",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "interestPerYear",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "marketMaxBorrow",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "userMaxBorrow",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "totalBorrow",
              "type": "tuple",
              "internalType": "struct MarketLens.Borrow",
              "components": [
                {
                  "name": "part",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "amount",
                  "type": "uint256",
                  "internalType": "uint256"
                }
              ]
            },
            {
              "name": "oracleExchangeRate",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "collateralPrice",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "totalCollateral",
              "type": "tuple",
              "internalType": "struct MarketLens.Collateral",
              "components": [
                {
                  "name": "token",
                  "type": "address",
                  "internalType": "contract IERC20"
                },
                {
                  "name": "amount",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "share",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "value",
                  "type": "uint256",
                  "internalType": "uint256"
                }
              ]
            }
          ]
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getMarketInfoCauldronV3",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV3"
        }
      ],
      "outputs": [
        {
          "name": "marketInfo",
          "type": "tuple",
          "internalType": "struct MarketLens.MarketInfo",
          "components": [
            {
              "name": "cauldron",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "borrowFee",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "maximumCollateralRatio",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "liquidationFee",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "interestPerYear",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "marketMaxBorrow",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "userMaxBorrow",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "totalBorrow",
              "type": "tuple",
              "internalType": "struct MarketLens.Borrow",
              "components": [
                {
                  "name": "part",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "amount",
                  "type": "uint256",
                  "internalType": "uint256"
                }
              ]
            },
            {
              "name": "oracleExchangeRate",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "collateralPrice",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "totalCollateral",
              "type": "tuple",
              "internalType": "struct MarketLens.Collateral",
              "components": [
                {
                  "name": "token",
                  "type": "address",
                  "internalType": "contract IERC20"
                },
                {
                  "name": "amount",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "share",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "value",
                  "type": "uint256",
                  "internalType": "uint256"
                }
              ]
            }
          ]
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getMaxMarketBorrowForCauldronV2",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getMaxMarketBorrowForCauldronV3",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV3"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getMaxUserBorrowForCauldronV2",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getMaxUserBorrowForCauldronV3",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV3"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getMaximumCollateralRatio",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getOracleExchangeRate",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getTokenInBentoBox",
      "inputs": [
        {
          "name": "bentoBox",
          "type": "address",
          "internalType": "contract IBentoBoxV1"
        },
        {
          "name": "token",
          "type": "address",
          "internalType": "contract IERC20"
        },
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "share",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getTotalBorrowed",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "tuple",
          "internalType": "struct MarketLens.Borrow",
          "components": [
            {
              "name": "part",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "amount",
              "type": "uint256",
              "internalType": "uint256"
            }
          ]
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getTotalCollateral",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "tuple",
          "internalType": "struct MarketLens.Collateral",
          "components": [
            {
              "name": "token",
              "type": "address",
              "internalType": "contract IERC20"
            },
            {
              "name": "amount",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "share",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "value",
              "type": "uint256",
              "internalType": "uint256"
            }
          ]
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getUserBorrow",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        },
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "tuple",
          "internalType": "struct MarketLens.Borrow",
          "components": [
            {
              "name": "part",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "amount",
              "type": "uint256",
              "internalType": "uint256"
            }
          ]
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getUserCollateral",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        },
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "tuple",
          "internalType": "struct MarketLens.Collateral",
          "components": [
            {
              "name": "token",
              "type": "address",
              "internalType": "contract IERC20"
            },
            {
              "name": "amount",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "share",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "value",
              "type": "uint256",
              "internalType": "uint256"
            }
          ]
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getUserLiquidationPrice",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        },
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "liquidationPrice",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getUserLtv",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        },
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "ltvBps",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getUserMaxBorrow",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        },
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getUserPosition",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        },
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "tuple",
          "internalType": "struct MarketLens.UserPosition",
          "components": [
            {
              "name": "cauldron",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "account",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "ltvBps",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "healthFactor",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "borrow",
              "type": "tuple",
              "internalType": "struct MarketLens.Borrow",
              "components": [
                {
                  "name": "part",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "amount",
                  "type": "uint256",
                  "internalType": "uint256"
                }
              ]
            },
            {
              "name": "collateral",
              "type": "tuple",
              "internalType": "struct MarketLens.Collateral",
              "components": [
                {
                  "name": "token",
                  "type": "address",
                  "internalType": "contract IERC20"
                },
                {
                  "name": "amount",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "share",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "value",
                  "type": "uint256",
                  "internalType": "uint256"
                }
              ]
            },
            {
              "name": "liquidationPrice",
              "type": "uint256",
              "internalType": "uint256"
            }
          ]
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getUserPositions",
      "inputs": [
        {
          "name": "cauldron",
          "type": "address",
          "internalType": "contract ICauldronV2"
        },
        {
          "name": "accounts",
          "type": "address[]",
          "internalType": "address[]"
        }
      ],
      "outputs": [
        {
          "name": "positions",
          "type": "tuple[]",
          "internalType": "struct MarketLens.UserPosition[]",
          "components": [
            {
              "name": "cauldron",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "account",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "ltvBps",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "healthFactor",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "borrow",
              "type": "tuple",
              "internalType": "struct MarketLens.Borrow",
              "components": [
                {
                  "name": "part",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "amount",
                  "type": "uint256",
                  "internalType": "uint256"
                }
              ]
            },
            {
              "name": "collateral",
              "type": "tuple",
              "internalType": "struct MarketLens.Collateral",
              "components": [
                {
                  "name": "token",
                  "type": "address",
                  "internalType": "contract IERC20"
                },
                {
                  "name": "amount",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "share",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "value",
                  "type": "uint256",
                  "internalType": "uint256"
                }
              ]
            },
            {
              "name": "liquidationPrice",
              "type": "uint256",
              "internalType": "uint256"
            }
          ]
        }
      ],
      "stateMutability": "view"
    }
  ],
  "bytecode": "0x6080604052348015600f57600080fd5b506125598061001f6000396000f3fe608060405234801561001057600080fd5b50600436106101a35760003560e01c806392a576e6116100ee578063cdb5964411610097578063d963099311610071578063d963099314610379578063dc6f1caa1461038c578063ee3b1eb9146103b4578063f79a987a146103d457600080fd5b8063cdb596441461034b578063d1a840df1461035e578063d33a24911461036657600080fd5b8063a55e8668116100c8578063a55e866814610318578063bbd1b02814610279578063c1cd378f1461032b57600080fd5b806392a576e6146102d25780639406aea1146102f2578063945ebb911461030557600080fd5b806361acf8d51161015057806373d045601161012a57806373d045601461028c578063842126351461029f57806387426a84146102bf57600080fd5b806361acf8d51461025357806364f6ea911461026657806366e3a4541461027957600080fd5b806342d3fd081161018157806342d3fd081461020d57806351a409941461022057806360a98b801461023357600080fd5b80631e713a37146101a85780633548ada0146101ce578063397938dd146101fa575b600080fd5b6101bb6101b6366004611d2d565b6103e7565b6040519081526020015b60405180910390f35b6101e16101dc366004611d66565b610403565b60405167ffffffffffffffff90911681526020016101c5565b6101bb610208366004611d83565b61047c565b6101bb61021b366004611d2d565b6104b2565b6101bb61022e366004611d66565b6104cd565b610246610241366004611d66565b6104de565b6040516101c59190611dd3565b6101bb610261366004611d66565b61071b565b6101bb610274366004611d66565b6107aa565b6101bb610287366004611d66565b6107be565b6101bb61029a366004611d66565b6107c9565b6102b26102ad366004611d66565b61086a565b6040516101c59190611e07565b6101bb6102cd366004611d66565b6108c2565b6102e56102e0366004611d2d565b610941565b6040516101c59190611eb3565b6101bb610300366004611d66565b610a06565b6101bb610313366004611d66565b610a11565b610246610326366004611d2d565b610b2a565b61033e610339366004611d66565b610ba2565b6040516101c59190611ec2565b6102b2610359366004611d2d565b610c5e565b6101bb610c9d565b6101bb610374366004611d2d565b610cad565b61033e610387366004611d66565b610ce8565b61039f61039a366004611f83565b610d1c565b604080519283526020830191909152016101c5565b6103c76103c2366004611fc3565b610e18565b6040516101c5919061204d565b6101bb6103e2366004611d66565b610ed2565b60006103f38383610f19565b50969a9950505050505050505050565b600080826001600160a01b031663b27c0e746040518163ffffffff1660e01b8152600401606060405180830381865afa158015610444573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061046891906120d0565b9250505061047581611094565b9392505050565b6000806104898585610f19565b505050505050509150508261049e57806104a9565b6104a981600a612129565b95945050505050565b60006104be8383610f19565b9b9a5050505050505050505050565b60006104d8826110b0565b92915050565b610512604051806080016040528060006001600160a01b031681526020016000815260200160008152602001600081525090565b6000826001600160a01b0316636b2ace876040518163ffffffff1660e01b8152600401602060405180830381865afa158015610552573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105769190612140565b90506000836001600160a01b031663d8dfeb456040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105dc9190612140565b90506000846001600160a01b031663473e3ce76040518163ffffffff1660e01b8152600401602060405180830381865afa15801561061e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610642919061215d565b604051630acc462360e31b81526001600160a01b03848116600483015260248201839052600060448301819052929350851690635662311890606401602060405180830381865afa15801561069b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106bf919061215d565b905060006106cc87610a06565b6106de670de0b6b3a764000084612129565b6106e8919061218c565b604080516080810182526001600160a01b0390961686526020860193909352918401929092526060830152509392505050565b600080620186a0836001600160a01b0316636ec097fb6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610760573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610784919061215d565b61078e91906121a0565b9050620186a06107a061271083612129565b610475919061218c565b60006104d8826001600160a01b031661114b565b60006104d882611311565b600080826001600160a01b031663e551d11d6040518163ffffffff1660e01b81526004016040805180830381865afa158015610809573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061082d91906121b3565b506001600160801b03169050600061084484611311565b9050600061085e836108558761086a565b602001516114d0565b90506104a982826114ea565b6040805180820190915260008082526020820152600061088983611500565b9050604051806040016040528082602001516001600160801b0316815260200182600001516001600160801b0316815250915050919050565b6000620186a0612710836001600160a01b031663aba024f46040518163ffffffff1660e01b8152600401602060405180830381865afa158015610909573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061092d919061215d565b6109379190612129565b6104d8919061218c565b610949611bca565b60008060008060008060008060006109618c8c610f19565b9850985098509850985098509850985098506040518060e001604052808d6001600160a01b031681526020018c6001600160a01b031681526020018a815260200189815260200160405180604001604052808981526020018a81525081526020016040518060800160405280886001600160a01b0316815260200187815260200186815260200185815250815260200182815250995050505050505050505092915050565b60006104d88261167c565b6000806000836001600160a01b031663e551d11d6040518163ffffffff1660e01b81526004016040805180830381865afa158015610a53573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a7791906121b3565b604080516003808252608082019092526001600160801b03938416955091909216925060009160208201606080368337019050509050610ab685611311565b81600081518110610ac957610ac96121fc565b602002602001018181525050610ae2836108558761086a565b81600181518110610af557610af56121fc565b6020026020010181815250508181600281518110610b1557610b156121fc565b6020026020010181815250506104a9816117bb565b610b5e604051806080016040528060006001600160a01b031681526020016000815260200160008152602001600081525090565b600080600080610b6e8787611838565b604080516080810182526001600160a01b039095168552602085019390935291830152606082015294505050505092915050565b610baa611c66565b604051806101600160405280836001600160a01b03168152602001610bce846108c2565b8152602001610bdc84610ed2565b8152602001610bea8461071b565b8152602001610bf884610403565b67ffffffffffffffff168152602001610c10846107be565b8152602001610c1e846107be565b8152602001610c2c8461086a565b8152602001610c3a84610a06565b8152602001610c48846104cd565b8152602001610c56846104de565b905292915050565b6040805180820190915260008082526020820152600080610c7f8585611a23565b60408051808201909152908152602081019190915295945050505050565b6000610ca83361114b565b905090565b600080610cba8484611838565b9350505050620186a0610ccc85610ed2565b610cd69083612129565b610ce0919061218c565b949350505050565b610cf0611c66565b610cf982610ba2565b9050610d04826107c9565b60a0820152610d1282610a11565b60c0820152919050565b604051633de222bb60e21b81526001600160a01b0383811660048301528281166024830152600091829186169063f7888aec90604401602060405180830381865afa158015610d6f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d93919061215d565b604051630acc462360e31b81526001600160a01b0386811660048301526024820185905260006044830152871690635662311890606401602060405180830381865afa158015610de7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e0b919061215d565b915091505b935093915050565b60608167ffffffffffffffff811115610e3357610e336121e6565b604051908082528060200260200182016040528015610e6c57816020015b610e59611bca565b815260200190600190039081610e515790505b50905060005b82811015610eca57610ea585858584818110610e9057610e906121fc565b90506020020160208101906102e09190611d66565b828281518110610eb757610eb76121fc565b6020908102919091010152600101610e72565b509392505050565b6000620186a0612710836001600160a01b031663c7ee2a7b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610909573d6000803e3d6000fd5b6000806000806000806000806000610f318b8b611838565b92975090955093509150610f458b8b611a23565b909750955081156110875781610f5d61271089612129565b610f67919061218c565b98506000610f7d866001600160a01b0316611afd565b610f8890600a6122f1565b9050670de0b6b3a7640000858d6001600160a01b031663c7ee2a7b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610fd2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ff6919061215d565b6110016002856122f1565b61100b908c612129565b61101890620186a0612129565b611022919061218c565b61102c919061218c565b611036919061218c565b9150611083670de0b6b3a764000061104f6002846122f1565b6110588f61167c565b61106a86670de0b6b3a7640000612129565b6110749190612129565b61107e919061218c565b6114d0565b9850505b9295985092959850929598565b60006312e337ee6110a6836064612300565b6104d89190612323565b600080826001600160a01b031663d8dfeb456040518163ffffffff1660e01b8152600401602060405180830381865afa1580156110f1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111159190612140565b9050600061112b826001600160a01b0316611afd565b61113690600a6122f1565b90506111418461167c565b610cd68280612129565b6000816001600160a01b031663473e3ce76040518163ffffffff1660e01b8152600401602060405180830381865afa15801561118b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111af919061215d565b826001600160a01b0316636b2ace876040518163ffffffff1660e01b8152600401602060405180830381865afa1580156111ed573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112119190612140565b6001600160a01b031663f7888aec846001600160a01b031663d8dfeb456040518163ffffffff1660e01b8152600401602060405180830381865afa15801561125d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112819190612140565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b1681526001600160a01b039091166004820152336024820152604401602060405180830381865afa1580156112e3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611307919061215d565b6104d891906121a0565b600080826001600160a01b0316636b2ace876040518163ffffffff1660e01b8152600401602060405180830381865afa158015611352573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113769190612140565b90506000836001600160a01b0316639b352ae16040518163ffffffff1660e01b8152600401602060405180830381865afa1580156113b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113dc9190612140565b604051633de222bb60e21b81526001600160a01b038083166004830152868116602483015291925060009184169063f7888aec90604401602060405180830381865afa158015611430573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611454919061215d565b604051630acc462360e31b81526001600160a01b038481166004830152602482018390526000604483015291925090841690635662311890606401602060405180830381865afa1580156114ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104a9919061215d565b60008183116114e0576000610475565b61047582846121a0565b60008183106114f95781610475565b5090919050565b6040805180820190915260008082526020820152816001600160a01b0316638285ef406040518163ffffffff1660e01b81526004016040805180830381865afa158015611551573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115759190612384565b9050600080836001600160a01b031663b27c0e746040518163ffffffff1660e01b8152600401606060405180830381865afa1580156115b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115dc91906120d0565b925050915060008267ffffffffffffffff16426115f991906121a0565b90508015801590611616575060208401516001600160801b031615155b1561167457670de0b6b3a7640000818367ffffffffffffffff1686600001516001600160801b03166116489190612129565b6116529190612129565b61165c919061218c565b845161166891906123e1565b6001600160801b031684525b505050919050565b600080826001600160a01b0316637dc0d1d06040518163ffffffff1660e01b8152600401602060405180830381865afa1580156116bd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116e19190612140565b90506000836001600160a01b03166374645ff36040518163ffffffff1660e01b8152600401600060405180830381865afa158015611723573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261174b9190810190612424565b604051630d39bbef60e41b81529091506001600160a01b0383169063d39bbef09061177a9084906004016124b1565b602060405180830381865afa158015611797573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ce0919061215d565b600080826000815181106117d1576117d16121fc565b602002602001015190506000600190505b835181101561183157818482815181106117fe576117fe6121fc565b602002602001015110156118295783818151811061181e5761181e6121fc565b602002602001015191505b6001016117e2565b5092915050565b6000806000806000866001600160a01b0316636b2ace876040518163ffffffff1660e01b8152600401602060405180830381865afa15801561187e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118a29190612140565b604051631c9e379b60e01b81526001600160a01b03888116600483015291925090881690631c9e379b90602401602060405180830381865afa1580156118ec573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611910919061215d565b9250866001600160a01b031663d8dfeb456040518163ffffffff1660e01b8152600401602060405180830381865afa158015611950573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119749190612140565b604051630acc462360e31b81526001600160a01b038083166004830152602482018690526000604483015291965090821690635662311890606401602060405180830381865afa1580156119cc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119f0919061215d565b93506119fb8761167c565b611a0d670de0b6b3a764000086612129565b611a17919061218c565b91505092959194509250565b6000806000611a3185611500565b905080602001516001600160801b0316600003611a55576000809250925050611af6565b6040516324720b1f60e11b81526001600160a01b0385811660048301528616906348e4163e90602401602060405180830381865afa158015611a9b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611abf919061215d565b915080602001516001600160801b031681600001516001600160801b031683611ae89190612129565b611af2919061218c565b9250505b9250929050565b60408051600481526024810182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1663313ce56760e01b1790529051600091829182916001600160a01b03861691611b5891906124e4565b600060405180830381855afa9150503d8060008114611b93576040519150601f19603f3d011682016040523d82523d6000602084013e611b98565b606091505b5091509150818015611bab575080516020145b611bb6576012610ce0565b80806020019051810190610ce09190612500565b6040518060e0016040528060006001600160a01b0316815260200160006001600160a01b031681526020016000815260200160008152602001611c20604051806040016040528060008152602001600081525090565b8152602001611c59604051806080016040528060006001600160a01b031681526020016000815260200160008152602001600081525090565b8152602001600081525090565b60405180610160016040528060006001600160a01b03168152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001611cc9604051806040016040528060008152602001600081525090565b81526020016000815260200160008152602001611d10604051806080016040528060006001600160a01b031681526020016000815260200160008152602001600081525090565b905290565b6001600160a01b0381168114611d2a57600080fd5b50565b60008060408385031215611d4057600080fd5b8235611d4b81611d15565b91506020830135611d5b81611d15565b809150509250929050565b600060208284031215611d7857600080fd5b813561047581611d15565b600080600060608486031215611d9857600080fd5b8335611da381611d15565b92506020840135611db381611d15565b915060408401358015158114611dc857600080fd5b809150509250925092565b81516001600160a01b03168152602080830151908201526040808301519082015260608083015190820152608081016104d8565b8151815260208083015190820152604081016104d8565b6001600160a01b0381511682526001600160a01b03602082015116602083015260408101516040830152606081015160608301526080810151611e6e608084018280518252602090810151910152565b5060a081015180516001600160a01b031660c0840152602081015160e0840152604081015161010084015260608101516101208401525060c001516101409190910152565b61016081016104d88284611e1e565b81516001600160a01b031681526101e081016020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015260c083015160c083015260e0830151611f2c60e084018280518252602090810151910152565b506101008301516101208301526101208301516101408301526101408301516118316101608401826001600160a01b0381511682526020810151602083015260408101516040830152606081015160608301525050565b600080600060608486031215611f9857600080fd5b8335611fa381611d15565b92506020840135611fb381611d15565b91506040840135611dc881611d15565b600080600060408486031215611fd857600080fd5b8335611fe381611d15565b9250602084013567ffffffffffffffff811115611fff57600080fd5b8401601f8101861361201057600080fd5b803567ffffffffffffffff81111561202757600080fd5b8660208260051b840101111561203c57600080fd5b939660209190910195509293505050565b602080825282518282018190526000918401906040840190835b818110156120915761207a838551611e1e565b602093909301926101609290920191600101612067565b509095945050505050565b805167ffffffffffffffff811681146120b457600080fd5b919050565b80516001600160801b03811681146120b457600080fd5b6000806000606084860312156120e557600080fd5b6120ee8461209c565b92506120fc602085016120b9565b915061210a6040850161209c565b90509250925092565b634e487b7160e01b600052601160045260246000fd5b80820281158282048414176104d8576104d8612113565b60006020828403121561215257600080fd5b815161047581611d15565b60006020828403121561216f57600080fd5b5051919050565b634e487b7160e01b600052601260045260246000fd5b60008261219b5761219b612176565b500490565b818103818111156104d8576104d8612113565b600080604083850312156121c657600080fd5b6121cf836120b9565b91506121dd602084016120b9565b90509250929050565b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b6001815b6001841115610e105780850481111561223157612231612113565b600184161561223f57908102905b60019390931c928002612216565b60008261225c575060016104d8565b81612269575060006104d8565b816001811461227f5760028114612289576122a5565b60019150506104d8565b60ff84111561229a5761229a612113565b50506001821b6104d8565b5060208310610133831016604e8410600b84101617156122c8575081810a6104d8565b6122d56000198484612212565b80600019048211156122e9576122e9612113565b029392505050565b600061047560ff84168361224d565b67ffffffffffffffff818116838216029081169081811461183157611831612113565b600067ffffffffffffffff83168061233d5761233d612176565b8067ffffffffffffffff84160491505092915050565b604051601f8201601f1916810167ffffffffffffffff8111828210171561237c5761237c6121e6565b604052919050565b6000604082840312801561239757600080fd5b506040805190810167ffffffffffffffff811182821017156123bb576123bb6121e6565b6040526123c7836120b9565b81526123d5602084016120b9565b60208201529392505050565b6001600160801b0381811683821601908111156104d8576104d8612113565b60005b8381101561241b578181015183820152602001612403565b50506000910152565b60006020828403121561243657600080fd5b815167ffffffffffffffff81111561244d57600080fd5b8201601f8101841361245e57600080fd5b805167ffffffffffffffff811115612478576124786121e6565b61248b601f8201601f1916602001612353565b8181528560208385010111156124a057600080fd5b6104a9826020830160208601612400565b60208152600082518060208401526124d0816040850160208701612400565b601f01601f19169190910160400192915050565b600082516124f6818460208701612400565b9190910192915050565b60006020828403121561251257600080fd5b815160ff8116811461047557600080fdfea264697066735822122002c07ae1d39a5ae0f004719162121c23108fce5c14de342cb7f36826b0aaa96b64736f6c634300081c0033",
  "args_data": "0x",
  "tx_hash": "",
  "args": null,
  "data": "",
  "artifact_path": "MarketLens.sol",
  "artifact_full_path": "MarketLens.sol:MarketLens",
  "standardJsonInput": {
    "language": "Solidity",
    "sources": {
      "src/lenses/MarketLens.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport {IERC20} from \"@BoringSolidity/interfaces/IERC20.sol\";\nimport {Rebase} from \"@BoringSolidity/libraries/BoringRebase.sol\";\nimport {IBentoBoxV1} from \"/interfaces/IBentoBoxV1.sol\";\nimport {ICauldronV2} from \"/interfaces/ICauldronV2.sol\";\nimport {ICauldronV3} from \"/interfaces/ICauldronV3.sol\";\nimport {MathLib} from \"/libraries/MathLib.sol\";\nimport {CauldronLib} from \"/libraries/CauldronLib.sol\";\n\ncontract MarketLens {\n    using CauldronLib for ICauldronV2;\n\n    struct UserPosition {\n        address cauldron;\n        address account;\n        uint256 ltvBps;\n        uint256 healthFactor;\n        Borrow borrow;\n        Collateral collateral;\n        uint256 liquidationPrice;\n    }\n\n    struct MarketInfo {\n        address cauldron;\n        uint256 borrowFee;\n        uint256 maximumCollateralRatio;\n        uint256 liquidationFee;\n        uint256 interestPerYear;\n        uint256 marketMaxBorrow;\n        uint256 userMaxBorrow;\n        Borrow totalBorrow;\n        uint256 oracleExchangeRate;\n        uint256 collateralPrice;\n        Collateral totalCollateral;\n    }\n\n    struct Collateral {\n        IERC20 token;\n        uint256 amount;\n        uint256 share;\n        uint256 value;\n    }\n\n    struct Borrow {\n        uint256 part;\n        uint256 amount;\n    }\n\n    uint256 constant PRECISION = 1e18;\n    uint256 constant TENK_PRECISION = 1e5;\n    uint256 constant BPS_PRECISION = 1e4;\n\n    function getBorrowFee(ICauldronV2 cauldron) public view returns (uint256) {\n        return (cauldron.BORROW_OPENING_FEE() * BPS_PRECISION) / TENK_PRECISION;\n    }\n\n    function getMaximumCollateralRatio(ICauldronV2 cauldron) public view returns (uint256) {\n        return (cauldron.COLLATERIZATION_RATE() * BPS_PRECISION) / TENK_PRECISION;\n    }\n\n    function getLiquidationFee(ICauldronV2 cauldron) public view returns (uint256) {\n        uint256 liquidationFee = cauldron.LIQUIDATION_MULTIPLIER() - 100_000;\n        return (liquidationFee * BPS_PRECISION) / TENK_PRECISION;\n    }\n\n    function getInterestPerYear(ICauldronV2 cauldron) public view returns (uint64) {\n        (, , uint64 interestPerSecond) = cauldron.accrueInfo();\n        return CauldronLib.getInterestPerYearFromInterestPerSecond(interestPerSecond);\n    }\n\n    function getMimInBentoBox(ICauldronV2 cauldron) private view returns (uint256 mimInBentoBox) {\n        IBentoBoxV1 bentoBox = IBentoBoxV1(cauldron.bentoBox());\n        IERC20 mim = IERC20(cauldron.magicInternetMoney());\n        uint256 poolBalance = bentoBox.balanceOf(mim, address(cauldron));\n        mimInBentoBox = bentoBox.toAmount(mim, poolBalance, false);\n    }\n\n    function getTokenInBentoBox(IBentoBoxV1 bentoBox, IERC20 token, address account) public view returns (uint256 share, uint256 amount) {\n        return (bentoBox.balanceOf(token, account), bentoBox.toAmount(token, share, false));\n    }\n\n    function getMaxMarketBorrowForCauldronV2(ICauldronV2 cauldron) public view returns (uint256) {\n        return getMimInBentoBox(cauldron);\n    }\n\n    function getMaxUserBorrowForCauldronV2(ICauldronV2 cauldron) public view returns (uint256) {\n        return getMimInBentoBox(cauldron);\n    }\n\n    // Returns the maximum amount that can be borrowed across all users\n    function getMaxMarketBorrowForCauldronV3(ICauldronV3 cauldron) public view returns (uint256) {\n        (uint256 totalBorrowLimit, ) = cauldron.borrowLimit();\n\n        uint256 mimInBentoBox = getMimInBentoBox(cauldron);\n        uint256 remainingBorrowLimit = MathLib.subWithZeroFloor(totalBorrowLimit, getTotalBorrowed(cauldron).amount);\n\n        return MathLib.min(mimInBentoBox, remainingBorrowLimit);\n    }\n\n    // Returns the maximum amount that a single user can borrow\n    function getMaxUserBorrowForCauldronV3(ICauldronV3 cauldron) public view returns (uint256) {\n        (uint256 totalBorrowLimit, uint256 userBorrowLimit) = cauldron.borrowLimit();\n\n        uint256[] memory values = new uint256[](3);\n        values[0] = getMimInBentoBox(cauldron);\n        values[1] = MathLib.subWithZeroFloor(totalBorrowLimit, getTotalBorrowed(cauldron).amount);\n        values[2] = userBorrowLimit;\n\n        return MathLib.min(values);\n    }\n\n    function getTotalBorrowed(ICauldronV2 cauldron) public view returns (Borrow memory) {\n        Rebase memory totalBorrow = CauldronLib.getTotalBorrowWithAccruedInterests(cauldron);\n        return Borrow({amount: totalBorrow.elastic, part: totalBorrow.base});\n    }\n\n    function getOracleExchangeRate(ICauldronV2 cauldron) public view returns (uint256) {\n        return CauldronLib.getOracleExchangeRate(cauldron);\n    }\n\n    function getCollateralPrice(ICauldronV2 cauldron) public view returns (uint256) {\n        return CauldronLib.getCollateralPrice(cauldron);\n    }\n\n    function getTotalCollateral(ICauldronV2 cauldron) public view returns (Collateral memory) {\n        IBentoBoxV1 bentoBox = IBentoBoxV1(cauldron.bentoBox());\n        IERC20 token = cauldron.collateral();\n        uint256 share = cauldron.totalCollateralShare();\n        uint256 amount = bentoBox.toAmount(token, share, false);\n        uint256 value = (amount * PRECISION) / getOracleExchangeRate(cauldron);\n        return Collateral({token: token, amount: amount, share: share, value: value});\n    }\n\n    function getUserBorrow(ICauldronV2 cauldron, address account) public view returns (Borrow memory) {\n        (uint256 amount, uint256 part) = CauldronLib.getUserBorrow(cauldron, account);\n        return Borrow({amount: amount, part: part});\n    }\n\n    function getUserMaxBorrow(ICauldronV2 cauldron, address account) public view returns (uint256) {\n        (, , , uint256 value) = CauldronLib.getUserCollateral(cauldron, account);\n        return (value * getMaximumCollateralRatio(cauldron)) / TENK_PRECISION;\n    }\n\n    function getUserCollateral(ICauldronV2 cauldron, address account) public view returns (Collateral memory) {\n        (IERC20 token, uint256 amount, uint256 share, uint256 value) = CauldronLib.getUserCollateral(cauldron, account);\n        return Collateral({token: token, amount: amount, share: share, value: value});\n    }\n\n    function getUserLtv(ICauldronV2 cauldron, address account) public view returns (uint256 ltvBps) {\n        (ltvBps, , , , , , , , ) = CauldronLib.getUserPositionInfo(cauldron, account);\n    }\n\n    function getHealthFactor(ICauldronV2 cauldron, address account, bool isStable) public view returns (uint256) {\n        (, uint256 healthFactor, , , , , , , ) = CauldronLib.getUserPositionInfo(cauldron, account);\n        return isStable ? healthFactor * 10 : healthFactor;\n    }\n\n    function getUserLiquidationPrice(ICauldronV2 cauldron, address account) public view returns (uint256 liquidationPrice) {\n        (, , , , , , , , liquidationPrice) = CauldronLib.getUserPositionInfo(cauldron, account);\n    }\n\n    function getUserPosition(ICauldronV2 cauldron, address account) public view returns (UserPosition memory) {\n        (\n            uint256 ltvBps,\n            uint256 healthFactor,\n            uint256 borrowAmount,\n            uint256 borrowPart,\n            IERC20 collateralToken,\n            uint256 collateralAmount,\n            uint256 collateralShare,\n            uint256 collateralValue,\n            uint256 liquidationPrice\n        ) = CauldronLib.getUserPositionInfo(cauldron, account);\n\n        return\n            UserPosition(\n                address(cauldron),\n                address(account),\n                ltvBps,\n                healthFactor,\n                Borrow({amount: borrowAmount, part: borrowPart}),\n                Collateral({token: collateralToken, amount: collateralAmount, share: collateralShare, value: collateralValue}),\n                liquidationPrice\n            );\n    }\n\n    // Get many user position information at once.\n    // Beware of hitting RPC `eth_call` gas limit\n    function getUserPositions(ICauldronV2 cauldron, address[] calldata accounts) public view returns (UserPosition[] memory positions) {\n        positions = new UserPosition[](accounts.length);\n        for (uint256 i = 0; i < accounts.length; i++) {\n            positions[i] = getUserPosition(cauldron, accounts[i]);\n        }\n    }\n\n    function getMarketInfoCauldronV2(ICauldronV2 cauldron) public view returns (MarketInfo memory) {\n        return\n            MarketInfo({\n                cauldron: address(cauldron),\n                borrowFee: getBorrowFee(cauldron),\n                maximumCollateralRatio: getMaximumCollateralRatio(cauldron),\n                liquidationFee: getLiquidationFee(cauldron),\n                interestPerYear: getInterestPerYear(cauldron),\n                marketMaxBorrow: getMaxMarketBorrowForCauldronV2(cauldron),\n                userMaxBorrow: getMaxUserBorrowForCauldronV2(cauldron),\n                totalBorrow: getTotalBorrowed(cauldron),\n                oracleExchangeRate: getOracleExchangeRate(cauldron),\n                collateralPrice: getCollateralPrice(cauldron),\n                totalCollateral: getTotalCollateral(cauldron)\n            });\n    }\n\n    function getMarketInfoCauldronV3(ICauldronV3 cauldron) public view returns (MarketInfo memory marketInfo) {\n        marketInfo = getMarketInfoCauldronV2(cauldron);\n        marketInfo.marketMaxBorrow = getMaxMarketBorrowForCauldronV3(cauldron);\n        marketInfo.userMaxBorrow = getMaxUserBorrowForCauldronV3(cauldron);\n    }\n\n    /// @notice Get the available skim amount for the caller cauldron.\n    /// Designed for use as a call action in `cook`. Typically followed\n    /// by an add collateral action that skims available amount of shares.\n    function availableSkim() public view returns (uint256 share) {\n        // Assume caller is a cauldron\n        return ICauldronV2(msg.sender).getAvailableSkim();\n    }\n\n    /// @notice Get the available skim amount for the cauldron.\n    function availableSkim(ICauldronV2 cauldron) public view returns (uint256 share) {\n        return cauldron.getAvailableSkim();\n    }\n}\n"
      },
      "dependencies/BoringSolidity-1.0.0/contracts/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    // transfer and tranferFrom have been removed, because they don't work on all tokens (some aren't ERC20 complaint).\n    // By removing them you can't accidentally use them.\n    // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).\n    // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ninterface IStrictERC20 {\n    // This is the strict ERC20 interface. Don't use this, certainly not if you don't control the ERC20 token you're calling.\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
      },
      "dependencies/BoringSolidity-1.0.0/contracts/libraries/BoringRebase.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport {BoringMath, BoringMath128} from \"./BoringMath.sol\";\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\n/// @notice A rebasing library using overflow-/underflow-safe math.\nlibrary RebaseLibrary {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = (elastic * total.base) / total.elastic;\n            if (roundUp && (base * total.elastic) / total.base < elastic) {\n                base++;\n            }\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = (base * total.elastic) / total.base;\n            if (roundUp && (elastic * total.base) / total.elastic < base) {\n                elastic++;\n            }\n        }\n    }\n\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\n    /// @return (Rebase) The new total.\n    /// @return base in relationship to `elastic`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 base) {\n        base = toBase(total, elastic, roundUp);\n        total.elastic += elastic.to128();\n        total.base += base.to128();\n        return (total, base);\n    }\n\n    /// @notice Sub `base` from `total` and update `total.elastic`.\n    /// @return (Rebase) The new total.\n    /// @return elastic in relationship to `base`.\n    function sub(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 elastic) {\n        elastic = toElastic(total, base, roundUp);\n        total.elastic -= elastic.to128();\n        total.base -= base.to128();\n        return (total, elastic);\n    }\n\n    /// @notice Add `elastic` and `base` to `total`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic += elastic.to128();\n        total.base += base.to128();\n        return total;\n    }\n\n    /// @notice Subtract `elastic` and `base` to `total`.\n    function sub(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic -= elastic.to128();\n        total.base -= base.to128();\n        return total;\n    }\n\n    /// @notice Add `elastic` to `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic += elastic.to128();\n    }\n\n    /// @notice Subtract `elastic` from `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic -= elastic.to128();\n    }\n}\n"
      },
      "src/interfaces/IBentoBoxV1.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC20} from \"@BoringSolidity/interfaces/IERC20.sol\";\nimport {Rebase} from \"@BoringSolidity/libraries/BoringRebase.sol\";\nimport {IStrategy} from \"/interfaces/IStrategy.sol\";\n\ninterface IFlashBorrower {\n    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.\n    /// @param sender The address of the invoker of this flashloan.\n    /// @param token The address of the token that is loaned.\n    /// @param amount of the `token` that is loaned.\n    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.\n    /// @param data Additional data that was passed to the flashloan function.\n    function onFlashLoan(address sender, IERC20 token, uint256 amount, uint256 fee, bytes calldata data) external;\n}\n\ninterface IBatchFlashBorrower {\n    /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.\n    /// @param sender The address of the invoker of this flashloan.\n    /// @param tokens Array of addresses for ERC-20 tokens that is loaned.\n    /// @param amounts A one-to-one map to `tokens` that is loaned.\n    /// @param fees A one-to-one map to `tokens` that needs to be paid on top for each loan. Needs to be the same token.\n    /// @param data Additional data that was passed to the flashloan function.\n    function onBatchFlashLoan(\n        address sender,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        uint256[] calldata fees,\n        bytes calldata data\n    ) external;\n}\n\ninterface IBentoBoxV1 {\n    function balanceOf(IERC20, address) external view returns (uint256);\n\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\n\n    function batchFlashLoan(\n        IBatchFlashBorrower borrower,\n        address[] calldata receivers,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n\n    function claimOwnership() external;\n\n    function flashLoan(IFlashBorrower borrower, address receiver, IERC20 token, uint256 amount, bytes calldata data) external;\n\n    function deploy(address masterContract, bytes calldata data, bool useCreate2) external payable returns (address);\n\n    function deposit(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    function harvest(IERC20 token, bool balance, uint256 maxChangeAmount) external;\n\n    function masterContractApproved(address, address) external view returns (bool);\n\n    function masterContractOf(address) external view returns (address);\n\n    function nonces(address) external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function pendingOwner() external view returns (address);\n\n    function pendingStrategy(IERC20) external view returns (IStrategy);\n\n    function permitToken(IERC20 token, address from, address to, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    function registerProtocol() external;\n\n    function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) external;\n\n    function setStrategy(IERC20 token, IStrategy newStrategy) external;\n\n    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;\n\n    function strategy(IERC20) external view returns (IStrategy);\n\n    function strategyData(IERC20) external view returns (uint64 strategyStartDate, uint64 targetPercentage, uint128 balance);\n\n    function toAmount(IERC20 token, uint256 share, bool roundUp) external view returns (uint256 amount);\n\n    function toShare(IERC20 token, uint256 amount, bool roundUp) external view returns (uint256 share);\n\n    function totals(IERC20) external view returns (Rebase memory totals_);\n\n    function transfer(IERC20 token, address from, address to, uint256 share) external;\n\n    function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) external;\n\n    function transferOwnership(address newOwner, bool direct, bool renounce) external;\n\n    function whitelistMasterContract(address masterContract, bool approved) external;\n\n    function whitelistedMasterContracts(address) external view returns (bool);\n\n    function withdraw(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n}\n\ninterface IBentoBoxLite {\n    function deposit(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    function balanceOf(address, address) external view returns (uint256);\n\n    function toAmount(address token, uint256 share, bool roundUp) external view returns (uint256 amount);\n\n    function toShare(address token, uint256 amount, bool roundUp) external view returns (uint256 share);\n\n    function transfer(address token, address from, address to, uint256 share) external;\n}\n"
      },
      "src/interfaces/ICauldronV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC20} from \"@BoringSolidity/interfaces/IERC20.sol\";\nimport {Rebase} from \"@BoringSolidity/libraries/BoringRebase.sol\";\nimport {IOracle} from \"/interfaces/IOracle.sol\";\n\ninterface ICauldronV2 {\n    function oracle() external view returns (IOracle);\n\n    function oracleData() external view returns (bytes memory);\n\n    function accrueInfo() external view returns (uint64, uint128, uint64);\n\n    function BORROW_OPENING_FEE() external view returns (uint256);\n\n    function COLLATERIZATION_RATE() external view returns (uint256);\n\n    function LIQUIDATION_MULTIPLIER() external view returns (uint256);\n\n    function totalCollateralShare() external view returns (uint256);\n\n    function bentoBox() external view returns (address);\n\n    function feeTo() external view returns (address);\n\n    function masterContract() external view returns (ICauldronV2);\n\n    function collateral() external view returns (IERC20);\n\n    function setFeeTo(address newFeeTo) external;\n\n    function accrue() external;\n\n    function totalBorrow() external view returns (Rebase memory);\n\n    function userBorrowPart(address account) external view returns (uint256);\n\n    function userCollateralShare(address account) external view returns (uint256);\n\n    function withdrawFees() external;\n\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2);\n\n    function addCollateral(address to, bool skim, uint256 share) external;\n\n    function removeCollateral(address to, uint256 share) external;\n\n    function borrow(address to, uint256 amount) external returns (uint256 part, uint256 share);\n\n    function repay(address to, bool skim, uint256 part) external returns (uint256 amount);\n\n    function reduceSupply(uint256 amount) external;\n\n    function magicInternetMoney() external view returns (IERC20);\n\n    function liquidate(address[] calldata users, uint256[] calldata maxBorrowParts, address to, address swapper) external;\n\n    function updateExchangeRate() external returns (bool updated, uint256 rate);\n\n    function exchangeRate() external view returns (uint256 rate);\n\n    function init(bytes calldata data) external payable;\n}\n"
      },
      "src/interfaces/ICauldronV3.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ICauldronV2} from \"/interfaces/ICauldronV2.sol\";\n\ninterface ICauldronV3 is ICauldronV2 {\n    function borrowLimit() external view returns (uint128 total, uint128 borrowPartPerAddres);\n\n    function changeInterestRate(uint64 newInterestRate) external;\n\n    function changeBorrowLimit(uint128 newBorrowLimit, uint128 perAddressPart) external;\n\n    function liquidate(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        address to,\n        address swapper,\n        bytes calldata swapperData\n    ) external;\n}\n"
      },
      "src/libraries/MathLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nlibrary MathLib {\n    function max(uint256[] memory values) internal pure returns (uint256) {\n        uint256 maxValue = values[0];\n        for (uint256 i = 1; i < values.length; i++) {\n            if (values[i] > maxValue) {\n                maxValue = values[i];\n            }\n        }\n        return maxValue;\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    function min(uint256[] memory values) internal pure returns (uint256) {\n        uint256 minValue = values[0];\n        for (uint256 i = 1; i < values.length; i++) {\n            if (values[i] < minValue) {\n                minValue = values[i];\n            }\n        }\n        return minValue;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function subWithZeroFloor(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : 0;\n    }\n}\n"
      },
      "src/libraries/CauldronLib.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {IERC20} from \"@BoringSolidity/interfaces/IERC20.sol\";\nimport {RebaseLibrary, Rebase} from \"@BoringSolidity/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@BoringSolidity/libraries/BoringERC20.sol\";\nimport {IBentoBoxV1} from \"/interfaces/IBentoBoxV1.sol\";\nimport {ICauldronV2} from \"/interfaces/ICauldronV2.sol\";\nimport {ICauldronV3} from \"/interfaces/ICauldronV3.sol\";\nimport {ICauldronV4} from \"/interfaces/ICauldronV4.sol\";\nimport {IOracle} from \"/interfaces/IOracle.sol\";\nimport {MathLib} from \"/libraries/MathLib.sol\";\n\nlibrary CauldronLib {\n    using BoringERC20 for IERC20;\n    using RebaseLibrary for Rebase;\n\n    uint256 internal constant EXCHANGE_RATE_PRECISION = 1e18;\n    uint256 internal constant BPS_PRECISION = 1e4;\n    uint256 internal constant COLLATERIZATION_RATE_PRECISION = 1e5;\n    uint256 internal constant LIQUIDATION_MULTIPLIER_PRECISION = 1e5;\n    uint256 internal constant DISTRIBUTION_PART = 10;\n    uint256 internal constant DISTRIBUTION_PRECISION = 100;\n\n    /// @dev example: 200 is 2% interests\n    function getInterestPerSecond(uint256 interestBips) internal pure returns (uint64 interestsPerSecond) {\n        return uint64((interestBips * 316880878) / 100); // 316880878 is the precomputed integral part of 1e18 / (36525 * 3600 * 24)\n    }\n\n    function getInterestPerYearFromInterestPerSecond(uint64 interestPerSecond) internal pure returns (uint64 interestPerYearBips) {\n        return (interestPerSecond * 100) / 316880878;\n    }\n\n    function getUserBorrow(ICauldronV2 cauldron, address user) internal view returns (uint256 amount, uint256 part) {\n        Rebase memory totalBorrow = getTotalBorrowWithAccruedInterests(cauldron);\n        if (totalBorrow.base == 0) {\n            return (0, 0);\n        }\n        part = cauldron.userBorrowPart(user);\n        amount = (part * totalBorrow.elastic) / totalBorrow.base;\n    }\n\n    // total borrow with on-fly accrued interests\n    function getTotalBorrowWithAccruedInterests(ICauldronV2 cauldron) internal view returns (Rebase memory totalBorrow) {\n        totalBorrow = cauldron.totalBorrow();\n        (uint64 lastAccrued, , uint64 INTEREST_PER_SECOND) = cauldron.accrueInfo();\n        uint256 elapsedTime = block.timestamp - lastAccrued;\n\n        if (elapsedTime != 0 && totalBorrow.base != 0) {\n            totalBorrow.elastic = totalBorrow.elastic + uint128((uint256(totalBorrow.elastic) * INTEREST_PER_SECOND * elapsedTime) / 1e18);\n        }\n    }\n\n    function getOracleExchangeRate(ICauldronV2 cauldron) internal view returns (uint256) {\n        IOracle oracle = IOracle(cauldron.oracle());\n        bytes memory oracleData = cauldron.oracleData();\n        return oracle.peekSpot(oracleData);\n    }\n\n    function getUserCollateral(\n        ICauldronV2 cauldron,\n        address account\n    ) internal view returns (IERC20 token, uint256 amount, uint256 share, uint256 value) {\n        IBentoBoxV1 bentoBox = IBentoBoxV1(cauldron.bentoBox());\n        share = cauldron.userCollateralShare(account);\n\n        token = cauldron.collateral();\n        amount = bentoBox.toAmount(token, share, false);\n        value = (amount * EXCHANGE_RATE_PRECISION) / getOracleExchangeRate(cauldron);\n    }\n\n    function getUserPositionInfo(\n        ICauldronV2 cauldron,\n        address account\n    )\n        internal\n        view\n        returns (\n            uint256 ltvBps,\n            uint256 healthFactor,\n            uint256 borrowAmount,\n            uint256 borrowPart,\n            IERC20 collateralToken,\n            uint256 collateralAmount,\n            uint256 collateralShare,\n            uint256 collateralValue,\n            uint256 liquidationPrice\n        )\n    {\n        (collateralToken, collateralAmount, collateralShare, collateralValue) = getUserCollateral(cauldron, account);\n\n        (borrowAmount, borrowPart) = getUserBorrow(cauldron, account);\n\n        if (collateralValue > 0) {\n            ltvBps = (borrowAmount * BPS_PRECISION) / collateralValue;\n\n            // example with WBTC (8 decimals)\n            // 18 + 8 + 5 - 5 - 8 - 10 = 8 decimals\n            uint256 collateralPrecision = 10 ** collateralToken.safeDecimals();\n\n            liquidationPrice =\n                (borrowAmount * collateralPrecision ** 2 * 1e5) /\n                cauldron.COLLATERIZATION_RATE() / // 1e5 precision\n                collateralAmount /\n                EXCHANGE_RATE_PRECISION;\n\n            healthFactor = MathLib.subWithZeroFloor(\n                EXCHANGE_RATE_PRECISION,\n                (EXCHANGE_RATE_PRECISION * liquidationPrice * getOracleExchangeRate(cauldron)) / collateralPrecision ** 2\n            );\n        }\n    }\n\n    /// @notice the liquidator will get \"MIM borrowPart\" worth of collateral + liquidation fee incentive but borrowPart needs to be adjusted to take in account\n    /// the sSpell distribution taken off the liquidation fee. This function takes in account the bad debt repayment in case\n    /// the borrowPart give less collateral than it should.\n    /// @param cauldron Cauldron contract\n    /// @param account Account to liquidate\n    /// @param borrowPart Amount of MIM debt to liquidate\n    /// @return collateralAmount Amount of collateral that the liquidator will receive\n    /// @return adjustedBorrowPart Adjusted borrowPart to take in account position with bad debt where the\n    ///                            borrowPart give out more collateral than what the user has.\n    /// @return requiredMim MIM amount that the liquidator will need to pay back to get the collateralShare\n    function getLiquidationCollateralAndBorrowAmount(\n        ICauldronV2 cauldron,\n        address account,\n        uint256 borrowPart\n    ) internal view returns (uint256 collateralAmount, uint256 adjustedBorrowPart, uint256 requiredMim) {\n        uint256 exchangeRate = getOracleExchangeRate(cauldron);\n        Rebase memory totalBorrow = getTotalBorrowWithAccruedInterests(cauldron);\n        IBentoBoxV1 box = IBentoBoxV1(cauldron.bentoBox());\n        uint256 collateralShare = cauldron.userCollateralShare(account);\n        IERC20 collateral = cauldron.collateral();\n\n        // cap to the maximum amount of debt that can be liquidated in case the cauldron has bad debt\n        {\n            Rebase memory bentoBoxTotals = box.totals(collateral);\n\n            // how much debt can be liquidated\n            uint256 maxBorrowPart = (bentoBoxTotals.toElastic(collateralShare, false) * 1e23) /\n                (cauldron.LIQUIDATION_MULTIPLIER() * exchangeRate);\n            maxBorrowPart = totalBorrow.toBase(maxBorrowPart, false);\n\n            if (borrowPart > maxBorrowPart) {\n                borrowPart = maxBorrowPart;\n            }\n        }\n\n        // convert borrowPart to debt\n        requiredMim = totalBorrow.toElastic(borrowPart, false);\n\n        // convert borrowPart to collateralShare\n        {\n            Rebase memory bentoBoxTotals = box.totals(collateral);\n\n            // how much collateral share the liquidator will get from the given borrow amount\n            collateralShare = bentoBoxTotals.toBase(\n                (requiredMim * cauldron.LIQUIDATION_MULTIPLIER() * exchangeRate) /\n                    (LIQUIDATION_MULTIPLIER_PRECISION * EXCHANGE_RATE_PRECISION),\n                false\n            );\n            collateralAmount = box.toAmount(collateral, collateralShare, false);\n        }\n\n        // add the sSpell distribution part\n        {\n            requiredMim +=\n                ((((requiredMim * cauldron.LIQUIDATION_MULTIPLIER()) / LIQUIDATION_MULTIPLIER_PRECISION) - requiredMim) *\n                    DISTRIBUTION_PART) /\n                DISTRIBUTION_PRECISION;\n\n            IERC20 mim = cauldron.magicInternetMoney();\n\n            // convert back and forth to amount to compensate for rounded up toShare conversion inside `liquidate`\n            requiredMim = box.toAmount(mim, box.toShare(mim, requiredMim, true), true);\n        }\n\n        adjustedBorrowPart = borrowPart;\n    }\n\n    function isSolvent(ICauldronV2 cauldron, address account) internal view returns (bool) {\n        IBentoBoxV1 bentoBox = IBentoBoxV1(cauldron.bentoBox());\n        Rebase memory totalBorrow = getTotalBorrowWithAccruedInterests(cauldron);\n        uint256 exchangeRate = getOracleExchangeRate(cauldron);\n        IERC20 collateral = cauldron.collateral();\n        uint256 COLLATERIZATION_RATE = cauldron.COLLATERIZATION_RATE();\n        uint256 collateralShare = cauldron.userCollateralShare(account);\n        uint256 borrowPart = cauldron.userBorrowPart(account);\n\n        if (borrowPart == 0) {\n            return true;\n        } else if (collateralShare == 0) {\n            return false;\n        } else {\n            return\n                bentoBox.toAmount(\n                    collateral,\n                    (collateralShare * (EXCHANGE_RATE_PRECISION / COLLATERIZATION_RATE_PRECISION)) * COLLATERIZATION_RATE,\n                    false\n                ) >= (borrowPart * totalBorrow.elastic * exchangeRate) / totalBorrow.base;\n        }\n    }\n\n    function getCollateralPrice(ICauldronV2 cauldron) internal view returns (uint256) {\n        IERC20 collateral = cauldron.collateral();\n        uint256 collateralPrecision = 10 ** collateral.safeDecimals();\n        return (collateralPrecision * collateralPrecision) / getOracleExchangeRate(cauldron);\n    }\n\n    function getAvailableSkim(ICauldronV2 cauldron) internal view returns (uint256) {\n        return IBentoBoxV1(cauldron.bentoBox()).balanceOf(IERC20(cauldron.collateral()), msg.sender) - cauldron.totalCollateralShare();\n    }\n\n    function decodeInitData(\n        bytes calldata data\n    )\n        internal\n        pure\n        returns (\n            address collateral,\n            address oracle,\n            bytes memory oracleData,\n            uint64 INTEREST_PER_SECOND,\n            uint256 LIQUIDATION_MULTIPLIER,\n            uint256 COLLATERIZATION_RATE,\n            uint256 BORROW_OPENING_FEE\n        )\n    {\n        (collateral, oracle, oracleData, INTEREST_PER_SECOND, LIQUIDATION_MULTIPLIER, COLLATERIZATION_RATE, BORROW_OPENING_FEE) = abi\n            .decode(data, (address, address, bytes, uint64, uint256, uint256, uint256));\n    }\n}\n"
      },
      "dependencies/BoringSolidity-1.0.0/contracts/libraries/BoringMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nlibrary BoringMath {\n    error ErrOverflow();\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function to32(uint256 a) internal pure returns (uint32) {\n        if (a > type(uint32).max) {\n            revert ErrOverflow();\n        }\n        return uint32(a);\n    }\n\n    function to40(uint256 a) internal pure returns (uint40) {\n        if (a > type(uint40).max) {\n            revert ErrOverflow();\n        }\n        return uint40(a);\n    }\n\n    function to64(uint256 a) internal pure returns (uint64) {\n        if (a > type(uint64).max) {\n            revert ErrOverflow();\n        }\n        return uint64(a);\n    }\n\n    function to112(uint256 a) internal pure returns (uint112) {\n        if (a > type(uint112).max) {\n            revert ErrOverflow();\n        }\n        return uint112(a);\n    }\n\n    function to128(uint256 a) internal pure returns (uint128) {\n        if (a > type(uint128).max) {\n            revert ErrOverflow();\n        }\n        return uint128(a);\n    }\n\n    function to208(uint256 a) internal pure returns (uint208) {\n        if (a > type(uint208).max) {\n            revert ErrOverflow();\n        }\n        return uint208(a);\n    }\n\n    function to216(uint256 a) internal pure returns (uint216) {\n        if (a > type(uint216).max) {\n            revert ErrOverflow();\n        }\n        return uint216(a);\n    }\n\n    function to224(uint256 a) internal pure returns (uint224) {\n        if (a > type(uint224).max) {\n            revert ErrOverflow();\n        }\n        return uint224(a);\n    }\n}\n\nlibrary BoringMath32 {\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a + b;\n    }\n\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a - b;\n    }\n\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a * b;\n    }\n\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a / b;\n    }\n}\n\nlibrary BoringMath64 {\n    function add(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a + b;\n    }\n\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a - b;\n    }\n\n    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a * b;\n    }\n\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a / b;\n    }\n}\n\nlibrary BoringMath112 {\n    function add(uint112 a, uint112 b) internal pure returns (uint112) {\n        return a + b;\n    }\n\n    function sub(uint112 a, uint112 b) internal pure returns (uint112) {\n        return a - b;\n    }\n\n    function mul(uint112 a, uint112 b) internal pure returns (uint112) {\n        return a * b;\n    }\n\n    function div(uint112 a, uint112 b) internal pure returns (uint112) {\n        return a / b;\n    }\n}\n\nlibrary BoringMath128 {\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\n        return a + b;\n    }\n\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\n        return a - b;\n    }\n\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\n        return a * b;\n    }\n\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\n        return a / b;\n    }\n}\n\nlibrary BoringMath224 {\n    function add(uint224 a, uint224 b) internal pure returns (uint224) {\n        return a + b;\n    }\n\n    function sub(uint224 a, uint224 b) internal pure returns (uint224) {\n        return a - b;\n    }\n\n    function mul(uint224 a, uint224 b) internal pure returns (uint224) {\n        return a * b;\n    }\n\n    function div(uint224 a, uint224 b) internal pure returns (uint224) {\n        return a / b;\n    }\n}\n"
      },
      "src/interfaces/IStrategy.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IStrategy {\n    function skim(uint256 amount) external;\n\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\n\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\n\n    function exit(uint256 balance) external returns (int256 amountAdded);\n}\n"
      },
      "src/interfaces/IOracle.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IOracle {\n    function decimals() external view returns (uint8);\n\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\n\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\n\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\n\n    function symbol(bytes calldata data) external view returns (string memory);\n\n    function name(bytes calldata data) external view returns (string memory);\n}\n"
      },
      "dependencies/BoringSolidity-1.0.0/contracts/libraries/BoringERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\n// solhint-disable avoid-low-level-calls\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)\n    bytes4 private constant SIG_TOTALSUPPLY = 0x18160ddd; // balanceOf(address)\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n        if (data.length >= 64) {\n            return abi.decode(data, (string));\n        } else if (data.length == 32) {\n            uint8 i = 0;\n            while (i < 32 && data[i] != 0) {\n                i++;\n            }\n            bytes memory bytesArray = new bytes(i);\n            for (i = 0; i < 32 && data[i] != 0; i++) {\n                bytesArray[i] = data[i];\n            }\n            return string(bytesArray);\n        } else {\n            return \"???\";\n        }\n    }\n\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token symbol.\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token name.\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (uint8) Token decimals.\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    /// @notice Provides a gas-optimized balance check to avoid a redundant extcodesize check in addition to the returndatasize check.\n    /// @param token The address of the ERC-20 token.\n    /// @param to The address of the user to check.\n    /// @return amount The token amount.\n    function safeBalanceOf(IERC20 token, address to) internal view returns (uint256 amount) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_BALANCE_OF, to));\n        require(success && data.length >= 32, \"BoringERC20: BalanceOf failed\");\n        amount = abi.decode(data, (uint256));\n    }\n\n    /// @notice Provides a gas-optimized totalSupply to avoid a redundant extcodesize check in addition to the returndatasize check.\n    /// @param token The address of the ERC-20 token.\n    /// @return totalSupply The token totalSupply.\n    function safeTotalSupply(IERC20 token) internal view returns (uint256 totalSupply) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_TOTALSUPPLY));\n        require(success && data.length >= 32, \"BoringERC20: totalSupply failed\");\n        totalSupply = abi.decode(data, (uint256));\n    }\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\n    }\n}\n"
      },
      "src/interfaces/ICauldronV4.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ICauldronV3} from \"/interfaces/ICauldronV3.sol\";\n\ninterface ICauldronV4 is ICauldronV3 {\n    function setBlacklistedCallee(address callee, bool blacklisted) external;\n\n    function blacklistedCallees(address callee) external view returns (bool);\n\n    function isSolvent(address user) external view returns (bool);\n}\n"
      }
    },
    "settings": {
      "remappings": [
        "/=src/",
        "forge-std/=dependencies/forge-std-1.9.5/src/",
        "halmos-cheatcodes/=dependencies/halmos-cheatcodes-7328abe/src/",
        "@openzeppelin/contracts/=dependencies/openzeppelin-contracts-5.0.2/contracts/",
        "@openzeppelin/contracts-upgradeable/=dependencies/openzeppelin-contracts-upgradeable-5.0.2/contracts/",
        "@BoringSolidity/=dependencies/BoringSolidity-1.0.0/contracts/",
        "@solady/=dependencies/solady-0.0.281/src/",
        "@solmate/=dependencies/solmate-6.2.0/src/",
        "@excessivelySafeCall/=dependencies/ExcessivelySafeCall-0.0.1/src/",
        "@safe-contracts/=dependencies/safe-contracts-1.3.0/contracts/",
        "@fuzzlib/=dependencies/fuzzlib-0.0.1/src/",
        "@abracadabra-oft-v1/=dependencies/abracadabra-oft-v1-0.0.1/src/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 400
      },
      "metadata": {
        "useLiteralContent": false,
        "bytecodeHash": "ipfs",
        "appendCBOR": true
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode.object",
            "evm.bytecode.sourceMap",
            "evm.bytecode.linkReferences",
            "evm.deployedBytecode.object",
            "evm.deployedBytecode.sourceMap",
            "evm.deployedBytecode.linkReferences",
            "evm.deployedBytecode.immutableReferences",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "evmVersion": "cancun",
      "viaIR": false,
      "libraries": {}
    }
  },
  "compiler": "0.8.28+commit.7893614a"
}