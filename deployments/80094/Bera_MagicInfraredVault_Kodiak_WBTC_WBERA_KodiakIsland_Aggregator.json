{
  "address": "0x9b27A40586AC7C4d283D0B07a749fC05f315fb45",
  "abi": [
    {
      "type": "constructor",
      "inputs": [
        {
          "name": "_island",
          "type": "address",
          "internalType": "contract IKodiakVaultV1"
        },
        {
          "name": "_tokenAggregator0",
          "type": "address",
          "internalType": "contract IAggregator"
        },
        {
          "name": "_tokenAggregator1",
          "type": "address",
          "internalType": "contract IAggregator"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "WAD",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "aggregatorDecimalScale0",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "aggregatorDecimalScale1",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "decimals",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint8",
          "internalType": "uint8"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "decimals0",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint8",
          "internalType": "uint8"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "decimals1",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint8",
          "internalType": "uint8"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "island",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IKodiakVaultV1"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "latestAnswer",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "int256",
          "internalType": "int256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "latestRoundData",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint80",
          "internalType": "uint80"
        },
        {
          "name": "",
          "type": "int256",
          "internalType": "int256"
        },
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "",
          "type": "uint80",
          "internalType": "uint80"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "token0",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "token1",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "tokenAggregator0",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IAggregator"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "tokenAggregator1",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IAggregator"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "error",
      "name": "ErrInvalidDecimals",
      "inputs": []
    },
    {
      "type": "error",
      "name": "SafeCastOverflowedUintDowncast",
      "inputs": [
        {
          "name": "bits",
          "type": "uint8",
          "internalType": "uint8"
        },
        {
          "name": "value",
          "type": "uint256",
          "internalType": "uint256"
        }
      ]
    },
    {
      "type": "error",
      "name": "SafeCastOverflowedUintToInt",
      "inputs": [
        {
          "name": "value",
          "type": "uint256",
          "internalType": "uint256"
        }
      ]
    }
  ],
  "bytecode": "0x6101c0604052348015610010575f5ffd5b5060405161125938038061125983398101604081905261002f916103d0565b6001600160a01b0380841661010081905283821660805290821660a05260408051630dfe168160e01b81529051630dfe1681916004808201926020929091908290030181865afa158015610085573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906100a9919061041a565b6001600160a01b0316610120816001600160a01b031681525050610100516001600160a01b031663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa158015610102573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610126919061041a565b6001600160a01b0316610140816001600160a01b031681525050610120516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561017f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906101a3919061043c565b60ff166101608160ff1681525050610140516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156101f0573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610214919061043c565b60ff166101808160ff16815250506080516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610260573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610284919061043c565b6102929060ff166012610470565b61029d90600a61056c565b60c0818152505060a0516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156102e2573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610306919061043c565b6103149060ff166012610470565b61031f90600a61056c565b60e08181525050610100516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610365573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610389919061043c565b60ff166101a08190526012146103b15760405162b967f360e21b815260040160405180910390fd5b505050610577565b6001600160a01b03811681146103cd575f5ffd5b50565b5f5f5f606084860312156103e2575f5ffd5b83516103ed816103b9565b60208501519093506103fe816103b9565b604085015190925061040f816103b9565b809150509250925092565b5f6020828403121561042a575f5ffd5b8151610435816103b9565b9392505050565b5f6020828403121561044c575f5ffd5b815160ff81168114610435575f5ffd5b634e487b7160e01b5f52601160045260245ffd5b818103818111156104835761048361045c565b92915050565b6001815b60018411156104c4578085048111156104a8576104a861045c565b60018416156104b657908102905b60019390931c92800261048d565b935093915050565b5f826104da57506001610483565b816104e657505f610483565b81600181146104fc576002811461050657610522565b6001915050610483565b60ff8411156105175761051761045c565b50506001821b610483565b5060208310610133831016604e8410600b8410161715610545575081810a610483565b6105515f198484610489565b805f19048211156105645761056461045c565b029392505050565b5f61043583836104cc565b60805160a05160c05160e05161010051610120516101405161016051610180516101a051610c206106395f395f61014e01525f81816101f301528181610487015281816104b2015261066e01525f81816101cc01528181610463015281816104d6015261062b01525f61021a01525f60e301525f8181610241015281816105b601526106ae01525f8181610187015261043401525f8181610268015261040201525f818161028f015261037b01525f818161012701526102f40152610c205ff3fe608060405234801561000f575f5ffd5b50600436106100da575f3560e01c80637bdd6b4411610088578063db5537e111610063578063db5537e11461023c578063dcd7240814610263578063ef8300001461028a578063feaf968c146102b1575f5ffd5b80637bdd6b44146101c7578063a28af8a4146101ee578063d21220a714610215575f5ffd5b80633f337e6c116100b85780633f337e6c1461018257806350d25bcd146101b75780636a146024146101bf575f5ffd5b80630dfe1681146100de57806313b6193714610122578063313ce56714610149575b5f5ffd5b6101057f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b6101057f000000000000000000000000000000000000000000000000000000000000000081565b6101707f000000000000000000000000000000000000000000000000000000000000000081565b60405160ff9091168152602001610119565b6101a97f000000000000000000000000000000000000000000000000000000000000000081565b604051908152602001610119565b6101a96102f0565b6101a9601281565b6101707f000000000000000000000000000000000000000000000000000000000000000081565b6101707f000000000000000000000000000000000000000000000000000000000000000081565b6101057f000000000000000000000000000000000000000000000000000000000000000081565b6101057f000000000000000000000000000000000000000000000000000000000000000081565b6101a97f000000000000000000000000000000000000000000000000000000000000000081565b6101057f000000000000000000000000000000000000000000000000000000000000000081565b6102b9610790565b6040805169ffffffffffffffffffff968716815260208101959095528401929092526060830152909116608082015260a001610119565b5f5f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa15801561034e573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061037291906109de565b5050509150505f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa1580156103d5573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906103f991906109de565b5050509150505f7f00000000000000000000000000000000000000000000000000000000000000008361042c9190610a40565b90505f6104597f000000000000000000000000000000000000000000000000000000000000000084610a40565b90505f5f5f6104ae7f000000000000000000000000000000000000000000000000000000000000000060ff167f000000000000000000000000000000000000000000000000000000000000000060ff166107b0565b90507f000000000000000000000000000000000000000000000000000000000000000060ff167f000000000000000000000000000000000000000000000000000000000000000060ff1610610513576001925061050c81600a610b3a565b9150610525565b61051e81600a610b3a565b9250600191505b5f6105308386610a40565b61053a8588610a40565b61054c90670de0b6b3a7640000610a40565b6105569190610b45565b90505f610590633b9aca0061056a846107db565b610581906c01000000000000000000000000610a40565b61058b9190610b45565b610958565b60405163b670ed7d60e01b81526001600160a01b0382811660048301529192505f9182917f00000000000000000000000000000000000000000000000000000000000000009091169063b670ed7d906024016040805180830381865afa1580156105fc573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106209190610b64565b90925090505f6106517f00000000000000000000000000000000000000000000000000000000000000006012610b86565b61065c90600a610b9f565b6106669084610a40565b90505f6106947f00000000000000000000000000000000000000000000000000000000000000006012610b86565b61069f90600a610b9f565b6106a99084610a40565b90505f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610708573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061072c9190610bad565b9050805f03610749575f9e50505050505050505050505050505090565b5f6107548c84610a40565b61075e8e86610a40565b6107689190610bc4565b905061077c6107778383610b45565b610994565b9f5050505050505050505050505050505090565b5f5f5f5f5f5f61079e6102f0565b90969095505f94508493508392509050565b5f818310156107c8576107c38383610bd7565b6107d2565b6107d28284610bd7565b90505b92915050565b5f815f036107ea57505f919050565b816001600160801b82106108035760809190911c9060401b5b68010000000000000000821061081e5760409190911c9060201b5b64010000000082106108355760209190911c9060101b5b62010000821061084a5760109190911c9060081b5b610100821061085e5760089190911c9060041b5b601082106108715760049190911c9060021b5b6008821061087d5760011b5b60016108898286610b45565b6108939083610bc4565b901c905060016108a38286610b45565b6108ad9083610bc4565b901c905060016108bd8286610b45565b6108c79083610bc4565b901c905060016108d78286610b45565b6108e19083610bc4565b901c905060016108f18286610b45565b6108fb9083610bc4565b901c9050600161090b8286610b45565b6109159083610bc4565b901c905060016109258286610b45565b61092f9083610bc4565b901c90505f61093e8286610b45565b905080821061094d578061094f565b815b95945050505050565b5f6001600160a01b03821115610990576040516306dfcc6560e41b815260a06004820152602481018390526044015b60405180910390fd5b5090565b5f6001600160ff1b038211156109905760405163123baf0360e11b815260048101839052602401610987565b805169ffffffffffffffffffff811681146109d9575f5ffd5b919050565b5f5f5f5f5f60a086880312156109f2575f5ffd5b6109fb866109c0565b60208701516040880151606089015192975090955093509150610a20608087016109c0565b90509295509295909350565b634e487b7160e01b5f52601160045260245ffd5b80820281158282048414176107d5576107d5610a2c565b6001815b6001841115610a9257808504811115610a7657610a76610a2c565b6001841615610a8457908102905b60019390931c928002610a5b565b935093915050565b5f82610aa8575060016107d5565b81610ab457505f6107d5565b8160018114610aca5760028114610ad457610af0565b60019150506107d5565b60ff841115610ae557610ae5610a2c565b50506001821b6107d5565b5060208310610133831016604e8410600b8410161715610b13575081810a6107d5565b610b1f5f198484610a57565b805f1904821115610b3257610b32610a2c565b029392505050565b5f6107d28383610a9a565b5f82610b5f57634e487b7160e01b5f52601260045260245ffd5b500490565b5f5f60408385031215610b75575f5ffd5b505080516020909101519092909150565b60ff82811682821603908111156107d5576107d5610a2c565b5f6107d260ff841683610a9a565b5f60208284031215610bbd575f5ffd5b5051919050565b808201808211156107d5576107d5610a2c565b818103818111156107d5576107d5610a2c56fea2646970667358221220b6d3ad23d8983141785fb8e273dcab867f9f115bff518cb24165e62f3f8d99f164736f6c634300081c0033",
  "args_data": "0x000000000000000000000000f06ea29fcf4765200742d29e685973a1870eac9800000000000000000000000016950c5978880537117f159a492805c021dd44eb000000000000000000000000e8de4c60da9c00da512c827e02224c8609fc916a",
  "tx_hash": "0x286730f16910c04485a65420bb6d6ab9e2f097319cbba34b68ba1b9675d5b807",
  "args": [
    "0xF06EA29FCF4765200742d29E685973a1870EaC98",
    "0x16950C5978880537117f159A492805C021dD44eb",
    "0xE8de4C60Da9c00Da512c827e02224c8609fc916a"
  ],
  "data": "0x6101c0604052348015610010575f5ffd5b5060405161125938038061125983398101604081905261002f916103d0565b6001600160a01b0380841661010081905283821660805290821660a05260408051630dfe168160e01b81529051630dfe1681916004808201926020929091908290030181865afa158015610085573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906100a9919061041a565b6001600160a01b0316610120816001600160a01b031681525050610100516001600160a01b031663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa158015610102573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610126919061041a565b6001600160a01b0316610140816001600160a01b031681525050610120516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561017f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906101a3919061043c565b60ff166101608160ff1681525050610140516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156101f0573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610214919061043c565b60ff166101808160ff16815250506080516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610260573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610284919061043c565b6102929060ff166012610470565b61029d90600a61056c565b60c0818152505060a0516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156102e2573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610306919061043c565b6103149060ff166012610470565b61031f90600a61056c565b60e08181525050610100516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610365573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610389919061043c565b60ff166101a08190526012146103b15760405162b967f360e21b815260040160405180910390fd5b505050610577565b6001600160a01b03811681146103cd575f5ffd5b50565b5f5f5f606084860312156103e2575f5ffd5b83516103ed816103b9565b60208501519093506103fe816103b9565b604085015190925061040f816103b9565b809150509250925092565b5f6020828403121561042a575f5ffd5b8151610435816103b9565b9392505050565b5f6020828403121561044c575f5ffd5b815160ff81168114610435575f5ffd5b634e487b7160e01b5f52601160045260245ffd5b818103818111156104835761048361045c565b92915050565b6001815b60018411156104c4578085048111156104a8576104a861045c565b60018416156104b657908102905b60019390931c92800261048d565b935093915050565b5f826104da57506001610483565b816104e657505f610483565b81600181146104fc576002811461050657610522565b6001915050610483565b60ff8411156105175761051761045c565b50506001821b610483565b5060208310610133831016604e8410600b8410161715610545575081810a610483565b6105515f198484610489565b805f19048211156105645761056461045c565b029392505050565b5f61043583836104cc565b60805160a05160c05160e05161010051610120516101405161016051610180516101a051610c206106395f395f61014e01525f81816101f301528181610487015281816104b2015261066e01525f81816101cc01528181610463015281816104d6015261062b01525f61021a01525f60e301525f8181610241015281816105b601526106ae01525f8181610187015261043401525f8181610268015261040201525f818161028f015261037b01525f818161012701526102f40152610c205ff3fe608060405234801561000f575f5ffd5b50600436106100da575f3560e01c80637bdd6b4411610088578063db5537e111610063578063db5537e11461023c578063dcd7240814610263578063ef8300001461028a578063feaf968c146102b1575f5ffd5b80637bdd6b44146101c7578063a28af8a4146101ee578063d21220a714610215575f5ffd5b80633f337e6c116100b85780633f337e6c1461018257806350d25bcd146101b75780636a146024146101bf575f5ffd5b80630dfe1681146100de57806313b6193714610122578063313ce56714610149575b5f5ffd5b6101057f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b6101057f000000000000000000000000000000000000000000000000000000000000000081565b6101707f000000000000000000000000000000000000000000000000000000000000000081565b60405160ff9091168152602001610119565b6101a97f000000000000000000000000000000000000000000000000000000000000000081565b604051908152602001610119565b6101a96102f0565b6101a9601281565b6101707f000000000000000000000000000000000000000000000000000000000000000081565b6101707f000000000000000000000000000000000000000000000000000000000000000081565b6101057f000000000000000000000000000000000000000000000000000000000000000081565b6101057f000000000000000000000000000000000000000000000000000000000000000081565b6101a97f000000000000000000000000000000000000000000000000000000000000000081565b6101057f000000000000000000000000000000000000000000000000000000000000000081565b6102b9610790565b6040805169ffffffffffffffffffff968716815260208101959095528401929092526060830152909116608082015260a001610119565b5f5f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa15801561034e573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061037291906109de565b5050509150505f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa1580156103d5573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906103f991906109de565b5050509150505f7f00000000000000000000000000000000000000000000000000000000000000008361042c9190610a40565b90505f6104597f000000000000000000000000000000000000000000000000000000000000000084610a40565b90505f5f5f6104ae7f000000000000000000000000000000000000000000000000000000000000000060ff167f000000000000000000000000000000000000000000000000000000000000000060ff166107b0565b90507f000000000000000000000000000000000000000000000000000000000000000060ff167f000000000000000000000000000000000000000000000000000000000000000060ff1610610513576001925061050c81600a610b3a565b9150610525565b61051e81600a610b3a565b9250600191505b5f6105308386610a40565b61053a8588610a40565b61054c90670de0b6b3a7640000610a40565b6105569190610b45565b90505f610590633b9aca0061056a846107db565b610581906c01000000000000000000000000610a40565b61058b9190610b45565b610958565b60405163b670ed7d60e01b81526001600160a01b0382811660048301529192505f9182917f00000000000000000000000000000000000000000000000000000000000000009091169063b670ed7d906024016040805180830381865afa1580156105fc573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106209190610b64565b90925090505f6106517f00000000000000000000000000000000000000000000000000000000000000006012610b86565b61065c90600a610b9f565b6106669084610a40565b90505f6106947f00000000000000000000000000000000000000000000000000000000000000006012610b86565b61069f90600a610b9f565b6106a99084610a40565b90505f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610708573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061072c9190610bad565b9050805f03610749575f9e50505050505050505050505050505090565b5f6107548c84610a40565b61075e8e86610a40565b6107689190610bc4565b905061077c6107778383610b45565b610994565b9f5050505050505050505050505050505090565b5f5f5f5f5f5f61079e6102f0565b90969095505f94508493508392509050565b5f818310156107c8576107c38383610bd7565b6107d2565b6107d28284610bd7565b90505b92915050565b5f815f036107ea57505f919050565b816001600160801b82106108035760809190911c9060401b5b68010000000000000000821061081e5760409190911c9060201b5b64010000000082106108355760209190911c9060101b5b62010000821061084a5760109190911c9060081b5b610100821061085e5760089190911c9060041b5b601082106108715760049190911c9060021b5b6008821061087d5760011b5b60016108898286610b45565b6108939083610bc4565b901c905060016108a38286610b45565b6108ad9083610bc4565b901c905060016108bd8286610b45565b6108c79083610bc4565b901c905060016108d78286610b45565b6108e19083610bc4565b901c905060016108f18286610b45565b6108fb9083610bc4565b901c9050600161090b8286610b45565b6109159083610bc4565b901c905060016109258286610b45565b61092f9083610bc4565b901c90505f61093e8286610b45565b905080821061094d578061094f565b815b95945050505050565b5f6001600160a01b03821115610990576040516306dfcc6560e41b815260a06004820152602481018390526044015b60405180910390fd5b5090565b5f6001600160ff1b038211156109905760405163123baf0360e11b815260048101839052602401610987565b805169ffffffffffffffffffff811681146109d9575f5ffd5b919050565b5f5f5f5f5f60a086880312156109f2575f5ffd5b6109fb866109c0565b60208701516040880151606089015192975090955093509150610a20608087016109c0565b90509295509295909350565b634e487b7160e01b5f52601160045260245ffd5b80820281158282048414176107d5576107d5610a2c565b6001815b6001841115610a9257808504811115610a7657610a76610a2c565b6001841615610a8457908102905b60019390931c928002610a5b565b935093915050565b5f82610aa8575060016107d5565b81610ab457505f6107d5565b8160018114610aca5760028114610ad457610af0565b60019150506107d5565b60ff841115610ae557610ae5610a2c565b50506001821b6107d5565b5060208310610133831016604e8410600b8410161715610b13575081810a6107d5565b610b1f5f198484610a57565b805f1904821115610b3257610b32610a2c565b029392505050565b5f6107d28383610a9a565b5f82610b5f57634e487b7160e01b5f52601260045260245ffd5b500490565b5f5f60408385031215610b75575f5ffd5b505080516020909101519092909150565b60ff82811682821603908111156107d5576107d5610a2c565b5f6107d260ff841683610a9a565b5f60208284031215610bbd575f5ffd5b5051919050565b808201808211156107d5576107d5610a2c565b818103818111156107d5576107d5610a2c56fea2646970667358221220b6d3ad23d8983141785fb8e273dcab867f9f115bff518cb24165e62f3f8d99f164736f6c634300081c0033000000000000000000000000f06ea29fcf4765200742d29e685973a1870eac9800000000000000000000000016950c5978880537117f159a492805c021dd44eb000000000000000000000000e8de4c60da9c00da512c827e02224c8609fc916a",
  "artifact_path": "KodiakIslandAggregator.sol",
  "artifact_full_path": "KodiakIslandAggregator.sol:KodiakIslandAggregator",
  "standardJsonInput": {
    "language": "Solidity",
    "sources": {
      "src/oracles/aggregators/KodiakIslandAggregator.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\nimport {IAggregator} from \"/interfaces/IAggregator.sol\";\nimport {BabylonianLib} from \"/libraries/BabylonianLib.sol\";\nimport {IKodiakVaultV1} from \"/interfaces/IKodiak.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {MathLib} from \"/libraries/MathLib.sol\";\n\ncontract KodiakIslandAggregator is IAggregator {\n    uint256 public constant WAD = 18;\n\n    error ErrInvalidDecimals();\n\n    IAggregator public immutable tokenAggregator0;\n    IAggregator public immutable tokenAggregator1;\n\n    uint256 public immutable aggregatorDecimalScale0;\n    uint256 public immutable aggregatorDecimalScale1;\n\n    IKodiakVaultV1 public immutable island;\n    address public immutable token0;\n    address public immutable token1;\n    uint8 public immutable decimals0;\n    uint8 public immutable decimals1;\n\n    uint8 public immutable override decimals;\n\n    constructor(IKodiakVaultV1 _island, IAggregator _tokenAggregator0, IAggregator _tokenAggregator1) {\n        island = _island;\n        tokenAggregator0 = _tokenAggregator0;\n        tokenAggregator1 = _tokenAggregator1;\n        token0 = island.token0();\n        token1 = island.token1();\n        decimals0 = IERC20Metadata(token0).decimals();\n        decimals1 = IERC20Metadata(token1).decimals();\n        aggregatorDecimalScale0 = 10 ** (WAD - tokenAggregator0.decimals());\n        aggregatorDecimalScale1 = 10 ** (WAD - tokenAggregator1.decimals());\n        decimals = IERC20Metadata(address(island)).decimals();\n\n        require(decimals == WAD, ErrInvalidDecimals());\n    }\n\n    function latestAnswer() public view override returns (int256) {\n        (, int256 feed0, , , ) = tokenAggregator0.latestRoundData();\n        (, int256 feed1, , , ) = tokenAggregator1.latestRoundData();\n\n        uint256 priceFeed_token0 = uint256(feed0) * aggregatorDecimalScale0;\n        uint256 priceFeed_token1 = uint256(feed1) * aggregatorDecimalScale1;\n\n        uint decimalMultiplier;\n        uint decimalDivider;\n        uint decimalDifference = MathLib.absoluteDifference(decimals0, decimals1);\n        if (decimals0 >= decimals1) {\n            decimalMultiplier = 1;\n            decimalDivider = 10 ** decimalDifference;\n        } else {\n            decimalMultiplier = 10 ** decimalDifference;\n            decimalDivider = 1;\n        }\n\n        uint priceRatio = (priceFeed_token0 * decimalMultiplier * 1e18) / (priceFeed_token1 * decimalDivider);\n\n        uint160 price_sqrtRatioX96 = SafeCast.toUint160((BabylonianLib.sqrt(priceRatio) * (2 ** 96)) / 1e9);\n\n        // Note: getUnderlyingBalancesAtPrice gets the reserves at a specified price based on UniV3 curve math + accumulated fees + token balances in contract\n        // The token reserve math is as described here: https://docs.parallel.fi/parallel-finance/staking-and-derivative-token-yield-management/borrow-against-uniswap-v3-lp-tokens/uniswap-v3-lp-token-analyzer\n        // As we use oracle price (rather than current bock pool balances) to get the reserves, this calculation isn't subject to flash loan exploit\n        (uint reserve0, uint reserve1) = IKodiakVaultV1(island).getUnderlyingBalancesAtPrice(price_sqrtRatioX96);\n\n        uint normalizedReserve0 = reserve0 * (10 ** (18 - decimals0));\n        uint normalizedReserve1 = reserve1 * (10 ** (18 - decimals1));\n\n        uint totalSupply = IKodiakVaultV1(island).totalSupply();\n\n        if (totalSupply == 0) return 0;\n\n        uint totalValue = normalizedReserve0 * priceFeed_token0 + normalizedReserve1 * priceFeed_token1;\n\n        return SafeCast.toInt256(totalValue / totalSupply);\n    }\n\n    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {\n        return (0, latestAnswer(), 0, 0, 0);\n    }\n}\n"
      },
      "dependencies/openzeppelin-contracts-5.0.2/contracts/interfaces/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n"
      },
      "src/interfaces/IAggregator.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IAggregator {\n    function decimals() external view returns (uint8);\n\n    function latestAnswer() external view returns (int256 answer);\n\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n\ninterface IAggregatorWithMeta is IAggregator {\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n}\n"
      },
      "src/libraries/BabylonianLib.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\n/// @notice Babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method).\nlibrary BabylonianLib {\n    // computes square roots using the babylonian method\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}"
      },
      "src/interfaces/IKodiak.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\ninterface IKodiakVaultV1 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function totalSupply() external view returns (uint256);\n\n    function getUnderlyingBalancesAtPrice(uint160 sqrtRatioX96) external view returns (uint256 amount0Current, uint256 amount1Current);\n\n    function getUnderlyingBalances() external view returns (uint256 amount0Current, uint256 amount1Current);\n}\n\ninterface IKodiakV1RouterStaking {\n    function addLiquidity(\n        IKodiakVaultV1 pool,\n        uint256 amount0Max,\n        uint256 amount1Max,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        uint256 amountSharesMin,\n        address receiver\n    ) external returns (uint256 amount0, uint256 amount1, uint256 mintAmount);\n\n    function addLiquidityETH(\n        IKodiakVaultV1 pool,\n        uint256 amount0Max,\n        uint256 amount1Max,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        uint256 amountSharesMin,\n        address receiver\n    ) external payable returns (uint256 amount0, uint256 amount1, uint256 mintAmount);\n\n    function removeLiquidity(\n        IKodiakVaultV1 pool,\n        uint256 burnAmount,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        address receiver\n    ) external returns (uint256 amount0, uint256 amount1, uint128 liquidityBurned);\n\n    function removeLiquidityETH(\n        IKodiakVaultV1 pool,\n        uint256 burnAmount,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        address payable receiver\n    ) external returns (uint256 amount0, uint256 amount1, uint128 liquidityBurned);\n}\n"
      },
      "dependencies/openzeppelin-contracts-5.0.2/contracts/utils/math/SafeCast.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n"
      },
      "src/libraries/MathLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nlibrary MathLib {\n    function max(uint256[] memory values) internal pure returns (uint256) {\n        uint256 maxValue = values[0];\n        for (uint256 i = 1; i < values.length; i++) {\n            if (values[i] > maxValue) {\n                maxValue = values[i];\n            }\n        }\n        return maxValue;\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    function min(uint256[] memory values) internal pure returns (uint256) {\n        uint256 minValue = values[0];\n        for (uint256 i = 1; i < values.length; i++) {\n            if (values[i] < minValue) {\n                minValue = values[i];\n            }\n        }\n        return minValue;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function subWithZeroFloor(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : 0;\n    }\n\n    function absoluteDifference(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a >= b) ? a - b : b - a;\n    }\n}\n"
      },
      "dependencies/openzeppelin-contracts-5.0.2/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
      },
      "dependencies/openzeppelin-contracts-5.0.2/contracts/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      }
    },
    "settings": {
      "remappings": [
        "/=src/",
        "forge-std/=dependencies/forge-std-1.9.5/src/",
        "halmos-cheatcodes/=dependencies/halmos-cheatcodes-7328abe/src/",
        "@openzeppelin/contracts/=dependencies/openzeppelin-contracts-5.0.2/contracts/",
        "@openzeppelin/contracts-upgradeable/=dependencies/openzeppelin-contracts-upgradeable-5.0.2/contracts/",
        "@BoringSolidity/=dependencies/BoringSolidity-1.0.0/contracts/",
        "@solady/=dependencies/solady-0.0.281/src/",
        "@solmate/=dependencies/solmate-6.2.0/src/",
        "@excessivelySafeCall/=dependencies/ExcessivelySafeCall-0.0.1/src/",
        "@safe-contracts/=dependencies/safe-contracts-1.3.0/contracts/",
        "@fuzzlib/=dependencies/fuzzlib-0.0.1/src/",
        "@abracadabra-oft-v1/=dependencies/abracadabra-oft-v1-0.0.1/src/",
        "@prb/math/=dependencies/prb-math-4.1.0/src/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 400
      },
      "metadata": {
        "useLiteralContent": false,
        "bytecodeHash": "ipfs",
        "appendCBOR": true
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode.object",
            "evm.bytecode.sourceMap",
            "evm.bytecode.linkReferences",
            "evm.deployedBytecode.object",
            "evm.deployedBytecode.sourceMap",
            "evm.deployedBytecode.linkReferences",
            "evm.deployedBytecode.immutableReferences",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "evmVersion": "cancun",
      "viaIR": false,
      "libraries": {}
    }
  },
  "compiler": "0.8.28+commit.7893614a"
}