{
  "address": "0x991536BF23fa40B578Fc3e1e3725E51D1bF889F3",
  "abi": [
    {
      "type": "constructor",
      "inputs": [
        {
          "name": "_box",
          "type": "address",
          "internalType": "contract IBentoBoxLite"
        },
        {
          "name": "_vault",
          "type": "address",
          "internalType": "contract IERC4626"
        },
        {
          "name": "_mim",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_poolId",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "receive",
      "stateMutability": "payable"
    },
    {
      "type": "function",
      "name": "box",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IBentoBoxLite"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "mim",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "poolId",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "swap",
      "inputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "recipient",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "shareToMin",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "shareFrom",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "data",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "extraShare",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "shareReturned",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "tokens",
      "inputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "vault",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IERC4626"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "error",
      "name": "AddressEmptyCode",
      "inputs": [
        {
          "name": "target",
          "type": "address",
          "internalType": "address"
        }
      ]
    },
    {
      "type": "error",
      "name": "AddressInsufficientBalance",
      "inputs": [
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        }
      ]
    },
    {
      "type": "error",
      "name": "ErrInvalidNumTokens",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrInvalidPool",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrInvalidPool",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrNotAllowed",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrSwapFailed",
      "inputs": []
    },
    {
      "type": "error",
      "name": "FailedInnerCall",
      "inputs": []
    }
  ],
  "bytecode": "0x610100604052348015610010575f5ffd5b5060405161168c38038061168c83398101604081905261002f9161033a565b6001600160a01b0380851660805283811660a081905290831660c05260e0829052604080516338d52e0f60e01b815290516338d52e0f916004808201926020929091908290030181865afa158015610089573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906100ad919061038a565b6001600160a01b03166100bf82610127565b6001600160a01b0316146100e65760405163a8c04abf60e01b815260040160405180910390fd5b60e0516100f2906101d9565b8051610105915f916020909101906102ac565b5060c05161011e906001600160a01b0316855f19610259565b5050505061059b565b60405163f6c0092760e01b8152600481018290525f908190734be03f781c497a489e3cb0287833452ca9b9e80b9063f6c00927906024016040805180830381865afa158015610178573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061019c91906103ac565b909250905060028160028111156101b5576101b56103e7565b146101d35760405163a8c04abf60e01b815260040160405180910390fd5b50919050565b604051631f29a8cd60e31b815260048101829052606090734be03f781c497a489e3cb0287833452ca9b9e80b9063f94d4668906024015f60405180830381865afa158015610229573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405261025091908101906104cb565b50909392505050565b81601452806034526f095ea7b30000000000000000000000005f5260205f604460105f875af18060015f5114166102a257803d853b1517106102a257633e3f8f735f526004601cfd5b505f603452505050565b828054828255905f5260205f209081019282156102ff579160200282015b828111156102ff57825182546001600160a01b0319166001600160a01b039091161782556020909201916001909101906102ca565b5061030b92915061030f565b5090565b5b8082111561030b575f8155600101610310565b6001600160a01b0381168114610337575f5ffd5b50565b5f5f5f5f6080858703121561034d575f5ffd5b845161035881610323565b602086015190945061036981610323565b604086015190935061037a81610323565b6060959095015193969295505050565b5f6020828403121561039a575f5ffd5b81516103a581610323565b9392505050565b5f5f604083850312156103bd575f5ffd5b82516103c881610323565b6020840151909250600381106103dc575f5ffd5b809150509250929050565b634e487b7160e01b5f52602160045260245ffd5b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f191681016001600160401b0381118282101715610437576104376103fb565b604052919050565b5f6001600160401b03821115610457576104576103fb565b5060051b60200190565b5f82601f830112610470575f5ffd5b815161048361047e8261043f565b61040f565b8082825260208201915060208360051b8601019250858311156104a4575f5ffd5b602085015b838110156104c15780518352602092830192016104a9565b5095945050505050565b5f5f5f606084860312156104dd575f5ffd5b83516001600160401b038111156104f2575f5ffd5b8401601f81018613610502575f5ffd5b805161051061047e8261043f565b8082825260208201915060208360051b850101925088831115610531575f5ffd5b6020840193505b8284101561055c57835161054b81610323565b825260209384019390910190610538565b6020880151909650925050506001600160401b0381111561057b575f5ffd5b61058786828701610461565b604095909501519396949550929392505050565b60805160a05160c05160e05161108e6105fe5f395f81816099015261037501525f81816101490152818161077b01526107a201525f81816101b00152818161022001526102fc01525f81816101160152818161026a015261074c015261108e5ff3fe608060405260043610610066575f3560e01c80639f67679e116100415780639f67679e14610138578063a5d4096b1461016b578063fbfa77cf1461019f575f5ffd5b80633e0dc34e146100885780634f64b2be146100ce578063754215a114610105575f5ffd5b3661008457604051630dfa0b4d60e21b815260040160405180910390fd5b5f5ffd5b348015610093575f5ffd5b506100bb7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b3480156100d9575f5ffd5b506100ed6100e8366004610b71565b6101d2565b6040516001600160a01b0390911681526020016100c5565b348015610110575f5ffd5b506100ed7f000000000000000000000000000000000000000000000000000000000000000081565b348015610143575f5ffd5b506100ed7f000000000000000000000000000000000000000000000000000000000000000081565b348015610176575f5ffd5b5061018a610185366004610ba3565b6101f9565b604080519283526020830191909152016100c5565b3480156101aa575f5ffd5b506100ed7f000000000000000000000000000000000000000000000000000000000000000081565b5f81815481106101e0575f80fd5b5f918252602090912001546001600160a01b0316905081565b5f80808061020985870187610daa565b60405163097da6d360e41b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152306024830181905260448301525f60648301819052608483018c90529395509193507f0000000000000000000000000000000000000000000000000000000000000000909116906397da6d309060a40160408051808303815f875af11580156102b1573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906102d59190610e6d565b50604051635d043b2960e11b815260048101829052306024820181905260448201529091507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063ba087652906064016020604051808303815f875af115801561034a573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061036e9190610e8f565b90506104277f00000000000000000000000000000000000000000000000000000000000000005f8054806020026020016040519081016040528092919081815260200182805480156103e757602002820191905f5260205f20905b81546001600160a01b031681526001909101906020018083116103c9575b50879350600292506103f7915050565b604051908082528060200260200182016040528015610420578160200160208202803683370190505b5030610892565b5f195f5f8154811061043b5761043b610ea6565b5f91825260208220015485516001600160a01b039091169163dd62ed3e913091889161046957610469610ea6565b60200260200101516040518363ffffffff1660e01b81526004016104a39291906001600160a01b0392831681529116602082015260400190565b602060405180830381865afa1580156104be573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906104e29190610e8f565b1461053357610533835f815181106104fc576104fc610ea6565b60200260200101515f195f5f8154811061051857610518610ea6565b5f918252602090912001546001600160a01b03169190610967565b61056f835f8151811061054857610548610ea6565b6020026020010151835f8151811061056257610562610ea6565b60200260200101516109ba565b505f6105a1305f5f8154811061058757610587610ea6565b5f918252602090912001546001600160a01b0316906109d0565b905080156105db576105db8b825f5f815481106105c0576105c0610ea6565b5f918252602090912001546001600160a01b03169190610a03565b505f195f6001815481106105f1576105f1610ea6565b905f5260205f20015f9054906101000a90046001600160a01b03166001600160a01b031663dd62ed3e308660018151811061062e5761062e610ea6565b60200260200101516040518363ffffffff1660e01b81526004016106689291906001600160a01b0392831681529116602082015260400190565b602060405180830381865afa158015610683573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106a79190610e8f565b146106df576106df836001815181106106c2576106c2610ea6565b60200260200101515f195f60018154811061051857610518610ea6565b610710836001815181106106f5576106f5610ea6565b60200260200101518360018151811061056257610562610ea6565b505f610729305f60018154811061058757610587610ea6565b90508015610749576107498b825f6001815481106105c0576105c0610ea6565b507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166302b9446c7f0000000000000000000000000000000000000000000000000000000000000000308d6107d8307f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166109d090919063ffffffff16565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e087901b1681526001600160a01b03948516600482015292841660248401529216604482015260648101919091525f608482015260a40160408051808303815f875af115801561084f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906108739190610e6d565b945061088190508985610eba565b945050505097509795505050505050565b83516002146108b457604051631a64250d60e01b815260040160405180910390fd5b5f6001846040516020016108c9929190610ed9565b60408051601f19818403018152608083018252878352602083018690528282018190525f60608401529051638bdb391360e01b8152909250734be03f781c497a489e3cb0287833452ca9b9e80b90638bdb391390610931908a90309088908790600401610f6b565b5f604051808303815f87803b158015610948575f5ffd5b505af115801561095a573d5f5f3e3d5ffd5b5050505050505050505050565b81601452806034526f095ea7b30000000000000000000000005f5260205f604460105f875af18060015f5114166109b057803d853b1517106109b057633e3f8f735f526004601cfd5b505f603452505050565b60606109c783835f610a4c565b90505b92915050565b5f816014526f70a082310000000000000000000000005f5260208060246010865afa601f3d111660205102905092915050565b81601452806034526fa9059cbb0000000000000000000000005f5260205f604460105f875af18060015f5114166109b057803d853b1517106109b0576390b8ec185f526004601cfd5b606081471015610a765760405163cd78605960e01b81523060048201526024015b60405180910390fd5b5f5f856001600160a01b03168486604051610a919190611042565b5f6040518083038185875af1925050503d805f8114610acb576040519150601f19603f3d011682016040523d82523d5f602084013e610ad0565b606091505b5091509150610ae0868383610aec565b925050505b9392505050565b606082610b0157610afc82610b48565b610ae5565b8151158015610b1857506001600160a01b0384163b155b15610b4157604051639996b31560e01b81526001600160a01b0385166004820152602401610a6d565b5080610ae5565b805115610b585780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b5f60208284031215610b81575f5ffd5b5035919050565b80356001600160a01b0381168114610b9e575f5ffd5b919050565b5f5f5f5f5f5f5f60c0888a031215610bb9575f5ffd5b610bc288610b88565b9650610bd060208901610b88565b9550610bde60408901610b88565b9450606088013593506080880135925060a088013567ffffffffffffffff811115610c07575f5ffd5b8801601f81018a13610c17575f5ffd5b803567ffffffffffffffff811115610c2d575f5ffd5b8a6020828401011115610c3e575f5ffd5b602082019350809250505092959891949750929550565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff81118282101715610c9257610c92610c55565b604052919050565b5f67ffffffffffffffff821115610cb357610cb3610c55565b5060051b60200190565b5f82601f830112610ccc575f5ffd5b8135610cdf610cda82610c9a565b610c69565b8082825260208201915060208360051b860101925085831115610d00575f5ffd5b602085015b83811015610da057803567ffffffffffffffff811115610d23575f5ffd5b8601603f81018813610d33575f5ffd5b602081013567ffffffffffffffff811115610d5057610d50610c55565b610d63601f8201601f1916602001610c69565b8181526040838301018a1015610d77575f5ffd5b816040840160208301375f60208383010152808652505050602083019250602081019050610d05565b5095945050505050565b5f5f60408385031215610dbb575f5ffd5b823567ffffffffffffffff811115610dd1575f5ffd5b8301601f81018513610de1575f5ffd5b8035610def610cda82610c9a565b8082825260208201915060208360051b850101925087831115610e10575f5ffd5b6020840193505b82841015610e3957610e2884610b88565b825260209384019390910190610e17565b9450505050602083013567ffffffffffffffff811115610e57575f5ffd5b610e6385828601610cbd565b9150509250929050565b5f5f60408385031215610e7e575f5ffd5b505080516020909101519092909150565b5f60208284031215610e9f575f5ffd5b5051919050565b634e487b7160e01b5f52603260045260245ffd5b818103818111156109ca57634e487b7160e01b5f52601160045260245ffd5b6040810160038410610ef957634e487b7160e01b5f52602160045260245ffd5b9281526020015290565b5f8151808452602084019350602083015f5b82811015610f33578151865260209586019590910190600101610f15565b5093949350505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b8481526001600160a01b03841660208201526001600160a01b0383166040820152608060608201525f61010082018351608080850152818151808452610120860191506020830193505f92505b80831015610fe4576001600160a01b038451168252602082019150602084019350600183019250610fb8565b506020860151858203607f190160a087015292506110028184610f03565b925050506040840151607f198483030160c08501526110218282610f3d565b915050606084015161103760e085018215159052565b509695505050505050565b5f82518060208501845e5f92019182525091905056fea2646970667358221220e382227adc8d1ed528cf87f0f73137edf0045e4a0baa7558a05e4afe1acbb4a364736f6c634300081c0033",
  "args_data": "0x000000000000000000000000b9565f2612e35cd58513145f1c7ed790504f265a0000000000000000000000009b0e08665be0bd1bc9da04d39234110afbe795be0000000000000000000000005b82028cfc477c4e7dda7ff33d59a23fa7be002a38fdd999fe8783037db1bbfe465759e312f2d809000200000000000000000004",
  "tx_hash": "0xbce30ce967a0fb17d91e0b90ac02aa6c93f914f7e75408aee71ab1fe25246665",
  "args": [
    "0xB9565f2612E35Cd58513145F1C7Ed790504F265A",
    "0x9b0E08665be0bD1bC9DA04d39234110AFbE795BE",
    "0x5B82028cfc477C4E7ddA7FF33d59A23FA7Be002a",
    "0x38fdd999fe8783037db1bbfe465759e312f2d809000200000000000000000004"
  ],
  "data": "0x610100604052348015610010575f5ffd5b5060405161168c38038061168c83398101604081905261002f9161033a565b6001600160a01b0380851660805283811660a081905290831660c05260e0829052604080516338d52e0f60e01b815290516338d52e0f916004808201926020929091908290030181865afa158015610089573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906100ad919061038a565b6001600160a01b03166100bf82610127565b6001600160a01b0316146100e65760405163a8c04abf60e01b815260040160405180910390fd5b60e0516100f2906101d9565b8051610105915f916020909101906102ac565b5060c05161011e906001600160a01b0316855f19610259565b5050505061059b565b60405163f6c0092760e01b8152600481018290525f908190734be03f781c497a489e3cb0287833452ca9b9e80b9063f6c00927906024016040805180830381865afa158015610178573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061019c91906103ac565b909250905060028160028111156101b5576101b56103e7565b146101d35760405163a8c04abf60e01b815260040160405180910390fd5b50919050565b604051631f29a8cd60e31b815260048101829052606090734be03f781c497a489e3cb0287833452ca9b9e80b9063f94d4668906024015f60405180830381865afa158015610229573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405261025091908101906104cb565b50909392505050565b81601452806034526f095ea7b30000000000000000000000005f5260205f604460105f875af18060015f5114166102a257803d853b1517106102a257633e3f8f735f526004601cfd5b505f603452505050565b828054828255905f5260205f209081019282156102ff579160200282015b828111156102ff57825182546001600160a01b0319166001600160a01b039091161782556020909201916001909101906102ca565b5061030b92915061030f565b5090565b5b8082111561030b575f8155600101610310565b6001600160a01b0381168114610337575f5ffd5b50565b5f5f5f5f6080858703121561034d575f5ffd5b845161035881610323565b602086015190945061036981610323565b604086015190935061037a81610323565b6060959095015193969295505050565b5f6020828403121561039a575f5ffd5b81516103a581610323565b9392505050565b5f5f604083850312156103bd575f5ffd5b82516103c881610323565b6020840151909250600381106103dc575f5ffd5b809150509250929050565b634e487b7160e01b5f52602160045260245ffd5b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f191681016001600160401b0381118282101715610437576104376103fb565b604052919050565b5f6001600160401b03821115610457576104576103fb565b5060051b60200190565b5f82601f830112610470575f5ffd5b815161048361047e8261043f565b61040f565b8082825260208201915060208360051b8601019250858311156104a4575f5ffd5b602085015b838110156104c15780518352602092830192016104a9565b5095945050505050565b5f5f5f606084860312156104dd575f5ffd5b83516001600160401b038111156104f2575f5ffd5b8401601f81018613610502575f5ffd5b805161051061047e8261043f565b8082825260208201915060208360051b850101925088831115610531575f5ffd5b6020840193505b8284101561055c57835161054b81610323565b825260209384019390910190610538565b6020880151909650925050506001600160401b0381111561057b575f5ffd5b61058786828701610461565b604095909501519396949550929392505050565b60805160a05160c05160e05161108e6105fe5f395f81816099015261037501525f81816101490152818161077b01526107a201525f81816101b00152818161022001526102fc01525f81816101160152818161026a015261074c015261108e5ff3fe608060405260043610610066575f3560e01c80639f67679e116100415780639f67679e14610138578063a5d4096b1461016b578063fbfa77cf1461019f575f5ffd5b80633e0dc34e146100885780634f64b2be146100ce578063754215a114610105575f5ffd5b3661008457604051630dfa0b4d60e21b815260040160405180910390fd5b5f5ffd5b348015610093575f5ffd5b506100bb7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b3480156100d9575f5ffd5b506100ed6100e8366004610b71565b6101d2565b6040516001600160a01b0390911681526020016100c5565b348015610110575f5ffd5b506100ed7f000000000000000000000000000000000000000000000000000000000000000081565b348015610143575f5ffd5b506100ed7f000000000000000000000000000000000000000000000000000000000000000081565b348015610176575f5ffd5b5061018a610185366004610ba3565b6101f9565b604080519283526020830191909152016100c5565b3480156101aa575f5ffd5b506100ed7f000000000000000000000000000000000000000000000000000000000000000081565b5f81815481106101e0575f80fd5b5f918252602090912001546001600160a01b0316905081565b5f80808061020985870187610daa565b60405163097da6d360e41b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152306024830181905260448301525f60648301819052608483018c90529395509193507f0000000000000000000000000000000000000000000000000000000000000000909116906397da6d309060a40160408051808303815f875af11580156102b1573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906102d59190610e6d565b50604051635d043b2960e11b815260048101829052306024820181905260448201529091507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063ba087652906064016020604051808303815f875af115801561034a573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061036e9190610e8f565b90506104277f00000000000000000000000000000000000000000000000000000000000000005f8054806020026020016040519081016040528092919081815260200182805480156103e757602002820191905f5260205f20905b81546001600160a01b031681526001909101906020018083116103c9575b50879350600292506103f7915050565b604051908082528060200260200182016040528015610420578160200160208202803683370190505b5030610892565b5f195f5f8154811061043b5761043b610ea6565b5f91825260208220015485516001600160a01b039091169163dd62ed3e913091889161046957610469610ea6565b60200260200101516040518363ffffffff1660e01b81526004016104a39291906001600160a01b0392831681529116602082015260400190565b602060405180830381865afa1580156104be573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906104e29190610e8f565b1461053357610533835f815181106104fc576104fc610ea6565b60200260200101515f195f5f8154811061051857610518610ea6565b5f918252602090912001546001600160a01b03169190610967565b61056f835f8151811061054857610548610ea6565b6020026020010151835f8151811061056257610562610ea6565b60200260200101516109ba565b505f6105a1305f5f8154811061058757610587610ea6565b5f918252602090912001546001600160a01b0316906109d0565b905080156105db576105db8b825f5f815481106105c0576105c0610ea6565b5f918252602090912001546001600160a01b03169190610a03565b505f195f6001815481106105f1576105f1610ea6565b905f5260205f20015f9054906101000a90046001600160a01b03166001600160a01b031663dd62ed3e308660018151811061062e5761062e610ea6565b60200260200101516040518363ffffffff1660e01b81526004016106689291906001600160a01b0392831681529116602082015260400190565b602060405180830381865afa158015610683573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106a79190610e8f565b146106df576106df836001815181106106c2576106c2610ea6565b60200260200101515f195f60018154811061051857610518610ea6565b610710836001815181106106f5576106f5610ea6565b60200260200101518360018151811061056257610562610ea6565b505f610729305f60018154811061058757610587610ea6565b90508015610749576107498b825f6001815481106105c0576105c0610ea6565b507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166302b9446c7f0000000000000000000000000000000000000000000000000000000000000000308d6107d8307f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166109d090919063ffffffff16565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e087901b1681526001600160a01b03948516600482015292841660248401529216604482015260648101919091525f608482015260a40160408051808303815f875af115801561084f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906108739190610e6d565b945061088190508985610eba565b945050505097509795505050505050565b83516002146108b457604051631a64250d60e01b815260040160405180910390fd5b5f6001846040516020016108c9929190610ed9565b60408051601f19818403018152608083018252878352602083018690528282018190525f60608401529051638bdb391360e01b8152909250734be03f781c497a489e3cb0287833452ca9b9e80b90638bdb391390610931908a90309088908790600401610f6b565b5f604051808303815f87803b158015610948575f5ffd5b505af115801561095a573d5f5f3e3d5ffd5b5050505050505050505050565b81601452806034526f095ea7b30000000000000000000000005f5260205f604460105f875af18060015f5114166109b057803d853b1517106109b057633e3f8f735f526004601cfd5b505f603452505050565b60606109c783835f610a4c565b90505b92915050565b5f816014526f70a082310000000000000000000000005f5260208060246010865afa601f3d111660205102905092915050565b81601452806034526fa9059cbb0000000000000000000000005f5260205f604460105f875af18060015f5114166109b057803d853b1517106109b0576390b8ec185f526004601cfd5b606081471015610a765760405163cd78605960e01b81523060048201526024015b60405180910390fd5b5f5f856001600160a01b03168486604051610a919190611042565b5f6040518083038185875af1925050503d805f8114610acb576040519150601f19603f3d011682016040523d82523d5f602084013e610ad0565b606091505b5091509150610ae0868383610aec565b925050505b9392505050565b606082610b0157610afc82610b48565b610ae5565b8151158015610b1857506001600160a01b0384163b155b15610b4157604051639996b31560e01b81526001600160a01b0385166004820152602401610a6d565b5080610ae5565b805115610b585780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b5f60208284031215610b81575f5ffd5b5035919050565b80356001600160a01b0381168114610b9e575f5ffd5b919050565b5f5f5f5f5f5f5f60c0888a031215610bb9575f5ffd5b610bc288610b88565b9650610bd060208901610b88565b9550610bde60408901610b88565b9450606088013593506080880135925060a088013567ffffffffffffffff811115610c07575f5ffd5b8801601f81018a13610c17575f5ffd5b803567ffffffffffffffff811115610c2d575f5ffd5b8a6020828401011115610c3e575f5ffd5b602082019350809250505092959891949750929550565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff81118282101715610c9257610c92610c55565b604052919050565b5f67ffffffffffffffff821115610cb357610cb3610c55565b5060051b60200190565b5f82601f830112610ccc575f5ffd5b8135610cdf610cda82610c9a565b610c69565b8082825260208201915060208360051b860101925085831115610d00575f5ffd5b602085015b83811015610da057803567ffffffffffffffff811115610d23575f5ffd5b8601603f81018813610d33575f5ffd5b602081013567ffffffffffffffff811115610d5057610d50610c55565b610d63601f8201601f1916602001610c69565b8181526040838301018a1015610d77575f5ffd5b816040840160208301375f60208383010152808652505050602083019250602081019050610d05565b5095945050505050565b5f5f60408385031215610dbb575f5ffd5b823567ffffffffffffffff811115610dd1575f5ffd5b8301601f81018513610de1575f5ffd5b8035610def610cda82610c9a565b8082825260208201915060208360051b850101925087831115610e10575f5ffd5b6020840193505b82841015610e3957610e2884610b88565b825260209384019390910190610e17565b9450505050602083013567ffffffffffffffff811115610e57575f5ffd5b610e6385828601610cbd565b9150509250929050565b5f5f60408385031215610e7e575f5ffd5b505080516020909101519092909150565b5f60208284031215610e9f575f5ffd5b5051919050565b634e487b7160e01b5f52603260045260245ffd5b818103818111156109ca57634e487b7160e01b5f52601160045260245ffd5b6040810160038410610ef957634e487b7160e01b5f52602160045260245ffd5b9281526020015290565b5f8151808452602084019350602083015f5b82811015610f33578151865260209586019590910190600101610f15565b5093949350505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b8481526001600160a01b03841660208201526001600160a01b0383166040820152608060608201525f61010082018351608080850152818151808452610120860191506020830193505f92505b80831015610fe4576001600160a01b038451168252602082019150602084019350600183019250610fb8565b506020860151858203607f190160a087015292506110028184610f03565b925050506040840151607f198483030160c08501526110218282610f3d565b915050606084015161103760e085018215159052565b509695505050505050565b5f82518060208501845e5f92019182525091905056fea2646970667358221220e382227adc8d1ed528cf87f0f73137edf0045e4a0baa7558a05e4afe1acbb4a364736f6c634300081c0033000000000000000000000000b9565f2612e35cd58513145f1c7ed790504f265a0000000000000000000000009b0e08665be0bd1bc9da04d39234110afbe795be0000000000000000000000005b82028cfc477c4e7dda7ff33d59a23fa7be002a38fdd999fe8783037db1bbfe465759e312f2d809000200000000000000000004",
  "artifact_path": "MagicBexVaultSwapper.sol",
  "artifact_full_path": "MagicBexVaultSwapper.sol:MagicBexVaultSwapper",
  "standardJsonInput": {
    "language": "Solidity",
    "sources": {
      "src/swappers/MagicBexVaultSwapper.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeTransferLib} from \"@solady/utils/SafeTransferLib.sol\";\nimport {IBentoBoxLite} from \"/interfaces/IBentoBoxV1.sol\";\nimport {ISwapperV2} from \"/interfaces/ISwapperV2.sol\";\nimport {IERC4626} from \"/interfaces/IERC4626.sol\";\nimport {BexLib} from \"../libraries/BexLib.sol\";\n\ncontract MagicBexVaultSwapper is ISwapperV2 {\n    using SafeTransferLib for address;\n\n    error ErrSwapFailed();\n    error ErrInvalidPool();\n    error ErrNotAllowed();\n\n    IBentoBoxLite public immutable box;\n    IERC4626 public immutable vault;\n    address public immutable mim;\n    address[] public tokens;\n    bytes32 public immutable poolId;\n\n    receive() external payable {\n        revert ErrNotAllowed();\n    }\n\n    constructor(IBentoBoxLite _box, IERC4626 _vault, address _mim, bytes32 _poolId) {\n        box = _box;\n        vault = _vault;\n        mim = _mim;\n        poolId = _poolId;\n\n        require(BexLib.getValidatedPool(_poolId) == _vault.asset(), ErrInvalidPool());\n        tokens = BexLib.getPoolTokens(poolId);\n        mim.safeApprove(address(_box), type(uint256).max);\n    }\n\n    function swap(\n        address,\n        address,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom,\n        bytes calldata data\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n        (address[] memory to, bytes[] memory swapData) = abi.decode(data, (address[], bytes[]));\n        (uint256 amount, ) = box.withdraw(address(vault), address(this), address(this), 0, shareFrom);\n\n        // ERC4626 -> BexVault\n        amount = IERC4626(address(vault)).redeem(amount, address(this), address(this));\n\n        // Pool -> Token0, Token1\n        // using the min amount out to 0 as it will be\n        // checked later with the min MIM share out\n        BexLib.exitPool(poolId, tokens, amount, new uint256[](2), address(this));\n\n        // Token0 -> MIM\n        {\n            if (IERC20Metadata(tokens[0]).allowance(address(this), to[0]) != type(uint256).max) {\n                tokens[0].safeApprove(to[0], type(uint256).max);\n            }\n\n            Address.functionCall(to[0], swapData[0]);\n\n            // Refund remaining balances to the recipient\n            uint256 balance = tokens[0].balanceOf(address(this));\n            if (balance > 0) {\n                tokens[0].safeTransfer(recipient, balance);\n            }\n        }\n\n        // Token1 -> MIM\n        {\n            if (IERC20Metadata(tokens[1]).allowance(address(this), to[1]) != type(uint256).max) {\n                tokens[1].safeApprove(to[1], type(uint256).max);\n            }\n\n            Address.functionCall(to[1], swapData[1]);\n\n            uint256 balance = tokens[1].balanceOf(address(this));\n            if (balance > 0) {\n                tokens[1].safeTransfer(recipient, balance);\n            }\n        }\n\n        (, shareReturned) = box.deposit(mim, address(this), recipient, mim.balanceOf(address(this)), 0);\n        extraShare = shareReturned - shareToMin;\n    }\n}\n"
      },
      "dependencies/openzeppelin-contracts-5.0.2/contracts/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
      },
      "dependencies/openzeppelin-contracts-5.0.2/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
      },
      "dependencies/solady-0.0.281/src/utils/SafeTransferLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\nlibrary SafeTransferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The ERC20 `totalSupply` query has failed.\n    error TotalSupplyQueryFailed();\n\n    /// @dev The Permit2 operation has failed.\n    error Permit2Failed();\n\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\n    error Permit2AmountOverflow();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\n\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// @dev The canonical Permit2 address.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                success := lt(or(iszero(extcodesize(token)), returndatasize()), success)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x34, 0) // Store 0 for the `amount`.\n                    mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                    pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                    mstore(0x34, amount) // Store back the original `amount`.\n                    // Retry the approval, reverting upon failure.\n                    success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    if iszero(and(eq(mload(0x00), 1), success)) {\n                        // Check the `extcodesize` again just in case the token selfdestructs lol.\n                        if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                            mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                            revert(0x1c, 0x04)\n                        }\n                    }\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Returns the total supply of the `token`.\n    /// Reverts if the token does not exist or does not implement `totalSupply()`.\n    function totalSupply(address token) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x18160ddd) // `totalSupply()`.\n            if iszero(\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), token, 0x1c, 0x04, 0x00, 0x20))\n            ) {\n                mstore(0x00, 0x54cd9435) // `TotalSupplyQueryFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\n    /// Reverts upon failure.\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(\n                and(\n                    call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00),\n                    lt(iszero(extcodesize(token)), exists) // Token has code and Permit2 exists.\n                )\n            ) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }\n\n    /// @dev Permit a user to spend a given amount of\n    /// another user's tokens via native EIP-2612 permit if possible, falling\n    /// back to Permit2 if native permit fails or is not implemented on the token.\n    function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `1` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Simple permit on the Permit2 contract.\n    function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero( // Revert if token does not have code, or if the call fails.\n            mul(extcodesize(token), call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00))) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"
      },
      "src/interfaces/IBentoBoxV1.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC20} from \"@BoringSolidity/interfaces/IERC20.sol\";\nimport {Rebase} from \"@BoringSolidity/libraries/BoringRebase.sol\";\nimport {IStrategy} from \"/interfaces/IStrategy.sol\";\n\ninterface IFlashBorrower {\n    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.\n    /// @param sender The address of the invoker of this flashloan.\n    /// @param token The address of the token that is loaned.\n    /// @param amount of the `token` that is loaned.\n    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.\n    /// @param data Additional data that was passed to the flashloan function.\n    function onFlashLoan(address sender, IERC20 token, uint256 amount, uint256 fee, bytes calldata data) external;\n}\n\ninterface IBatchFlashBorrower {\n    /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.\n    /// @param sender The address of the invoker of this flashloan.\n    /// @param tokens Array of addresses for ERC-20 tokens that is loaned.\n    /// @param amounts A one-to-one map to `tokens` that is loaned.\n    /// @param fees A one-to-one map to `tokens` that needs to be paid on top for each loan. Needs to be the same token.\n    /// @param data Additional data that was passed to the flashloan function.\n    function onBatchFlashLoan(\n        address sender,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        uint256[] calldata fees,\n        bytes calldata data\n    ) external;\n}\n\ninterface IBentoBoxV1 {\n    function balanceOf(IERC20, address) external view returns (uint256);\n\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\n\n    function batchFlashLoan(\n        IBatchFlashBorrower borrower,\n        address[] calldata receivers,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n\n    function claimOwnership() external;\n\n    function flashLoan(IFlashBorrower borrower, address receiver, IERC20 token, uint256 amount, bytes calldata data) external;\n\n    function deploy(address masterContract, bytes calldata data, bool useCreate2) external payable returns (address);\n\n    function deposit(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    function harvest(IERC20 token, bool balance, uint256 maxChangeAmount) external;\n\n    function masterContractApproved(address, address) external view returns (bool);\n\n    function masterContractOf(address) external view returns (address);\n\n    function nonces(address) external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function pendingOwner() external view returns (address);\n\n    function pendingStrategy(IERC20) external view returns (IStrategy);\n\n    function permitToken(IERC20 token, address from, address to, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    function registerProtocol() external;\n\n    function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) external;\n\n    function setStrategy(IERC20 token, IStrategy newStrategy) external;\n\n    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;\n\n    function strategy(IERC20) external view returns (IStrategy);\n\n    function strategyData(IERC20) external view returns (uint64 strategyStartDate, uint64 targetPercentage, uint128 balance);\n\n    function toAmount(IERC20 token, uint256 share, bool roundUp) external view returns (uint256 amount);\n\n    function toShare(IERC20 token, uint256 amount, bool roundUp) external view returns (uint256 share);\n\n    function totals(IERC20) external view returns (Rebase memory totals_);\n\n    function transfer(IERC20 token, address from, address to, uint256 share) external;\n\n    function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) external;\n\n    function transferOwnership(address newOwner, bool direct, bool renounce) external;\n\n    function whitelistMasterContract(address masterContract, bool approved) external;\n\n    function whitelistedMasterContracts(address) external view returns (bool);\n\n    function withdraw(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n}\n\ninterface IBentoBoxLite {\n    function deposit(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    function balanceOf(address, address) external view returns (uint256);\n\n    function toAmount(address token, uint256 share, bool roundUp) external view returns (uint256 amount);\n\n    function toShare(address token, uint256 amount, bool roundUp) external view returns (uint256 share);\n\n    function transfer(address token, address from, address to, uint256 share) external;\n}\n"
      },
      "src/interfaces/ISwapperV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ISwapperV2 {\n    function swap(\n        address fromToken,\n        address toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom,\n        bytes calldata data\n    ) external returns (uint256 extraShare, uint256 shareReturned);\n}\n"
      },
      "src/interfaces/IERC4626.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n\n/// @notice Tokenized Vaults with a single underlying EIP-20 token.\ninterface IERC4626 {\n    function decimals() external view returns (uint8 decimals);\n    \n    /// @notice The address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n    function asset() external view returns (address assetTokenAddress);\n\n    /// @notice Total amount of the underlying asset that is “managed” by Vault.\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /// @notice The amount of shares that the Vault would exchange for the amount of assets provided, in an ideal scenario where all the conditions are met.\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice The amount of assets that the Vault would exchange for the amount of shares provided, in an ideal scenario where all the conditions are met.\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Maximum amount of the underlying asset that can be deposited into the Vault for the receiver, through a deposit call.\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given current on-chain conditions.\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Mints shares Vault shares to receiver by depositing exactly assets of underlying tokens.\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /// @notice Maximum amount of shares that can be minted from the Vault for the receiver, through a mint call.\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given current on-chain conditions.\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Mints exactly shares Vault shares to receiver by depositing assets of underlying tokens.\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /// @notice Maximum amount of the underlying asset that can be withdrawn from the owner balance in the Vault, through a withdraw call.\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block, given current on-chain conditions.\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /// @notice Maximum amount of Vault shares that can be redeemed from the owner balance in the Vault, through a redeem call.\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block, given current on-chain conditions.\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n    event Withdraw(address indexed caller, address indexed receiver, address indexed owner, uint256 assets, uint256 shares);\n}\n"
      },
      "src/libraries/BexLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IBexVault, JoinPoolRequest, ExitPoolRequest, JoinKind, ExitKind, PoolSpecialization} from \"../interfaces/IBexVault.sol\";\n\nIBexVault constant BEX_VAULT = IBexVault(0x4Be03f781C497A489E3cB0287833452cA9B9E80B);\n\n/// @notice Library for interacting with the 2-tokens bex pools in a very high-level abstracted way\nlibrary BexLib {\n    error ErrInvalidInput();\n    error ErrInvalidNumTokens();\n    error ErrInvalidPool();\n\n    function getValidatedPool(bytes32 poolId) internal view returns (address pool) {\n        PoolSpecialization specialization;\n        (pool, specialization) = BEX_VAULT.getPool(poolId);\n        require(specialization == PoolSpecialization.TWO_TOKEN, ErrInvalidPool());\n    }\n\n    function getPoolTokens(bytes32 poolId) internal view returns (address[] memory tokens) {\n        (tokens, , ) = BEX_VAULT.getPoolTokens(poolId);\n    }\n\n    function joinPool(bytes32 poolId, address[] memory tokens, uint256[] memory amountsIn, uint256 minAmountOut, address to) internal {\n        require(tokens.length == 2, ErrInvalidNumTokens());\n        require(amountsIn.length == 2, ErrInvalidNumTokens());\n\n        bytes memory userData = abi.encode(JoinKind.EXACT_TOKENS_IN_FOR_LP_OUT, amountsIn, minAmountOut);\n\n        JoinPoolRequest memory request = JoinPoolRequest({\n            assets: tokens,\n            maxAmountsIn: amountsIn,\n            userData: userData,\n            fromInternalBalance: false\n        });\n\n        BEX_VAULT.joinPool(poolId, address(this), to, request);\n    }\n\n    function exitPool(bytes32 poolId, address[] memory tokens, uint256 amountIn, uint256[] memory minAmountsOut, address to) internal {\n        require(tokens.length == 2, ErrInvalidNumTokens());\n\n        bytes memory userData = abi.encode(ExitKind.EXACT_LP_IN_FOR_TOKENS_OUT, amountIn);\n\n        ExitPoolRequest memory request = ExitPoolRequest({\n            assets: tokens,\n            minAmountsOut: minAmountsOut,\n            userData: userData,\n            toInternalBalance: false\n        });\n\n        BEX_VAULT.exitPool(poolId, address(this), payable(to), request);\n    }\n}\n"
      },
      "dependencies/openzeppelin-contracts-5.0.2/contracts/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "dependencies/BoringSolidity-1.0.0/contracts/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    // transfer and tranferFrom have been removed, because they don't work on all tokens (some aren't ERC20 complaint).\n    // By removing them you can't accidentally use them.\n    // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).\n    // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ninterface IStrictERC20 {\n    // This is the strict ERC20 interface. Don't use this, certainly not if you don't control the ERC20 token you're calling.\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
      },
      "dependencies/BoringSolidity-1.0.0/contracts/libraries/BoringRebase.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport {BoringMath, BoringMath128} from \"./BoringMath.sol\";\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\n/// @notice A rebasing library using overflow-/underflow-safe math.\nlibrary RebaseLibrary {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = (elastic * total.base) / total.elastic;\n            if (roundUp && (base * total.elastic) / total.base < elastic) {\n                base++;\n            }\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = (base * total.elastic) / total.base;\n            if (roundUp && (elastic * total.base) / total.elastic < base) {\n                elastic++;\n            }\n        }\n    }\n\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\n    /// @return (Rebase) The new total.\n    /// @return base in relationship to `elastic`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 base) {\n        base = toBase(total, elastic, roundUp);\n        total.elastic += elastic.to128();\n        total.base += base.to128();\n        return (total, base);\n    }\n\n    /// @notice Sub `base` from `total` and update `total.elastic`.\n    /// @return (Rebase) The new total.\n    /// @return elastic in relationship to `base`.\n    function sub(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 elastic) {\n        elastic = toElastic(total, base, roundUp);\n        total.elastic -= elastic.to128();\n        total.base -= base.to128();\n        return (total, elastic);\n    }\n\n    /// @notice Add `elastic` and `base` to `total`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic += elastic.to128();\n        total.base += base.to128();\n        return total;\n    }\n\n    /// @notice Subtract `elastic` and `base` to `total`.\n    function sub(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic -= elastic.to128();\n        total.base -= base.to128();\n        return total;\n    }\n\n    /// @notice Add `elastic` to `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic += elastic.to128();\n    }\n\n    /// @notice Subtract `elastic` from `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic -= elastic.to128();\n    }\n}\n"
      },
      "src/interfaces/IStrategy.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IStrategy {\n    function skim(uint256 amount) external;\n\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\n\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\n\n    function exit(uint256 balance) external returns (int256 amountAdded);\n}\n"
      },
      "src/interfaces/IBexVault.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nstruct JoinPoolRequest {\n    address[] assets;\n    uint256[] maxAmountsIn;\n    bytes userData;\n    bool fromInternalBalance;\n}\n\nstruct ExitPoolRequest {\n    address[] assets;\n    uint256[] minAmountsOut;\n    bytes userData;\n    bool toInternalBalance;\n}\n\nenum JoinKind {\n    INIT,\n    EXACT_TOKENS_IN_FOR_LP_OUT,\n    TOKEN_IN_FOR_EXACT_LP_OUT,\n    ALL_TOKENS_IN_FOR_EXACT_LP_OUT\n}\n\nenum ExitKind {\n    EXACT_LP_IN_FOR_ONE_TOKEN_OUT,\n    EXACT_LP_IN_FOR_TOKENS_OUT,\n    LP_IN_FOR_EXACT_TOKENS_OUT\n}\n\nenum PoolSpecialization {\n    GENERAL,\n    MINIMAL_SWAP_INFO,\n    TWO_TOKEN\n}\n\ninterface IBexVault {\n    function joinPool(bytes32 poolId, address sender, address recipient, JoinPoolRequest memory request) external payable;\n\n    function exitPool(bytes32 poolId, address sender, address payable recipient, ExitPoolRequest memory request) external;\n\n    function getPoolTokens(\n        bytes32 poolId\n    ) external view returns (address[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);\n\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n}\n"
      },
      "dependencies/BoringSolidity-1.0.0/contracts/libraries/BoringMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nlibrary BoringMath {\n    error ErrOverflow();\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function to32(uint256 a) internal pure returns (uint32) {\n        if (a > type(uint32).max) {\n            revert ErrOverflow();\n        }\n        return uint32(a);\n    }\n\n    function to40(uint256 a) internal pure returns (uint40) {\n        if (a > type(uint40).max) {\n            revert ErrOverflow();\n        }\n        return uint40(a);\n    }\n\n    function to64(uint256 a) internal pure returns (uint64) {\n        if (a > type(uint64).max) {\n            revert ErrOverflow();\n        }\n        return uint64(a);\n    }\n\n    function to112(uint256 a) internal pure returns (uint112) {\n        if (a > type(uint112).max) {\n            revert ErrOverflow();\n        }\n        return uint112(a);\n    }\n\n    function to128(uint256 a) internal pure returns (uint128) {\n        if (a > type(uint128).max) {\n            revert ErrOverflow();\n        }\n        return uint128(a);\n    }\n\n    function to208(uint256 a) internal pure returns (uint208) {\n        if (a > type(uint208).max) {\n            revert ErrOverflow();\n        }\n        return uint208(a);\n    }\n\n    function to216(uint256 a) internal pure returns (uint216) {\n        if (a > type(uint216).max) {\n            revert ErrOverflow();\n        }\n        return uint216(a);\n    }\n\n    function to224(uint256 a) internal pure returns (uint224) {\n        if (a > type(uint224).max) {\n            revert ErrOverflow();\n        }\n        return uint224(a);\n    }\n}\n\nlibrary BoringMath32 {\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a + b;\n    }\n\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a - b;\n    }\n\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a * b;\n    }\n\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a / b;\n    }\n}\n\nlibrary BoringMath64 {\n    function add(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a + b;\n    }\n\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a - b;\n    }\n\n    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a * b;\n    }\n\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a / b;\n    }\n}\n\nlibrary BoringMath112 {\n    function add(uint112 a, uint112 b) internal pure returns (uint112) {\n        return a + b;\n    }\n\n    function sub(uint112 a, uint112 b) internal pure returns (uint112) {\n        return a - b;\n    }\n\n    function mul(uint112 a, uint112 b) internal pure returns (uint112) {\n        return a * b;\n    }\n\n    function div(uint112 a, uint112 b) internal pure returns (uint112) {\n        return a / b;\n    }\n}\n\nlibrary BoringMath128 {\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\n        return a + b;\n    }\n\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\n        return a - b;\n    }\n\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\n        return a * b;\n    }\n\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\n        return a / b;\n    }\n}\n\nlibrary BoringMath224 {\n    function add(uint224 a, uint224 b) internal pure returns (uint224) {\n        return a + b;\n    }\n\n    function sub(uint224 a, uint224 b) internal pure returns (uint224) {\n        return a - b;\n    }\n\n    function mul(uint224 a, uint224 b) internal pure returns (uint224) {\n        return a * b;\n    }\n\n    function div(uint224 a, uint224 b) internal pure returns (uint224) {\n        return a / b;\n    }\n}\n"
      }
    },
    "settings": {
      "remappings": [
        "/=src/",
        "forge-std/=dependencies/forge-std-1.9.5/src/",
        "halmos-cheatcodes/=dependencies/halmos-cheatcodes-7328abe/src/",
        "@openzeppelin/contracts/=dependencies/openzeppelin-contracts-5.0.2/contracts/",
        "@openzeppelin/contracts-upgradeable/=dependencies/openzeppelin-contracts-upgradeable-5.0.2/contracts/",
        "@BoringSolidity/=dependencies/BoringSolidity-1.0.0/contracts/",
        "@solady/=dependencies/solady-0.0.281/src/",
        "@solmate/=dependencies/solmate-6.2.0/src/",
        "@excessivelySafeCall/=dependencies/ExcessivelySafeCall-0.0.1/src/",
        "@safe-contracts/=dependencies/safe-contracts-1.3.0/contracts/",
        "@fuzzlib/=dependencies/fuzzlib-0.0.1/src/",
        "@abracadabra-oft-v1/=dependencies/abracadabra-oft-v1-0.0.1/src/",
        "@prb/math/=dependencies/prb-math-4.1.0/src/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 400
      },
      "metadata": {
        "useLiteralContent": false,
        "bytecodeHash": "ipfs",
        "appendCBOR": true
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode.object",
            "evm.bytecode.sourceMap",
            "evm.bytecode.linkReferences",
            "evm.deployedBytecode.object",
            "evm.deployedBytecode.sourceMap",
            "evm.deployedBytecode.linkReferences",
            "evm.deployedBytecode.immutableReferences",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "evmVersion": "cancun",
      "viaIR": false,
      "libraries": {}
    }
  },
  "compiler": "0.8.28+commit.7893614a"
}