{
  "address": "0x21713CfD14241475B30F7145D263Ac5f48b98D7C",
  "abi": [
    {
      "type": "constructor",
      "inputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "CHAINLINK_USD0PP_AGGREGATOR",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "UPPER_BOUNDARY",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "VAULT",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "aggregator",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IAggregator"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "decimalScale",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "decimals",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint8",
          "internalType": "uint8"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "get",
      "inputs": [
        {
          "name": "",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        },
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "name",
      "inputs": [
        {
          "name": "",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "string",
          "internalType": "string"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "peek",
      "inputs": [
        {
          "name": "",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        },
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "peekSpot",
      "inputs": [
        {
          "name": "data",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "rate",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "symbol",
      "inputs": [
        {
          "name": "",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "string",
          "internalType": "string"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "vault",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IERC4626"
        }
      ],
      "stateMutability": "view"
    }
  ],
  "bytecode": "0x60e060405234801561000f575f80fd5b5060408051808201909152600f81526e135859da58d554d10c0acacbd554d1608a1b60208201527373075fd1522893d9dc922991542f98f08f2c1c9973fc9e30cf89f8a00dba3d34edf8b65bcdadecc1cb5f61006b84826101f7565b506001600160a01b03808316608052811660a08190526040805163313ce56760e01b8152905163313ce567916004808201926020929091908290030181865afa1580156100ba573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906100de91906102b1565b826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561011a573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061013e91906102b1565b61014891906102ec565b61015390600a6103ee565b60c052506103fc915050565b634e487b7160e01b5f52604160045260245ffd5b600181811c9082168061018757607f821691505b6020821081036101a557634e487b7160e01b5f52602260045260245ffd5b50919050565b601f8211156101f257805f5260205f20601f840160051c810160208510156101d05750805b601f840160051c820191505b818110156101ef575f81556001016101dc565b50505b505050565b81516001600160401b038111156102105761021061015f565b6102248161021e8454610173565b846101ab565b6020601f821160018114610256575f831561023f5750848201515b5f19600385901b1c1916600184901b1784556101ef565b5f84815260208120601f198516915b828110156102855787850151825560209485019460019092019101610265565b50848210156102a257868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b5f602082840312156102c1575f80fd5b815160ff811681146102d1575f80fd5b9392505050565b634e487b7160e01b5f52601160045260245ffd5b60ff8181168382160190811115610305576103056102d8565b92915050565b6001815b60018411156103465780850481111561032a5761032a6102d8565b600184161561033857908102905b60019390931c92800261030f565b935093915050565b5f8261035c57506001610305565b8161036857505f610305565b816001811461037e5760028114610388576103a4565b6001915050610305565b60ff841115610399576103996102d8565b50506001821b610305565b5060208310610133831016604e8410600b84101617156103c7575081810a610305565b6103d35f19848461030b565b805f19048211156103e6576103e66102d8565b029392505050565b5f6102d160ff84168361034e565b60805160a05160c0516106456104415f395f818161016c015261048d01525f818160d801526103a701525f81816102090152818161022e015261037001526106455ff3fe608060405234801561000f575f80fd5b50600436106100cf575f3560e01c8063d39bbef01161007d578063e8991e0611610058578063e8991e06146101f9578063eeb8a8d3146101cf578063fbfa77cf14610204575f80fd5b8063d39bbef0146101bc578063d568866c1461019c578063d6d7d525146101cf575f80fd5b80635458ca46116100ad5780635458ca461461014c578063c4f5183b14610167578063c699c4d61461019c575f80fd5b8063245a7bfc146100d3578063313ce56714610117578063411557d114610131575b5f80fd5b6100fa7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b61011f61022b565b60405160ff909116815260200161010e565b6100fa7373075fd1522893d9dc922991542f98f08f2c1c9981565b6100fa73fc9e30cf89f8a00dba3d34edf8b65bcdadecc1cb81565b61018e7f000000000000000000000000000000000000000000000000000000000000000081565b60405190815260200161010e565b6101af6101aa3660046104c8565b6102b1565b60405161010e9190610536565b61018e6101ca3660046104c8565b610343565b6101e26101dd3660046104c8565b610356565b60408051921515835260208301919091520161010e565b61018e6305f5e10081565b6100fa7f000000000000000000000000000000000000000000000000000000000000000081565b5f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610288573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906102ac9190610581565b905090565b60605f80546102bf906105a1565b80601f01602080910402602001604051908101604052809291908181526020018280546102eb906105a1565b80156103365780601f1061030d57610100808354040283529160200191610336565b820191905f5260205f20905b81548152906001019060200180831161031957829003601f168201915b5050505050905092915050565b5f61034e8383610356565b949350505050565b5f80600161036261036d565b915091509250929050565b5f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166307a2d13a61042a6305f5e1007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166350d25bcd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610401573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061042591906105d9565b6104b1565b6040518263ffffffff1660e01b815260040161044891815260200190565b602060405180830381865afa158015610463573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061048791906105d9565b6102ac907f00000000000000000000000000000000000000000000000000000000000000006105f0565b5f8183106104bf57816104c1565b825b9392505050565b5f80602083850312156104d9575f80fd5b823567ffffffffffffffff8111156104ef575f80fd5b8301601f810185136104ff575f80fd5b803567ffffffffffffffff811115610515575f80fd5b856020828401011115610526575f80fd5b6020919091019590945092505050565b602081525f82518060208401525f5b818110156105625760208186018101516040868401015201610545565b505f604082850101526040601f19601f83011684010191505092915050565b5f60208284031215610591575f80fd5b815160ff811681146104c1575f80fd5b600181811c908216806105b557607f821691505b6020821081036105d357634e487b7160e01b5f52602260045260245ffd5b50919050565b5f602082840312156105e9575f80fd5b5051919050565b5f8261060a57634e487b7160e01b5f52601260045260245ffd5b50049056fea2646970667358221220222a411221b145c748ee91315842d6aa7ff56b46bfeafa3e6bfa2cdec8dde1bb64736f6c634300081a0033",
  "args_data": "0x",
  "tx_hash": "0xc2452b4bc1d38aeccccd2966e9161841c7046b8fa9c89e8956c9fbcb53439da3",
  "args": null,
  "data": "0x60e060405234801561000f575f80fd5b5060408051808201909152600f81526e135859da58d554d10c0acacbd554d1608a1b60208201527373075fd1522893d9dc922991542f98f08f2c1c9973fc9e30cf89f8a00dba3d34edf8b65bcdadecc1cb5f61006b84826101f7565b506001600160a01b03808316608052811660a08190526040805163313ce56760e01b8152905163313ce567916004808201926020929091908290030181865afa1580156100ba573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906100de91906102b1565b826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561011a573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061013e91906102b1565b61014891906102ec565b61015390600a6103ee565b60c052506103fc915050565b634e487b7160e01b5f52604160045260245ffd5b600181811c9082168061018757607f821691505b6020821081036101a557634e487b7160e01b5f52602260045260245ffd5b50919050565b601f8211156101f257805f5260205f20601f840160051c810160208510156101d05750805b601f840160051c820191505b818110156101ef575f81556001016101dc565b50505b505050565b81516001600160401b038111156102105761021061015f565b6102248161021e8454610173565b846101ab565b6020601f821160018114610256575f831561023f5750848201515b5f19600385901b1c1916600184901b1784556101ef565b5f84815260208120601f198516915b828110156102855787850151825560209485019460019092019101610265565b50848210156102a257868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b5f602082840312156102c1575f80fd5b815160ff811681146102d1575f80fd5b9392505050565b634e487b7160e01b5f52601160045260245ffd5b60ff8181168382160190811115610305576103056102d8565b92915050565b6001815b60018411156103465780850481111561032a5761032a6102d8565b600184161561033857908102905b60019390931c92800261030f565b935093915050565b5f8261035c57506001610305565b8161036857505f610305565b816001811461037e5760028114610388576103a4565b6001915050610305565b60ff841115610399576103996102d8565b50506001821b610305565b5060208310610133831016604e8410600b84101617156103c7575081810a610305565b6103d35f19848461030b565b805f19048211156103e6576103e66102d8565b029392505050565b5f6102d160ff84168361034e565b60805160a05160c0516106456104415f395f818161016c015261048d01525f818160d801526103a701525f81816102090152818161022e015261037001526106455ff3fe608060405234801561000f575f80fd5b50600436106100cf575f3560e01c8063d39bbef01161007d578063e8991e0611610058578063e8991e06146101f9578063eeb8a8d3146101cf578063fbfa77cf14610204575f80fd5b8063d39bbef0146101bc578063d568866c1461019c578063d6d7d525146101cf575f80fd5b80635458ca46116100ad5780635458ca461461014c578063c4f5183b14610167578063c699c4d61461019c575f80fd5b8063245a7bfc146100d3578063313ce56714610117578063411557d114610131575b5f80fd5b6100fa7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b61011f61022b565b60405160ff909116815260200161010e565b6100fa7373075fd1522893d9dc922991542f98f08f2c1c9981565b6100fa73fc9e30cf89f8a00dba3d34edf8b65bcdadecc1cb81565b61018e7f000000000000000000000000000000000000000000000000000000000000000081565b60405190815260200161010e565b6101af6101aa3660046104c8565b6102b1565b60405161010e9190610536565b61018e6101ca3660046104c8565b610343565b6101e26101dd3660046104c8565b610356565b60408051921515835260208301919091520161010e565b61018e6305f5e10081565b6100fa7f000000000000000000000000000000000000000000000000000000000000000081565b5f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610288573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906102ac9190610581565b905090565b60605f80546102bf906105a1565b80601f01602080910402602001604051908101604052809291908181526020018280546102eb906105a1565b80156103365780601f1061030d57610100808354040283529160200191610336565b820191905f5260205f20905b81548152906001019060200180831161031957829003601f168201915b5050505050905092915050565b5f61034e8383610356565b949350505050565b5f80600161036261036d565b915091509250929050565b5f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166307a2d13a61042a6305f5e1007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166350d25bcd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610401573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061042591906105d9565b6104b1565b6040518263ffffffff1660e01b815260040161044891815260200190565b602060405180830381865afa158015610463573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061048791906105d9565b6102ac907f00000000000000000000000000000000000000000000000000000000000000006105f0565b5f8183106104bf57816104c1565b825b9392505050565b5f80602083850312156104d9575f80fd5b823567ffffffffffffffff8111156104ef575f80fd5b8301601f810185136104ff575f80fd5b803567ffffffffffffffff811115610515575f80fd5b856020828401011115610526575f80fd5b6020919091019590945092505050565b602081525f82518060208401525f5b818110156105625760208186018101516040868401015201610545565b505f604082850101526040601f19601f83011684010191505092915050565b5f60208284031215610591575f80fd5b815160ff811681146104c1575f80fd5b600181811c908216806105b557607f821691505b6020821081036105d357634e487b7160e01b5f52602260045260245ffd5b50919050565b5f602082840312156105e9575f80fd5b5051919050565b5f8261060a57634e487b7160e01b5f52601260045260245ffd5b50049056fea2646970667358221220222a411221b145c748ee91315842d6aa7ff56b46bfeafa3e6bfa2cdec8dde1bb64736f6c634300081a0033",
  "artifact_path": "MagicUSD0ppOracle.sol",
  "artifact_full_path": "MagicUSD0ppOracle.sol:MagicUSD0ppOracle",
  "standardJsonInput": {
    "language": "Solidity",
    "sources": {
      "src/oracles/MagicUSD0ppOracle.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {ERC4626Oracle} from \"/oracles/ERC4626Oracle.sol\";\nimport {IERC4626} from \"/interfaces/IERC4626.sol\";\nimport {IAggregator} from \"/interfaces/IAggregator.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\ncontract MagicUSD0ppOracle is ERC4626Oracle {\n    address public constant VAULT = 0x73075fD1522893D9dC922991542f98F08F2c1C99;\n    address public constant CHAINLINK_USD0PP_AGGREGATOR = 0xFC9e30Cf89f8A00dba3D34edf8b65BCDAdeCC1cB;\n    uint256 public constant UPPER_BOUNDARY = 1e8;\n\n    constructor() ERC4626Oracle(\"MagicUSD0++/USD\", IERC4626(VAULT), IAggregator(CHAINLINK_USD0PP_AGGREGATOR)) {}\n\n    function _get() internal view override returns (uint256) {\n        return decimalScale / vault.convertToAssets(uint256(Math.min(UPPER_BOUNDARY, uint256(aggregator.latestAnswer()))));\n    }\n}\n"
      },
      "src/oracles/ERC4626Oracle.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {IERC20} from \"@BoringSolidity/interfaces/IERC20.sol\";\nimport {IERC4626} from \"/interfaces/IERC4626.sol\";\nimport {IAggregator} from \"/interfaces/IAggregator.sol\";\nimport {IOracle} from \"/interfaces/IOracle.sol\";\nimport {IGmxGlpManager} from \"/interfaces/IGmxV1.sol\";\n\n/// @notice ERC4626 oracle to be used with cauldrons\n/// @dev This oracle is used to get the _inverted_ price of an ERC4626 vault in USD\ncontract ERC4626Oracle is IOracle {\n    IERC4626 public immutable vault;\n    IAggregator public immutable aggregator;\n    uint256 public immutable decimalScale;\n    string private desc;\n\n    /// @notice ERC4626 oracle\n    /// @param _desc The description of the oracle\n    /// @param _vault The vault to use\n    /// @param _aggregator The aggregator to use for the asset.\n    constructor(string memory _desc, IERC4626 _vault, IAggregator _aggregator) {\n        desc = _desc;\n        vault = _vault;\n        aggregator = _aggregator;\n        decimalScale = (10 ** (_vault.decimals() + _aggregator.decimals()));\n    }\n\n    function decimals() external view returns (uint8) {\n        return vault.decimals();\n    }\n\n    function _get() internal view virtual returns (uint256) {\n        return decimalScale / vault.convertToAssets(uint256(aggregator.latestAnswer()));\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return desc;\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return desc;\n    }\n}\n"
      },
      "src/interfaces/IERC4626.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n\n/// @notice Tokenized Vaults with a single underlying EIP-20 token.\ninterface IERC4626 {\n    function decimals() external view returns (uint8 decimals);\n    \n    /// @notice The address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n    function asset() external view returns (address assetTokenAddress);\n\n    /// @notice Total amount of the underlying asset that is “managed” by Vault.\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /// @notice The amount of shares that the Vault would exchange for the amount of assets provided, in an ideal scenario where all the conditions are met.\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice The amount of assets that the Vault would exchange for the amount of shares provided, in an ideal scenario where all the conditions are met.\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Maximum amount of the underlying asset that can be deposited into the Vault for the receiver, through a deposit call.\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given current on-chain conditions.\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Mints shares Vault shares to receiver by depositing exactly assets of underlying tokens.\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /// @notice Maximum amount of shares that can be minted from the Vault for the receiver, through a mint call.\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given current on-chain conditions.\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Mints exactly shares Vault shares to receiver by depositing assets of underlying tokens.\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /// @notice Maximum amount of the underlying asset that can be withdrawn from the owner balance in the Vault, through a withdraw call.\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block, given current on-chain conditions.\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /// @notice Maximum amount of Vault shares that can be redeemed from the owner balance in the Vault, through a redeem call.\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block, given current on-chain conditions.\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n    event Withdraw(address indexed caller, address indexed receiver, address indexed owner, uint256 assets, uint256 shares);\n}\n"
      },
      "src/interfaces/IAggregator.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IAggregator {\n    function decimals() external view returns (uint8);\n\n    function latestAnswer() external view returns (int256 answer);\n\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n\ninterface IAggregatorWithMeta is IAggregator {\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n}\n"
      },
      "dependencies/openzeppelin-contracts-5.0.2/contracts/utils/math/Math.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
      },
      "dependencies/BoringSolidity-1.0.0/contracts/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    // transfer and tranferFrom have been removed, because they don't work on all tokens (some aren't ERC20 complaint).\n    // By removing them you can't accidentally use them.\n    // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).\n    // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ninterface IStrictERC20 {\n    // This is the strict ERC20 interface. Don't use this, certainly not if you don't control the ERC20 token you're calling.\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
      },
      "src/interfaces/IOracle.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IOracle {\n    function decimals() external view returns (uint8);\n\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\n\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\n\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\n\n    function symbol(bytes calldata data) external view returns (string memory);\n\n    function name(bytes calldata data) external view returns (string memory);\n}\n"
      },
      "src/interfaces/IGmxV1.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC20} from \"@BoringSolidity/interfaces/IERC20.sol\";\n\ninterface IGmxVault {\n    event BuyUSDG(address account, address token, uint256 tokenAmount, uint256 usdgAmount, uint256 feeBasisPoints);\n    event ClosePosition(\n        bytes32 key,\n        uint256 size,\n        uint256 collateral,\n        uint256 averagePrice,\n        uint256 entryFundingRate,\n        uint256 reserveAmount,\n        int256 realisedPnl\n    );\n    event CollectMarginFees(address token, uint256 feeUsd, uint256 feeTokens);\n    event CollectSwapFees(address token, uint256 feeUsd, uint256 feeTokens);\n    event DecreaseGuaranteedUsd(address token, uint256 amount);\n    event DecreasePoolAmount(address token, uint256 amount);\n    event DecreasePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        uint256 collateralDelta,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 price,\n        uint256 fee\n    );\n    event DecreaseReservedAmount(address token, uint256 amount);\n    event DecreaseUsdgAmount(address token, uint256 amount);\n    event DirectPoolDeposit(address token, uint256 amount);\n    event IncreaseGuaranteedUsd(address token, uint256 amount);\n    event IncreasePoolAmount(address token, uint256 amount);\n    event IncreasePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        uint256 collateralDelta,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 price,\n        uint256 fee\n    );\n    event IncreaseReservedAmount(address token, uint256 amount);\n    event IncreaseUsdgAmount(address token, uint256 amount);\n    event LiquidatePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        bool isLong,\n        uint256 size,\n        uint256 collateral,\n        uint256 reserveAmount,\n        int256 realisedPnl,\n        uint256 markPrice\n    );\n    event SellUSDG(address account, address token, uint256 usdgAmount, uint256 tokenAmount, uint256 feeBasisPoints);\n    event Swap(\n        address account,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 amountOutAfterFees,\n        uint256 feeBasisPoints\n    );\n    event UpdateFundingRate(address token, uint256 fundingRate);\n    event UpdatePnl(bytes32 key, bool hasProfit, uint256 delta);\n    event UpdatePosition(\n        bytes32 key,\n        uint256 size,\n        uint256 collateral,\n        uint256 averagePrice,\n        uint256 entryFundingRate,\n        uint256 reserveAmount,\n        int256 realisedPnl\n    );\n\n    function BASIS_POINTS_DIVISOR() external view returns (uint256);\n\n    function FUNDING_RATE_PRECISION() external view returns (uint256);\n\n    function MAX_FEE_BASIS_POINTS() external view returns (uint256);\n\n    function MAX_FUNDING_RATE_FACTOR() external view returns (uint256);\n\n    function MAX_LIQUIDATION_FEE_USD() external view returns (uint256);\n\n    function MIN_FUNDING_RATE_INTERVAL() external view returns (uint256);\n\n    function MIN_LEVERAGE() external view returns (uint256);\n\n    function PRICE_PRECISION() external view returns (uint256);\n\n    function USDG_DECIMALS() external view returns (uint256);\n\n    function addRouter(address _router) external;\n\n    function adjustForDecimals(uint256 _amount, address _tokenDiv, address _tokenMul) external view returns (uint256);\n\n    function allWhitelistedTokens(uint256) external view returns (address);\n\n    function allWhitelistedTokensLength() external view returns (uint256);\n\n    function approvedRouters(address, address) external view returns (bool);\n\n    function bufferAmounts(address) external view returns (uint256);\n\n    function buyUSDG(address _token, address _receiver) external returns (uint256);\n\n    function clearTokenConfig(address _token) external;\n\n    function cumulativeFundingRates(address) external view returns (uint256);\n\n    function decreasePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver\n    ) external returns (uint256);\n\n    function directPoolDeposit(address _token) external;\n\n    function errorController() external view returns (address);\n\n    function errors(uint256) external view returns (string memory);\n\n    function feeReserves(address) external view returns (uint256);\n\n    function fundingInterval() external view returns (uint256);\n\n    function fundingRateFactor() external view returns (uint256);\n\n    function getDelta(\n        address _indexToken,\n        uint256 _size,\n        uint256 _averagePrice,\n        bool _isLong,\n        uint256 _lastIncreasedTime\n    ) external view returns (bool, uint256);\n\n    function getFeeBasisPoints(\n        address _token,\n        uint256 _usdgDelta,\n        uint256 _feeBasisPoints,\n        uint256 _taxBasisPoints,\n        bool _increment\n    ) external view returns (uint256);\n\n    function getFundingFee(address _token, uint256 _size, uint256 _entryFundingRate) external view returns (uint256);\n\n    function getGlobalShortDelta(address _token) external view returns (bool, uint256);\n\n    function getMaxPrice(address _token) external view returns (uint256);\n\n    function getMinPrice(address _token) external view returns (uint256);\n\n    function getNextAveragePrice(\n        address _indexToken,\n        uint256 _size,\n        uint256 _averagePrice,\n        bool _isLong,\n        uint256 _nextPrice,\n        uint256 _sizeDelta,\n        uint256 _lastIncreasedTime\n    ) external view returns (uint256);\n\n    function getNextFundingRate(address _token) external view returns (uint256);\n\n    function getNextGlobalShortAveragePrice(address _indexToken, uint256 _nextPrice, uint256 _sizeDelta) external view returns (uint256);\n\n    function getPosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) external view returns (uint256, uint256, uint256, uint256, uint256, uint256, bool, uint256);\n\n    function getPositionDelta(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) external view returns (bool, uint256);\n\n    function getPositionFee(uint256 _sizeDelta) external view returns (uint256);\n\n    function getPositionKey(address _account, address _collateralToken, address _indexToken, bool _isLong) external pure returns (bytes32);\n\n    function getPositionLeverage(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) external view returns (uint256);\n\n    function getRedemptionAmount(address _token, uint256 _usdgAmount) external view returns (uint256);\n\n    function getRedemptionCollateral(address _token) external view returns (uint256);\n\n    function getRedemptionCollateralUsd(address _token) external view returns (uint256);\n\n    function getTargetUsdgAmount(address _token) external view returns (uint256);\n\n    function getUtilisation(address _token) external view returns (uint256);\n\n    function globalShortAveragePrices(address) external view returns (uint256);\n\n    function globalShortSizes(address) external view returns (uint256);\n\n    function gov() external view returns (address);\n\n    function guaranteedUsd(address) external view returns (uint256);\n\n    function hasDynamicFees() external view returns (bool);\n\n    function inManagerMode() external view returns (bool);\n\n    function inPrivateLiquidationMode() external view returns (bool);\n\n    function includeAmmPrice() external view returns (bool);\n\n    function increasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong) external;\n\n    function initialize(\n        address _router,\n        address _usdg,\n        address _priceFeed,\n        uint256 _liquidationFeeUsd,\n        uint256 _fundingRateFactor,\n        uint256 _stableFundingRateFactor\n    ) external;\n\n    function isInitialized() external view returns (bool);\n\n    function isLeverageEnabled() external view returns (bool);\n\n    function isLiquidator(address) external view returns (bool);\n\n    function isManager(address) external view returns (bool);\n\n    function isSwapEnabled() external view returns (bool);\n\n    function lastFundingTimes(address) external view returns (uint256);\n\n    function liquidatePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong,\n        address _feeReceiver\n    ) external;\n\n    function liquidationFeeUsd() external view returns (uint256);\n\n    function marginFeeBasisPoints() external view returns (uint256);\n\n    function maxGasPrice() external view returns (uint256);\n\n    function maxLeverage() external view returns (uint256);\n\n    function maxUsdgAmounts(address) external view returns (uint256);\n\n    function minProfitBasisPoints(address) external view returns (uint256);\n\n    function minProfitTime() external view returns (uint256);\n\n    function mintBurnFeeBasisPoints() external view returns (uint256);\n\n    function poolAmounts(address) external view returns (uint256);\n\n    function positions(\n        bytes32\n    )\n        external\n        view\n        returns (\n            uint256 size,\n            uint256 collateral,\n            uint256 averagePrice,\n            uint256 entryFundingRate,\n            uint256 reserveAmount,\n            int256 realisedPnl,\n            uint256 lastIncreasedTime\n        );\n\n    function priceFeed() external view returns (address);\n\n    function removeRouter(address _router) external;\n\n    function reservedAmounts(address) external view returns (uint256);\n\n    function router() external view returns (address);\n\n    function sellUSDG(address _token, address _receiver) external returns (uint256);\n\n    function setBufferAmount(address _token, uint256 _amount) external;\n\n    function setError(uint256 _errorCode, string memory _error) external;\n\n    function setErrorController(address _errorController) external;\n\n    function setFees(\n        uint256 _taxBasisPoints,\n        uint256 _stableTaxBasisPoints,\n        uint256 _mintBurnFeeBasisPoints,\n        uint256 _swapFeeBasisPoints,\n        uint256 _stableSwapFeeBasisPoints,\n        uint256 _marginFeeBasisPoints,\n        uint256 _liquidationFeeUsd,\n        uint256 _minProfitTime,\n        bool _hasDynamicFees\n    ) external;\n\n    function setFundingRate(uint256 _fundingInterval, uint256 _fundingRateFactor, uint256 _stableFundingRateFactor) external;\n\n    function setGov(address _gov) external;\n\n    function setInManagerMode(bool _inManagerMode) external;\n\n    function setInPrivateLiquidationMode(bool _inPrivateLiquidationMode) external;\n\n    function setIsLeverageEnabled(bool _isLeverageEnabled) external;\n\n    function setIsSwapEnabled(bool _isSwapEnabled) external;\n\n    function setLiquidator(address _liquidator, bool _isActive) external;\n\n    function setManager(address _manager, bool _isManager) external;\n\n    function setMaxGasPrice(uint256 _maxGasPrice) external;\n\n    function setMaxLeverage(uint256 _maxLeverage) external;\n\n    function setPriceFeed(address _priceFeed) external;\n\n    function setTokenConfig(\n        address _token,\n        uint256 _tokenDecimals,\n        uint256 _tokenWeight,\n        uint256 _minProfitBps,\n        uint256 _maxUsdgAmount,\n        bool _isStable,\n        bool _isShortable\n    ) external;\n\n    function setUsdgAmount(address _token, uint256 _amount) external;\n\n    function shortableTokens(address) external view returns (bool);\n\n    function stableFundingRateFactor() external view returns (uint256);\n\n    function stableSwapFeeBasisPoints() external view returns (uint256);\n\n    function stableTaxBasisPoints() external view returns (uint256);\n\n    function stableTokens(address) external view returns (bool);\n\n    function swap(address _tokenIn, address _tokenOut, address _receiver) external returns (uint256);\n\n    function swapFeeBasisPoints() external view returns (uint256);\n\n    function taxBasisPoints() external view returns (uint256);\n\n    function tokenBalances(address) external view returns (uint256);\n\n    function tokenDecimals(address) external view returns (uint256);\n\n    function tokenToUsdMin(address _token, uint256 _tokenAmount) external view returns (uint256);\n\n    function tokenWeights(address) external view returns (uint256);\n\n    function totalTokenWeights() external view returns (uint256);\n\n    function updateCumulativeFundingRate(address _token) external;\n\n    function upgradeVault(address _newVault, address _token, uint256 _amount) external;\n\n    function usdToToken(address _token, uint256 _usdAmount, uint256 _price) external view returns (uint256);\n\n    function usdToTokenMax(address _token, uint256 _usdAmount) external view returns (uint256);\n\n    function usdToTokenMin(address _token, uint256 _usdAmount) external view returns (uint256);\n\n    function usdg() external view returns (address);\n\n    function usdgAmounts(address) external view returns (uint256);\n\n    function useSwapPricing() external view returns (bool);\n\n    function validateLiquidation(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong,\n        bool _raise\n    ) external view returns (uint256, uint256);\n\n    function whitelistedTokenCount() external view returns (uint256);\n\n    function whitelistedTokens(address) external view returns (bool);\n\n    function withdrawFees(address _token, address _receiver) external returns (uint256);\n}\n\ninterface IGmxVester {\n    function rewardTracker() external view returns (address);\n\n    function claimForAccount(address _account, address _receiver) external returns (uint256);\n\n    function claimable(address _account) external view returns (uint256);\n\n    function setHasMaxVestableAmount(bool _hasMaxVestableAmount) external;\n\n    function cumulativeClaimAmounts(address _account) external view returns (uint256);\n\n    function claimedAmounts(address _account) external view returns (uint256);\n\n    function pairAmounts(address _account) external view returns (uint256);\n\n    function getVestedAmount(address _account) external view returns (uint256);\n\n    function transferredAverageStakedAmounts(address _account) external view returns (uint256);\n\n    function transferredCumulativeRewards(address _account) external view returns (uint256);\n\n    function cumulativeRewardDeductions(address _account) external view returns (uint256);\n\n    function bonusRewards(address _account) external view returns (uint256);\n\n    function transferStakeValues(address _sender, address _receiver) external;\n\n    function setTransferredAverageStakedAmounts(address _account, uint256 _amount) external;\n\n    function setTransferredCumulativeRewards(address _account, uint256 _amount) external;\n\n    function setCumulativeRewardDeductions(address _account, uint256 _amount) external;\n\n    function setBonusRewards(address _account, uint256 _amount) external;\n\n    function getMaxVestableAmount(address _account) external view returns (uint256);\n\n    function getCombinedAverageStakedAmount(address _account) external view returns (uint256);\n\n    function deposit(uint256 _amount) external;\n\n    function withdraw() external;\n\n    function claim() external returns (uint256);\n\n    function getTotalVested(address _account) external view returns (uint256);\n\n    function balances(address account) external view returns (uint256);\n}\n\ninterface IVaultPriceFeed {\n    function adjustmentBasisPoints(address _token) external view returns (uint256);\n\n    function isAdjustmentAdditive(address _token) external view returns (bool);\n\n    function setAdjustment(address _token, bool _isAdditive, uint256 _adjustmentBps) external;\n\n    function setUseV2Pricing(bool _useV2Pricing) external;\n\n    function setIsAmmEnabled(bool _isEnabled) external;\n\n    function setIsSecondaryPriceEnabled(bool _isEnabled) external;\n\n    function setSpreadBasisPoints(address _token, uint256 _spreadBasisPoints) external;\n\n    function setSpreadThresholdBasisPoints(uint256 _spreadThresholdBasisPoints) external;\n\n    function setFavorPrimaryPrice(bool _favorPrimaryPrice) external;\n\n    function setPriceSampleSpace(uint256 _priceSampleSpace) external;\n\n    function setMaxStrictPriceDeviation(uint256 _maxStrictPriceDeviation) external;\n\n    function getPrice(address _token, bool _maximise, bool _includeAmmPrice, bool _useSwapPricing) external view returns (uint256);\n\n    function getAmmPrice(address _token) external view returns (uint256);\n\n    function getPrimaryPrice(address _token, bool _maximise) external view returns (uint256);\n}\n\ninterface IGmxRewardDistributor {\n    function pendingRewards() external view returns (uint256);\n\n    function distribute() external returns (uint256);\n}\n\ninterface IGmxRewardRouterV2 {\n    type VotingPowerType is uint8;\n\n    event StakeGlp(address account, uint256 amount);\n    event StakeGmx(address account, address token, uint256 amount);\n    event UnstakeGlp(address account, uint256 amount);\n    event UnstakeGmx(address account, address token, uint256 amount);\n\n    function BASIS_POINTS_DIVISOR() external view returns (uint256);\n\n    function acceptTransfer(address _sender) external;\n\n    function batchCompoundForAccounts(address[] memory _accounts) external;\n\n    function batchStakeGmxForAccount(address[] memory _accounts, uint256[] memory _amounts) external;\n\n    function bnGmx() external view returns (address);\n\n    function bonusGmxTracker() external view returns (address);\n\n    function claim() external;\n\n    function claimEsGmx() external;\n\n    function claimFees() external;\n\n    function compound() external;\n\n    function compoundForAccount(address _account) external;\n\n    function esGmx() external view returns (address);\n\n    function feeGlpTracker() external view returns (address);\n\n    function feeGmxTracker() external view returns (address);\n\n    function glp() external view returns (address);\n\n    function glpManager() external view returns (address);\n\n    function glpVester() external view returns (address);\n\n    function gmx() external view returns (address);\n\n    function gmxVester() external view returns (address);\n\n    function gov() external view returns (address);\n\n    function govToken() external view returns (address);\n\n    function handleRewards(\n        bool shouldClaimGmx,\n        bool shouldStakeGmx,\n        bool shouldClaimEsGmx,\n        bool shouldStakeEsGmx,\n        bool shouldStakeMultiplierPoints,\n        bool shouldClaimWeth,\n        bool shouldConvertWethToEth\n    ) external;\n\n    function inStrictTransferMode() external view returns (bool);\n\n    function initialize(\n        address _weth,\n        address _gmx,\n        address _esGmx,\n        address _bnGmx,\n        address _glp,\n        address _stakedGmxTracker,\n        address _bonusGmxTracker,\n        address _feeGmxTracker,\n        address _feeGlpTracker,\n        address _stakedGlpTracker,\n        address _glpManager,\n        address _gmxVester,\n        address _glpVester,\n        address _govToken\n    ) external;\n\n    function isInitialized() external view returns (bool);\n\n    function maxBoostBasisPoints() external view returns (uint256);\n\n    function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns (uint256);\n\n    function mintAndStakeGlpETH(uint256 _minUsdg, uint256 _minGlp) external payable returns (uint256);\n\n    function pendingReceivers(address) external view returns (address);\n\n    function setGov(address _gov) external;\n\n    function setInStrictTransferMode(bool _inStrictTransferMode) external;\n\n    function setMaxBoostBasisPoints(uint256 _maxBoostBasisPoints) external;\n\n    function setVotingPowerType(VotingPowerType _votingPowerType) external;\n\n    function signalTransfer(address _receiver) external;\n\n    function stakeEsGmx(uint256 _amount) external;\n\n    function stakeGmx(uint256 _amount) external;\n\n    function stakeGmxForAccount(address _account, uint256 _amount) external;\n\n    function stakedGlpTracker() external view returns (address);\n\n    function stakedGmxTracker() external view returns (address);\n\n    function unstakeAndRedeemGlp(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);\n\n    function unstakeAndRedeemGlpETH(uint256 _glpAmount, uint256 _minOut, address payable _receiver) external returns (uint256);\n\n    function unstakeEsGmx(uint256 _amount) external;\n\n    function unstakeGmx(uint256 _amount) external;\n\n    function votingPowerType() external view returns (VotingPowerType);\n\n    function weth() external view returns (address);\n\n    function withdrawToken(address _token, address _account, uint256 _amount) external;\n}\n\ninterface IGmxRewardTracker {\n    function rewardToken() external view returns (address);\n\n    function depositBalances(address _account, address _depositToken) external view returns (uint256);\n\n    function stakedAmounts(address _account) external view returns (uint256);\n\n    function updateRewards() external;\n\n    function stake(address _depositToken, uint256 _amount) external;\n\n    function stakeForAccount(address _fundingAccount, address _account, address _depositToken, uint256 _amount) external;\n\n    function unstake(address _depositToken, uint256 _amount) external;\n\n    function unstakeForAccount(address _account, address _depositToken, uint256 _amount, address _receiver) external;\n\n    function tokensPerInterval() external view returns (uint256);\n\n    function claim(address _receiver) external returns (uint256);\n\n    function claimForAccount(address _account, address _receiver) external returns (uint256);\n\n    function claimable(address _account) external view returns (uint256);\n\n    function averageStakedAmounts(address _account) external view returns (uint256);\n\n    function cumulativeRewards(address _account) external view returns (uint256);\n}\n\ninterface IGmxStakedGlp {\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    function allowances(address, address) external view returns (uint256);\n\n    function approve(address _spender, uint256 _amount) external returns (bool);\n\n    function balanceOf(address _account) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function feeGlpTracker() external view returns (address);\n\n    function glp() external view returns (address);\n\n    function glpManager() external view returns (address);\n\n    function name() external view returns (string memory);\n\n    function stakedGlpTracker() external view returns (address);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\n\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool);\n}\n\ninterface IGmxGlpRewardRouter {\n    event StakeGlp(address account, uint256 amount);\n    event StakeGmx(address account, address token, uint256 amount);\n    event UnstakeGlp(address account, uint256 amount);\n    event UnstakeGmx(address account, address token, uint256 amount);\n\n    function acceptTransfer(address _sender) external;\n\n    function batchCompoundForAccounts(address[] memory _accounts) external;\n\n    function batchStakeGmxForAccount(address[] memory _accounts, uint256[] memory _amounts) external;\n\n    function claim() external;\n\n    function claimEsGmx() external;\n\n    function claimFees() external;\n\n    function compound() external;\n\n    function compoundForAccount(address _account) external;\n\n    function feeGlpTracker() external view returns (address);\n\n    function glp() external view returns (address);\n\n    function glpManager() external view returns (address);\n\n    function gov() external view returns (address);\n\n    function handleRewards(\n        bool shouldClaimGmx,\n        bool shouldStakeGmx,\n        bool shouldClaimEsGmx,\n        bool shouldStakeEsGmx,\n        bool shouldStakeMultiplierPoints,\n        bool shouldClaimWeth,\n        bool shouldConvertWethToEth\n    ) external;\n\n    function initialize(\n        address _weth,\n        address _gmx,\n        address _esGmx,\n        address _bnGmx,\n        address _glp,\n        address _stakedGmxTracker,\n        address _bonusGmxTracker,\n        address _feeGmxTracker,\n        address _feeGlpTracker,\n        address _stakedGlpTracker,\n        address _glpManager,\n        address _gmxVester,\n        address _glpVester\n    ) external;\n\n    function isInitialized() external view returns (bool);\n\n    function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns (uint256);\n\n    function mintAndStakeGlpETH(uint256 _minUsdg, uint256 _minGlp) external payable returns (uint256);\n\n    function pendingReceivers(address) external view returns (address);\n\n    function setGov(address _gov) external;\n\n    function signalTransfer(address _receiver) external;\n\n    function stakeEsGmx(uint256 _amount) external;\n\n    function stakeGmx(uint256 _amount) external;\n\n    function stakeGmxForAccount(address _account, uint256 _amount) external;\n\n    function stakedGlpTracker() external view returns (address);\n\n    function stakedGmxTracker() external view returns (address);\n\n    function unstakeAndRedeemGlp(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);\n\n    function unstakeAndRedeemGlpETH(uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);\n\n    function unstakeEsGmx(uint256 _amount) external;\n\n    function unstakeGmx(uint256 _amount) external;\n\n    function withdrawToken(address _token, address _account, uint256 _amount) external;\n}\n\ninterface IGmxGlpManager {\n    event AddLiquidity(\n        address account,\n        address token,\n        uint256 amount,\n        uint256 aumInUsdg,\n        uint256 glpSupply,\n        uint256 usdgAmount,\n        uint256 mintAmount\n    );\n    event RemoveLiquidity(\n        address account,\n        address token,\n        uint256 glpAmount,\n        uint256 aumInUsdg,\n        uint256 glpSupply,\n        uint256 usdgAmount,\n        uint256 amountOut\n    );\n\n    function BASIS_POINTS_DIVISOR() external view returns (uint256);\n\n    function GLP_PRECISION() external view returns (uint256);\n\n    function MAX_COOLDOWN_DURATION() external view returns (uint256);\n\n    function PRICE_PRECISION() external view returns (uint256);\n\n    function USDG_DECIMALS() external view returns (uint256);\n\n    function addLiquidity(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns (uint256);\n\n    function addLiquidityForAccount(\n        address _fundingAccount,\n        address _account,\n        address _token,\n        uint256 _amount,\n        uint256 _minUsdg,\n        uint256 _minGlp\n    ) external returns (uint256);\n\n    function aumAddition() external view returns (uint256);\n\n    function aumDeduction() external view returns (uint256);\n\n    function cooldownDuration() external view returns (uint256);\n\n    function getAum(bool maximise) external view returns (uint256);\n\n    function getAumInUsdg(bool maximise) external view returns (uint256);\n\n    function getAums() external view returns (uint256[] memory);\n\n    function getGlobalShortAveragePrice(address _token) external view returns (uint256);\n\n    function getGlobalShortDelta(address _token, uint256 _price, uint256 _size) external view returns (uint256, bool);\n\n    function getPrice(bool _maximise) external view returns (uint256);\n\n    function glp() external view returns (address);\n\n    function gov() external view returns (address);\n\n    function inPrivateMode() external view returns (bool);\n\n    function isHandler(address) external view returns (bool);\n\n    function lastAddedAt(address) external view returns (uint256);\n\n    function removeLiquidity(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);\n\n    function removeLiquidityForAccount(\n        address _account,\n        address _tokenOut,\n        uint256 _glpAmount,\n        uint256 _minOut,\n        address _receiver\n    ) external returns (uint256);\n\n    function setAumAdjustment(uint256 _aumAddition, uint256 _aumDeduction) external;\n\n    function setCooldownDuration(uint256 _cooldownDuration) external;\n\n    function setGov(address _gov) external;\n\n    function setHandler(address _handler, bool _isActive) external;\n\n    function setInPrivateMode(bool _inPrivateMode) external;\n\n    function setShortsTracker(address _shortsTracker) external;\n\n    function setShortsTrackerAveragePriceWeight(uint256 _shortsTrackerAveragePriceWeight) external;\n\n    function shortsTracker() external view returns (address);\n\n    function shortsTrackerAveragePriceWeight() external view returns (uint256);\n\n    function usdg() external view returns (address);\n\n    function vault() external view returns (address);\n}\n\ninterface IGmxGlpRewardHandler {\n    function harvest() external;\n\n    function swapRewards(\n        uint256 amountOutMin,\n        IERC20 rewardToken,\n        IERC20 outputToken,\n        address recipient,\n        bytes calldata data\n    ) external returns (uint256 amountOut);\n\n    function setFeeParameters(address _feeCollector, uint8 _feePercent) external;\n\n    function setRewardTokenEnabled(IERC20 token, bool enabled) external;\n\n    function setSwappingTokenOutEnabled(IERC20 token, bool enabled) external;\n\n    function setAllowedSwappingRecipient(address recipient, bool enabled) external;\n\n    function setRewardRouter(IGmxRewardRouterV2 _rewardRouter) external;\n\n    function setSwapper(address _swapper) external;\n\n    function unstakeGmx(uint256 amount, uint256 amountTransferToFeeCollector) external;\n\n    function unstakeEsGmxAndVest(uint256 amount, uint256 glpVesterDepositAmount, uint256 gmxVesterDepositAmount) external;\n\n    function withdrawFromVesting(bool withdrawFromGlpVester, bool withdrawFromGmxVester, bool stake) external;\n\n    function claimVestedGmx(bool withdrawFromGlpVester, bool withdrawFromGmxVester, bool stake, bool transferToFeeCollecter) external;\n}\n"
      }
    },
    "settings": {
      "remappings": [
        "/=src/",
        "forge-std/=dependencies/forge-std-1.9.2/src/",
        "halmos-cheatcodes/=dependencies/halmos-cheatcodes-3ca0e11/src/",
        "@openzeppelin/contracts/=dependencies/openzeppelin-contracts-5.0.2/contracts/",
        "@openzeppelin/contracts-upgradeable/=dependencies/openzeppelin-contracts-upgradeable-5.0.2/contracts/",
        "@BoringSolidity/=dependencies/BoringSolidity-1.0.0/contracts/",
        "@solady/=dependencies/solady-0.0.281/src/",
        "@solmate/=dependencies/solmate-6.2.0/src/",
        "@excessivelySafeCall/=dependencies/ExcessivelySafeCall-0.0.1/src/",
        "@safe-contracts/=dependencies/safe-contracts-1.3.0/contracts/",
        "@fuzzlib/=dependencies/fuzzlib-0.0.1/src/",
        "@abracadabra-oftv2/=dependencies/abracadabra-oftv2-0.0.1/src/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 400
      },
      "metadata": {
        "useLiteralContent": false,
        "bytecodeHash": "ipfs",
        "appendCBOR": true
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "evmVersion": "shanghai",
      "viaIR": false,
      "libraries": {}
    }
  },
  "compiler": "0.8.26+commit.8a97fa7a"
}