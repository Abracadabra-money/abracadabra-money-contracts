{
  "address": "0x00E033DC26612Cd42BfE98b59Edaf93abCC269cE",
  "abi": [
    {
      "type": "constructor",
      "inputs": [
        {
          "name": "_mim",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_oft",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_owner",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "MESSAGE_VERSION",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint16",
          "internalType": "uint16"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "balanceOf",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "claimRewards",
      "inputs": [],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "claimRewards",
      "inputs": [
        {
          "name": "_params",
          "type": "tuple",
          "internalType": "struct MSpellStakingRewardHandlerParam",
          "components": [
            {
              "name": "fee",
              "type": "uint128",
              "internalType": "uint128"
            },
            {
              "name": "gas",
              "type": "uint112",
              "internalType": "uint112"
            },
            {
              "name": "dstChainId",
              "type": "uint16",
              "internalType": "uint16"
            }
          ]
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "estimateBridgingFee",
      "inputs": [
        {
          "name": "_dstChainId",
          "type": "uint16",
          "internalType": "uint16"
        }
      ],
      "outputs": [
        {
          "name": "fee",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "gas",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "data",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "mim",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "notifyRewards",
      "inputs": [
        {
          "name": "_user",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_token",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_amount",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "_data",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [],
      "stateMutability": "payable"
    },
    {
      "type": "function",
      "name": "oft",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract ILzOFTV2"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "operators",
      "inputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "owner",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "setOperator",
      "inputs": [
        {
          "name": "operator",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "enable",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "transferOwnership",
      "inputs": [
        {
          "name": "newOwner",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "event",
      "name": "OperatorChanged",
      "inputs": [
        {
          "name": "",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "",
          "type": "bool",
          "indexed": false,
          "internalType": "bool"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "OwnershipTransferred",
      "inputs": [
        {
          "name": "user",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "newOwner",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "error",
      "name": "ErrNotEnoughNativeTokenToCoverFee",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrUnsupportedToken",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrZeroAddress",
      "inputs": []
    },
    {
      "type": "error",
      "name": "Unauthorized",
      "inputs": []
    }
  ],
  "bytecode": "0x60c060405234801561000f575f80fd5b50604051610e28380380610e2883398101604081905261002e916100ef565b6001600160a01b038316158061004b57506001600160a01b038216155b1561006957604051630ecc6fdf60e41b815260040160405180910390fd5b6100728161008a565b506001600160a01b039182166080521660a05261012f565b5f80546001600160a01b0319166001600160a01b03831690811782556040519091907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a350565b80516001600160a01b03811681146100ea575f80fd5b919050565b5f805f60608486031215610101575f80fd5b61010a846100d4565b9250610118602085016100d4565b9150610126604085016100d4565b90509250925092565b60805160a051610cb56101735f395f81816102270152818161037b0152818161041c01526107ad01525f818161025a0152818161055401526106ab0152610cb55ff3fe6080604052600436106100c3575f3560e01c80637126de9f116100715780639f67679e1161004c5780639f67679e14610249578063cd3ac5571461027c578063f2fde38b1461029b575f80fd5b80637126de9f146101cd5780638da5cb5b146101e05780639b5215f614610216575f80fd5b8063558a7297116100a1578063558a7297146101475780636ea9efec1461016657806370a0823114610194575f80fd5b806313e7c9d8146100c7578063372500ab1461010a5780633f827a5a14610120575b5f80fd5b3480156100d2575f80fd5b506100f56100e136600461088f565b60016020525f908152604090205460ff1681565b60405190151581526020015b60405180910390f35b348015610115575f80fd5b5061011e6102ba565b005b34801561012b575f80fd5b50610134600181565b60405161ffff9091168152602001610101565b348015610152575f80fd5b5061011e6101613660046108af565b6102c5565b348015610171575f80fd5b506101856101803660046108f7565b61034c565b60405161010193929190610955565b34801561019f575f80fd5b506101bf6101ae36600461088f565b60026020525f908152604090205481565b604051908152602001610101565b61011e6101db3660046109ea565b61050c565b3480156101eb575f80fd5b505f546101fe906001600160a01b031681565b6040516001600160a01b039091168152602001610101565b348015610221575f80fd5b506101fe7f000000000000000000000000000000000000000000000000000000000000000081565b348015610254575f80fd5b506101fe7f000000000000000000000000000000000000000000000000000000000000000081565b348015610287575f80fd5b5061011e610296366004610ad7565b6105fa565b3480156102a6575f80fd5b5061011e6102b536600461088f565b610607565b6102c333610687565b565b5f546001600160a01b031633146102ee576040516282b42960e81b815260040160405180910390fd5b6001600160a01b0382165f81815260016020908152604091829020805460ff191685151590811790915591519182527f193de8d500b5cb7b720089b258a39e9c1d0b840019a73ae7c51c3f9101732b02910160405180910390a25050565b60405163233f63d760e21b815261ffff821660048201525f602482018190529081906060906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690638cfd8f5c90604401602060405180830381865afa1580156103c0573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906103e49190610b2b565b60408051600160f01b60208201526022808201849052825180830390910181526042820192839052630d94982d60e21b9092529193507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169163365260b4916104609188915f916001918391604601610b42565b6040805180830381865afa15801561047a573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061049e9190610b7d565b5060408051606080820183526001600160801b0384168083526dffffffffffffffffffffffffffff878116602080860191825261ffff9b8c16958701958652865190810193909352511681850152915190971681880152815180820390970187526080019052949193925050565b335f9081526001602052604090205460ff1615801561053557505f546001600160a01b03163314155b15610552576040516282b42960e81b815260040160405180910390fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316836001600160a01b0316146105a457604051631b79f53b60e21b815260040160405180910390fd5b6001600160a01b0384165f90815260026020526040812080548492906105cb908490610b9f565b90915550508051156105f4576105f484828060200190518101906105ef9190610bc4565b6106d6565b50505050565b61060433826106d6565b50565b5f546001600160a01b03163314610630576040516282b42960e81b815260040160405180910390fd5b5f805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0383169081178255604051909133917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a350565b6001600160a01b038082165f9081526002602052604081208054919055906106d2907f000000000000000000000000000000000000000000000000000000000000000016838361082b565b5050565b806040015161ffff165f036106ee576106d282610687565b47815f01516001600160801b0316111561071b57604051630271b2c160e31b815260040160405180910390fd5b6001600160a01b0382165f8181526002602090815260408083208054908490558151606081018352948552848301849052858301518251600160f01b948101949094526dffffffffffffffffffffffffffff16602284015293919082019060420160408051601f198184030181529181529152845185820151915163695ef6bf60e01b81529293506001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081169363695ef6bf936001600160801b03909316926107f7923092908b169089908990600401610c0c565b5f604051808303818588803b15801561080e575f80fd5b505af1158015610820573d5f803e3d5ffd5b505050505050505050565b81601452806034526fa9059cbb0000000000000000000000005f5260205f604460105f875af13d1560015f5114171661086b576390b8ec185f526004601cfd5b5f603452505050565b80356001600160a01b038116811461088a575f80fd5b919050565b5f6020828403121561089f575f80fd5b6108a882610874565b9392505050565b5f80604083850312156108c0575f80fd5b6108c983610874565b9150602083013580151581146108dd575f80fd5b809150509250929050565b61ffff81168114610604575f80fd5b5f60208284031215610907575f80fd5b81356108a8816108e8565b5f81518084525f5b818110156109365760208185018101518683018201520161091a565b505f602082860101526020601f19601f83011685010191505092915050565b838152826020820152606060408201525f6109736060830184610912565b95945050505050565b634e487b7160e01b5f52604160045260245ffd5b6040516060810167ffffffffffffffff811182821017156109b3576109b361097c565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156109e2576109e261097c565b604052919050565b5f805f80608085870312156109fd575f80fd5b610a0685610874565b9350610a1460208601610874565b925060408501359150606085013567ffffffffffffffff811115610a36575f80fd5b8501601f81018713610a46575f80fd5b803567ffffffffffffffff811115610a6057610a6061097c565b610a73601f8201601f19166020016109b9565b818152886020838501011115610a87575f80fd5b816020840160208301375f6020838301015280935050505092959194509250565b6001600160801b0381168114610604575f80fd5b6dffffffffffffffffffffffffffff81168114610604575f80fd5b5f6060828403128015610ae8575f80fd5b50610af1610990565b8235610afc81610aa8565b81526020830135610b0c81610abc565b60208201526040830135610b1f816108e8565b60408201529392505050565b5f60208284031215610b3b575f80fd5b5051919050565b61ffff86168152846020820152836040820152821515606082015260a060808201525f610b7260a0830184610912565b979650505050505050565b5f8060408385031215610b8e575f80fd5b505080516020909101519092909150565b80820180821115610bbe57634e487b7160e01b5f52601160045260245ffd5b92915050565b5f6060828403128015610bd5575f80fd5b50610bde610990565b8251610be981610aa8565b81526020830151610bf981610abc565b60208201526040830151610b1f816108e8565b6001600160a01b038616815261ffff8516602082015283604082015282606082015260a060808201526001600160a01b0382511660a08201526001600160a01b0360208301511660c08201525f6040830151606060e0840152610c73610100840182610912565b9897505050505050505056fea2646970667358221220a18f272c761216c0af203f5225d7032033269f87123beaffa7041b6a572bc63a64736f6c634300081a003300000000000000000000000099d8a9c45b2eca8864373a26d1459e3dff1e17f3000000000000000000000000439a5f0f5e8d149dda9a0ca367d4a8e4d6f83c10000000000000000000000000fb3485c2e209a5cfbdc1447674256578f1a80ee3",
  "args_data": "0x00000000000000000000000099d8a9c45b2eca8864373a26d1459e3dff1e17f3000000000000000000000000439a5f0f5e8d149dda9a0ca367d4a8e4d6f83c10000000000000000000000000fb3485c2e209a5cfbdc1447674256578f1a80ee3",
  "tx_hash": null,
  "args": [
    "0x0000000000000000000000000000000000000000",
    "true"
  ],
  "data": "0x558a729700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001",
  "artifact_path": "MSpellStakingRewardHandler.sol",
  "artifact_full_path": "MSpellStakingRewardHandler.sol:MSpellStakingRewardHandler",
  "standardJsonInput": {
    "language": "Solidity",
    "sources": {
      "src/periphery/MSpellStakingRewardHandler.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8;\n\nimport {ILzCommonOFT, ILzApp, ILzOFTV2} from \"@abracadabra-oftv2/interfaces/ILayerZero.sol\";\nimport {SafeTransferLib} from \"@solady/utils/SafeTransferLib.sol\";\nimport {OwnableOperators} from \"/mixins/OwnableOperators.sol\";\nimport {IRewardHandler} from \"/staking/MSpellStaking.sol\";\n\nstruct MSpellStakingRewardHandlerParam {\n    uint128 fee;\n    uint112 gas;\n    uint16 dstChainId;\n}\n\ncontract MSpellStakingRewardHandler is IRewardHandler, OwnableOperators {\n    using SafeTransferLib for address;\n\n    error ErrUnsupportedToken();\n    error ErrNotEnoughNativeTokenToCoverFee();\n    error ErrZeroAddress();\n\n    uint16 public constant MESSAGE_VERSION = 1;\n\n    mapping(address user => uint256 amount) public balanceOf;\n    address public immutable mim;\n    ILzOFTV2 public immutable oft;\n\n    constructor(address _mim, address _oft, address _owner) {\n        if (_mim == address(0) || _oft == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        _initializeOwner(_owner);\n\n        mim = _mim;\n        oft = ILzOFTV2(_oft);\n    }\n\n    function claimRewards() external {\n        _claimRewardsLocal(msg.sender);\n    }\n\n    function claimRewards(MSpellStakingRewardHandlerParam memory _params) public {\n        _claimRewards(msg.sender, _params);\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    /// Views\n    ////////////////////////////////////////////////////////////////////\n\n    function estimateBridgingFee(uint16 _dstChainId) external view returns (uint256 fee, uint256 gas, bytes memory data) {\n        gas = ILzApp(address(oft)).minDstGasLookup(_dstChainId, 0 /* packet type for sendFrom */);\n        (fee, ) = oft.estimateSendFee(_dstChainId, bytes32(0), uint256(1), false, abi.encodePacked(uint16(1), uint256(gas)));\n        data = abi.encode(MSpellStakingRewardHandlerParam({fee: uint128(fee), gas: uint112(gas), dstChainId: _dstChainId}));\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    /// Operators\n    ////////////////////////////////////////////////////////////////////\n\n    function notifyRewards(address _user, address _token, uint256 _amount, bytes memory _data) external payable override onlyOperators {\n        if (_token != mim) {\n            revert ErrUnsupportedToken();\n        }\n\n        balanceOf[_user] += _amount;\n\n        if (_data.length > 0) {\n            _claimRewards(_user, abi.decode(_data, (MSpellStakingRewardHandlerParam)));\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    /// Internals\n    ////////////////////////////////////////////////////////////////////\n\n    function _claimRewards(address _user, MSpellStakingRewardHandlerParam memory _params) internal {\n        if (_params.dstChainId == 0) {\n            _claimRewardsLocal(_user);\n            return;\n        }\n\n        if (_params.fee > address(this).balance) {\n            revert ErrNotEnoughNativeTokenToCoverFee();\n        }\n\n        uint256 amount = balanceOf[_user];\n        balanceOf[_user] = 0;\n\n        ILzCommonOFT.LzCallParams memory lzCallParams = ILzCommonOFT.LzCallParams({\n            refundAddress: payable(_user),\n            zroPaymentAddress: address(0),\n            adapterParams: abi.encodePacked(MESSAGE_VERSION, uint256(_params.gas))\n        });\n\n        oft.sendFrom{value: _params.fee}(\n            address(this), // 'from' address to send tokens\n            _params.dstChainId, // mainnet remote LayerZero chainId\n            bytes32(uint256(uint160(address(_user)))), // 'to' address to send tokens\n            amount, // amount of tokens to send (in wei)\n            lzCallParams\n        );\n    }\n\n    function _claimRewardsLocal(address _user) internal {\n        uint256 _amount = balanceOf[_user];\n        balanceOf[_user] = 0;\n\n        mim.safeTransfer(_user, _amount);\n    }\n}\n"
      },
      "dependencies/abracadabra-oftv2-0.0.1/src/interfaces/ILayerZero.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface ILzFeeHandler {\n    enum QuoteType {\n        None,\n        Oracle,\n        Fixed\n    }\n\n    function getFee() external view returns (uint256);\n}\n\ninterface ILzCommonOFT is IERC165 {\n    struct LzCallParams {\n        address payable refundAddress;\n        address zroPaymentAddress;\n        bytes adapterParams;\n    }\n\n    function estimateSendFee(\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        bool _useZro,\n        bytes calldata _adapterParams\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    function estimateSendAndCallFee(\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        bytes calldata _payload,\n        uint64 _dstGasForCall,\n        bool _useZro,\n        bytes calldata _adapterParams\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    function circulatingSupply() external view returns (uint);\n\n    function token() external view returns (address);\n}\n\ninterface ILzUserApplicationConfig {\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint _configType,\n        bytes calldata _config\n    ) external;\n\n    function setSendVersion(uint16 _version) external;\n\n    function setReceiveVersion(uint16 _version) external;\n\n    function forceResumeReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress\n    ) external;\n}\n\ninterface ILzEndpoint is ILzUserApplicationConfig {\n    function defaultSendLibrary() external view returns (address);\n\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint _gasLimit,\n        bytes calldata _payload\n    ) external;\n\n    function getInboundNonce(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress\n    ) external view returns (uint64);\n\n    function getOutboundNonce(\n        uint16 _dstChainId,\n        address _srcAddress\n    ) external view returns (uint64);\n\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParam\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    function getChainId() external view returns (uint16);\n\n    function retryPayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        bytes calldata _payload\n    ) external;\n\n    function hasStoredPayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress\n    ) external view returns (bool);\n\n    function getSendLibraryAddress(\n        address _userApplication\n    ) external view returns (address);\n\n    function getReceiveLibraryAddress(\n        address _userApplication\n    ) external view returns (address);\n\n    function isSendingPayload() external view returns (bool);\n\n    function isReceivingPayload() external view returns (bool);\n\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view returns (bytes memory);\n\n    function getSendVersion(\n        address _userApplication\n    ) external view returns (uint16);\n\n    function getReceiveVersion(\n        address _userApplication\n    ) external view returns (uint16);\n\n    function defaultSendVersion() external view returns (uint16);\n\n    function defaultReceiveVersion() external view returns (uint16);\n\n    function defaultReceiveLibraryAddress() external view returns (address);\n\n    function uaConfigLookup(\n        address _address\n    )\n        external\n        view\n        returns (\n            uint16 sendVersion,\n            uint16 receiveVersion,\n            address receiveLibraryAddress,\n            address sendLibrary\n        );\n}\n\ninterface ILzBaseOFTV2 {\n    function sharedDecimals() external view returns (uint8);\n\n    function innerToken() external view returns (address);\n\n    function feeHandler() external view returns (ILzFeeHandler);\n}\n\ninterface ILzApp {\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external;\n\n    function minDstGasLookup(\n        uint16 _srcChainId,\n        uint16 _dstChainId\n    ) external view returns (uint);\n\n    function setTrustedRemote(\n        uint16 _remoteChainId,\n        bytes calldata _path\n    ) external;\n\n    function trustedRemoteLookup(\n        uint16 _srcChainId\n    ) external view returns (bytes memory);\n\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint _configType,\n        bytes calldata _config\n    ) external;\n\n    function lzEndpoint() external view returns (ILzEndpoint);\n}\n\ninterface ILzOFTV2 is ILzCommonOFT {\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        LzCallParams calldata _callParams\n    ) external payable;\n\n    function sendAndCall(\n        address _from,\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        bytes calldata _payload,\n        uint64 _dstGasForCall,\n        LzCallParams calldata _callParams\n    ) external payable;\n}\n\ninterface ILzOFTReceiverV2 {\n    function onOFTReceived(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes32 _from,\n        uint _amount,\n        bytes calldata _payload\n    ) external;\n}\n\ninterface ILzUltraLightNodeV2 {\n    function defaultAppConfig(\n        uint16\n    )\n        external\n        view\n        returns (\n            uint16 inboundProofLibraryVersion,\n            uint64 inboundBlockConfirmations,\n            address relayer,\n            uint16 outboundProofType,\n            uint64 outboundBlockConfirmations,\n            address oracle\n        );\n\n    function appConfig(\n        address,\n        uint16\n    )\n        external\n        view\n        returns (\n            uint16 inboundProofLibraryVersion,\n            uint64 inboundBlockConfirmations,\n            address relayer,\n            uint16 outboundProofType,\n            uint64 outboundBlockConfirmations,\n            address oracle\n        );\n}\n\ninterface ILzReceiver {\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external;\n}\n\ninterface ILzIndirectOFTV2 is ILzBaseOFTV2 {\n    function ld2sdRate() external view returns (uint);\n}\n\ninterface ILzProxyOFTV2 is ILzBaseOFTV2 {\n    function ld2sdRate() external view returns (uint);\n}\n\ninterface IOFTV2View {\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes32 _scrAddress,\n        bytes memory _payload,\n        uint _totalSupply\n    ) external view returns (uint);\n\n    function getInboundNonce(uint16 _srcChainId) external view returns (uint64);\n\n    function getCurrentState() external view returns (uint);\n\n    function isProxy() external view returns (bool);\n}\n\ninterface IPreCrimeView {\n    struct Packet {\n        uint16 srcChainId;\n        bytes32 srcAddress;\n        uint64 nonce;\n        bytes payload;\n    }\n\n    struct SimulationResult {\n        uint chainTotalSupply;\n        bool isProxy;\n    }\n\n    function getConfig(\n        Packet[] calldata _packets\n    ) external view returns (bytes memory);\n\n    function precrime(\n        Packet[] calldata _packets,\n        bytes[] calldata _simulation\n    ) external view returns (uint16 code, bytes memory reason);\n\n    function version() external view returns (uint16);\n\n    function simulate(\n        Packet[] calldata _packets\n    ) external view returns (uint16 code, bytes memory result);\n}\n"
      },
      "dependencies/solady-0.0.231/src/utils/SafeTransferLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\n/// - For ERC20s, this implementation won't check that a token has code,\n///   responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The Permit2 operation has failed.\n    error Permit2Failed();\n\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\n    error Permit2AmountOverflow();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\n\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// @dev The canonical Permit2 address.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success :=\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x34, 0) // Store 0 for the `amount`.\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                mstore(0x34, amount) // Store back the original `amount`.\n                // Retry the approval, reverting upon failure.\n                if iszero(\n                    and(\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    )\n                ) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\n    /// Reverts upon failure.\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }\n\n    /// @dev Permit a user to spend a given amount of\n    /// another user's tokens via native EIP-2612 permit if possible, falling\n    /// back to Permit2 if native permit fails or is not implemented on the token.\n    function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `1` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Simple permit on the Permit2 contract.\n    function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"
      },
      "src/mixins/OwnableOperators.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/// @title OwnableOperators\n/// @dev must call `_initializeOwner` to initialize owner\ncontract OwnableOperators {\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n    event OperatorChanged(address indexed, bool);\n\n    error Unauthorized();\n\n    address public owner;\n    mapping(address => bool) public operators;\n\n    modifier onlyOwner() virtual {\n        if(msg.sender != owner) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    modifier onlyOperators() {\n        if (!operators[msg.sender] && msg.sender != owner) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// Admin\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function setOperator(address operator, bool enable) external onlyOwner {\n        operators[operator] = enable;\n        emit OperatorChanged(operator, enable);\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        owner = newOwner;\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// Internals\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _initializeOwner(address _owner) internal {\n        owner = _owner;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function _checkOwner() internal view {\n        if (msg.sender != owner) {\n            revert Unauthorized();\n        }\n    }\n}\n"
      },
      "src/staking/MSpellStaking.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {SafeTransferLib} from \"@solady/utils/SafeTransferLib.sol\";\nimport {Owned} from \"@solmate/auth/Owned.sol\";\n\ninterface IRewardHandler {\n    function notifyRewards(address _user, address _token, uint256 _amount, bytes memory _data) external payable;\n}\n\nstruct UserInfo {\n    uint128 amount;\n    uint128 rewardDebt;\n    uint256 lastAdded;\n}\n\nstruct RewardHandlerParams {\n    bytes data;\n    uint256 value;\n}\n\n/**\n * @title Magic Spell Staking\n * @author Inspired by Stable Joe Staking which in turn is derived from the SushiSwap MasterChef contract\n * @notice When a reward handler is used, the contract will transfer the reward tokens to the reward handler\n * for custom processing, like immediate or postponed cross-chain transfers, otherwise directly to the users.\n */\nabstract contract MSpellStakingBase {\n    using SafeTransferLib for address;\n\n    event LockupEnabled(bool status);\n    event RewardHandlerSet(address rewardHandler);\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event ClaimReward(address indexed user, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 amount);\n\n    error ErrZeroAddress();\n    error ErrLockedUp();\n\n    uint256 public constant ACC_REWARD_PER_SHARE_PRECISION = 1e24;\n    uint256 public constant LOCK_TIME = 24 hours;\n\n    address public immutable spell;\n    address public immutable mim;\n\n    uint256 public lastRewardBalance;\n    uint256 public accRewardPerShare;\n    bool public lockupEnabled;\n    IRewardHandler public rewardHandler;\n\n    mapping(address => UserInfo) public userInfo;\n\n    constructor(address _mim, address _spell) {\n        if (_mim == address(0) || _spell == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        mim = _mim;\n        spell = _spell;\n    }\n\n    function deposit(uint256 _amount) external payable {\n        deposit(_amount, RewardHandlerParams({data: \"\", value: 0}));\n    }\n\n    function withdraw(uint256 _amount) external payable {\n        withdraw(_amount, RewardHandlerParams({data: \"\", value: 0}));\n    }\n\n    function deposit(uint256 _amount, RewardHandlerParams memory _rewardHandlerParams) public payable {\n        updateReward();\n\n        UserInfo storage user = userInfo[msg.sender];\n\n        uint256 _previousAmount = user.amount;\n        uint256 _previousRewardDebt = user.rewardDebt;\n        uint256 _newAmount = _previousAmount + _amount;\n\n        user.amount = uint128(_newAmount);\n        user.rewardDebt = uint128((_newAmount * accRewardPerShare) / ACC_REWARD_PER_SHARE_PRECISION);\n        user.lastAdded = block.timestamp;\n\n        if (_previousAmount != 0) {\n            uint256 rewardsAmount = (_previousAmount * accRewardPerShare) / ACC_REWARD_PER_SHARE_PRECISION - _previousRewardDebt;\n            if (rewardsAmount > 0) {\n                _claimRewards(msg.sender, rewardsAmount, _rewardHandlerParams);\n            }\n        }\n\n        spell.safeTransferFrom(msg.sender, address(this), _amount);\n        _afterDeposit(msg.sender, _amount, msg.value - _rewardHandlerParams.value);\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    function withdraw(uint256 _amount, RewardHandlerParams memory _rewardHandlerParams) public payable {\n        updateReward();\n\n        UserInfo storage user = userInfo[msg.sender];\n        _checkLockup(user);\n\n        uint256 _previousAmount = user.amount;\n        uint256 _previousRewardDebt = user.rewardDebt;\n        uint256 _newAmount = _previousAmount - _amount;\n\n        user.amount = uint128(_newAmount);\n        user.rewardDebt = uint128((_newAmount * accRewardPerShare) / ACC_REWARD_PER_SHARE_PRECISION);\n\n        if (_previousAmount != 0) {\n            uint256 rewardsAmount = (_previousAmount * accRewardPerShare) / ACC_REWARD_PER_SHARE_PRECISION - _previousRewardDebt;\n            if (rewardsAmount > 0) {\n                _claimRewards(msg.sender, rewardsAmount, _rewardHandlerParams);\n            }\n        }\n\n        spell.safeTransfer(msg.sender, _amount);\n        _afterWithdraw(msg.sender, _amount, msg.value - _rewardHandlerParams.value);\n\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    function updateReward() public {\n        uint256 _rewardBalance = mim.balanceOf(address(this));\n        uint256 _totalSpell = spell.balanceOf(address(this));\n\n        if (_rewardBalance == lastRewardBalance || _totalSpell == 0) {\n            return;\n        }\n\n        uint256 _accruedReward = _rewardBalance - lastRewardBalance;\n\n        accRewardPerShare += (_accruedReward * ACC_REWARD_PER_SHARE_PRECISION) / _totalSpell;\n        lastRewardBalance = _rewardBalance;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////\n    // Views\n    //////////////////////////////////////////////////////////////////////////////////\n\n    function pendingReward(address _user) external view returns (uint256) {\n        UserInfo storage user = userInfo[_user];\n        uint256 _totalSpell = spell.balanceOf(address(this));\n        uint256 _rewardBalance = mim.balanceOf(address(this));\n        uint256 _accRewardTokenPerShare = accRewardPerShare;\n\n        if (_rewardBalance != lastRewardBalance && _totalSpell != 0) {\n            uint256 _accruedReward = _rewardBalance - lastRewardBalance;\n            _accRewardTokenPerShare = _accRewardTokenPerShare + (_accruedReward * ACC_REWARD_PER_SHARE_PRECISION) / _totalSpell;\n        }\n\n        return (user.amount * _accRewardTokenPerShare) / ACC_REWARD_PER_SHARE_PRECISION - user.rewardDebt;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////\n    // Internals\n    //////////////////////////////////////////////////////////////////////////////////\n\n    function _checkLockup(UserInfo storage user) internal view {\n        if (lockupEnabled && user.lastAdded + LOCK_TIME > block.timestamp) {\n            revert ErrLockedUp();\n        }\n    }\n\n    function _claimRewards(address _to, uint256 _amount, RewardHandlerParams memory _rewardHandlerParams) internal {\n        uint256 _rewardBalance = mim.balanceOf(address(this));\n\n        if (_amount > _rewardBalance) {\n            _amount = _rewardBalance;\n        }\n\n        lastRewardBalance -= _amount;\n\n        if (rewardHandler != IRewardHandler(address(0))) {\n            mim.safeTransfer(address(rewardHandler), _amount);\n            rewardHandler.notifyRewards{value: _rewardHandlerParams.value}(_to, mim, _amount, _rewardHandlerParams.data);\n        } else {\n            mim.safeTransfer(_to, _amount);\n        }\n\n        emit ClaimReward(msg.sender, _amount);\n    }\n\n    function _setLockupEnabled(bool enabled) internal {\n        lockupEnabled = enabled;\n        emit LockupEnabled(enabled);\n    }\n\n    function _setRewardHandler(address _rewardHandler) internal {\n        rewardHandler = IRewardHandler(_rewardHandler);\n        emit RewardHandlerSet(_rewardHandler);\n    }\n\n    function _afterDeposit(address _user, uint256 _amount, uint256 _value) internal virtual;\n\n    function _afterWithdraw(address _user, uint256 _amount, uint256 _value) internal virtual;\n}\n\n/// @notice Default implementation of MSpellStaking\ncontract MSpellStaking is MSpellStakingBase, Owned {\n    constructor(address _mim, address _spell, address _owner) MSpellStakingBase(_mim, _spell) Owned(_owner) {\n        _setLockupEnabled(true);\n    }\n\n    function setToggleLockUp(bool status) external onlyOwner {\n        _setLockupEnabled(status);\n    }\n\n    function setRewardHandler(address _rewardHandler) external onlyOwner {\n        _setRewardHandler(_rewardHandler);\n    }\n\n    function _afterDeposit(address _user, uint256 _amount, uint256 _value) internal override {}\n\n    function _afterWithdraw(address _user, uint256 _amount, uint256 _value) internal override {}\n}\n"
      },
      "dependencies/openzeppelin-contracts-5.0.2/contracts/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "dependencies/solmate-6.2.0/src/auth/Owned.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
      }
    },
    "settings": {
      "remappings": [
        "/=src/",
        "forge-std/=dependencies/forge-std-1.9.2/src/",
        "halmos-cheatcodes/=dependencies/halmos-cheatcodes-3ca0e11/src/",
        "@openzeppelin/contracts/=dependencies/openzeppelin-contracts-5.0.2/contracts/",
        "@openzeppelin/contracts-upgradeable/=dependencies/openzeppelin-contracts-upgradeable-5.0.2/contracts/",
        "@BoringSolidity/=dependencies/BoringSolidity-1.0.0/contracts/",
        "@solady/=dependencies/solady-0.0.231/src/",
        "@solmate/=dependencies/solmate-6.2.0/src/",
        "@excessivelySafeCall/=dependencies/ExcessivelySafeCall-0.0.1/src/",
        "@safe-contracts/=dependencies/safe-contracts-1.3.0/contracts/",
        "@fuzzlib/=dependencies/fuzzlib-0.0.1/src/",
        "@abracadabra-oftv2/=dependencies/abracadabra-oftv2-0.0.1/src/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 400
      },
      "metadata": {
        "useLiteralContent": false,
        "bytecodeHash": "ipfs",
        "appendCBOR": true
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "evmVersion": "shanghai",
      "viaIR": false,
      "libraries": {}
    }
  },
  "compiler": "0.8.26+commit.8a97fa7a"
}