{
  "address": "0x9227B5d7a0edb837aa9AeEeB15aF06ee03182367",
  "abi": [
    {
      "type": "constructor",
      "inputs": [
        {
          "name": "_bentoBox",
          "type": "address",
          "internalType": "contract IBentoBoxLite"
        },
        {
          "name": "_wrapper",
          "type": "address",
          "internalType": "contract IConvexWrapper"
        },
        {
          "name": "_mim",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_curvePoolInterfaceType",
          "type": "uint8",
          "internalType": "enum CurvePoolInterfaceType"
        },
        {
          "name": "_curvePool",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_curvePoolDepositor",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_poolTokens",
          "type": "address[]",
          "internalType": "address[]"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "box",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IBentoBoxLite"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "curvePool",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "curvePoolDepositor",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "curvePoolInterfaceType",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint8",
          "internalType": "enum CurvePoolInterfaceType"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "curveToken",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "mim",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "poolTokens",
      "inputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "swap",
      "inputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "recipient",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "shareToMin",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "shareFrom",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "data",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "extraShare",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "shareReturned",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "wrapper",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IConvexWrapper"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "error",
      "name": "ErrSwapFailed",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrTokenNotSupported",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrUnsupportedCurvePool",
      "inputs": []
    }
  ],
  "bytecode": "0x610160604052348015610010575f5ffd5b5060405161134938038061134983398101604081905261002f916102d8565b86866001600160a01b0316634f39059c6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561006c573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610090919061041f565b6001600160a01b0380831660a05281811660c052871660e05286868686868360048111156100c0576100c0610441565b60808160048111156100d4576100d4610441565b9052506001600160a01b0383166101005280516100f7905f906020840190610226565b50826001600160a01b0383161561010b5750815b6001600160a01b038082166101205260e05161012a9116895f196101d3565b5050506001600160a01b03808c166101405287161594506101c79350505050575f610140516001600160a01b0316634f39059c6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561018a573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906101ae919061041f565b90506101c56001600160a01b038216845f196101d3565b505b50505050505050610455565b81601452806034526f095ea7b30000000000000000000000005f5260205f604460105f875af18060015f51141661021c57803d853b15171061021c57633e3f8f735f526004601cfd5b505f603452505050565b828054828255905f5260205f20908101928215610279579160200282015b8281111561027957825182546001600160a01b0319166001600160a01b03909116178255602090920191600190910190610244565b50610285929150610289565b5090565b5b80821115610285575f815560010161028a565b6001600160a01b03811681146102b1575f5ffd5b50565b80516102bf8161029d565b919050565b634e487b7160e01b5f52604160045260245ffd5b5f5f5f5f5f5f5f60e0888a0312156102ee575f5ffd5b87516102f98161029d565b602089015190975061030a8161029d565b604089015190965061031b8161029d565b60608901519095506005811061032f575f5ffd5b60808901519094506103408161029d565b60a08901519093506103518161029d565b60c08901519092506001600160401b0381111561036c575f5ffd5b88015f601f82018b1361037d575f5ffd5b81516001600160401b03811115610396576103966102c4565b604051600582901b90603f8201601f191681016001600160401b03811182821017156103c4576103c46102c4565b60405291825260208185018101929081018e8411156103e1575f5ffd5b6020860195505b83861015610407576103f9866102b4565b8152602095860195016103e8565b50809350809550505050505092959891949750929550565b5f6020828403121561042f575f5ffd5b815161043a8161029d565b9392505050565b634e487b7160e01b5f52602160045260245ffd5b60805160a05160c05160e051610100516101205161014051610e276105225f395f81816101b2015281816109480152610a1201525f81816101d90152818161028f015281816103670152818161045b015281816104e6015261057901525f818160d60152818161041c015261072301525f8181610163015281816107f2015261081901525f61011501525f818161013c015281816107c3015261098d01525f81816099015281816102340152818161030c015281816103d00152818161048e01526105210152610e275ff3fe608060405234801561000f575f5ffd5b5060043610610090575f3560e01c80639f67679e116100635780639f67679e1461015e578063a5d4096b14610185578063ac210cc7146101ad578063cda640e9146101d4578063dced1a5a146101fb575f5ffd5b806313c2eacc14610094578063218751b2146100d15780634f39059c14610110578063754215a114610137575b5f5ffd5b6100bb7f000000000000000000000000000000000000000000000000000000000000000081565b6040516100c89190610b59565b60405180910390f35b6100f87f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100c8565b6100f87f000000000000000000000000000000000000000000000000000000000000000081565b6100f87f000000000000000000000000000000000000000000000000000000000000000081565b6100f87f000000000000000000000000000000000000000000000000000000000000000081565b610198610193366004610b96565b61020e565b604080519283526020830191909152016100c8565b6100f87f000000000000000000000000000000000000000000000000000000000000000081565b6100f87f000000000000000000000000000000000000000000000000000000000000000081565b6100f8610209366004610c4e565b61090a565b5f8080808061021f86880188610c79565b9250925092505f61022f89610931565b90505f7f0000000000000000000000000000000000000000000000000000000000000000600481111561026457610264610b45565b0361030857604051630d2680e960e11b815260048101829052600f85900b60248201525f60448201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690631a4d01d2906064015b6020604051808303815f875af11580156102de573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906103029190610d47565b506105c9565b60047f0000000000000000000000000000000000000000000000000000000000000000600481111561033c5761033c610b45565b036103cc57604051630d2680e960e11b815260048101829052600f85900b60248201525f60448201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690631a4d01d2906064015b5f604051808303815f87803b1580156103b1575f5ffd5b505af11580156103c3573d5f5f3e3d5ffd5b505050506105c9565b60017f0000000000000000000000000000000000000000000000000000000000000000600481111561040057610400610b45565b0361048a576040516314f6943160e11b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116600483015260248201839052600f86900b60448301525f60648301527f000000000000000000000000000000000000000000000000000000000000000016906329ed2862906084016102c2565b60027f000000000000000000000000000000000000000000000000000000000000000060048111156104be576104be610b45565b0361051d5760405163f1dc3cc960e01b815260048101829052602481018590525f60448201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063f1dc3cc9906064016102c2565b60037f0000000000000000000000000000000000000000000000000000000000000000600481111561055157610551610b45565b036105b05760405163f1dc3cc960e01b815260048101829052602481018590525f60448201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063f1dc3cc99060640161039a565b604051635ab9d7dd60e01b815260040160405180910390fd5b8151156107c1575f5b5f54811015610691575f5f82815481106105ee576105ee610d5e565b5f91825260209091200154604051636eb1769f60e11b81523060048201526001600160a01b03878116602483015290911691505f1990829063dd62ed3e90604401602060405180830381865afa15801561064a573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061066e9190610d47565b14610688576106886001600160a01b038216865f19610a76565b506001016105d2565b505f836001600160a01b0316836040516106ab9190610d72565b5f604051808303815f865af19150503d805f81146106e4576040519150601f19603f3d011682016040523d82523d5f602084013e6106e9565b606091505b505090508061070b5760405163fc3116c160e01b815260040160405180910390fd5b60405163c661065760e01b8152600481018690525f907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063c661065790602401602060405180830381865afa158015610770573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906107949190610d88565b90506107be8d6107ad6001600160a01b03841630610ac9565b6001600160a01b0384169190610afc565b50505b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166302b9446c7f0000000000000000000000000000000000000000000000000000000000000000308e61084f307f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610ac990919063ffffffff16565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e087901b1681526001600160a01b03948516600482015292841660248401529216604482015260648101919091525f608482015260a40160408051808303815f875af11580156108c6573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906108ea9190610daa565b95506108f890508a86610dcc565b95505050505097509795505050505050565b5f8181548110610918575f80fd5b5f918252602090912001546001600160a01b0316905081565b60405163097da6d360e41b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152306024830181905260448301525f6064830181905260848301849052917f0000000000000000000000000000000000000000000000000000000000000000909116906397da6d309060a40160408051808303815f875af11580156109d4573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906109f89190610daa565b50604051630e5a77ed60e21b8152600481018290529091507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690633969dfb4906024015f604051808303815f87803b158015610a5b575f5ffd5b505af1158015610a6d573d5f5f3e3d5ffd5b50505050919050565b81601452806034526f095ea7b30000000000000000000000005f5260205f604460105f875af18060015f511416610abf57803d853b151710610abf57633e3f8f735f526004601cfd5b505f603452505050565b5f816014526f70a082310000000000000000000000005f5260208060246010865afa601f3d111660205102905092915050565b81601452806034526fa9059cbb0000000000000000000000005f5260205f604460105f875af18060015f511416610abf57803d853b151710610abf576390b8ec185f526004601cfd5b634e487b7160e01b5f52602160045260245ffd5b6020810160058310610b7957634e487b7160e01b5f52602160045260245ffd5b91905290565b6001600160a01b0381168114610b93575f5ffd5b50565b5f5f5f5f5f5f5f60c0888a031215610bac575f5ffd5b8735610bb781610b7f565b96506020880135610bc781610b7f565b95506040880135610bd781610b7f565b9450606088013593506080880135925060a088013567ffffffffffffffff811115610c00575f5ffd5b8801601f81018a13610c10575f5ffd5b803567ffffffffffffffff811115610c26575f5ffd5b8a6020828401011115610c37575f5ffd5b602082019350809250505092959891949750929550565b5f60208284031215610c5e575f5ffd5b5035919050565b634e487b7160e01b5f52604160045260245ffd5b5f5f5f60608486031215610c8b575f5ffd5b833592506020840135610c9d81610b7f565b9150604084013567ffffffffffffffff811115610cb8575f5ffd5b8401601f81018613610cc8575f5ffd5b803567ffffffffffffffff811115610ce257610ce2610c65565b604051601f8201601f19908116603f0116810167ffffffffffffffff81118282101715610d1157610d11610c65565b604052818152828201602001881015610d28575f5ffd5b816020840160208301375f602083830101528093505050509250925092565b5f60208284031215610d57575f5ffd5b5051919050565b634e487b7160e01b5f52603260045260245ffd5b5f82518060208501845e5f920191825250919050565b5f60208284031215610d98575f5ffd5b8151610da381610b7f565b9392505050565b5f5f60408385031215610dbb575f5ffd5b505080516020909101519092909150565b81810381811115610deb57634e487b7160e01b5f52601160045260245ffd5b9291505056fea26469706673582212206f9fa89c2f2e8311baa04a6eee768c60448de098c4f629ee60a8f024f1edda5a64736f6c634300081c0033",
  "args_data": "0x000000000000000000000000d96f48665a1410c0cd669a88898eca36b9fc2cce0000000000000000000000009447c1413da928af354a114954bfc9e6114c564600000000000000000000000099d8a9c45b2eca8864373a26d1459e3dff1e17f30000000000000000000000000000000000000000000000000000000000000003000000000000000000000000d51a44d3fae010294c616388b506acda1bfaae46000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000003000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c599000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "tx_hash": "0xcf8f3b44db4a798488a41b3dcccecad66254bb5b0365e20bfe4124e91ff14370",
  "args": [
    "0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce",
    "0x9447c1413DA928aF354A114954BFc9E6114c5646",
    "0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3",
    "3",
    "0xD51a44d3FaE010294C616388b506AcdA1bfAAE46",
    "0x0000000000000000000000000000000000000000",
    "[0xdAC17F958D2ee523a2206206994597C13D831ec7, 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599, 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2]"
  ],
  "data": "0x610160604052348015610010575f5ffd5b5060405161134938038061134983398101604081905261002f916102d8565b86866001600160a01b0316634f39059c6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561006c573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610090919061041f565b6001600160a01b0380831660a05281811660c052871660e05286868686868360048111156100c0576100c0610441565b60808160048111156100d4576100d4610441565b9052506001600160a01b0383166101005280516100f7905f906020840190610226565b50826001600160a01b0383161561010b5750815b6001600160a01b038082166101205260e05161012a9116895f196101d3565b5050506001600160a01b03808c166101405287161594506101c79350505050575f610140516001600160a01b0316634f39059c6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561018a573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906101ae919061041f565b90506101c56001600160a01b038216845f196101d3565b505b50505050505050610455565b81601452806034526f095ea7b30000000000000000000000005f5260205f604460105f875af18060015f51141661021c57803d853b15171061021c57633e3f8f735f526004601cfd5b505f603452505050565b828054828255905f5260205f20908101928215610279579160200282015b8281111561027957825182546001600160a01b0319166001600160a01b03909116178255602090920191600190910190610244565b50610285929150610289565b5090565b5b80821115610285575f815560010161028a565b6001600160a01b03811681146102b1575f5ffd5b50565b80516102bf8161029d565b919050565b634e487b7160e01b5f52604160045260245ffd5b5f5f5f5f5f5f5f60e0888a0312156102ee575f5ffd5b87516102f98161029d565b602089015190975061030a8161029d565b604089015190965061031b8161029d565b60608901519095506005811061032f575f5ffd5b60808901519094506103408161029d565b60a08901519093506103518161029d565b60c08901519092506001600160401b0381111561036c575f5ffd5b88015f601f82018b1361037d575f5ffd5b81516001600160401b03811115610396576103966102c4565b604051600582901b90603f8201601f191681016001600160401b03811182821017156103c4576103c46102c4565b60405291825260208185018101929081018e8411156103e1575f5ffd5b6020860195505b83861015610407576103f9866102b4565b8152602095860195016103e8565b50809350809550505050505092959891949750929550565b5f6020828403121561042f575f5ffd5b815161043a8161029d565b9392505050565b634e487b7160e01b5f52602160045260245ffd5b60805160a05160c05160e051610100516101205161014051610e276105225f395f81816101b2015281816109480152610a1201525f81816101d90152818161028f015281816103670152818161045b015281816104e6015261057901525f818160d60152818161041c015261072301525f8181610163015281816107f2015261081901525f61011501525f818161013c015281816107c3015261098d01525f81816099015281816102340152818161030c015281816103d00152818161048e01526105210152610e275ff3fe608060405234801561000f575f5ffd5b5060043610610090575f3560e01c80639f67679e116100635780639f67679e1461015e578063a5d4096b14610185578063ac210cc7146101ad578063cda640e9146101d4578063dced1a5a146101fb575f5ffd5b806313c2eacc14610094578063218751b2146100d15780634f39059c14610110578063754215a114610137575b5f5ffd5b6100bb7f000000000000000000000000000000000000000000000000000000000000000081565b6040516100c89190610b59565b60405180910390f35b6100f87f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100c8565b6100f87f000000000000000000000000000000000000000000000000000000000000000081565b6100f87f000000000000000000000000000000000000000000000000000000000000000081565b6100f87f000000000000000000000000000000000000000000000000000000000000000081565b610198610193366004610b96565b61020e565b604080519283526020830191909152016100c8565b6100f87f000000000000000000000000000000000000000000000000000000000000000081565b6100f87f000000000000000000000000000000000000000000000000000000000000000081565b6100f8610209366004610c4e565b61090a565b5f8080808061021f86880188610c79565b9250925092505f61022f89610931565b90505f7f0000000000000000000000000000000000000000000000000000000000000000600481111561026457610264610b45565b0361030857604051630d2680e960e11b815260048101829052600f85900b60248201525f60448201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690631a4d01d2906064015b6020604051808303815f875af11580156102de573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906103029190610d47565b506105c9565b60047f0000000000000000000000000000000000000000000000000000000000000000600481111561033c5761033c610b45565b036103cc57604051630d2680e960e11b815260048101829052600f85900b60248201525f60448201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690631a4d01d2906064015b5f604051808303815f87803b1580156103b1575f5ffd5b505af11580156103c3573d5f5f3e3d5ffd5b505050506105c9565b60017f0000000000000000000000000000000000000000000000000000000000000000600481111561040057610400610b45565b0361048a576040516314f6943160e11b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116600483015260248201839052600f86900b60448301525f60648301527f000000000000000000000000000000000000000000000000000000000000000016906329ed2862906084016102c2565b60027f000000000000000000000000000000000000000000000000000000000000000060048111156104be576104be610b45565b0361051d5760405163f1dc3cc960e01b815260048101829052602481018590525f60448201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063f1dc3cc9906064016102c2565b60037f0000000000000000000000000000000000000000000000000000000000000000600481111561055157610551610b45565b036105b05760405163f1dc3cc960e01b815260048101829052602481018590525f60448201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063f1dc3cc99060640161039a565b604051635ab9d7dd60e01b815260040160405180910390fd5b8151156107c1575f5b5f54811015610691575f5f82815481106105ee576105ee610d5e565b5f91825260209091200154604051636eb1769f60e11b81523060048201526001600160a01b03878116602483015290911691505f1990829063dd62ed3e90604401602060405180830381865afa15801561064a573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061066e9190610d47565b14610688576106886001600160a01b038216865f19610a76565b506001016105d2565b505f836001600160a01b0316836040516106ab9190610d72565b5f604051808303815f865af19150503d805f81146106e4576040519150601f19603f3d011682016040523d82523d5f602084013e6106e9565b606091505b505090508061070b5760405163fc3116c160e01b815260040160405180910390fd5b60405163c661065760e01b8152600481018690525f907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063c661065790602401602060405180830381865afa158015610770573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906107949190610d88565b90506107be8d6107ad6001600160a01b03841630610ac9565b6001600160a01b0384169190610afc565b50505b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166302b9446c7f0000000000000000000000000000000000000000000000000000000000000000308e61084f307f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610ac990919063ffffffff16565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e087901b1681526001600160a01b03948516600482015292841660248401529216604482015260648101919091525f608482015260a40160408051808303815f875af11580156108c6573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906108ea9190610daa565b95506108f890508a86610dcc565b95505050505097509795505050505050565b5f8181548110610918575f80fd5b5f918252602090912001546001600160a01b0316905081565b60405163097da6d360e41b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152306024830181905260448301525f6064830181905260848301849052917f0000000000000000000000000000000000000000000000000000000000000000909116906397da6d309060a40160408051808303815f875af11580156109d4573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906109f89190610daa565b50604051630e5a77ed60e21b8152600481018290529091507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690633969dfb4906024015f604051808303815f87803b158015610a5b575f5ffd5b505af1158015610a6d573d5f5f3e3d5ffd5b50505050919050565b81601452806034526f095ea7b30000000000000000000000005f5260205f604460105f875af18060015f511416610abf57803d853b151710610abf57633e3f8f735f526004601cfd5b505f603452505050565b5f816014526f70a082310000000000000000000000005f5260208060246010865afa601f3d111660205102905092915050565b81601452806034526fa9059cbb0000000000000000000000005f5260205f604460105f875af18060015f511416610abf57803d853b151710610abf576390b8ec185f526004601cfd5b634e487b7160e01b5f52602160045260245ffd5b6020810160058310610b7957634e487b7160e01b5f52602160045260245ffd5b91905290565b6001600160a01b0381168114610b93575f5ffd5b50565b5f5f5f5f5f5f5f60c0888a031215610bac575f5ffd5b8735610bb781610b7f565b96506020880135610bc781610b7f565b95506040880135610bd781610b7f565b9450606088013593506080880135925060a088013567ffffffffffffffff811115610c00575f5ffd5b8801601f81018a13610c10575f5ffd5b803567ffffffffffffffff811115610c26575f5ffd5b8a6020828401011115610c37575f5ffd5b602082019350809250505092959891949750929550565b5f60208284031215610c5e575f5ffd5b5035919050565b634e487b7160e01b5f52604160045260245ffd5b5f5f5f60608486031215610c8b575f5ffd5b833592506020840135610c9d81610b7f565b9150604084013567ffffffffffffffff811115610cb8575f5ffd5b8401601f81018613610cc8575f5ffd5b803567ffffffffffffffff811115610ce257610ce2610c65565b604051601f8201601f19908116603f0116810167ffffffffffffffff81118282101715610d1157610d11610c65565b604052818152828201602001881015610d28575f5ffd5b816020840160208301375f602083830101528093505050509250925092565b5f60208284031215610d57575f5ffd5b5051919050565b634e487b7160e01b5f52603260045260245ffd5b5f82518060208501845e5f920191825250919050565b5f60208284031215610d98575f5ffd5b8151610da381610b7f565b9392505050565b5f5f60408385031215610dbb575f5ffd5b505080516020909101519092909150565b81810381811115610deb57634e487b7160e01b5f52601160045260245ffd5b9291505056fea26469706673582212206f9fa89c2f2e8311baa04a6eee768c60448de098c4f629ee60a8f024f1edda5a64736f6c634300081c0033000000000000000000000000d96f48665a1410c0cd669a88898eca36b9fc2cce0000000000000000000000009447c1413da928af354a114954bfc9e6114c564600000000000000000000000099d8a9c45b2eca8864373a26d1459e3dff1e17f30000000000000000000000000000000000000000000000000000000000000003000000000000000000000000d51a44d3fae010294c616388b506acda1bfaae46000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000003000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c599000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "artifact_path": "ConvexWrapperSwapper.sol",
  "artifact_full_path": "ConvexWrapperSwapper.sol:ConvexWrapperSwapper",
  "standardJsonInput": {
    "language": "Solidity",
    "sources": {
      "src/swappers/ConvexWrapperSwapper.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {SafeTransferLib} from \"@solady/utils/SafeTransferLib.sol\";\nimport {CurveSwapper} from \"/swappers/CurveSwapper.sol\";\nimport {IBentoBoxLite} from \"/interfaces/IBentoBoxV1.sol\";\nimport {IConvexWrapper} from \"/interfaces/IConvexWrapper.sol\";\nimport {CurvePoolInterfaceType} from \"/interfaces/ICurvePool.sol\";\n\ncontract ConvexWrapperSwapper is CurveSwapper {\n    using SafeTransferLib for address;\n\n    IConvexWrapper public immutable wrapper;\n\n    constructor(\n        IBentoBoxLite _bentoBox,\n        IConvexWrapper _wrapper,\n        address _mim,\n        CurvePoolInterfaceType _curvePoolInterfaceType,\n        address _curvePool,\n        address _curvePoolDepositor /* Optional Curve Deposit Zapper */,\n        address[] memory _poolTokens\n    )\n        CurveSwapper(\n            _bentoBox,\n            _wrapper.curveToken(),\n            _mim,\n            _curvePoolInterfaceType,\n            _curvePool,\n            _curvePoolDepositor,\n            _poolTokens\n        )\n    {\n        wrapper = _wrapper;\n        if (_curvePoolDepositor != address(0)) {\n            address curveToken = wrapper.curveToken();\n            curveToken.safeApprove(_curvePoolDepositor, type(uint256).max);\n        }\n    }\n\n    function withdrawFromBentoBox(uint256 shareFrom) internal override returns (uint256 amount) {\n        (amount, ) = box.withdraw(address(wrapper), address(this), address(this), 0, shareFrom);\n\n        // ConvexWrapper -> CurveLP token\n        wrapper.withdrawAndUnwrap(amount);\n    }\n}\n"
      },
      "dependencies/solady-0.0.281/src/utils/SafeTransferLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\nlibrary SafeTransferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The ERC20 `totalSupply` query has failed.\n    error TotalSupplyQueryFailed();\n\n    /// @dev The Permit2 operation has failed.\n    error Permit2Failed();\n\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\n    error Permit2AmountOverflow();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\n\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// @dev The canonical Permit2 address.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                success := lt(or(iszero(extcodesize(token)), returndatasize()), success)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x34, 0) // Store 0 for the `amount`.\n                    mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                    pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                    mstore(0x34, amount) // Store back the original `amount`.\n                    // Retry the approval, reverting upon failure.\n                    success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    if iszero(and(eq(mload(0x00), 1), success)) {\n                        // Check the `extcodesize` again just in case the token selfdestructs lol.\n                        if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                            mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                            revert(0x1c, 0x04)\n                        }\n                    }\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Returns the total supply of the `token`.\n    /// Reverts if the token does not exist or does not implement `totalSupply()`.\n    function totalSupply(address token) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x18160ddd) // `totalSupply()`.\n            if iszero(\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), token, 0x1c, 0x04, 0x00, 0x20))\n            ) {\n                mstore(0x00, 0x54cd9435) // `TotalSupplyQueryFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\n    /// Reverts upon failure.\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(\n                and(\n                    call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00),\n                    lt(iszero(extcodesize(token)), exists) // Token has code and Permit2 exists.\n                )\n            ) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }\n\n    /// @dev Permit a user to spend a given amount of\n    /// another user's tokens via native EIP-2612 permit if possible, falling\n    /// back to Permit2 if native permit fails or is not implemented on the token.\n    function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `1` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Simple permit on the Permit2 contract.\n    function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero( // Revert if token does not have code, or if the call fails.\n            mul(extcodesize(token), call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00))) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"
      },
      "src/swappers/CurveSwapper.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// solhint-disable avoid-low-level-calls\npragma solidity >=0.8.0;\n\nimport {SafeTransferLib} from \"@solady/utils/SafeTransferLib.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IBentoBoxLite} from \"/interfaces/IBentoBoxV1.sol\";\nimport {ISwapperV2} from \"/interfaces/ISwapperV2.sol\";\nimport {ICurvePool, CurvePoolInterfaceType, ITriCrypto, ICurve3PoolZapper, IFactoryPool, ICurvePoolLegacy} from \"/interfaces/ICurvePool.sol\";\n\ncontract CurveSwapper is ISwapperV2 {\n    using SafeTransferLib for address;\n\n    error ErrSwapFailed();\n    error ErrTokenNotSupported();\n    error ErrUnsupportedCurvePool();\n\n    CurvePoolInterfaceType public immutable curvePoolInterfaceType;\n    IBentoBoxLite public immutable box;\n    address public immutable curveToken;\n    address public immutable mim;\n    address public immutable curvePool;\n    address public immutable curvePoolDepositor;\n    address[] public poolTokens;\n\n    constructor(\n        IBentoBoxLite _box,\n        address _curveToken,\n        address _mim,\n        CurvePoolInterfaceType _curvePoolInterfaceType,\n        address _curvePool,\n        address _curvePoolDepositor /* Optional Curve Deposit Zapper */,\n        address[] memory _poolTokens\n    ) {\n        box = _box;\n        curveToken = _curveToken;\n        mim = _mim;\n        curvePoolInterfaceType = _curvePoolInterfaceType;\n        curvePool = _curvePool;\n        poolTokens = _poolTokens;\n\n        address depositor = _curvePool;\n\n        if (_curvePoolDepositor != address(0)) {\n            depositor = _curvePoolDepositor;\n        }\n\n        curvePoolDepositor = depositor;\n\n        mim.safeApprove(address(_box), type(uint256).max);\n    }\n\n    function withdrawFromBentoBox(uint256 shareFrom) internal virtual returns (uint256 amount) {\n        (amount, ) = box.withdraw(curveToken, address(this), address(this), 0, shareFrom);\n    }\n\n    /// @inheritdoc ISwapperV2\n    function swap(\n        address,\n        address,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom,\n        bytes calldata data\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n        (uint256 poolIndex, address to, bytes memory swapData) = abi.decode(data, (uint256, address, bytes));\n        uint256 amount = withdrawFromBentoBox(shareFrom);\n\n        // CurveLP token -> underlyingToken\n        if (curvePoolInterfaceType == CurvePoolInterfaceType.ICURVE_POOL) {\n            ICurvePool(curvePoolDepositor).remove_liquidity_one_coin(amount, int128(uint128(poolIndex)), uint256(0));\n        } else if (curvePoolInterfaceType == CurvePoolInterfaceType.ICURVE_POOL_LEGACY) {\n            ICurvePoolLegacy(curvePoolDepositor).remove_liquidity_one_coin(amount, int128(uint128(poolIndex)), uint256(0));\n        } else if (curvePoolInterfaceType == CurvePoolInterfaceType.ICURVE_3POOL_ZAPPER) {\n            ICurve3PoolZapper(curvePoolDepositor).remove_liquidity_one_coin(curvePool, amount, int128(uint128(poolIndex)), uint256(0));\n        } else if (curvePoolInterfaceType == CurvePoolInterfaceType.IFACTORY_POOL) {\n            IFactoryPool(curvePoolDepositor).remove_liquidity_one_coin(amount, poolIndex, uint256(0));\n        } else if (curvePoolInterfaceType == CurvePoolInterfaceType.ITRICRYPTO_POOL) {\n            ITriCrypto(curvePoolDepositor).remove_liquidity_one_coin(amount, poolIndex, uint256(0));\n        } else {\n            revert ErrUnsupportedCurvePool();\n        }\n\n        // Optional underlyingToken -> MIM\n        if (swapData.length != 0) {\n            for (uint256 i = 0; i < poolTokens.length; i++) {\n                address token = poolTokens[i];\n                if (IERC20Metadata(token).allowance(address(this), to) != type(uint256).max) {\n                    token.safeApprove(to, type(uint256).max);\n                }\n            }\n\n            (bool success, ) = to.call(swapData);\n            if (!success) {\n                revert ErrSwapFailed();\n            }\n\n            // Refund remaining underlying balance to the recipient\n            address underlyingToken = ICurvePool(curvePool).coins(poolIndex);\n            underlyingToken.safeTransfer(recipient, underlyingToken.balanceOf(address(this)));\n        }\n\n        (, shareReturned) = box.deposit(mim, address(this), recipient, mim.balanceOf(address(this)), 0);\n        extraShare = shareReturned - shareToMin;\n    }\n}\n"
      },
      "src/interfaces/IBentoBoxV1.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC20} from \"@BoringSolidity/interfaces/IERC20.sol\";\nimport {Rebase} from \"@BoringSolidity/libraries/BoringRebase.sol\";\nimport {IStrategy} from \"/interfaces/IStrategy.sol\";\n\ninterface IFlashBorrower {\n    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.\n    /// @param sender The address of the invoker of this flashloan.\n    /// @param token The address of the token that is loaned.\n    /// @param amount of the `token` that is loaned.\n    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.\n    /// @param data Additional data that was passed to the flashloan function.\n    function onFlashLoan(address sender, IERC20 token, uint256 amount, uint256 fee, bytes calldata data) external;\n}\n\ninterface IBatchFlashBorrower {\n    /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.\n    /// @param sender The address of the invoker of this flashloan.\n    /// @param tokens Array of addresses for ERC-20 tokens that is loaned.\n    /// @param amounts A one-to-one map to `tokens` that is loaned.\n    /// @param fees A one-to-one map to `tokens` that needs to be paid on top for each loan. Needs to be the same token.\n    /// @param data Additional data that was passed to the flashloan function.\n    function onBatchFlashLoan(\n        address sender,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        uint256[] calldata fees,\n        bytes calldata data\n    ) external;\n}\n\ninterface IBentoBoxV1 {\n    function balanceOf(IERC20, address) external view returns (uint256);\n\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\n\n    function batchFlashLoan(\n        IBatchFlashBorrower borrower,\n        address[] calldata receivers,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n\n    function claimOwnership() external;\n\n    function flashLoan(IFlashBorrower borrower, address receiver, IERC20 token, uint256 amount, bytes calldata data) external;\n\n    function deploy(address masterContract, bytes calldata data, bool useCreate2) external payable returns (address);\n\n    function deposit(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    function harvest(IERC20 token, bool balance, uint256 maxChangeAmount) external;\n\n    function masterContractApproved(address, address) external view returns (bool);\n\n    function masterContractOf(address) external view returns (address);\n\n    function nonces(address) external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function pendingOwner() external view returns (address);\n\n    function pendingStrategy(IERC20) external view returns (IStrategy);\n\n    function permitToken(IERC20 token, address from, address to, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    function registerProtocol() external;\n\n    function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) external;\n\n    function setStrategy(IERC20 token, IStrategy newStrategy) external;\n\n    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;\n\n    function strategy(IERC20) external view returns (IStrategy);\n\n    function strategyData(IERC20) external view returns (uint64 strategyStartDate, uint64 targetPercentage, uint128 balance);\n\n    function toAmount(IERC20 token, uint256 share, bool roundUp) external view returns (uint256 amount);\n\n    function toShare(IERC20 token, uint256 amount, bool roundUp) external view returns (uint256 share);\n\n    function totals(IERC20) external view returns (Rebase memory totals_);\n\n    function transfer(IERC20 token, address from, address to, uint256 share) external;\n\n    function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) external;\n\n    function transferOwnership(address newOwner, bool direct, bool renounce) external;\n\n    function whitelistMasterContract(address masterContract, bool approved) external;\n\n    function whitelistedMasterContracts(address) external view returns (bool);\n\n    function withdraw(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n}\n\ninterface IBentoBoxLite {\n    function deposit(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    function balanceOf(address, address) external view returns (uint256);\n\n    function toAmount(address token, uint256 share, bool roundUp) external view returns (uint256 amount);\n\n    function toShare(address token, uint256 amount, bool roundUp) external view returns (uint256 share);\n\n    function transfer(address token, address from, address to, uint256 share) external;\n}\n"
      },
      "src/interfaces/IConvexWrapper.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IConvexWrapper {\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n\n    function addRewards() external;\n\n    function addTokenReward(address _token) external;\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function cauldrons(uint256) external view returns (address);\n\n    function cauldronsLength() external view returns (uint256);\n\n    function collateralVault() external view returns (address);\n\n    function convexBooster() external view returns (address);\n\n    function convexPool() external view returns (address);\n\n    function convexPoolId() external view returns (uint256);\n\n    function convexToken() external view returns (address);\n\n    function crv() external view returns (address);\n\n    function curveToken() external view returns (address);\n\n    function cvx() external view returns (address);\n\n    function decimals() external view returns (uint8);\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n    function deposit(uint256 _amount, address _to) external;\n\n    function earmarkRewards() external returns (bool);\n\n    function earned(address _account) external returns (EarnedData[] memory claimable);\n\n    function factory() external view returns (address);\n\n    function getReward(address _account, address _forwardTo) external;\n\n    function getReward(address _account) external;\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n    function initialize(uint256 _poolId) external;\n\n    function invalidateReward(address _token) external;\n\n    function isInit() external view returns (bool);\n\n    function isShutdown() external view returns (bool);\n\n    function name() external view returns (string memory);\n\n    function owner() external view returns (address);\n\n    function registeredRewards(address) external view returns (uint256);\n\n    function renounceOwnership() external;\n\n    function rewardHook() external view returns (address);\n\n    function rewardLength() external view returns (uint256);\n\n    function rewardRedirect(address) external view returns (address);\n\n    function rewards(\n        uint256\n    ) external view returns (address reward_token, address reward_pool, uint256 reward_integral, uint256 reward_remaining);\n\n    function setApprovals() external;\n\n    function setCauldron(address _cauldron) external;\n\n    function setHook(address _hook) external;\n\n    function setRewardRedirect(address _to) external;\n\n    function shutdown() external;\n\n    function stake(uint256 _amount, address _to) external;\n\n    function symbol() external view returns (string memory);\n\n    function totalBalanceOf(address _account) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    function transferOwnership(address newOwner) external;\n\n    function user_checkpoint(address _account) external returns (bool);\n\n    function withdraw(uint256 _amount) external;\n\n    function withdrawAndUnwrap(uint256 _amount) external;\n}\n"
      },
      "src/interfaces/ICurvePool.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase, var-name-mixedcase\npragma solidity >=0.8.0;\n\nenum CurvePoolInterfaceType {\n    ICURVE_POOL,\n    ICURVE_3POOL_ZAPPER,\n    IFACTORY_POOL,\n    ITRICRYPTO_POOL,\n    ICURVE_POOL_LEGACY\n}\n\ninterface ICurvePool {\n    function decimals() external view returns (uint256);\n\n    function coins(uint256 i) external view returns (address);\n\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external returns (uint256);\n\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256);\n\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function add_liquidity(uint256[2] memory amounts, uint256 _min_mint_amount) external;\n\n    function add_liquidity(uint256[3] memory amounts, uint256 _min_mint_amount) external;\n\n    function add_liquidity(uint256[4] memory amounts, uint256 _min_mint_amount) external;\n\n    function remove_liquidity_one_coin(uint256 tokenAmount, int128 i, uint256 min_amount) external returns (uint256);\n\n    function get_virtual_price() external view returns (uint256 price);\n}\n\ninterface ICurvePoolLegacy {\n    function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_amount) external;\n}\n\ninterface ICurve3PoolZapper {\n    function add_liquidity(address _pool, uint256[4] memory _deposit_amounts, uint256 _min_mint_amount) external returns (uint256);\n\n    function add_liquidity(\n        address _pool,\n        uint256[4] memory _deposit_amounts,\n        uint256 _min_mint_amount,\n        address _receiver\n    ) external returns (uint256);\n\n    function remove_liquidity(address _pool, uint256 _burn_amount, uint256[4] memory _min_amounts) external returns (uint256[4] memory);\n\n    function remove_liquidity(\n        address _pool,\n        uint256 _burn_amount,\n        uint256[4] memory _min_amounts,\n        address _receiver\n    ) external returns (uint256[4] memory);\n\n    function remove_liquidity_one_coin(address _pool, uint256 _burn_amount, int128 i, uint256 _min_amount) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        address _pool,\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_amount,\n        address _receiver\n    ) external returns (uint256);\n}\n\ninterface IFactoryPool is ICurvePool {\n    function remove_liquidity_one_coin(uint256 tokenAmount, uint256 i, uint256 min_amount) external returns (uint256);\n}\n\ninterface ITriCrypto is ICurvePool {\n    function remove_liquidity_one_coin(uint256 tokenAmount, uint256 i, uint256 min_amount) external;\n}\n"
      },
      "dependencies/openzeppelin-contracts-5.0.2/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
      },
      "src/interfaces/ISwapperV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ISwapperV2 {\n    function swap(\n        address fromToken,\n        address toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom,\n        bytes calldata data\n    ) external returns (uint256 extraShare, uint256 shareReturned);\n}\n"
      },
      "dependencies/BoringSolidity-1.0.0/contracts/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    // transfer and tranferFrom have been removed, because they don't work on all tokens (some aren't ERC20 complaint).\n    // By removing them you can't accidentally use them.\n    // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).\n    // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ninterface IStrictERC20 {\n    // This is the strict ERC20 interface. Don't use this, certainly not if you don't control the ERC20 token you're calling.\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
      },
      "dependencies/BoringSolidity-1.0.0/contracts/libraries/BoringRebase.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport {BoringMath, BoringMath128} from \"./BoringMath.sol\";\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\n/// @notice A rebasing library using overflow-/underflow-safe math.\nlibrary RebaseLibrary {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = (elastic * total.base) / total.elastic;\n            if (roundUp && (base * total.elastic) / total.base < elastic) {\n                base++;\n            }\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = (base * total.elastic) / total.base;\n            if (roundUp && (elastic * total.base) / total.elastic < base) {\n                elastic++;\n            }\n        }\n    }\n\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\n    /// @return (Rebase) The new total.\n    /// @return base in relationship to `elastic`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 base) {\n        base = toBase(total, elastic, roundUp);\n        total.elastic += elastic.to128();\n        total.base += base.to128();\n        return (total, base);\n    }\n\n    /// @notice Sub `base` from `total` and update `total.elastic`.\n    /// @return (Rebase) The new total.\n    /// @return elastic in relationship to `base`.\n    function sub(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 elastic) {\n        elastic = toElastic(total, base, roundUp);\n        total.elastic -= elastic.to128();\n        total.base -= base.to128();\n        return (total, elastic);\n    }\n\n    /// @notice Add `elastic` and `base` to `total`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic += elastic.to128();\n        total.base += base.to128();\n        return total;\n    }\n\n    /// @notice Subtract `elastic` and `base` to `total`.\n    function sub(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic -= elastic.to128();\n        total.base -= base.to128();\n        return total;\n    }\n\n    /// @notice Add `elastic` to `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic += elastic.to128();\n    }\n\n    /// @notice Subtract `elastic` from `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic -= elastic.to128();\n    }\n}\n"
      },
      "src/interfaces/IStrategy.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IStrategy {\n    function skim(uint256 amount) external;\n\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\n\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\n\n    function exit(uint256 balance) external returns (int256 amountAdded);\n}\n"
      },
      "dependencies/openzeppelin-contracts-5.0.2/contracts/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "dependencies/BoringSolidity-1.0.0/contracts/libraries/BoringMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nlibrary BoringMath {\n    error ErrOverflow();\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function to32(uint256 a) internal pure returns (uint32) {\n        if (a > type(uint32).max) {\n            revert ErrOverflow();\n        }\n        return uint32(a);\n    }\n\n    function to40(uint256 a) internal pure returns (uint40) {\n        if (a > type(uint40).max) {\n            revert ErrOverflow();\n        }\n        return uint40(a);\n    }\n\n    function to64(uint256 a) internal pure returns (uint64) {\n        if (a > type(uint64).max) {\n            revert ErrOverflow();\n        }\n        return uint64(a);\n    }\n\n    function to112(uint256 a) internal pure returns (uint112) {\n        if (a > type(uint112).max) {\n            revert ErrOverflow();\n        }\n        return uint112(a);\n    }\n\n    function to128(uint256 a) internal pure returns (uint128) {\n        if (a > type(uint128).max) {\n            revert ErrOverflow();\n        }\n        return uint128(a);\n    }\n\n    function to208(uint256 a) internal pure returns (uint208) {\n        if (a > type(uint208).max) {\n            revert ErrOverflow();\n        }\n        return uint208(a);\n    }\n\n    function to216(uint256 a) internal pure returns (uint216) {\n        if (a > type(uint216).max) {\n            revert ErrOverflow();\n        }\n        return uint216(a);\n    }\n\n    function to224(uint256 a) internal pure returns (uint224) {\n        if (a > type(uint224).max) {\n            revert ErrOverflow();\n        }\n        return uint224(a);\n    }\n}\n\nlibrary BoringMath32 {\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a + b;\n    }\n\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a - b;\n    }\n\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a * b;\n    }\n\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a / b;\n    }\n}\n\nlibrary BoringMath64 {\n    function add(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a + b;\n    }\n\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a - b;\n    }\n\n    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a * b;\n    }\n\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a / b;\n    }\n}\n\nlibrary BoringMath112 {\n    function add(uint112 a, uint112 b) internal pure returns (uint112) {\n        return a + b;\n    }\n\n    function sub(uint112 a, uint112 b) internal pure returns (uint112) {\n        return a - b;\n    }\n\n    function mul(uint112 a, uint112 b) internal pure returns (uint112) {\n        return a * b;\n    }\n\n    function div(uint112 a, uint112 b) internal pure returns (uint112) {\n        return a / b;\n    }\n}\n\nlibrary BoringMath128 {\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\n        return a + b;\n    }\n\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\n        return a - b;\n    }\n\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\n        return a * b;\n    }\n\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\n        return a / b;\n    }\n}\n\nlibrary BoringMath224 {\n    function add(uint224 a, uint224 b) internal pure returns (uint224) {\n        return a + b;\n    }\n\n    function sub(uint224 a, uint224 b) internal pure returns (uint224) {\n        return a - b;\n    }\n\n    function mul(uint224 a, uint224 b) internal pure returns (uint224) {\n        return a * b;\n    }\n\n    function div(uint224 a, uint224 b) internal pure returns (uint224) {\n        return a / b;\n    }\n}\n"
      }
    },
    "settings": {
      "remappings": [
        "/=src/",
        "forge-std/=dependencies/forge-std-1.9.5/src/",
        "halmos-cheatcodes/=dependencies/halmos-cheatcodes-7328abe/src/",
        "@openzeppelin/contracts/=dependencies/openzeppelin-contracts-5.0.2/contracts/",
        "@openzeppelin/contracts-upgradeable/=dependencies/openzeppelin-contracts-upgradeable-5.0.2/contracts/",
        "@BoringSolidity/=dependencies/BoringSolidity-1.0.0/contracts/",
        "@solady/=dependencies/solady-0.0.281/src/",
        "@solmate/=dependencies/solmate-6.2.0/src/",
        "@excessivelySafeCall/=dependencies/ExcessivelySafeCall-0.0.1/src/",
        "@safe-contracts/=dependencies/safe-contracts-1.3.0/contracts/",
        "@fuzzlib/=dependencies/fuzzlib-0.0.1/src/",
        "@abracadabra-oft-v1/=dependencies/abracadabra-oft-v1-0.0.1/src/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 400
      },
      "metadata": {
        "useLiteralContent": false,
        "bytecodeHash": "ipfs",
        "appendCBOR": true
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode.object",
            "evm.bytecode.sourceMap",
            "evm.bytecode.linkReferences",
            "evm.deployedBytecode.object",
            "evm.deployedBytecode.sourceMap",
            "evm.deployedBytecode.linkReferences",
            "evm.deployedBytecode.immutableReferences",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "evmVersion": "cancun",
      "viaIR": false,
      "libraries": {}
    }
  },
  "compiler": "0.8.28+commit.7893614a"
}