{
  "address": "0xE433a9BC3374D99b856294D0FA705E25A3e41dE1",
  "abi": [
    {
      "type": "function",
      "name": "getMidPrice",
      "inputs": [
        {
          "name": "lp",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    }
  ],
  "bytecode": "0x6080604052348015600f57600080fd5b5061039f8061001f6000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063542b84ac14610030575b600080fd5b61004361003e3660046101fe565b610055565b60405190815260200160405180910390f35b600080826001600160a01b031663a382d1b96040518163ffffffff1660e01b815260040160e060405180830381865afa158015610096573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100ba9190610242565b905060028160c0015160028111156100d4576100d46102de565b0361015157606081015160a0820151600091610108916100f4908061030a565b6100fe9190610321565b83606001516101c1565b90506101188260200151826101e9565b602083015161012f90670de0b6b3a7640000610343565b6101399190610356565b90506101498260000151826101c1565b949350505050565b604081015160808201516000916101809161016c908061030a565b6101769190610321565b83604001516101c1565b90506101908260200151826101e9565b60208301516101a790670de0b6b3a7640000610343565b6101b19190610356565b90506101498260000151826101e9565b6000816101d6670de0b6b3a76400008561030a565b6101e09190610321565b90505b92915050565b6000670de0b6b3a76400006101d6838561030a565b60006020828403121561021057600080fd5b81356001600160a01b038116811461022757600080fd5b9392505050565b80516003811061023d57600080fd5b919050565b600060e082840312801561025557600080fd5b6000905060405160e0810181811067ffffffffffffffff8211171561028857634e487b7160e01b83526041600452602483fd5b604090815284518252602080860151908301528481015190820152606080850151908201526080808501519082015260a08085015190820181905291506102d160c0850161022e565b60c0820152949350505050565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b80820281158282048414176101e3576101e36102f4565b60008261033e57634e487b7160e01b600052601260045260246000fd5b500490565b818103818111156101e3576101e36102f4565b808201808211156101e3576101e36102f456fea2646970667358221220173e3662f4ef3d5b9862709379169c8d89d9f53f15f1743500a7b40b1fc3fb2264736f6c634300081a0033",
  "args_data": "0x",
  "tx_hash": "",
  "args": null,
  "data": "",
  "artifact_path": "MagicLPLens.sol",
  "artifact_full_path": "MagicLPLens.sol:MagicLPLens",
  "standardJsonInput": {
    "language": "Solidity",
    "sources": {
      "src/lenses/MagicLPLens.sol": {
        "content": "pragma solidity >=0.8.0;\n/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\nimport {DecimalMath} from \"/mimswap/libraries/DecimalMath.sol\";\nimport {MagicLP} from \"/mimswap/MagicLP.sol\";\nimport {PMMPricing} from \"/mimswap/libraries/PMMPricing.sol\";\n\ncontract MagicLPLens {\n    function getMidPrice(address lp) external view returns (uint256) {\n        PMMPricing.PMMState memory state = MagicLP(lp).getPMMState();\n        if (state.R == PMMPricing.RState.BELOW_ONE) {\n            uint256 R = DecimalMath.divFloor((state.Q0 * state.Q0) / state.Q, state.Q);\n            R = DecimalMath.ONE - state.K + DecimalMath.mulFloor(state.K, R);\n            return DecimalMath.divFloor(state.i, R);\n        } else {\n            uint256 R = DecimalMath.divFloor((state.B0 * state.B0) / state.B, state.B);\n            R = DecimalMath.ONE - state.K + DecimalMath.mulFloor(state.K, R);\n            return DecimalMath.mulFloor(state.i, R);\n        }\n    }\n}\n"
      },
      "src/mimswap/libraries/DecimalMath.sol": {
        "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\npragma solidity >=0.8.0;\n\nimport {Math} from \"/mimswap/libraries/Math.sol\";\n\n/**\n * @title DecimalMath\n * @author DODO Breeder\n *\n * @notice Functions for fixed point number with 18 decimals\n */\nlibrary DecimalMath {\n    using Math for uint256;\n\n    uint256 internal constant ONE = 10 ** 18;\n    uint256 internal constant ONE2 = 10 ** 36;\n\n    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n        return (target * d) / ONE;\n    }\n\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n        return (target * d).divCeil(ONE);\n    }\n\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n        return (target * ONE) / d;\n    }\n\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n        return (target * ONE).divCeil(d);\n    }\n\n    function reciprocalFloor(uint256 target) internal pure returns (uint256) {\n        return ONE2 / target;\n    }\n\n    function reciprocalCeil(uint256 target) internal pure returns (uint256) {\n        return ONE2.divCeil(target);\n    }\n\n    function powFloor(uint256 target, uint256 e) internal pure returns (uint256) {\n        if (e == 0) {\n            return 10 ** 18;\n        } else if (e == 1) {\n            return target;\n        } else {\n            uint p = powFloor(target, e / 2);\n            p = (p * p) / ONE;\n            if (e % 2 == 1) {\n                p = (p * target) / ONE;\n            }\n            return p;\n        }\n    }\n}\n"
      },
      "src/mimswap/MagicLP.sol": {
        "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity >=0.8.0;\n\nimport {Owned} from \"@solmate/auth/Owned.sol\";\nimport {ERC20} from \"@solady/tokens/ERC20.sol\";\nimport {SafeCastLib} from \"@solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"@solady/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"@solady/utils/ReentrancyGuard.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\nimport {DecimalMath} from \"/mimswap/libraries/DecimalMath.sol\";\nimport {Math} from \"/mimswap/libraries/Math.sol\";\nimport {PMMPricing} from \"/mimswap/libraries/PMMPricing.sol\";\nimport {ICallee} from \"/mimswap/interfaces/ICallee.sol\";\nimport {IFeeRateModel} from \"/mimswap/interfaces/IFeeRateModel.sol\";\nimport {IWETH} from \"/interfaces/IWETH.sol\";\n\n/// @title MIMSwap MagicLP\n/// @author Adapted from DODOEX DSP https://github.com/DODOEX/contractV2/tree/main/contracts/DODOStablePool\ncontract MagicLP is ERC20, ReentrancyGuard, Owned {\n    using Math for uint256;\n    using SafeCastLib for uint256;\n    using SafeTransferLib for address;\n\n    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);\n    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);\n    event Swap(address fromToken, address toToken, uint256 fromAmount, uint256 toAmount, address trader, address receiver);\n    event FlashLoan(address borrower, address assetTo, uint256 baseAmount, uint256 quoteAmount);\n    event RChange(PMMPricing.RState newRState);\n    event TokenRescue(address indexed token, address to, uint256 amount);\n    event ParametersChanged(uint256 newLpFeeRate, uint256 newI, uint256 newK);\n    event TargetChanged(uint112 newBaseTarget, uint112 newQuoteTarget);\n    event PausedChanged(bool paused);\n    event OperatorChanged(address indexed operator, bool status);\n\n    error ErrInitialized();\n    error ErrBaseQuoteSame();\n    error ErrInvalidI();\n    error ErrInvalidK();\n    error ErrExpired();\n    error ErrInvalidSignature();\n    error ErrFlashLoanFailed();\n    error ErrNoBaseInput();\n    error ErrZeroAddress();\n    error ErrZeroQuoteAmount();\n    error ErrZeroQuoteTarget();\n    error ErrMintAmountNotEnough();\n    error ErrNotEnough();\n    error ErrWithdrawNotEnough();\n    error ErrSellBackNotAllowed();\n    error ErrInvalidLPFeeRate();\n    error ErrNotImplementationOwner();\n    error ErrNotImplementation();\n    error ErrNotClone();\n    error ErrNotAllowed();\n    error ErrReserveAmountNotEnough();\n    error ErrOverflow();\n    error ErrNotPaused();\n    error ErrNotAllowedImplementationOperator();\n    error ErrInvalidTargets();\n\n    MagicLP public immutable implementation;\n\n    uint256 public constant MAX_I = 10 ** 36;\n    uint256 public constant MAX_K = 10 ** 18;\n    uint256 public constant MIN_LP_FEE_RATE = 1e14; // 0.01%\n    uint256 public constant MAX_LP_FEE_RATE = 1e16; // 1%\n\n    bool internal _INITIALIZED_;\n    bool public _PAUSED_;\n    bool public _PROTOCOL_OWNED_POOL_;\n\n    address public _BASE_TOKEN_;\n    address public _QUOTE_TOKEN_;\n    uint112 public _BASE_RESERVE_;\n    uint112 public _QUOTE_RESERVE_;\n    uint112 public _BASE_TARGET_;\n    uint112 public _QUOTE_TARGET_;\n    uint32 public _RState_;\n    IFeeRateModel public _MT_FEE_RATE_MODEL_;\n    uint256 public _LP_FEE_RATE_;\n    uint256 public _K_;\n    uint256 public _I_;\n\n    mapping(address => bool) public operators;\n\n    constructor(address owner_) Owned(owner_) {\n        implementation = this;\n\n        // prevents the implementation contract initialization\n        _INITIALIZED_ = true;\n    }\n\n    function init(\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 i,\n        uint256 k,\n        bool protocolOwnedPool\n    ) external {\n        if (_INITIALIZED_) {\n            revert ErrInitialized();\n        }\n        if (mtFeeRateModel == address(0) || baseTokenAddress == address(0) || quoteTokenAddress == address(0)) {\n            revert ErrZeroAddress();\n        }\n        if (baseTokenAddress == quoteTokenAddress) {\n            revert ErrBaseQuoteSame();\n        }\n        if (i == 0 || i > MAX_I) {\n            revert ErrInvalidI();\n        }\n        if (k > MAX_K) {\n            revert ErrInvalidK();\n        }\n        if (lpFeeRate < MIN_LP_FEE_RATE || lpFeeRate > MAX_LP_FEE_RATE) {\n            revert ErrInvalidLPFeeRate();\n        }\n\n        _INITIALIZED_ = true;\n        _BASE_TOKEN_ = baseTokenAddress;\n        _QUOTE_TOKEN_ = quoteTokenAddress;\n        _I_ = i;\n        _K_ = k;\n        _LP_FEE_RATE_ = lpFeeRate;\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\n        _PROTOCOL_OWNED_POOL_ = protocolOwnedPool;\n\n        _afterInitialized();\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PUBLIC - CLONES ONLY\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function sync() external nonReentrant onlyClones {\n        _sync();\n    }\n\n    function correctRState() external onlyClones {\n        if (_RState_ == uint32(PMMPricing.RState.BELOW_ONE) && _BASE_RESERVE_ < _BASE_TARGET_) {\n            _RState_ = uint32(PMMPricing.RState.ONE);\n            _BASE_TARGET_ = _BASE_RESERVE_;\n            _QUOTE_TARGET_ = _QUOTE_RESERVE_;\n        }\n        if (_RState_ == uint32(PMMPricing.RState.ABOVE_ONE) && _QUOTE_RESERVE_ < _QUOTE_TARGET_) {\n            _RState_ = uint32(PMMPricing.RState.ONE);\n            _BASE_TARGET_ = _BASE_RESERVE_;\n            _QUOTE_TARGET_ = _QUOTE_RESERVE_;\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// VIEWS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function name() public view override returns (string memory) {\n        return string(abi.encodePacked(\"MagicLP \", IERC20Metadata(_BASE_TOKEN_).symbol(), \"/\", IERC20Metadata(_QUOTE_TOKEN_).symbol()));\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return \"MagicLP\";\n    }\n\n    function decimals() public view override returns (uint8) {\n        return IERC20Metadata(_BASE_TOKEN_).decimals();\n    }\n\n    function isImplementationOperator(address _operator) public view returns (bool) {\n        return implementation.operators(_operator) || _operator == implementation.owner();\n    }\n\n    function querySellBase(\n        address trader,\n        uint256 payBaseAmount\n    ) public view returns (uint256 receiveQuoteAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newBaseTarget) {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveQuoteAmount, newRState) = PMMPricing.sellBaseToken(state, payBaseAmount);\n\n        (uint256 lpFeeRate, uint256 mtFeeRate) = _MT_FEE_RATE_MODEL_.getFeeRate(trader, _LP_FEE_RATE_);\n        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\n        receiveQuoteAmount = (receiveQuoteAmount - DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate)) - mtFee;\n        newBaseTarget = state.B0;\n    }\n\n    function querySellQuote(\n        address trader,\n        uint256 payQuoteAmount\n    ) public view returns (uint256 receiveBaseAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newQuoteTarget) {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveBaseAmount, newRState) = PMMPricing.sellQuoteToken(state, payQuoteAmount);\n\n        (uint256 lpFeeRate, uint256 mtFeeRate) = _MT_FEE_RATE_MODEL_.getFeeRate(trader, _LP_FEE_RATE_);\n        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\n        receiveBaseAmount = (receiveBaseAmount - DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate)) - mtFee;\n        newQuoteTarget = state.Q0;\n    }\n\n    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\n        state.i = _I_;\n        state.K = _K_;\n        state.B = _BASE_RESERVE_;\n        state.Q = _QUOTE_RESERVE_;\n        state.B0 = _BASE_TARGET_; // will be calculated in adjustedTarget\n        state.Q0 = _QUOTE_TARGET_;\n        state.R = PMMPricing.RState(_RState_);\n        PMMPricing.adjustedTarget(state);\n    }\n\n    function getPMMStateForCall() external view returns (uint256 i, uint256 K, uint256 B, uint256 Q, uint256 B0, uint256 Q0, uint256 R) {\n        PMMPricing.PMMState memory state = getPMMState();\n        i = state.i;\n        K = state.K;\n        B = state.B;\n        Q = state.Q;\n        B0 = state.B0;\n        Q0 = state.Q0;\n        R = uint256(state.R);\n    }\n\n    function getReserves() external view returns (uint256 baseReserve, uint256 quoteReserve) {\n        baseReserve = _BASE_RESERVE_;\n        quoteReserve = _QUOTE_RESERVE_;\n    }\n\n    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate) {\n        return _MT_FEE_RATE_MODEL_.getFeeRate(user, _LP_FEE_RATE_);\n    }\n\n    function getBaseInput() public view nonReadReentrant returns (uint256 input) {\n        return _BASE_TOKEN_.balanceOf(address(this)) - uint256(_BASE_RESERVE_);\n    }\n\n    function getQuoteInput() public view nonReadReentrant returns (uint256 input) {\n        return _QUOTE_TOKEN_.balanceOf(address(this)) - uint256(_QUOTE_RESERVE_);\n    }\n\n    function version() external pure virtual returns (string memory) {\n        return \"MagicLP 1.0.0\";\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// TRADE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function sellBase(address to) external nonReentrant onlyClones whenNotPaused returns (uint256 receiveQuoteAmount) {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 baseInput = baseBalance - uint256(_BASE_RESERVE_);\n        uint256 mtFee;\n        uint256 newBaseTarget;\n        PMMPricing.RState newRState;\n        (receiveQuoteAmount, mtFee, newRState, newBaseTarget) = querySellBase(tx.origin, baseInput);\n\n        _transferQuoteOut(to, receiveQuoteAmount);\n        _transferQuoteOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);\n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            _BASE_TARGET_ = newBaseTarget.toUint112();\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)));\n\n        emit Swap(address(_BASE_TOKEN_), address(_QUOTE_TOKEN_), baseInput, receiveQuoteAmount, msg.sender, to);\n    }\n\n    function sellQuote(address to) external nonReentrant onlyClones whenNotPaused returns (uint256 receiveBaseAmount) {\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 quoteInput = quoteBalance - uint256(_QUOTE_RESERVE_);\n        uint256 mtFee;\n        uint256 newQuoteTarget;\n        PMMPricing.RState newRState;\n        (receiveBaseAmount, mtFee, newRState, newQuoteTarget) = querySellQuote(tx.origin, quoteInput);\n\n        _transferBaseOut(to, receiveBaseAmount);\n        _transferBaseOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);\n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            _QUOTE_TARGET_ = newQuoteTarget.toUint112();\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(_BASE_TOKEN_.balanceOf(address(this)), quoteBalance);\n\n        emit Swap(address(_QUOTE_TOKEN_), address(_BASE_TOKEN_), quoteInput, receiveBaseAmount, msg.sender, to);\n    }\n\n    function flashLoan(\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        address assetTo,\n        bytes calldata data\n    ) external nonReentrant onlyClones whenNotPaused {\n        _transferBaseOut(assetTo, baseAmount);\n        _transferQuoteOut(assetTo, quoteAmount);\n\n        if (data.length > 0) {\n            ICallee(assetTo).FlashLoanCall(msg.sender, baseAmount, quoteAmount, data);\n        }\n\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        // no input -> pure loss\n        if (baseBalance < _BASE_RESERVE_ && quoteBalance < _QUOTE_RESERVE_) {\n            revert ErrFlashLoanFailed();\n        }\n\n        // sell quote case\n        // quote input + base output\n        if (baseBalance < _BASE_RESERVE_) {\n            uint256 quoteInput = quoteBalance - uint256(_QUOTE_RESERVE_);\n            (uint256 receiveBaseAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newQuoteTarget) = querySellQuote(\n                tx.origin,\n                quoteInput\n            );\n\n            if (uint256(_BASE_RESERVE_) - baseBalance > receiveBaseAmount) {\n                revert ErrFlashLoanFailed();\n            }\n\n            _transferBaseOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);\n            if (_RState_ != uint32(newRState)) {\n                _QUOTE_TARGET_ = newQuoteTarget.toUint112();\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit Swap(address(_QUOTE_TOKEN_), address(_BASE_TOKEN_), quoteInput, receiveBaseAmount, msg.sender, assetTo);\n        }\n\n        // sell base case\n        // base input + quote output\n        if (quoteBalance < _QUOTE_RESERVE_) {\n            uint256 baseInput = baseBalance - uint256(_BASE_RESERVE_);\n            (uint256 receiveQuoteAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newBaseTarget) = querySellBase(\n                tx.origin,\n                baseInput\n            );\n\n            if (uint256(_QUOTE_RESERVE_) - quoteBalance > receiveQuoteAmount) {\n                revert ErrFlashLoanFailed();\n            }\n\n            _transferQuoteOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);\n            if (_RState_ != uint32(newRState)) {\n                _BASE_TARGET_ = newBaseTarget.toUint112();\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit Swap(address(_BASE_TOKEN_), address(_QUOTE_TOKEN_), baseInput, receiveQuoteAmount, msg.sender, assetTo);\n        }\n\n        _sync();\n\n        emit FlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// BUY & SELL SHARES\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    // buy shares [round down]\n    function buyShares(\n        address to\n    ) external nonReentrant onlyClones whenNotPaused returns (uint256 shares, uint256 baseInput, uint256 quoteInput) {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 baseReserve = _BASE_RESERVE_;\n        uint256 quoteReserve = _QUOTE_RESERVE_;\n\n        baseInput = baseBalance - baseReserve;\n        quoteInput = quoteBalance - quoteReserve;\n\n        if (baseInput == 0) {\n            revert ErrNoBaseInput();\n        }\n\n        // Round down when withdrawing. Therefore, never be a situation occurring balance is 0 but totalsupply is not 0\n        // But May Happen，reserve >0 But totalSupply = 0\n        if (totalSupply() == 0) {\n            // case 1. initial supply\n            if (quoteBalance == 0) {\n                revert ErrZeroQuoteAmount();\n            }\n\n            shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_) ? DecimalMath.divFloor(quoteBalance, _I_) : baseBalance;\n            _BASE_TARGET_ = shares.toUint112();\n            _QUOTE_TARGET_ = DecimalMath.mulFloor(shares, _I_).toUint112();\n\n            if (_QUOTE_TARGET_ == 0) {\n                revert ErrZeroQuoteTarget();\n            }\n\n            if (shares <= 2001) {\n                revert ErrMintAmountNotEnough();\n            }\n\n            _mint(address(0), 1001);\n            shares -= 1001;\n        } else if (baseReserve > 0 && quoteReserve > 0) {\n            // case 2. normal case\n            uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\n            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\n            uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;\n            shares = DecimalMath.mulFloor(totalSupply(), mintRatio);\n\n            _BASE_TARGET_ = (uint256(_BASE_TARGET_) + DecimalMath.mulFloor(uint256(_BASE_TARGET_), mintRatio)).toUint112();\n            _QUOTE_TARGET_ = (uint256(_QUOTE_TARGET_) + DecimalMath.mulFloor(uint256(_QUOTE_TARGET_), mintRatio)).toUint112();\n        }\n\n        _mint(to, shares);\n        _setReserve(baseBalance, quoteBalance);\n\n        emit BuyShares(to, shares, balanceOf(to));\n    }\n\n    // sell shares [round down]\n    function sellShares(\n        uint256 shareAmount,\n        address to,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount,\n        bytes calldata data,\n        uint256 deadline\n    ) external nonReentrant onlyClones whenNotPaused returns (uint256 baseAmount, uint256 quoteAmount) {\n        if (deadline < block.timestamp) {\n            revert ErrExpired();\n        }\n        if (shareAmount > balanceOf(msg.sender)) {\n            revert ErrNotEnough();\n        }\n        if (to == address(this)) {\n            revert ErrSellBackNotAllowed();\n        }\n\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 totalShares = totalSupply();\n\n        baseAmount = (baseBalance * shareAmount) / totalShares;\n        quoteAmount = (quoteBalance * shareAmount) / totalShares;\n\n        _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_) - (uint256(_BASE_TARGET_) * shareAmount).divCeil(totalShares));\n        _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_) - (uint256(_QUOTE_TARGET_) * shareAmount).divCeil(totalShares));\n\n        if (baseAmount < baseMinAmount || quoteAmount < quoteMinAmount) {\n            revert ErrWithdrawNotEnough();\n        }\n\n        _burn(msg.sender, shareAmount);\n        _transferBaseOut(to, baseAmount);\n        _transferQuoteOut(to, quoteAmount);\n        _sync();\n\n        if (data.length > 0) {\n            ICallee(to).SellShareCall(msg.sender, shareAmount, baseAmount, quoteAmount, data);\n        }\n\n        emit SellShares(msg.sender, to, shareAmount, balanceOf(msg.sender));\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// ADMIN - IMPLEMENTATION ONLY\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function setOperator(address _operator, bool _status) external onlyImplementation onlyImplementationOwner {\n        operators[_operator] = _status;\n        emit OperatorChanged(_operator, _status);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// OPERATORS / ADMIN - PROTOCOL OWNED POOL AND CLONES ONLY\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function setPaused(bool paused) external onlyClones onlyProtocolOwnedPool onlyImplementationOperators {\n        _PAUSED_ = paused;\n        emit PausedChanged(paused);\n    }\n\n    function rescue(address token, address to, uint256 amount) external onlyClones onlyProtocolOwnedPool onlyImplementationOperators {\n        if (token == _BASE_TOKEN_ || token == _QUOTE_TOKEN_) {\n            revert ErrNotAllowed();\n        }\n\n        token.safeTransfer(to, amount);\n        emit TokenRescue(token, to, amount);\n    }\n\n    /// @notice Set new parameters for the pool\n    /// The pool must be paused, preferably blocks earlier to avoid sandwiching\n    function setParameters(\n        address assetTo,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) public nonReentrant onlyClones whenPaused onlyProtocolOwnedPool onlyImplementationOperators {\n        if (_BASE_RESERVE_ < minBaseReserve || _QUOTE_RESERVE_ < minQuoteReserve) {\n            revert ErrReserveAmountNotEnough();\n        }\n        if (newI == 0 || newI > MAX_I) {\n            revert ErrInvalidI();\n        }\n        if (newK > MAX_K) {\n            revert ErrInvalidK();\n        }\n        if (newLpFeeRate < MIN_LP_FEE_RATE || newLpFeeRate > MAX_LP_FEE_RATE) {\n            revert ErrInvalidLPFeeRate();\n        }\n\n        _LP_FEE_RATE_ = newLpFeeRate;\n        _K_ = newK;\n        _I_ = newI;\n\n        _transferBaseOut(assetTo, baseOutAmount);\n        _transferQuoteOut(assetTo, quoteOutAmount);\n\n        emit ParametersChanged(newLpFeeRate, newI, newK);\n    }\n\n    function resetTargetAndReserve()\n        public\n        nonReentrant\n        onlyClones\n        whenPaused\n        onlyProtocolOwnedPool\n        onlyImplementationOperators\n        returns (uint256 baseBalance, uint256 quoteBalance)\n    {\n        (baseBalance, quoteBalance) = _resetTargetAndReserve();\n        emit TargetChanged(uint112(baseBalance), uint112(quoteBalance));\n    }\n\n    function setTargets(\n        uint112 baseTarget,\n        uint112 quoteTarget\n    ) public nonReentrant onlyClones whenPaused onlyProtocolOwnedPool onlyImplementationOperators {\n        _BASE_TARGET_ = baseTarget;\n        _QUOTE_TARGET_ = quoteTarget;\n        emit TargetChanged(baseTarget, quoteTarget);\n    }\n\n    function setRState(\n        PMMPricing.RState newState\n    ) public nonReentrant onlyClones whenPaused onlyProtocolOwnedPool onlyImplementationOperators {\n        _RState_ = uint32(newState);\n        emit RChange(newState);\n    }\n\n    function ratioSync() external nonReentrant onlyClones onlyProtocolOwnedPool onlyImplementationOperators {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        if (baseBalance > type(uint112).max || quoteBalance > type(uint112).max) {\n            revert ErrOverflow();\n        }\n\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_TARGET_ = uint112((uint256(_BASE_TARGET_) * baseBalance) / uint256(_BASE_RESERVE_));\n            _BASE_RESERVE_ = uint112(baseBalance);\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_TARGET_ = uint112((uint256(_QUOTE_TARGET_) * quoteBalance) / uint256(_QUOTE_RESERVE_));\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\n        }\n\n        if (_BASE_TARGET_ == 0 || _QUOTE_TARGET_ == 0) {\n            revert ErrInvalidTargets();\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// INTERNALS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _resetTargetAndReserve() internal returns (uint256 baseBalance, uint256 quoteBalance) {\n        baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        if (baseBalance > type(uint112).max || quoteBalance > type(uint112).max) {\n            revert ErrOverflow();\n        }\n\n        _BASE_RESERVE_ = uint112(baseBalance);\n        _QUOTE_RESERVE_ = uint112(quoteBalance);\n        _BASE_TARGET_ = uint112(baseBalance);\n        _QUOTE_TARGET_ = uint112(quoteBalance);\n        _RState_ = uint32(PMMPricing.RState.ONE);\n    }\n\n    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {\n        _BASE_RESERVE_ = baseReserve.toUint112();\n        _QUOTE_RESERVE_ = quoteReserve.toUint112();\n    }\n\n    function _sync() internal {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_RESERVE_ = baseBalance.toUint112();\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_RESERVE_ = quoteBalance.toUint112();\n        }\n    }\n\n    function _transferBaseOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _BASE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function _transferQuoteOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _QUOTE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function _mint(address to, uint256 amount) internal override {\n        if (amount <= 1000) {\n            revert ErrMintAmountNotEnough();\n        }\n\n        super._mint(to, amount);\n    }\n\n    function _afterInitialized() internal virtual {}\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// MODIFIERS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    modifier onlyImplementationOwner() {\n        if (msg.sender != implementation.owner()) {\n            revert ErrNotImplementationOwner();\n        }\n        _;\n    }\n\n    /// @dev owner is always considered an operator\n    modifier onlyImplementationOperators() {\n        if (!isImplementationOperator(msg.sender)) {\n            revert ErrNotAllowedImplementationOperator();\n        }\n        _;\n    }\n\n    /// @dev can only be called on a clone contract\n    modifier onlyClones() {\n        if (address(this) == address(implementation)) {\n            revert ErrNotClone();\n        }\n        _;\n    }\n\n    /// @dev can only be called on the implementation contract\n    modifier onlyImplementation() {\n        if (address(this) != address(implementation)) {\n            revert ErrNotImplementation();\n        }\n        _;\n    }\n\n    modifier onlyProtocolOwnedPool() {\n        if (!_PROTOCOL_OWNED_POOL_) {\n            revert ErrNotAllowed();\n        }\n        _;\n    }\n\n    modifier whenPaused() {\n        if (!_PAUSED_) {\n            revert ErrNotPaused();\n        }\n        _;\n    }\n\n    /// @dev When it's a paused protocol owned pool,\n    /// only the implementation operators can call the function\n    /// A normal pool can never be paused.\n    modifier whenNotPaused() {\n        if (_PROTOCOL_OWNED_POOL_ && _PAUSED_ && !isImplementationOperator(msg.sender)) {\n            revert ErrNotAllowedImplementationOperator();\n        }\n        _;\n    }\n}\n"
      },
      "src/mimswap/libraries/PMMPricing.sol": {
        "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity >=0.8.0;\n\nimport {DecimalMath} from \"/mimswap/libraries/DecimalMath.sol\";\nimport {Math} from \"/mimswap/libraries/Math.sol\";\n\n/**\n * @title Pricing\n * @author DODO Breeder\n *\n * @notice DODO Pricing model\n */\n\nlibrary PMMPricing {\n    enum RState {\n        ONE,\n        ABOVE_ONE,\n        BELOW_ONE\n    }\n\n    struct PMMState {\n        uint256 i;\n        uint256 K;\n        uint256 B;\n        uint256 Q;\n        uint256 B0;\n        uint256 Q0;\n        RState R;\n    }\n\n    // ============ buy & sell ============\n\n    function sellBaseToken(PMMState memory state, uint256 payBaseAmount) internal pure returns (uint256 receiveQuoteAmount, RState newR) {\n        if (state.R == RState.ONE) {\n            // case 1: R=1\n            // R falls below one\n            receiveQuoteAmount = _ROneSellBaseToken(state, payBaseAmount);\n            newR = RState.BELOW_ONE;\n        } else if (state.R == RState.ABOVE_ONE) {\n            uint256 backToOnePayBase = state.B0 - state.B;\n            uint256 backToOneReceiveQuote = state.Q - state.Q0;\n            // case 2: R>1\n            // complex case, R status depends on trading amount\n            if (payBaseAmount < backToOnePayBase) {\n                // case 2.1: R status do not change\n                receiveQuoteAmount = _RAboveSellBaseToken(state, payBaseAmount);\n                newR = RState.ABOVE_ONE;\n                if (receiveQuoteAmount > backToOneReceiveQuote) {\n                    // [Important corner case!] may enter this branch when some precision problem happens. And consequently contribute to negative spare quote amount\n                    // to make sure spare quote>=0, mannually set receiveQuote=backToOneReceiveQuote\n                    receiveQuoteAmount = backToOneReceiveQuote;\n                }\n            } else if (payBaseAmount == backToOnePayBase) {\n                // case 2.2: R status changes to ONE\n                receiveQuoteAmount = backToOneReceiveQuote;\n                newR = RState.ONE;\n            } else {\n                // case 2.3: R status changes to BELOW_ONE\n                receiveQuoteAmount = backToOneReceiveQuote + _ROneSellBaseToken(state, payBaseAmount - backToOnePayBase);\n                newR = RState.BELOW_ONE;\n            }\n        } else {\n            // state.R == RState.BELOW_ONE\n            // case 3: R<1\n            receiveQuoteAmount = _RBelowSellBaseToken(state, payBaseAmount);\n            newR = RState.BELOW_ONE;\n        }\n    }\n\n    function sellQuoteToken(PMMState memory state, uint256 payQuoteAmount) internal pure returns (uint256 receiveBaseAmount, RState newR) {\n        if (state.R == RState.ONE) {\n            receiveBaseAmount = _ROneSellQuoteToken(state, payQuoteAmount);\n            newR = RState.ABOVE_ONE;\n        } else if (state.R == RState.ABOVE_ONE) {\n            receiveBaseAmount = _RAboveSellQuoteToken(state, payQuoteAmount);\n            newR = RState.ABOVE_ONE;\n        } else {\n            uint256 backToOnePayQuote = state.Q0 - state.Q;\n            uint256 backToOneReceiveBase = state.B - state.B0;\n            if (payQuoteAmount < backToOnePayQuote) {\n                receiveBaseAmount = _RBelowSellQuoteToken(state, payQuoteAmount);\n                newR = RState.BELOW_ONE;\n                if (receiveBaseAmount > backToOneReceiveBase) {\n                    receiveBaseAmount = backToOneReceiveBase;\n                }\n            } else if (payQuoteAmount == backToOnePayQuote) {\n                receiveBaseAmount = backToOneReceiveBase;\n                newR = RState.ONE;\n            } else {\n                receiveBaseAmount = backToOneReceiveBase + _ROneSellQuoteToken(state, payQuoteAmount - backToOnePayQuote);\n                newR = RState.ABOVE_ONE;\n            }\n        }\n    }\n\n    // ============ R = 1 cases ============\n\n    function _ROneSellBaseToken(\n        PMMState memory state,\n        uint256 payBaseAmount\n    )\n        internal\n        pure\n        returns (\n            uint256 // receiveQuoteToken\n        )\n    {\n        // in theory Q2 <= targetQuoteTokenAmount\n        // however when amount is close to 0, precision problems may cause Q2 > targetQuoteTokenAmount\n        return Math._SolveQuadraticFunctionForTrade(state.Q0, state.Q0, payBaseAmount, state.i, state.K);\n    }\n\n    function _ROneSellQuoteToken(\n        PMMState memory state,\n        uint256 payQuoteAmount\n    )\n        internal\n        pure\n        returns (\n            uint256 // receiveBaseToken\n        )\n    {\n        return Math._SolveQuadraticFunctionForTrade(state.B0, state.B0, payQuoteAmount, DecimalMath.reciprocalFloor(state.i), state.K);\n    }\n\n    // ============ R < 1 cases ============\n\n    function _RBelowSellQuoteToken(\n        PMMState memory state,\n        uint256 payQuoteAmount\n    )\n        internal\n        pure\n        returns (\n            uint256 // receiveBaseToken\n        )\n    {\n        return Math._GeneralIntegrate(state.Q0, state.Q + payQuoteAmount, state.Q, DecimalMath.reciprocalFloor(state.i), state.K);\n    }\n\n    function _RBelowSellBaseToken(\n        PMMState memory state,\n        uint256 payBaseAmount\n    )\n        internal\n        pure\n        returns (\n            uint256 // receiveQuoteToken\n        )\n    {\n        return Math._SolveQuadraticFunctionForTrade(state.Q0, state.Q, payBaseAmount, state.i, state.K);\n    }\n\n    // ============ R > 1 cases ============\n\n    function _RAboveSellBaseToken(\n        PMMState memory state,\n        uint256 payBaseAmount\n    )\n        internal\n        pure\n        returns (\n            uint256 // receiveQuoteToken\n        )\n    {\n        return Math._GeneralIntegrate(state.B0, state.B + payBaseAmount, state.B, state.i, state.K);\n    }\n\n    function _RAboveSellQuoteToken(\n        PMMState memory state,\n        uint256 payQuoteAmount\n    )\n        internal\n        pure\n        returns (\n            uint256 // receiveBaseToken\n        )\n    {\n        return Math._SolveQuadraticFunctionForTrade(state.B0, state.B, payQuoteAmount, DecimalMath.reciprocalFloor(state.i), state.K);\n    }\n\n    // ============ Helper functions ============\n\n    function adjustedTarget(PMMState memory state) internal pure {\n        if (state.R == RState.BELOW_ONE) {\n            state.Q0 = Math._SolveQuadraticFunctionForTarget(state.Q, state.B - state.B0, state.i, state.K);\n        } else if (state.R == RState.ABOVE_ONE) {\n            state.B0 = Math._SolveQuadraticFunctionForTarget(\n                state.B,\n                state.Q - state.Q0,\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n        }\n    }\n}\n"
      },
      "src/mimswap/libraries/Math.sol": {
        "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity >=0.8.0;\n\nimport {DecimalMath} from \"/mimswap/libraries/DecimalMath.sol\";\n\n/**\n * @author Adapted from https://github.com/DODOEX/contractV2/blob/main/contracts/lib/Math.sol\n * @notice Functions for complex calculating. Including ONE Integration and TWO Quadratic solutions\n */\nlibrary Math {\n    error ErrIsZero();\n\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 quotient = a / b;\n        uint256 remainder = a - quotient * b;\n        if (remainder > 0) {\n            return quotient + 1;\n        } else {\n            return quotient;\n        }\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    // from UniswapV2 https://github.com/Uniswap/v2-core/blob/master/contracts/libraries/Math.sol\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    /*\n        Integrate dodo curve from V1 to V2\n        require V0>=V1>=V2>0\n        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\n        let V1-V2=delta\n        res = i*delta*(1-k+k(V0^2/V1/V2))\n\n        i is the price of V-res trading pair\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _GeneralIntegrate(uint256 V0, uint256 V1, uint256 V2, uint256 i, uint256 k) internal pure returns (uint256) {\n        if (V0 == 0) {\n            revert ErrIsZero();\n        }\n\n        uint256 fairAmount = i * (V1 - V2); // i*delta\n\n        if (k == 0) {\n            return fairAmount / DecimalMath.ONE;\n        }\n\n        uint256 V0V0V1V2 = DecimalMath.divFloor((V0 * V0) / V1, V2);\n        uint256 penalty = DecimalMath.mulFloor(k, V0V0V1V2); // k(V0^2/V1/V2)\n        return (((DecimalMath.ONE - k) + penalty) * fairAmount) / DecimalMath.ONE2;\n    }\n\n    /*\n        Follow the integration function above\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Assume Q2=Q0, Given Q1 and deltaB, solve Q0\n\n        i is the price of delta-V trading pair\n        give out target of V\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _SolveQuadraticFunctionForTarget(uint256 V1, uint256 delta, uint256 i, uint256 k) internal pure returns (uint256) {\n        if (k == 0) {\n            return V1 + DecimalMath.mulFloor(i, delta);\n        }\n\n        // V0 = V1*(1+(sqrt-1)/2k)\n        // sqrt = √(1+4kidelta/V1)\n        // premium = 1+(sqrt-1)/2k\n        // uint256 sqrt = (4 * k).mul(i).mul(delta).div(V1).add(DecimalMath.ONE2).sqrt();\n\n        if (V1 == 0) {\n            return 0;\n        }\n        uint256 _sqrt;\n        uint256 ki = (4 * k) * i;\n        if (ki == 0) {\n            _sqrt = DecimalMath.ONE;\n        } else if ((ki * delta) / ki == delta) {\n            _sqrt = sqrt(((ki * delta) / V1) + DecimalMath.ONE2);\n        } else {\n            _sqrt = sqrt(((ki / V1) * delta) + DecimalMath.ONE2);\n        }\n        uint256 premium = DecimalMath.divFloor(_sqrt - DecimalMath.ONE, k * 2) + DecimalMath.ONE;\n        // V0 is greater than or equal to V1 according to the solution\n        return DecimalMath.mulFloor(V1, premium);\n    }\n\n    /*\n        Follow the integration expression above, we have:\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Given Q1 and deltaB, solve Q2\n        This is a quadratic function and the standard version is\n        aQ2^2 + bQ2 + c = 0, where\n        a=1-k\n        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\n        c=-kQ0^2 \n        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\n        note: another root is negative, abondan\n\n        if deltaBSig=true, then Q2>Q1, user sell Q and receive B\n        if deltaBSig=false, then Q2<Q1, user sell B and receive Q\n        return |Q1-Q2|\n\n        as we only support sell amount as delta, the deltaB is always negative\n        the input ideltaB is actually -ideltaB in the equation\n\n        i is the price of delta-V trading pair\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _SolveQuadraticFunctionForTrade(uint256 V0, uint256 V1, uint256 delta, uint256 i, uint256 k) internal pure returns (uint256) {\n        if (V0 == 0) {\n            revert ErrIsZero();\n        }\n\n        if (delta == 0) {\n            return 0;\n        }\n\n        if (k == 0) {\n            return DecimalMath.mulFloor(i, delta) > V1 ? V1 : DecimalMath.mulFloor(i, delta);\n        }\n\n        if (k == DecimalMath.ONE) {\n            // if k==1\n            // Q2=Q1/(1+ideltaBQ1/Q0/Q0)\n            // temp = ideltaBQ1/Q0/Q0\n            // Q2 = Q1/(1+temp)\n            // Q1-Q2 = Q1*(1-1/(1+temp)) = Q1*(temp/(1+temp))\n            // uint256 temp = i.mul(delta).mul(V1).div(V0.mul(V0));\n            uint256 temp;\n            uint256 idelta = i * delta;\n            if (idelta == 0) {\n                temp = 0;\n            } else if ((idelta * V1) / idelta == V1) {\n                temp = (idelta * V1) / (V0 * V0);\n            } else {\n                temp = (((delta * V1) / V0) * i) / V0;\n            }\n            return (V1 * temp) / (temp + DecimalMath.ONE);\n        }\n\n        // calculate -b value and sig\n        // b = kQ0^2/Q1-i*deltaB-(1-k)Q1\n        // part1 = (1-k)Q1 >=0\n        // part2 = kQ0^2/Q1-i*deltaB >=0\n        // bAbs = abs(part1-part2)\n        // if part1>part2 => b is negative => bSig is false\n        // if part2>part1 => b is positive => bSig is true\n        uint256 part2 = (((k * V0) / V1) * V0) + (i * delta); // kQ0^2/Q1-i*deltaB\n        uint256 bAbs = (DecimalMath.ONE - k) * V1; // (1-k)Q1\n\n        bool bSig;\n        if (bAbs >= part2) {\n            bAbs = bAbs - part2;\n            bSig = false;\n        } else {\n            bAbs = part2 - bAbs;\n            bSig = true;\n        }\n        bAbs = bAbs / DecimalMath.ONE;\n\n        // calculate sqrt\n        uint256 squareRoot = DecimalMath.mulFloor((DecimalMath.ONE - k) * 4, DecimalMath.mulFloor(k, V0) * V0); // 4(1-k)kQ0^2\n        squareRoot = sqrt((bAbs * bAbs) + squareRoot); // sqrt(b*b+4(1-k)kQ0*Q0)\n\n        // final res\n        uint256 denominator = (DecimalMath.ONE - k) * 2; // 2(1-k)\n        uint256 numerator;\n        if (bSig) {\n            numerator = squareRoot - bAbs;\n            if (numerator == 0) {\n                revert ErrIsZero();\n            }\n        } else {\n            numerator = bAbs + squareRoot;\n        }\n\n        uint256 V2 = DecimalMath.divCeil(numerator, denominator);\n        if (V2 > V1) {\n            return 0;\n        } else {\n            return V1 - V2;\n        }\n    }\n}\n"
      },
      "lib/solmate/src/auth/Owned.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
      },
      "lib/solady/src/tokens/ERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple ERC20 + EIP-2612 implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\n///\n/// @dev Note:\n/// - The ERC20 standard allows minting and transferring to and from the zero address,\n///   minting and transferring zero tokens, as well as self-approvals.\n///   For performance, this implementation WILL NOT revert for such actions.\n///   Please add any checks with overrides if desired.\n/// - The `permit` function uses the ecrecover precompile (0x1).\n///\n/// If you are overriding:\n/// - NEVER violate the ERC20 invariant:\n///   the total sum of all balances must be equal to `totalSupply()`.\n/// - Check that the overridden function is actually used in the function you want to\n///   change the behavior of. Much of the code has been manually inlined for performance.\nabstract contract ERC20 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The total supply has overflowed.\n    error TotalSupplyOverflow();\n\n    /// @dev The allowance has overflowed.\n    error AllowanceOverflow();\n\n    /// @dev The allowance has underflowed.\n    error AllowanceUnderflow();\n\n    /// @dev Insufficient balance.\n    error InsufficientBalance();\n\n    /// @dev Insufficient allowance.\n    error InsufficientAllowance();\n\n    /// @dev The permit is invalid.\n    error InvalidPermit();\n\n    /// @dev The permit has expired.\n    error PermitExpired();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The storage slot for the total supply.\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\n\n    /// @dev The balance slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\n\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\n    /// ```\n    ///     mstore(0x20, spender)\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\n    /// ```\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\n\n    /// @dev The nonce slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.\n    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 private constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev `keccak256(\"1\")`.\n    bytes32 private constant _VERSION_HASH =\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    /// @dev `keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")`.\n    bytes32 private constant _PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ERC20 METADATA                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the name of the token.\n    function name() public view virtual returns (string memory);\n\n    /// @dev Returns the symbol of the token.\n    function symbol() public view virtual returns (string memory);\n\n    /// @dev Returns the decimals places of the token.\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           ERC20                            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the amount of tokens in existence.\n    function totalSupply() public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_TOTAL_SUPPLY_SLOT)\n        }\n    }\n\n    /// @dev Returns the amount of tokens owned by `owner`.\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n    ///\n    /// Emits a {Approval} event.\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\n        }\n        return true;\n    }\n\n    /// @dev Transfer `amount` tokens from the caller to `to`.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    ///\n    /// Emits a {Transfer} event.\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(msg.sender, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @dev Transfers `amount` tokens from `from` to `to`.\n    ///\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\n    ///\n    /// Emits a {Transfer} event.\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(from, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            // Compute the allowance slot and load its value.\n            mstore(0x20, caller())\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowance_ := sload(allowanceSlot)\n            // If the allowance is not the maximum uint256 value.\n            if add(allowance_, 1) {\n                // Revert if the amount to be transferred exceeds the allowance.\n                if gt(amount, allowance_) {\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated allowance.\n                sstore(allowanceSlot, sub(allowance_, amount))\n            }\n            // Compute the balance slot and load its value.\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(from, to, amount);\n        return true;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          EIP-2612                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev For more performance, override to return the constant value\n    /// of `keccak256(bytes(name()))` if `name()` will never change.\n    function _constantNameHash() internal view virtual returns (bytes32 result) {}\n\n    /// @dev Returns the current nonce for `owner`.\n    /// This value is used to compute the signature for EIP-2612 permit.\n    function nonces(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the nonce slot and load its value.\n            mstore(0x0c, _NONCES_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\n    /// authorized by a signed approval by `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the block timestamp is greater than `deadline`.\n            if gt(timestamp(), deadline) {\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\n                revert(0x1c, 0x04)\n            }\n            let m := mload(0x40) // Grab the free memory pointer.\n            // Clean the upper 96 bits.\n            owner := shr(96, shl(96, owner))\n            spender := shr(96, shl(96, spender))\n            // Compute the nonce slot and load its value.\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\n            mstore(0x00, owner)\n            let nonceSlot := keccak256(0x0c, 0x20)\n            let nonceValue := sload(nonceSlot)\n            // Prepare the domain separator.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), _VERSION_HASH)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            mstore(0x2e, keccak256(m, 0xa0))\n            // Prepare the struct hash.\n            mstore(m, _PERMIT_TYPEHASH)\n            mstore(add(m, 0x20), owner)\n            mstore(add(m, 0x40), spender)\n            mstore(add(m, 0x60), value)\n            mstore(add(m, 0x80), nonceValue)\n            mstore(add(m, 0xa0), deadline)\n            mstore(0x4e, keccak256(m, 0xc0))\n            // Prepare the ecrecover calldata.\n            mstore(0x00, keccak256(0x2c, 0x42))\n            mstore(0x20, and(0xff, v))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)\n            // If the ecrecover fails, the returndatasize will be 0x00,\n            // `owner` will be checked if it equals the hash at 0x00,\n            // which evaluates to false (i.e. 0), and we will revert.\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\n            // `owner` will be compared against the returned address at 0x20.\n            if iszero(eq(mload(returndatasize()), owner)) {\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\n                revert(0x1c, 0x04)\n            }\n            // Increment and store the updated nonce.\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\n            // Compute the allowance slot and store the value.\n            // The `owner` is already at slot 0x20.\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\n            sstore(keccak256(0x2c, 0x34), value)\n            // Emit the {Approval} event.\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Grab the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), _VERSION_HASH)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  INTERNAL MINT FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _mint(address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\n            // Revert if the total supply overflows.\n            if lt(totalSupplyAfter, totalSupplyBefore) {\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(address(0), to, amount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  INTERNAL BURN FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _burn(address from, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, from)\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Subtract and store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\n            // Emit the {Transfer} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\n        }\n        _afterTokenTransfer(from, address(0), amount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Moves `amount` of tokens from `from` to `to`.\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and load its value.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowance_ := sload(allowanceSlot)\n            // If the allowance is not the maximum uint256 value.\n            if add(allowance_, 1) {\n                // Revert if the amount to be transferred exceeds the allowance.\n                if gt(amount, allowance_) {\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated allowance.\n                sstore(allowanceSlot, sub(allowance_, amount))\n            }\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let owner_ := shl(96, owner)\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HOOKS TO OVERRIDE                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Hook that is called before any transfer of tokens.\n    /// This includes minting and burning.\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /// @dev Hook that is called after any transfer of tokens.\n    /// This includes minting and burning.\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
      },
      "lib/solady/src/utils/SafeCastLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe integer casting library that reverts on overflow.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\n/// @dev Optimized for runtime gas for very high number of optimizer runs (i.e. >= 1000000).\nlibrary SafeCastLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    error Overflow();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          UNSIGNED INTEGER SAFE CASTING OPERATIONS          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function toUint8(uint256 x) internal pure returns (uint8) {\n        if (x >= 1 << 8) _revertOverflow();\n        return uint8(x);\n    }\n\n    function toUint16(uint256 x) internal pure returns (uint16) {\n        if (x >= 1 << 16) _revertOverflow();\n        return uint16(x);\n    }\n\n    function toUint24(uint256 x) internal pure returns (uint24) {\n        if (x >= 1 << 24) _revertOverflow();\n        return uint24(x);\n    }\n\n    function toUint32(uint256 x) internal pure returns (uint32) {\n        if (x >= 1 << 32) _revertOverflow();\n        return uint32(x);\n    }\n\n    function toUint40(uint256 x) internal pure returns (uint40) {\n        if (x >= 1 << 40) _revertOverflow();\n        return uint40(x);\n    }\n\n    function toUint48(uint256 x) internal pure returns (uint48) {\n        if (x >= 1 << 48) _revertOverflow();\n        return uint48(x);\n    }\n\n    function toUint56(uint256 x) internal pure returns (uint56) {\n        if (x >= 1 << 56) _revertOverflow();\n        return uint56(x);\n    }\n\n    function toUint64(uint256 x) internal pure returns (uint64) {\n        if (x >= 1 << 64) _revertOverflow();\n        return uint64(x);\n    }\n\n    function toUint72(uint256 x) internal pure returns (uint72) {\n        if (x >= 1 << 72) _revertOverflow();\n        return uint72(x);\n    }\n\n    function toUint80(uint256 x) internal pure returns (uint80) {\n        if (x >= 1 << 80) _revertOverflow();\n        return uint80(x);\n    }\n\n    function toUint88(uint256 x) internal pure returns (uint88) {\n        if (x >= 1 << 88) _revertOverflow();\n        return uint88(x);\n    }\n\n    function toUint96(uint256 x) internal pure returns (uint96) {\n        if (x >= 1 << 96) _revertOverflow();\n        return uint96(x);\n    }\n\n    function toUint104(uint256 x) internal pure returns (uint104) {\n        if (x >= 1 << 104) _revertOverflow();\n        return uint104(x);\n    }\n\n    function toUint112(uint256 x) internal pure returns (uint112) {\n        if (x >= 1 << 112) _revertOverflow();\n        return uint112(x);\n    }\n\n    function toUint120(uint256 x) internal pure returns (uint120) {\n        if (x >= 1 << 120) _revertOverflow();\n        return uint120(x);\n    }\n\n    function toUint128(uint256 x) internal pure returns (uint128) {\n        if (x >= 1 << 128) _revertOverflow();\n        return uint128(x);\n    }\n\n    function toUint136(uint256 x) internal pure returns (uint136) {\n        if (x >= 1 << 136) _revertOverflow();\n        return uint136(x);\n    }\n\n    function toUint144(uint256 x) internal pure returns (uint144) {\n        if (x >= 1 << 144) _revertOverflow();\n        return uint144(x);\n    }\n\n    function toUint152(uint256 x) internal pure returns (uint152) {\n        if (x >= 1 << 152) _revertOverflow();\n        return uint152(x);\n    }\n\n    function toUint160(uint256 x) internal pure returns (uint160) {\n        if (x >= 1 << 160) _revertOverflow();\n        return uint160(x);\n    }\n\n    function toUint168(uint256 x) internal pure returns (uint168) {\n        if (x >= 1 << 168) _revertOverflow();\n        return uint168(x);\n    }\n\n    function toUint176(uint256 x) internal pure returns (uint176) {\n        if (x >= 1 << 176) _revertOverflow();\n        return uint176(x);\n    }\n\n    function toUint184(uint256 x) internal pure returns (uint184) {\n        if (x >= 1 << 184) _revertOverflow();\n        return uint184(x);\n    }\n\n    function toUint192(uint256 x) internal pure returns (uint192) {\n        if (x >= 1 << 192) _revertOverflow();\n        return uint192(x);\n    }\n\n    function toUint200(uint256 x) internal pure returns (uint200) {\n        if (x >= 1 << 200) _revertOverflow();\n        return uint200(x);\n    }\n\n    function toUint208(uint256 x) internal pure returns (uint208) {\n        if (x >= 1 << 208) _revertOverflow();\n        return uint208(x);\n    }\n\n    function toUint216(uint256 x) internal pure returns (uint216) {\n        if (x >= 1 << 216) _revertOverflow();\n        return uint216(x);\n    }\n\n    function toUint224(uint256 x) internal pure returns (uint224) {\n        if (x >= 1 << 224) _revertOverflow();\n        return uint224(x);\n    }\n\n    function toUint232(uint256 x) internal pure returns (uint232) {\n        if (x >= 1 << 232) _revertOverflow();\n        return uint232(x);\n    }\n\n    function toUint240(uint256 x) internal pure returns (uint240) {\n        if (x >= 1 << 240) _revertOverflow();\n        return uint240(x);\n    }\n\n    function toUint248(uint256 x) internal pure returns (uint248) {\n        if (x >= 1 << 248) _revertOverflow();\n        return uint248(x);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*           SIGNED INTEGER SAFE CASTING OPERATIONS           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function toInt8(int256 x) internal pure returns (int8) {\n        unchecked {\n            if (((1 << 7) + uint256(x)) >> 8 == uint256(0)) return int8(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt16(int256 x) internal pure returns (int16) {\n        unchecked {\n            if (((1 << 15) + uint256(x)) >> 16 == uint256(0)) return int16(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt24(int256 x) internal pure returns (int24) {\n        unchecked {\n            if (((1 << 23) + uint256(x)) >> 24 == uint256(0)) return int24(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt32(int256 x) internal pure returns (int32) {\n        unchecked {\n            if (((1 << 31) + uint256(x)) >> 32 == uint256(0)) return int32(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt40(int256 x) internal pure returns (int40) {\n        unchecked {\n            if (((1 << 39) + uint256(x)) >> 40 == uint256(0)) return int40(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt48(int256 x) internal pure returns (int48) {\n        unchecked {\n            if (((1 << 47) + uint256(x)) >> 48 == uint256(0)) return int48(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt56(int256 x) internal pure returns (int56) {\n        unchecked {\n            if (((1 << 55) + uint256(x)) >> 56 == uint256(0)) return int56(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt64(int256 x) internal pure returns (int64) {\n        unchecked {\n            if (((1 << 63) + uint256(x)) >> 64 == uint256(0)) return int64(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt72(int256 x) internal pure returns (int72) {\n        unchecked {\n            if (((1 << 71) + uint256(x)) >> 72 == uint256(0)) return int72(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt80(int256 x) internal pure returns (int80) {\n        unchecked {\n            if (((1 << 79) + uint256(x)) >> 80 == uint256(0)) return int80(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt88(int256 x) internal pure returns (int88) {\n        unchecked {\n            if (((1 << 87) + uint256(x)) >> 88 == uint256(0)) return int88(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt96(int256 x) internal pure returns (int96) {\n        unchecked {\n            if (((1 << 95) + uint256(x)) >> 96 == uint256(0)) return int96(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt104(int256 x) internal pure returns (int104) {\n        unchecked {\n            if (((1 << 103) + uint256(x)) >> 104 == uint256(0)) return int104(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt112(int256 x) internal pure returns (int112) {\n        unchecked {\n            if (((1 << 111) + uint256(x)) >> 112 == uint256(0)) return int112(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt120(int256 x) internal pure returns (int120) {\n        unchecked {\n            if (((1 << 119) + uint256(x)) >> 120 == uint256(0)) return int120(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt128(int256 x) internal pure returns (int128) {\n        unchecked {\n            if (((1 << 127) + uint256(x)) >> 128 == uint256(0)) return int128(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt136(int256 x) internal pure returns (int136) {\n        unchecked {\n            if (((1 << 135) + uint256(x)) >> 136 == uint256(0)) return int136(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt144(int256 x) internal pure returns (int144) {\n        unchecked {\n            if (((1 << 143) + uint256(x)) >> 144 == uint256(0)) return int144(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt152(int256 x) internal pure returns (int152) {\n        unchecked {\n            if (((1 << 151) + uint256(x)) >> 152 == uint256(0)) return int152(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt160(int256 x) internal pure returns (int160) {\n        unchecked {\n            if (((1 << 159) + uint256(x)) >> 160 == uint256(0)) return int160(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt168(int256 x) internal pure returns (int168) {\n        unchecked {\n            if (((1 << 167) + uint256(x)) >> 168 == uint256(0)) return int168(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt176(int256 x) internal pure returns (int176) {\n        unchecked {\n            if (((1 << 175) + uint256(x)) >> 176 == uint256(0)) return int176(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt184(int256 x) internal pure returns (int184) {\n        unchecked {\n            if (((1 << 183) + uint256(x)) >> 184 == uint256(0)) return int184(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt192(int256 x) internal pure returns (int192) {\n        unchecked {\n            if (((1 << 191) + uint256(x)) >> 192 == uint256(0)) return int192(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt200(int256 x) internal pure returns (int200) {\n        unchecked {\n            if (((1 << 199) + uint256(x)) >> 200 == uint256(0)) return int200(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt208(int256 x) internal pure returns (int208) {\n        unchecked {\n            if (((1 << 207) + uint256(x)) >> 208 == uint256(0)) return int208(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt216(int256 x) internal pure returns (int216) {\n        unchecked {\n            if (((1 << 215) + uint256(x)) >> 216 == uint256(0)) return int216(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt224(int256 x) internal pure returns (int224) {\n        unchecked {\n            if (((1 << 223) + uint256(x)) >> 224 == uint256(0)) return int224(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt232(int256 x) internal pure returns (int232) {\n        unchecked {\n            if (((1 << 231) + uint256(x)) >> 232 == uint256(0)) return int232(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt240(int256 x) internal pure returns (int240) {\n        unchecked {\n            if (((1 << 239) + uint256(x)) >> 240 == uint256(0)) return int240(x);\n            _revertOverflow();\n        }\n    }\n\n    function toInt248(int256 x) internal pure returns (int248) {\n        unchecked {\n            if (((1 << 247) + uint256(x)) >> 248 == uint256(0)) return int248(x);\n            _revertOverflow();\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               OTHER SAFE CASTING OPERATIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function toInt8(uint256 x) internal pure returns (int8) {\n        if (x >= 1 << 7) _revertOverflow();\n        return int8(int256(x));\n    }\n\n    function toInt16(uint256 x) internal pure returns (int16) {\n        if (x >= 1 << 15) _revertOverflow();\n        return int16(int256(x));\n    }\n\n    function toInt24(uint256 x) internal pure returns (int24) {\n        if (x >= 1 << 23) _revertOverflow();\n        return int24(int256(x));\n    }\n\n    function toInt32(uint256 x) internal pure returns (int32) {\n        if (x >= 1 << 31) _revertOverflow();\n        return int32(int256(x));\n    }\n\n    function toInt40(uint256 x) internal pure returns (int40) {\n        if (x >= 1 << 39) _revertOverflow();\n        return int40(int256(x));\n    }\n\n    function toInt48(uint256 x) internal pure returns (int48) {\n        if (x >= 1 << 47) _revertOverflow();\n        return int48(int256(x));\n    }\n\n    function toInt56(uint256 x) internal pure returns (int56) {\n        if (x >= 1 << 55) _revertOverflow();\n        return int56(int256(x));\n    }\n\n    function toInt64(uint256 x) internal pure returns (int64) {\n        if (x >= 1 << 63) _revertOverflow();\n        return int64(int256(x));\n    }\n\n    function toInt72(uint256 x) internal pure returns (int72) {\n        if (x >= 1 << 71) _revertOverflow();\n        return int72(int256(x));\n    }\n\n    function toInt80(uint256 x) internal pure returns (int80) {\n        if (x >= 1 << 79) _revertOverflow();\n        return int80(int256(x));\n    }\n\n    function toInt88(uint256 x) internal pure returns (int88) {\n        if (x >= 1 << 87) _revertOverflow();\n        return int88(int256(x));\n    }\n\n    function toInt96(uint256 x) internal pure returns (int96) {\n        if (x >= 1 << 95) _revertOverflow();\n        return int96(int256(x));\n    }\n\n    function toInt104(uint256 x) internal pure returns (int104) {\n        if (x >= 1 << 103) _revertOverflow();\n        return int104(int256(x));\n    }\n\n    function toInt112(uint256 x) internal pure returns (int112) {\n        if (x >= 1 << 111) _revertOverflow();\n        return int112(int256(x));\n    }\n\n    function toInt120(uint256 x) internal pure returns (int120) {\n        if (x >= 1 << 119) _revertOverflow();\n        return int120(int256(x));\n    }\n\n    function toInt128(uint256 x) internal pure returns (int128) {\n        if (x >= 1 << 127) _revertOverflow();\n        return int128(int256(x));\n    }\n\n    function toInt136(uint256 x) internal pure returns (int136) {\n        if (x >= 1 << 135) _revertOverflow();\n        return int136(int256(x));\n    }\n\n    function toInt144(uint256 x) internal pure returns (int144) {\n        if (x >= 1 << 143) _revertOverflow();\n        return int144(int256(x));\n    }\n\n    function toInt152(uint256 x) internal pure returns (int152) {\n        if (x >= 1 << 151) _revertOverflow();\n        return int152(int256(x));\n    }\n\n    function toInt160(uint256 x) internal pure returns (int160) {\n        if (x >= 1 << 159) _revertOverflow();\n        return int160(int256(x));\n    }\n\n    function toInt168(uint256 x) internal pure returns (int168) {\n        if (x >= 1 << 167) _revertOverflow();\n        return int168(int256(x));\n    }\n\n    function toInt176(uint256 x) internal pure returns (int176) {\n        if (x >= 1 << 175) _revertOverflow();\n        return int176(int256(x));\n    }\n\n    function toInt184(uint256 x) internal pure returns (int184) {\n        if (x >= 1 << 183) _revertOverflow();\n        return int184(int256(x));\n    }\n\n    function toInt192(uint256 x) internal pure returns (int192) {\n        if (x >= 1 << 191) _revertOverflow();\n        return int192(int256(x));\n    }\n\n    function toInt200(uint256 x) internal pure returns (int200) {\n        if (x >= 1 << 199) _revertOverflow();\n        return int200(int256(x));\n    }\n\n    function toInt208(uint256 x) internal pure returns (int208) {\n        if (x >= 1 << 207) _revertOverflow();\n        return int208(int256(x));\n    }\n\n    function toInt216(uint256 x) internal pure returns (int216) {\n        if (x >= 1 << 215) _revertOverflow();\n        return int216(int256(x));\n    }\n\n    function toInt224(uint256 x) internal pure returns (int224) {\n        if (x >= 1 << 223) _revertOverflow();\n        return int224(int256(x));\n    }\n\n    function toInt232(uint256 x) internal pure returns (int232) {\n        if (x >= 1 << 231) _revertOverflow();\n        return int232(int256(x));\n    }\n\n    function toInt240(uint256 x) internal pure returns (int240) {\n        if (x >= 1 << 239) _revertOverflow();\n        return int240(int256(x));\n    }\n\n    function toInt248(uint256 x) internal pure returns (int248) {\n        if (x >= 1 << 247) _revertOverflow();\n        return int248(int256(x));\n    }\n\n    function toInt256(uint256 x) internal pure returns (int256) {\n        if (int256(x) >= 0) return int256(x);\n        _revertOverflow();\n    }\n\n    function toUint256(int256 x) internal pure returns (uint256) {\n        if (x >= 0) return uint256(x);\n        _revertOverflow();\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function _revertOverflow() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the function selector of `Overflow()`.\n            mstore(0x00, 0x35278d12)\n            // Revert with (offset, size).\n            revert(0x1c, 0x04)\n        }\n    }\n}\n"
      },
      "lib/solady/src/utils/SafeTransferLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\n/// - For ERC20s, this implementation won't check that a token has code,\n///   responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The Permit2 operation has failed.\n    error Permit2Failed();\n\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\n    error Permit2AmountOverflow();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\n\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// @dev The canonical Permit2 address.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success :=\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x34, 0) // Store 0 for the `amount`.\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                mstore(0x34, amount) // Store back the original `amount`.\n                // Retry the approval, reverting upon failure.\n                if iszero(\n                    and(\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    )\n                ) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\n    /// Reverts upon failure.\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }\n\n    /// @dev Permit a user to spend a given amount of\n    /// another user's tokens via native EIP-2612 permit if possible, falling\n    /// back to Permit2 if native permit fails or is not implemented on the token.\n    function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `1` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Simple permit on the Permit2 contract.\n    function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"
      },
      "lib/solady/src/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Reentrancy guard mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unauthorized reentrant call.\n    error Reentrancy();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to: `uint72(bytes9(keccak256(\"_REENTRANCY_GUARD_SLOT\")))`.\n    /// 9 bytes is large enough to avoid collisions with lower slots,\n    /// but not too large to result in excessive bytecode bloat.\n    uint256 private constant _REENTRANCY_GUARD_SLOT = 0x929eee149b4bd21268;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      REENTRANCY GUARD                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Guards a function from reentrancy.\n    modifier nonReentrant() virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(sload(_REENTRANCY_GUARD_SLOT), address()) {\n                mstore(0x00, 0xab143c06) // `Reentrancy()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(_REENTRANCY_GUARD_SLOT, address())\n        }\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(_REENTRANCY_GUARD_SLOT, codesize())\n        }\n    }\n\n    /// @dev Guards a view function from read-only reentrancy.\n    modifier nonReadReentrant() virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(sload(_REENTRANCY_GUARD_SLOT), address()) {\n                mstore(0x00, 0xab143c06) // `Reentrancy()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }\n}\n"
      },
      "lib/openzeppelin-contracts/contracts/interfaces/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n"
      },
      "src/mimswap/interfaces/ICallee.sol": {
        "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity >=0.8.0;\n\ninterface ICallee {\n    function SellShareCall(\n        address sender,\n        uint256 burnShareAmount,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function FlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external;\n}\n"
      },
      "src/mimswap/interfaces/IFeeRateModel.sol": {
        "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity >=0.8.0;\n\ninterface IFeeRateImpl {\n    function getFeeRate(\n        address pool,\n        address trader,\n        uint256 lpFeeRate\n    ) external view returns (uint256 adjustedLpFeeRate, uint256 mtFeeRate);\n}\n\ninterface IFeeRateModel {\n    function maintainer() external view returns (address);\n\n    function getFeeRate(address trader, uint256 lpFeeRate) external view returns (uint256 adjustedLpFeeRate, uint256 mtFeeRate);\n}\n"
      },
      "src/interfaces/IWETH.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC20} from \"@BoringSolidity/interfaces/IERC20.sol\";\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n}\n\ninterface IWETHAlike is IWETH {}\n"
      },
      "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
      },
      "lib/BoringSolidity/contracts/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    // transfer and tranferFrom have been removed, because they don't work on all tokens (some aren't ERC20 complaint).\n    // By removing them you can't accidentally use them.\n    // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).\n    // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ninterface IStrictERC20 {\n    // This is the strict ERC20 interface. Don't use this, certainly not if you don't control the ERC20 token you're calling.\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
      },
      "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      }
    },
    "settings": {
      "remappings": [
        "/=src/",
        "forge-std/=lib/forge-std/src/",
        "halmos-cheatcodes/=lib/halmos-cheatcodes/src/",
        "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
        "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
        "@BoringSolidity/=lib/BoringSolidity/contracts/",
        "@solady/=lib/solady/src/",
        "@solmate/=lib/solmate/src/",
        "@excessivelySafeCall/=lib/ExcessivelySafeCall/src/",
        "@safe-contracts/=lib/safe-contracts/contracts/",
        "@fuzzlib/=lib/fuzzlib/src/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 400
      },
      "metadata": {
        "useLiteralContent": false,
        "bytecodeHash": "ipfs",
        "appendCBOR": true
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "evmVersion": "london",
      "viaIR": false,
      "libraries": {}
    }
  },
  "compiler": "0.8.26+commit.8a97fa7a"
}