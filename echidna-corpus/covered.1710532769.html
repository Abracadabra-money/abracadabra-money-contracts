<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/BoringBatchable.sol</b>
<code>
  1 |     | <span class='unexecuted'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  4 |     | <span class='neutral'>// solhint-disable no-inline-assembly</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>// WARNING!!!</span>
  7 |     | <span class='neutral'>// Combining BoringBatchable with msg.value can cause double spending issues</span>
  8 |     | <span class='neutral'>// https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>import {IERC20} from &quot;./interfaces/IERC20.sol&quot;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>contract BaseBoringBatchable {</span>
 13 |     | <span class='neutral'>    error BatchError(bytes innerError);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /// @dev Helper function to extract a useful revert message from a failed call.</span>
 16 |     | <span class='neutral'>    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.</span>
 17 |     | <span class='unexecuted'>    function _getRevertMsg(bytes memory _returnData) internal pure{</span>
 18 |     | <span class='neutral'>        // If the _res length is less than 68, then</span>
 19 |     | <span class='neutral'>        // the transaction failed with custom error or silently (without a revert message)</span>
 20 |     | <span class='unexecuted'>        if (_returnData.length &lt; 68) revert BatchError(_returnData);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>        assembly {</span>
 23 |     | <span class='neutral'>            // Slice the sighash.</span>
 24 |     | <span class='unexecuted'>            _returnData := add(_returnData, 0x04)</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='unexecuted'>        revert(abi.decode(_returnData, (string))); // All that remains is the revert string</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /// @notice Allows batched call to self (this contract).</span>
 30 |     | <span class='neutral'>    /// @param calls An array of inputs for each call.</span>
 31 |     | <span class='neutral'>    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.</span>
 32 |     | <span class='neutral'>    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense</span>
 33 |     | <span class='neutral'>    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value</span>
 34 |     | <span class='neutral'>    // C3: The length of the loop is fully under user control, so can&#39;t be exploited</span>
 35 |     | <span class='neutral'>    // C7: Delegatecall is only used on the same contract, so it&#39;s safe</span>
 36 |     | <span class='unexecuted'>    function batch(bytes[] calldata calls, bool revertOnFail) external payable {</span>
 37 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; calls.length; i++) {</span>
 38 |     | <span class='unexecuted'>            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);</span>
 39 |     | <span class='unexecuted'>            if (!success &amp;&amp; revertOnFail) {</span>
 40 |     | <span class='unexecuted'>                _getRevertMsg(result);</span>
 41 |     | <span class='neutral'>            }</span>
 42 |     | <span class='neutral'>        }</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'>}</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>contract BoringBatchable is BaseBoringBatchable {</span>
 47 |     | <span class='neutral'>    /// @notice Call wrapper that performs `ERC20.permit` on `token`.</span>
 48 |     | <span class='neutral'>    /// Lookup `IERC20.permit`.</span>
 49 |     | <span class='neutral'>    // F6: Parameters can be used front-run the permit and the user&#39;s permit will fail (due to nonce or other revert)</span>
 50 |     | <span class='neutral'>    //     if part of a batch this could be used to grief once as the second call would not need the permit</span>
 51 |     | <span class='unexecuted'>    function permitToken(</span>
 52 |     | <span class='neutral'>        IERC20 token,</span>
 53 |     | <span class='neutral'>        address from,</span>
 54 |     | <span class='neutral'>        address to,</span>
 55 |     | <span class='neutral'>        uint256 amount,</span>
 56 |     | <span class='neutral'>        uint256 deadline,</span>
 57 |     | <span class='neutral'>        uint8 v,</span>
 58 |     | <span class='neutral'>        bytes32 r,</span>
 59 |     | <span class='neutral'>        bytes32 s</span>
 60 |     | <span class='neutral'>    ) public {</span>
 61 |     | <span class='unexecuted'>        token.permit(from, to, amount, deadline, v, r, s);</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'>}</span>
 64 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/BoringFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'>import {IMasterContract} from &quot;./interfaces/IMasterContract.sol&quot;;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>// solhint-disable no-inline-assembly</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract BoringFactory {</span>
  8 |     | <span class='neutral'>    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    /// @notice Mapping from clone contracts to their masterContract.</span>
 11 |     | <span class='unexecuted'>    mapping(address =&gt; address) public masterContractOf;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    /// @notice Mapping from masterContract to an array of all clones</span>
 14 |     | <span class='neutral'>    /// On mainnet events can be used to get this list, but events aren&#39;t always easy to retrieve and</span>
 15 |     | <span class='neutral'>    /// barely work on sidechains. While this adds gas, it makes enumerating all clones much easier.</span>
 16 |     | <span class='unexecuted'>    mapping(address =&gt; address[]) public clonesOf;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /// @notice Returns the count of clones that exists for a specific masterContract</span>
 19 |     | <span class='neutral'>    /// @param masterContract The address of the master contract.</span>
 20 |     | <span class='neutral'>    /// @return cloneCount total number of clones for the masterContract.</span>
 21 |     | <span class='unexecuted'>    function clonesOfCount(address masterContract) public view returns (uint256 cloneCount) {</span>
 22 |     | <span class='unexecuted'>        cloneCount = clonesOf[masterContract].length;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    /// @notice Deploys a given master Contract as a clone.</span>
 26 |     | <span class='neutral'>    /// Any ETH transferred with this call is forwarded to the new clone.</span>
 27 |     | <span class='neutral'>    /// Emits `LogDeploy`.</span>
 28 |     | <span class='neutral'>    /// @param masterContract The address of the contract to clone.</span>
 29 |     | <span class='neutral'>    /// @param data Additional abi encoded calldata that is passed to the new clone via `IMasterContract.init`.</span>
 30 |     | <span class='neutral'>    /// @param useCreate2 Creates the clone by using the CREATE2 opcode, in this case `data` will be used as salt.</span>
 31 |     | <span class='neutral'>    /// @return cloneAddress Address of the created clone contract.</span>
 32 |     | <span class='unexecuted'>    function deploy(</span>
 33 |     | <span class='neutral'>        address masterContract,</span>
 34 |     | <span class='neutral'>        bytes calldata data,</span>
 35 |     | <span class='neutral'>        bool useCreate2</span>
 36 |     | <span class='unexecuted'>    ) public payable returns (address cloneAddress) {</span>
 37 |     | <span class='unexecuted'>        require(masterContract != address(0), &quot;BoringFactory: No masterContract&quot;);</span>
 38 |     | <span class='unexecuted'>        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract&#39;s address</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>        if (useCreate2) {</span>
 41 |     | <span class='neutral'>            // each masterContract has different code already. So clones are distinguished by their data only.</span>
 42 |     | <span class='unexecuted'>            bytes32 salt = keccak256(data);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>            // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/</span>
 45 |     | <span class='unexecuted'>            assembly {</span>
 46 |     | <span class='unexecuted'>                let clone := mload(0x40)</span>
 47 |     | <span class='unexecuted'>                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)</span>
 48 |     | <span class='unexecuted'>                mstore(add(clone, 0x14), targetBytes)</span>
 49 |     | <span class='unexecuted'>                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)</span>
 50 |     | <span class='unexecuted'>                cloneAddress := create2(0, clone, 0x37, salt)</span>
 51 |     | <span class='neutral'>            }</span>
 52 |     | <span class='neutral'>        } else {</span>
 53 |     | <span class='neutral'>            assembly {</span>
 54 |     | <span class='unexecuted'>                let clone := mload(0x40)</span>
 55 |     | <span class='unexecuted'>                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)</span>
 56 |     | <span class='unexecuted'>                mstore(add(clone, 0x14), targetBytes)</span>
 57 |     | <span class='unexecuted'>                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)</span>
 58 |     | <span class='unexecuted'>                cloneAddress := create(0, clone, 0x37)</span>
 59 |     | <span class='neutral'>            }</span>
 60 |     | <span class='neutral'>        }</span>
 61 |     | <span class='unexecuted'>        masterContractOf[cloneAddress] = masterContract;</span>
 62 |     | <span class='unexecuted'>        clonesOf[masterContract].push(cloneAddress);</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='unexecuted'>        IMasterContract(cloneAddress).init{value: msg.value}(data);</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='unexecuted'>        emit LogDeploy(masterContract, data, cloneAddress);</span>
 67 |     | <span class='neutral'>    }</span>
 68 |     | <span class='neutral'>}</span>
 69 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/BoringOwnable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol</span>
  5 |     | <span class='neutral'>// Simplified by BoringCrypto</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract BoringOwnableData {</span>
  8 |     | <span class='unexecuted'>    address public owner;</span>
  9 |     | <span class='unexecuted'>    address public pendingOwner;</span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>contract BoringOwnable is BoringOwnableData {</span>
 13 |     | <span class='neutral'>    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /// @notice `owner` defaults to msg.sender on construction.</span>
 16 |     | <span class='unexecuted'>    constructor() {</span>
 17 |     | <span class='unexecuted'>        owner = msg.sender;</span>
 18 |     | <span class='unexecuted'>        emit OwnershipTransferred(address(0), msg.sender);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.</span>
 22 |     | <span class='neutral'>    /// Can only be invoked by the current `owner`.</span>
 23 |     | <span class='neutral'>    /// @param newOwner Address of the new owner.</span>
 24 |     | <span class='neutral'>    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.</span>
 25 |     | <span class='neutral'>    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.</span>
 26 |     | <span class='unexecuted'>    function transferOwnership(</span>
 27 |     | <span class='neutral'>        address newOwner,</span>
 28 |     | <span class='neutral'>        bool direct,</span>
 29 |     | <span class='neutral'>        bool renounce</span>
 30 |     | <span class='neutral'>    ) public onlyOwner {</span>
 31 |     | <span class='unexecuted'>        if (direct) {</span>
 32 |     | <span class='neutral'>            // Checks</span>
 33 |     | <span class='unexecuted'>            require(newOwner != address(0) || renounce, &quot;Ownable: zero address&quot;);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>            // Effects</span>
 36 |     | <span class='unexecuted'>            emit OwnershipTransferred(owner, newOwner);</span>
 37 |     | <span class='unexecuted'>            owner = newOwner;</span>
 38 |     | <span class='unexecuted'>            pendingOwner = address(0);</span>
 39 |     | <span class='neutral'>        } else {</span>
 40 |     | <span class='neutral'>            // Effects</span>
 41 |     | <span class='unexecuted'>            pendingOwner = newOwner;</span>
 42 |     | <span class='neutral'>        }</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    /// @notice Needs to be called by `pendingOwner` to claim ownership.</span>
 46 |     | <span class='unexecuted'>    function claimOwnership() public {</span>
 47 |     | <span class='unexecuted'>        address _pendingOwner = pendingOwner;</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>        // Checks</span>
 50 |     | <span class='unexecuted'>        require(msg.sender == _pendingOwner, &quot;Ownable: caller != pending owner&quot;);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>        // Effects</span>
 53 |     | <span class='unexecuted'>        emit OwnershipTransferred(owner, _pendingOwner);</span>
 54 |     | <span class='unexecuted'>        owner = _pendingOwner;</span>
 55 |     | <span class='unexecuted'>        pendingOwner = address(0);</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    /// @notice Only allows the `owner` to execute the function.</span>
 59 |     | <span class='neutral'>    modifier onlyOwner() {</span>
 60 |     | <span class='unexecuted'>        require(msg.sender == owner, &quot;Ownable: caller is not the owner&quot;);</span>
 61 |     | <span class='neutral'>        _;</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'>}</span>
 64 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/Domain.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// Based on code and smartness by Ross Campbell and Keno</span>
  3 |     | <span class='neutral'>// Uses immutable to store the domain separator to reduce gas usage</span>
  4 |     | <span class='neutral'>// If the chain id changes due to a fork, the forked chain will calculate on the fly.</span>
  5 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>// solhint-disable no-inline-assembly</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>contract Domain {</span>
 10 |     | <span class='unexecuted'>    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(&quot;EIP712Domain(uint256 chainId,address verifyingContract)&quot;);</span>
 11 |     | <span class='neutral'>    // See https://eips.ethereum.org/EIPS/eip-191</span>
 12 |     | <span class='neutral'>    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = &quot;\x19\x01&quot;;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    // solhint-disable var-name-mixedcase</span>
 15 |     | <span class='neutral'>    bytes32 private immutable _DOMAIN_SEPARATOR;</span>
 16 |     | <span class='neutral'>    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /// @dev Calculate the DOMAIN_SEPARATOR</span>
 19 |     | <span class='unexecuted'>    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {</span>
 20 |     | <span class='unexecuted'>        return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, chainId, address(this)));</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    constructor() {</span>
 24 |     | <span class='unexecuted'>        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = block.chainid);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    /// @dev Return the DOMAIN_SEPARATOR</span>
 28 |     | <span class='neutral'>    // It&#39;s named internal to allow making it public from the contract that uses it by creating a simple view function</span>
 29 |     | <span class='neutral'>    // with the desired public name, such as DOMAIN_SEPARATOR or domainSeparator.</span>
 30 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 31 |     | <span class='unexecuted'>    function _domainSeparator() internal view returns (bytes32) {</span>
 32 |     | <span class='unexecuted'>        return block.chainid == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>    function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {</span>
 36 |     | <span class='unexecuted'>        digest = keccak256(abi.encodePacked(EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA, _domainSeparator(), dataHash));</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'>}</span>
 39 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'>import {IERC20} from &quot;./interfaces/IERC20.sol&quot;;</span>
   4 |     | <span class='neutral'>import {Domain} from &quot;./Domain.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>// solhint-disable no-inline-assembly</span>
   7 |     | <span class='neutral'>// solhint-disable not-rely-on-time</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>// Data part taken out for building of contracts that receive delegate calls</span>
  10 |     | <span class='unexecuted'>contract ERC20Data {</span>
  11 |     | <span class='neutral'>    /// @notice owner &gt; balance mapping.</span>
  12 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public balanceOf;</span>
  13 |     | <span class='neutral'>    /// @notice owner &gt; spender &gt; allowance mapping.</span>
  14 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span>
  15 |     | <span class='neutral'>    /// @notice owner &gt; nonce mapping. Used in `permit`.</span>
  16 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public nonces;</span>
  17 |     | <span class='neutral'>}</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>abstract contract ERC20 is IERC20, Domain {</span>
  20 |     | <span class='neutral'>    /// @notice owner &gt; balance mapping.</span>
  21 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public override balanceOf;</span>
  22 |     | <span class='neutral'>    /// @notice owner &gt; spender &gt; allowance mapping.</span>
  23 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance;</span>
  24 |     | <span class='neutral'>    /// @notice owner &gt; nonce mapping. Used in `permit`.</span>
  25 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public nonces;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.</span>
  28 |     | <span class='neutral'>    /// @param to The address to move the tokens.</span>
  29 |     | <span class='neutral'>    /// @param amount of the tokens to move.</span>
  30 |     | <span class='neutral'>    /// @return (bool) Returns True if succeeded.</span>
  31 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public returns (bool) {</span>
  32 |     | <span class='neutral'>        // If `amount` is 0, or `msg.sender` is `to` nothing happens</span>
  33 |     | <span class='unexecuted'>        if (amount != 0 || msg.sender == to) {</span>
  34 |     | <span class='unexecuted'>            uint256 srcBalance = balanceOf[msg.sender];</span>
  35 |     | <span class='unexecuted'>            require(srcBalance &gt;= amount, &quot;ERC20: balance too low&quot;);</span>
  36 |     | <span class='unexecuted'>            if (msg.sender != to) {</span>
  37 |     | <span class='unexecuted'>                require(to != address(0), &quot;ERC20: no zero address&quot;); // Moved down so low balance calls safe some gas</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked</span>
  40 |     | <span class='unexecuted'>                balanceOf[to] += amount;</span>
  41 |     | <span class='neutral'>            }</span>
  42 |     | <span class='neutral'>        }</span>
  43 |     | <span class='unexecuted'>        emit Transfer(msg.sender, to, amount);</span>
  44 |     | <span class='neutral'>        return true;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.</span>
  48 |     | <span class='neutral'>    /// @param from Address to draw tokens from.</span>
  49 |     | <span class='neutral'>    /// @param to The address to move the tokens.</span>
  50 |     | <span class='neutral'>    /// @param amount The token amount to move.</span>
  51 |     | <span class='neutral'>    /// @return (bool) Returns True if succeeded.</span>
  52 |     | <span class='unexecuted'>    function transferFrom(</span>
  53 |     | <span class='neutral'>        address from,</span>
  54 |     | <span class='neutral'>        address to,</span>
  55 |     | <span class='neutral'>        uint256 amount</span>
  56 |     | <span class='unexecuted'>    ) public returns (bool) {</span>
  57 |     | <span class='neutral'>        // If `amount` is 0, or `from` is `to` nothing happens</span>
  58 |     | <span class='unexecuted'>        if (amount != 0) {</span>
  59 |     | <span class='unexecuted'>            uint256 srcBalance = balanceOf[from];</span>
  60 |     | <span class='unexecuted'>            require(srcBalance &gt;= amount, &quot;ERC20: balance too low&quot;);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>            if (from != to) {</span>
  63 |     | <span class='unexecuted'>                uint256 spenderAllowance = allowance[from][msg.sender];</span>
  64 |     | <span class='neutral'>                // If allowance is infinite, don&#39;t decrease it to save on gas (breaks with EIP-20).</span>
  65 |     | <span class='unexecuted'>                if (spenderAllowance != type(uint256).max) {</span>
  66 |     | <span class='unexecuted'>                    require(spenderAllowance &gt;= amount, &quot;ERC20: allowance too low&quot;);</span>
  67 |     | <span class='unexecuted'>                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked</span>
  68 |     | <span class='neutral'>                }</span>
  69 |     | <span class='unexecuted'>                require(to != address(0), &quot;ERC20: no zero address&quot;); // Moved down so other failed calls safe some gas</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>                balanceOf[from] = srcBalance - amount; // Underflow is checked</span>
  72 |     | <span class='unexecuted'>                balanceOf[to] += amount;</span>
  73 |     | <span class='neutral'>            }</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='unexecuted'>        emit Transfer(from, to, amount);</span>
  76 |     | <span class='unexecuted'>        return true;</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    /// @notice Approves `amount` from sender to be spend by `spender`.</span>
  80 |     | <span class='neutral'>    /// @param spender Address of the party that can draw from msg.sender&#39;s account.</span>
  81 |     | <span class='neutral'>    /// @param amount The maximum collective amount that `spender` can draw.</span>
  82 |     | <span class='neutral'>    /// @return (bool) Returns True if approved.</span>
  83 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) public override returns (bool) {</span>
  84 |     | <span class='unexecuted'>        allowance[msg.sender][spender] = amount;</span>
  85 |     | <span class='unexecuted'>        emit Approval(msg.sender, spender, amount);</span>
  86 |     | <span class='unexecuted'>        return true;</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
  90 |     | <span class='unexecuted'>    function DOMAIN_SEPARATOR() external view returns (bytes32) {</span>
  91 |     | <span class='unexecuted'>        return _domainSeparator();</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    // keccak256(&quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;);</span>
  95 |     | <span class='unexecuted'>    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /// @notice Approves `value` from `owner_` to be spend by `spender`.</span>
  98 |     | <span class='neutral'>    /// @param owner_ Address of the owner.</span>
  99 |     | <span class='neutral'>    /// @param spender The address of the spender that gets approved to draw from `owner_`.</span>
 100 |     | <span class='neutral'>    /// @param value The maximum collective amount that `spender` can draw.</span>
 101 |     | <span class='neutral'>    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).</span>
 102 |     | <span class='unexecuted'>    function permit(</span>
 103 |     | <span class='neutral'>        address owner_,</span>
 104 |     | <span class='neutral'>        address spender,</span>
 105 |     | <span class='neutral'>        uint256 value,</span>
 106 |     | <span class='neutral'>        uint256 deadline,</span>
 107 |     | <span class='neutral'>        uint8 v,</span>
 108 |     | <span class='neutral'>        bytes32 r,</span>
 109 |     | <span class='neutral'>        bytes32 s</span>
 110 |     | <span class='neutral'>    ) external override {</span>
 111 |     | <span class='unexecuted'>        require(owner_ != address(0), &quot;ERC20: Owner cannot be 0&quot;);</span>
 112 |     | <span class='unexecuted'>        require(block.timestamp &lt; deadline, &quot;ERC20: Expired&quot;);</span>
 113 |     | <span class='unexecuted'>        require(</span>
 114 |     | <span class='unexecuted'>            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==</span>
 115 |     | <span class='unexecuted'>                owner_,</span>
 116 |     | <span class='neutral'>            &quot;ERC20: Invalid Signature&quot;</span>
 117 |     | <span class='neutral'>        );</span>
 118 |     | <span class='unexecuted'>        allowance[owner_][spender] = value;</span>
 119 |     | <span class='unexecuted'>        emit Approval(owner_, spender, value);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'>}</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>contract ERC20WithSupply is IERC20, ERC20 {</span>
 124 |     | <span class='unexecuted'>    uint256 public override totalSupply;</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>    function _mint(address user, uint256 amount) internal {</span>
 127 |     | <span class='unexecuted'>        uint256 newTotalSupply = totalSupply + amount;</span>
 128 |     | <span class='unexecuted'>        require(newTotalSupply &gt;= totalSupply, &quot;Mint overflow&quot;);</span>
 129 |     | <span class='unexecuted'>        totalSupply = newTotalSupply;</span>
 130 |     | <span class='unexecuted'>        balanceOf[user] += amount;</span>
 131 |     | <span class='unexecuted'>        emit Transfer(address(0), user, amount);</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>    function _burn(address user, uint256 amount) internal {</span>
 135 |     | <span class='unexecuted'>        require(balanceOf[user] &gt;= amount, &quot;Burn too much&quot;);</span>
 136 |     | <span class='unexecuted'>        totalSupply -= amount;</span>
 137 |     | <span class='unexecuted'>        balanceOf[user] -= amount;</span>
 138 |     | <span class='unexecuted'>        emit Transfer(user, address(0), amount);</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'>}</span>
 141 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/interfaces/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IERC20 {</span>
  5 |     | <span class='neutral'>    // transfer and tranferFrom have been removed, because they don&#39;t work on all tokens (some aren&#39;t ERC20 complaint).</span>
  6 |     | <span class='neutral'>    // By removing them you can&#39;t accidentally use them.</span>
  7 |     | <span class='neutral'>    // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).</span>
  8 |     | <span class='neutral'>    // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.</span>
  9 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 18 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /// @notice EIP 2612</span>
 21 |     | <span class='neutral'>    function permit(</span>
 22 |     | <span class='neutral'>        address owner,</span>
 23 |     | <span class='neutral'>        address spender,</span>
 24 |     | <span class='neutral'>        uint256 value,</span>
 25 |     | <span class='neutral'>        uint256 deadline,</span>
 26 |     | <span class='neutral'>        uint8 v,</span>
 27 |     | <span class='neutral'>        bytes32 r,</span>
 28 |     | <span class='neutral'>        bytes32 s</span>
 29 |     | <span class='neutral'>    ) external;</span>
 30 |     | <span class='neutral'>}</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>interface IStrictERC20 {</span>
 33 |     | <span class='neutral'>    // This is the strict ERC20 interface. Don&#39;t use this, certainly not if you don&#39;t control the ERC20 token you&#39;re calling.</span>
 34 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 35 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 36 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 37 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 38 |     | <span class='neutral'>    function balanceOf(address _owner) external view returns (uint256 balance);</span>
 39 |     | <span class='neutral'>    function transfer(address _to, uint256 _value) external returns (bool success);</span>
 40 |     | <span class='neutral'>    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);</span>
 41 |     | <span class='neutral'>    function approve(address _spender, uint256 _value) external returns (bool success);</span>
 42 |     | <span class='neutral'>    function allowance(address _owner, address _spender) external view returns (uint256 remaining);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 45 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /// @notice EIP 2612</span>
 48 |     | <span class='neutral'>    function permit(</span>
 49 |     | <span class='neutral'>        address owner,</span>
 50 |     | <span class='neutral'>        address spender,</span>
 51 |     | <span class='neutral'>        uint256 value,</span>
 52 |     | <span class='neutral'>        uint256 deadline,</span>
 53 |     | <span class='neutral'>        uint8 v,</span>
 54 |     | <span class='neutral'>        bytes32 r,</span>
 55 |     | <span class='neutral'>        bytes32 s</span>
 56 |     | <span class='neutral'>    ) external;</span>
 57 |     | <span class='neutral'>}</span>
 58 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/interfaces/IMasterContract.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IMasterContract {</span>
  5 |     | <span class='neutral'>    /// @notice Init function that gets called from `BoringFactory.deploy`.</span>
  6 |     | <span class='neutral'>    /// Also kown as the constructor for cloned contracts.</span>
  7 |     | <span class='neutral'>    /// Any ETH send to `BoringFactory.deploy` ends up here.</span>
  8 |     | <span class='neutral'>    /// @param data Can be abi encoded arguments or anything else.</span>
  9 |     | <span class='neutral'>    function init(bytes calldata data) external payable;</span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/libraries/BoringERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'>import {IERC20} from &quot;../interfaces/IERC20.sol&quot;;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='unexecuted'>library BoringERC20 {</span>
   8 |     | <span class='neutral'>    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()</span>
   9 |     | <span class='neutral'>    bytes4 private constant SIG_NAME = 0x06fdde03; // name()</span>
  10 |     | <span class='neutral'>    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()</span>
  11 |     | <span class='neutral'>    bytes4 private constant SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)</span>
  12 |     | <span class='neutral'>    bytes4 private constant SIG_TOTALSUPPLY = 0x18160ddd; // balanceOf(address)</span>
  13 |     | <span class='neutral'>    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)</span>
  14 |     | <span class='neutral'>    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    function returnDataToString(bytes memory data) internal pure returns (string memory) {</span>
  17 |     | <span class='neutral'>        if (data.length &gt;= 64) {</span>
  18 |     | <span class='neutral'>            return abi.decode(data, (string));</span>
  19 |     | <span class='neutral'>        } else if (data.length == 32) {</span>
  20 |     | <span class='neutral'>            uint8 i = 0;</span>
  21 |     | <span class='neutral'>            while (i &lt; 32 &amp;&amp; data[i] != 0) {</span>
  22 |     | <span class='neutral'>                i++;</span>
  23 |     | <span class='neutral'>            }</span>
  24 |     | <span class='neutral'>            bytes memory bytesArray = new bytes(i);</span>
  25 |     | <span class='neutral'>            for (i = 0; i &lt; 32 &amp;&amp; data[i] != 0; i++) {</span>
  26 |     | <span class='neutral'>                bytesArray[i] = data[i];</span>
  27 |     | <span class='neutral'>            }</span>
  28 |     | <span class='neutral'>            return string(bytesArray);</span>
  29 |     | <span class='neutral'>        } else {</span>
  30 |     | <span class='neutral'>            return &quot;???&quot;;</span>
  31 |     | <span class='neutral'>        }</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /// @notice Provides a safe ERC20.symbol version which returns &#39;???&#39; as fallback string.</span>
  35 |     | <span class='neutral'>    /// @param token The address of the ERC-20 token contract.</span>
  36 |     | <span class='neutral'>    /// @return (string) Token symbol.</span>
  37 |     | <span class='neutral'>    function safeSymbol(IERC20 token) internal view returns (string memory) {</span>
  38 |     | <span class='neutral'>        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));</span>
  39 |     | <span class='neutral'>        return success ? returnDataToString(data) : &quot;???&quot;;</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @notice Provides a safe ERC20.name version which returns &#39;???&#39; as fallback string.</span>
  43 |     | <span class='neutral'>    /// @param token The address of the ERC-20 token contract.</span>
  44 |     | <span class='neutral'>    /// @return (string) Token name.</span>
  45 |     | <span class='neutral'>    function safeName(IERC20 token) internal view returns (string memory) {</span>
  46 |     | <span class='neutral'>        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));</span>
  47 |     | <span class='neutral'>        return success ? returnDataToString(data) : &quot;???&quot;;</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /// @notice Provides a safe ERC20.decimals version which returns &#39;18&#39; as fallback value.</span>
  51 |     | <span class='neutral'>    /// @param token The address of the ERC-20 token contract.</span>
  52 |     | <span class='neutral'>    /// @return (uint8) Token decimals.</span>
  53 |     | <span class='unexecuted'>    function safeDecimals(IERC20 token) internal view returns (uint8) {</span>
  54 |     | <span class='unexecuted'>        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));</span>
  55 |     | <span class='unexecuted'>        return success &amp;&amp; data.length == 32 ? abi.decode(data, (uint8)) : 18;</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /// @notice Provides a gas-optimized balance check to avoid a redundant extcodesize check in addition to the returndatasize check.</span>
  59 |     | <span class='neutral'>    /// @param token The address of the ERC-20 token.</span>
  60 |     | <span class='neutral'>    /// @param to The address of the user to check.</span>
  61 |     | <span class='neutral'>    /// @return amount The token amount.</span>
  62 |     | <span class='neutral'>    function safeBalanceOf(IERC20 token, address to) internal view returns (uint256 amount) {</span>
  63 |     | <span class='neutral'>        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_BALANCE_OF, to));</span>
  64 |     | <span class='neutral'>        require(success &amp;&amp; data.length &gt;= 32, &quot;BoringERC20: BalanceOf failed&quot;);</span>
  65 |     | <span class='neutral'>        amount = abi.decode(data, (uint256));</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /// @notice Provides a gas-optimized totalSupply to avoid a redundant extcodesize check in addition to the returndatasize check.</span>
  69 |     | <span class='neutral'>    /// @param token The address of the ERC-20 token.</span>
  70 |     | <span class='neutral'>    /// @return totalSupply The token totalSupply.</span>
  71 |     | <span class='neutral'>    function safeTotalSupply(IERC20 token) internal view returns (uint256 totalSupply) {</span>
  72 |     | <span class='neutral'>        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_TOTALSUPPLY));</span>
  73 |     | <span class='neutral'>        require(success &amp;&amp; data.length &gt;= 32, &quot;BoringERC20: totalSupply failed&quot;);</span>
  74 |     | <span class='neutral'>        totalSupply = abi.decode(data, (uint256));</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.</span>
  78 |     | <span class='neutral'>    /// Reverts on a failed transfer.</span>
  79 |     | <span class='neutral'>    /// @param token The address of the ERC-20 token.</span>
  80 |     | <span class='neutral'>    /// @param to Transfer tokens to.</span>
  81 |     | <span class='neutral'>    /// @param amount The token amount.</span>
  82 |     | <span class='unexecuted'>    function safeTransfer(</span>
  83 |     | <span class='neutral'>        IERC20 token,</span>
  84 |     | <span class='neutral'>        address to,</span>
  85 |     | <span class='neutral'>        uint256 amount</span>
  86 |     | <span class='unexecuted'>    ) internal {</span>
  87 |     | <span class='unexecuted'>        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));</span>
  88 |     | <span class='unexecuted'>        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &quot;BoringERC20: Transfer failed&quot;);</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.</span>
  92 |     | <span class='neutral'>    /// Reverts on a failed transfer.</span>
  93 |     | <span class='neutral'>    /// @param token The address of the ERC-20 token.</span>
  94 |     | <span class='neutral'>    /// @param from Transfer tokens from.</span>
  95 |     | <span class='neutral'>    /// @param to Transfer tokens to.</span>
  96 |     | <span class='neutral'>    /// @param amount The token amount.</span>
  97 |     | <span class='unexecuted'>    function safeTransferFrom(</span>
  98 |     | <span class='neutral'>        IERC20 token,</span>
  99 |     | <span class='neutral'>        address from,</span>
 100 |     | <span class='neutral'>        address to,</span>
 101 |     | <span class='neutral'>        uint256 amount</span>
 102 |     | <span class='unexecuted'>    ) internal {</span>
 103 |     | <span class='unexecuted'>        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));</span>
 104 |     | <span class='unexecuted'>        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &quot;BoringERC20: TransferFrom failed&quot;);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'>}</span>
 107 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/libraries/BoringMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='unexecuted'>library BoringMath {</span>
   5 |     | <span class='neutral'>    error ErrOverflow();</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='unexecuted'>    function add(uint256 a, uint256 b) internal pure returns (uint256) {</span>
   8 |     | <span class='unexecuted'>        return a + b;</span>
   9 |     | <span class='neutral'>    }</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>    function sub(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  12 |     | <span class='unexecuted'>        return a - b;</span>
  13 |     | <span class='neutral'>    }</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>    function mul(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  16 |     | <span class='unexecuted'>        return a * b;</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    function div(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  20 |     | <span class='neutral'>        return a / b;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    function to32(uint256 a) internal pure returns (uint32) {</span>
  24 |     | <span class='neutral'>        if (a &gt; type(uint32).max) {</span>
  25 |     | <span class='neutral'>            revert ErrOverflow();</span>
  26 |     | <span class='neutral'>        }</span>
  27 |     | <span class='neutral'>        return uint32(a);</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    function to40(uint256 a) internal pure returns (uint40) {</span>
  31 |     | <span class='neutral'>        if (a &gt; type(uint40).max) {</span>
  32 |     | <span class='neutral'>            revert ErrOverflow();</span>
  33 |     | <span class='neutral'>        }</span>
  34 |     | <span class='neutral'>        return uint40(a);</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>    function to64(uint256 a) internal pure returns (uint64) {</span>
  38 |     | <span class='unexecuted'>        if (a &gt; type(uint64).max) {</span>
  39 |     | <span class='unexecuted'>            revert ErrOverflow();</span>
  40 |     | <span class='neutral'>        }</span>
  41 |     | <span class='neutral'>        return uint64(a);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function to112(uint256 a) internal pure returns (uint112) {</span>
  45 |     | <span class='neutral'>        if (a &gt; type(uint112).max) {</span>
  46 |     | <span class='neutral'>            revert ErrOverflow();</span>
  47 |     | <span class='neutral'>        }</span>
  48 |     | <span class='neutral'>        return uint112(a);</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>    function to128(uint256 a) internal pure returns (uint128) {</span>
  52 |     | <span class='unexecuted'>        if (a &gt; type(uint128).max) {</span>
  53 |     | <span class='unexecuted'>            revert ErrOverflow();</span>
  54 |     | <span class='neutral'>        }</span>
  55 |     | <span class='unexecuted'>        return uint128(a);</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    function to208(uint256 a) internal pure returns (uint208) {</span>
  59 |     | <span class='neutral'>        if (a &gt; type(uint208).max) {</span>
  60 |     | <span class='neutral'>            revert ErrOverflow();</span>
  61 |     | <span class='neutral'>        }</span>
  62 |     | <span class='neutral'>        return uint208(a);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    function to216(uint256 a) internal pure returns (uint216) {</span>
  66 |     | <span class='neutral'>        if (a &gt; type(uint216).max) {</span>
  67 |     | <span class='neutral'>            revert ErrOverflow();</span>
  68 |     | <span class='neutral'>        }</span>
  69 |     | <span class='neutral'>        return uint216(a);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function to224(uint256 a) internal pure returns (uint224) {</span>
  73 |     | <span class='neutral'>        if (a &gt; type(uint224).max) {</span>
  74 |     | <span class='neutral'>            revert ErrOverflow();</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='neutral'>        return uint224(a);</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'>}</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>library BoringMath32 {</span>
  81 |     | <span class='neutral'>    function add(uint32 a, uint32 b) internal pure returns (uint32) {</span>
  82 |     | <span class='neutral'>        return a + b;</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    function sub(uint32 a, uint32 b) internal pure returns (uint32) {</span>
  86 |     | <span class='neutral'>        return a - b;</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    function mul(uint32 a, uint32 b) internal pure returns (uint32) {</span>
  90 |     | <span class='neutral'>        return a * b;</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    function div(uint32 a, uint32 b) internal pure returns (uint32) {</span>
  94 |     | <span class='neutral'>        return a / b;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'>}</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='unexecuted'>library BoringMath64 {</span>
  99 |     | <span class='neutral'>    function add(uint64 a, uint64 b) internal pure returns (uint64) {</span>
 100 |     | <span class='neutral'>        return a + b;</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function sub(uint64 a, uint64 b) internal pure returns (uint64) {</span>
 104 |     | <span class='neutral'>        return a - b;</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function mul(uint64 a, uint64 b) internal pure returns (uint64) {</span>
 108 |     | <span class='neutral'>        return a * b;</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    function div(uint64 a, uint64 b) internal pure returns (uint64) {</span>
 112 |     | <span class='neutral'>        return a / b;</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'>}</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>library BoringMath112 {</span>
 117 |     | <span class='neutral'>    function add(uint112 a, uint112 b) internal pure returns (uint112) {</span>
 118 |     | <span class='neutral'>        return a + b;</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    function sub(uint112 a, uint112 b) internal pure returns (uint112) {</span>
 122 |     | <span class='neutral'>        return a - b;</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    function mul(uint112 a, uint112 b) internal pure returns (uint112) {</span>
 126 |     | <span class='neutral'>        return a * b;</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    function div(uint112 a, uint112 b) internal pure returns (uint112) {</span>
 130 |     | <span class='neutral'>        return a / b;</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'>}</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>library BoringMath128 {</span>
 135 |     | <span class='unexecuted'>    function add(uint128 a, uint128 b) internal pure returns (uint128) {</span>
 136 |     | <span class='unexecuted'>        return a + b;</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>    function sub(uint128 a, uint128 b) internal pure returns (uint128) {</span>
 140 |     | <span class='unexecuted'>        return a - b;</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    function mul(uint128 a, uint128 b) internal pure returns (uint128) {</span>
 144 |     | <span class='neutral'>        return a * b;</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    function div(uint128 a, uint128 b) internal pure returns (uint128) {</span>
 148 |     | <span class='neutral'>        return a / b;</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'>}</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='unexecuted'>library BoringMath224 {</span>
 153 |     | <span class='neutral'>    function add(uint224 a, uint224 b) internal pure returns (uint224) {</span>
 154 |     | <span class='neutral'>        return a + b;</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    function sub(uint224 a, uint224 b) internal pure returns (uint224) {</span>
 158 |     | <span class='neutral'>        return a - b;</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    function mul(uint224 a, uint224 b) internal pure returns (uint224) {</span>
 162 |     | <span class='neutral'>        return a * b;</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    function div(uint224 a, uint224 b) internal pure returns (uint224) {</span>
 166 |     | <span class='neutral'>        return a / b;</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'>}</span>
 169 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/libraries/BoringRebase.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'>import {BoringMath, BoringMath128} from &quot;./BoringMath.sol&quot;;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>struct Rebase {</span>
   6 |     | <span class='neutral'>    uint128 elastic;</span>
   7 |     | <span class='neutral'>    uint128 base;</span>
   8 |     | <span class='neutral'>}</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/// @notice A rebasing library using overflow-/underflow-safe math.</span>
  11 |     | <span class='unexecuted'>library RebaseLibrary {</span>
  12 |     | <span class='neutral'>    using BoringMath for uint256;</span>
  13 |     | <span class='neutral'>    using BoringMath128 for uint128;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    /// @notice Calculates the base value in relationship to `elastic` and `total`.</span>
  16 |     | <span class='unexecuted'>    function toBase(</span>
  17 |     | <span class='neutral'>        Rebase memory total,</span>
  18 |     | <span class='neutral'>        uint256 elastic,</span>
  19 |     | <span class='neutral'>        bool roundUp</span>
  20 |     | <span class='unexecuted'>    ) internal pure returns (uint256 base) {</span>
  21 |     | <span class='unexecuted'>        if (total.elastic == 0) {</span>
  22 |     | <span class='unexecuted'>            base = elastic;</span>
  23 |     | <span class='neutral'>        } else {</span>
  24 |     | <span class='unexecuted'>            base = (elastic * total.base) / total.elastic;</span>
  25 |     | <span class='unexecuted'>            if (roundUp &amp;&amp; (base * total.elastic) / total.base &lt; elastic) {</span>
  26 |     | <span class='unexecuted'>                base++;</span>
  27 |     | <span class='neutral'>            }</span>
  28 |     | <span class='neutral'>        }</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /// @notice Calculates the elastic value in relationship to `base` and `total`.</span>
  32 |     | <span class='unexecuted'>    function toElastic(</span>
  33 |     | <span class='neutral'>        Rebase memory total,</span>
  34 |     | <span class='neutral'>        uint256 base,</span>
  35 |     | <span class='neutral'>        bool roundUp</span>
  36 |     | <span class='unexecuted'>    ) internal pure returns (uint256 elastic) {</span>
  37 |     | <span class='unexecuted'>        if (total.base == 0) {</span>
  38 |     | <span class='unexecuted'>            elastic = base;</span>
  39 |     | <span class='neutral'>        } else {</span>
  40 |     | <span class='unexecuted'>            elastic = (base * total.elastic) / total.base;</span>
  41 |     | <span class='unexecuted'>            if (roundUp &amp;&amp; (elastic * total.base) / total.elastic &lt; base) {</span>
  42 |     | <span class='unexecuted'>                elastic++;</span>
  43 |     | <span class='neutral'>            }</span>
  44 |     | <span class='neutral'>        }</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /// @notice Add `elastic` to `total` and doubles `total.base`.</span>
  48 |     | <span class='neutral'>    /// @return (Rebase) The new total.</span>
  49 |     | <span class='neutral'>    /// @return base in relationship to `elastic`.</span>
  50 |     | <span class='unexecuted'>    function add(</span>
  51 |     | <span class='neutral'>        Rebase memory total,</span>
  52 |     | <span class='neutral'>        uint256 elastic,</span>
  53 |     | <span class='neutral'>        bool roundUp</span>
  54 |     | <span class='unexecuted'>    ) internal pure returns (Rebase memory, uint256 base) {</span>
  55 |     | <span class='unexecuted'>        base = toBase(total, elastic, roundUp);</span>
  56 |     | <span class='unexecuted'>        total.elastic += elastic.to128();</span>
  57 |     | <span class='unexecuted'>        total.base += base.to128();</span>
  58 |     | <span class='unexecuted'>        return (total, base);</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /// @notice Sub `base` from `total` and update `total.elastic`.</span>
  62 |     | <span class='neutral'>    /// @return (Rebase) The new total.</span>
  63 |     | <span class='neutral'>    /// @return elastic in relationship to `base`.</span>
  64 |     | <span class='unexecuted'>    function sub(</span>
  65 |     | <span class='neutral'>        Rebase memory total,</span>
  66 |     | <span class='neutral'>        uint256 base,</span>
  67 |     | <span class='neutral'>        bool roundUp</span>
  68 |     | <span class='unexecuted'>    ) internal pure returns (Rebase memory, uint256 elastic) {</span>
  69 |     | <span class='unexecuted'>        elastic = toElastic(total, base, roundUp);</span>
  70 |     | <span class='unexecuted'>        total.elastic -= elastic.to128();</span>
  71 |     | <span class='unexecuted'>        total.base -= base.to128();</span>
  72 |     | <span class='unexecuted'>        return (total, elastic);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /// @notice Add `elastic` and `base` to `total`.</span>
  76 |     | <span class='neutral'>    function add(</span>
  77 |     | <span class='neutral'>        Rebase memory total,</span>
  78 |     | <span class='neutral'>        uint256 elastic,</span>
  79 |     | <span class='neutral'>        uint256 base</span>
  80 |     | <span class='neutral'>    ) internal pure returns (Rebase memory) {</span>
  81 |     | <span class='neutral'>        total.elastic += elastic.to128();</span>
  82 |     | <span class='neutral'>        total.base += base.to128();</span>
  83 |     | <span class='neutral'>        return total;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /// @notice Subtract `elastic` and `base` to `total`.</span>
  87 |     | <span class='neutral'>    function sub(</span>
  88 |     | <span class='neutral'>        Rebase memory total,</span>
  89 |     | <span class='neutral'>        uint256 elastic,</span>
  90 |     | <span class='neutral'>        uint256 base</span>
  91 |     | <span class='neutral'>    ) internal pure returns (Rebase memory) {</span>
  92 |     | <span class='neutral'>        total.elastic -= elastic.to128();</span>
  93 |     | <span class='neutral'>        total.base -= base.to128();</span>
  94 |     | <span class='neutral'>        return total;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /// @notice Add `elastic` to `total` and update storage.</span>
  98 |     | <span class='neutral'>    /// @return newElastic Returns updated `elastic`.</span>
  99 |     | <span class='unexecuted'>    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {</span>
 100 |     | <span class='unexecuted'>        newElastic = total.elastic += elastic.to128();</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /// @notice Subtract `elastic` from `total` and update storage.</span>
 104 |     | <span class='neutral'>    /// @return newElastic Returns updated `elastic`.</span>
 105 |     | <span class='unexecuted'>    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {</span>
 106 |     | <span class='unexecuted'>        newElastic = total.elastic -= elastic.to128();</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'>}</span>
 109 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/ExcessivelySafeCall/src/ExcessivelySafeCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT OR Apache-2.0</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.7.6;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='unexecuted'>library ExcessivelySafeCall {</span>
   5 |     | <span class='neutral'>    uint256 constant LOW_28_MASK =</span>
   6 |     | <span class='neutral'>        0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>    /// @notice Use when you _really_ really _really_ don&#39;t trust the called</span>
   9 |     | <span class='neutral'>    /// contract. This prevents the called contract from causing reversion of</span>
  10 |     | <span class='neutral'>    /// the caller in as many ways as we can.</span>
  11 |     | <span class='neutral'>    /// @dev The main difference between this and a solidity low-level call is</span>
  12 |     | <span class='neutral'>    /// that we limit the number of bytes that the callee can cause to be</span>
  13 |     | <span class='neutral'>    /// copied to caller memory. This prevents stupid things like malicious</span>
  14 |     | <span class='neutral'>    /// contracts returning 10,000,000 bytes causing a local OOG when copying</span>
  15 |     | <span class='neutral'>    /// to memory.</span>
  16 |     | <span class='neutral'>    /// @param _target The address to call</span>
  17 |     | <span class='neutral'>    /// @param _gas The amount of gas to forward to the remote contract</span>
  18 |     | <span class='neutral'>    /// @param _maxCopy The maximum number of bytes of returndata to copy</span>
  19 |     | <span class='neutral'>    /// to memory.</span>
  20 |     | <span class='neutral'>    /// @param _calldata The data to send to the remote contract</span>
  21 |     | <span class='neutral'>    /// @return success and returndata, as `.call()`. Returndata is capped to</span>
  22 |     | <span class='neutral'>    /// `_maxCopy` bytes.</span>
  23 |     | <span class='unexecuted'>    function excessivelySafeCall(</span>
  24 |     | <span class='neutral'>        address _target,</span>
  25 |     | <span class='neutral'>        uint256 _gas,</span>
  26 |     | <span class='neutral'>        uint16 _maxCopy,</span>
  27 |     | <span class='neutral'>        bytes memory _calldata</span>
  28 |     | <span class='unexecuted'>    ) internal returns (bool, bytes memory) {</span>
  29 |     | <span class='neutral'>        // set up for assembly call</span>
  30 |     | <span class='unexecuted'>        uint256 _toCopy;</span>
  31 |     | <span class='unexecuted'>        bool _success;</span>
  32 |     | <span class='unexecuted'>        bytes memory _returnData = new bytes(_maxCopy);</span>
  33 |     | <span class='neutral'>        // dispatch message to recipient</span>
  34 |     | <span class='neutral'>        // by assembly calling &quot;handle&quot; function</span>
  35 |     | <span class='neutral'>        // we call via assembly to avoid memcopying a very large returndata</span>
  36 |     | <span class='neutral'>        // returned by a malicious contract</span>
  37 |     | <span class='neutral'>        assembly {</span>
  38 |     | <span class='unexecuted'>            _success := call(</span>
  39 |     | <span class='unexecuted'>                _gas, // gas</span>
  40 |     | <span class='unexecuted'>                _target, // recipient</span>
  41 |     | <span class='unexecuted'>                0, // ether value</span>
  42 |     | <span class='unexecuted'>                add(_calldata, 0x20), // inloc</span>
  43 |     | <span class='unexecuted'>                mload(_calldata), // inlen</span>
  44 |     | <span class='unexecuted'>                0, // outloc</span>
  45 |     | <span class='unexecuted'>                0 // outlen</span>
  46 |     | <span class='neutral'>            )</span>
  47 |     | <span class='neutral'>            // limit our copy to 256 bytes</span>
  48 |     | <span class='unexecuted'>            _toCopy := returndatasize()</span>
  49 |     | <span class='unexecuted'>            if gt(_toCopy, _maxCopy) {</span>
  50 |     | <span class='unexecuted'>                _toCopy := _maxCopy</span>
  51 |     | <span class='neutral'>            }</span>
  52 |     | <span class='neutral'>            // Store the length of the copied bytes</span>
  53 |     | <span class='unexecuted'>            mstore(_returnData, _toCopy)</span>
  54 |     | <span class='neutral'>            // copy the bytes from returndata[0:_toCopy]</span>
  55 |     | <span class='unexecuted'>            returndatacopy(add(_returnData, 0x20), 0, _toCopy)</span>
  56 |     | <span class='neutral'>        }</span>
  57 |     | <span class='unexecuted'>        return (_success, _returnData);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /// @notice Use when you _really_ really _really_ don&#39;t trust the called</span>
  61 |     | <span class='neutral'>    /// contract. This prevents the called contract from causing reversion of</span>
  62 |     | <span class='neutral'>    /// the caller in as many ways as we can.</span>
  63 |     | <span class='neutral'>    /// @dev The main difference between this and a solidity low-level call is</span>
  64 |     | <span class='neutral'>    /// that we limit the number of bytes that the callee can cause to be</span>
  65 |     | <span class='neutral'>    /// copied to caller memory. This prevents stupid things like malicious</span>
  66 |     | <span class='neutral'>    /// contracts returning 10,000,000 bytes causing a local OOG when copying</span>
  67 |     | <span class='neutral'>    /// to memory.</span>
  68 |     | <span class='neutral'>    /// @param _target The address to call</span>
  69 |     | <span class='neutral'>    /// @param _gas The amount of gas to forward to the remote contract</span>
  70 |     | <span class='neutral'>    /// @param _maxCopy The maximum number of bytes of returndata to copy</span>
  71 |     | <span class='neutral'>    /// to memory.</span>
  72 |     | <span class='neutral'>    /// @param _calldata The data to send to the remote contract</span>
  73 |     | <span class='neutral'>    /// @return success and returndata, as `.call()`. Returndata is capped to</span>
  74 |     | <span class='neutral'>    /// `_maxCopy` bytes.</span>
  75 |     | <span class='neutral'>    function excessivelySafeStaticCall(</span>
  76 |     | <span class='neutral'>        address _target,</span>
  77 |     | <span class='neutral'>        uint256 _gas,</span>
  78 |     | <span class='neutral'>        uint16 _maxCopy,</span>
  79 |     | <span class='neutral'>        bytes memory _calldata</span>
  80 |     | <span class='neutral'>    ) internal view returns (bool, bytes memory) {</span>
  81 |     | <span class='neutral'>        // set up for assembly call</span>
  82 |     | <span class='neutral'>        uint256 _toCopy;</span>
  83 |     | <span class='neutral'>        bool _success;</span>
  84 |     | <span class='neutral'>        bytes memory _returnData = new bytes(_maxCopy);</span>
  85 |     | <span class='neutral'>        // dispatch message to recipient</span>
  86 |     | <span class='neutral'>        // by assembly calling &quot;handle&quot; function</span>
  87 |     | <span class='neutral'>        // we call via assembly to avoid memcopying a very large returndata</span>
  88 |     | <span class='neutral'>        // returned by a malicious contract</span>
  89 |     | <span class='neutral'>        assembly {</span>
  90 |     | <span class='neutral'>            _success := staticcall(</span>
  91 |     | <span class='neutral'>                _gas, // gas</span>
  92 |     | <span class='neutral'>                _target, // recipient</span>
  93 |     | <span class='neutral'>                add(_calldata, 0x20), // inloc</span>
  94 |     | <span class='neutral'>                mload(_calldata), // inlen</span>
  95 |     | <span class='neutral'>                0, // outloc</span>
  96 |     | <span class='neutral'>                0 // outlen</span>
  97 |     | <span class='neutral'>            )</span>
  98 |     | <span class='neutral'>            // limit our copy to 256 bytes</span>
  99 |     | <span class='neutral'>            _toCopy := returndatasize()</span>
 100 |     | <span class='neutral'>            if gt(_toCopy, _maxCopy) {</span>
 101 |     | <span class='neutral'>                _toCopy := _maxCopy</span>
 102 |     | <span class='neutral'>            }</span>
 103 |     | <span class='neutral'>            // Store the length of the copied bytes</span>
 104 |     | <span class='neutral'>            mstore(_returnData, _toCopy)</span>
 105 |     | <span class='neutral'>            // copy the bytes from returndata[0:_toCopy]</span>
 106 |     | <span class='neutral'>            returndatacopy(add(_returnData, 0x20), 0, _toCopy)</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'>        return (_success, _returnData);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /**</span>
 112 |     | <span class='neutral'>     * @notice Swaps function selectors in encoded contract calls</span>
 113 |     | <span class='neutral'>     * @dev Allows reuse of encoded calldata for functions with identical</span>
 114 |     | <span class='neutral'>     * argument types but different names. It simply swaps out the first 4 bytes</span>
 115 |     | <span class='neutral'>     * for the new selector. This function modifies memory in place, and should</span>
 116 |     | <span class='neutral'>     * only be used with caution.</span>
 117 |     | <span class='neutral'>     * @param _newSelector The new 4-byte selector</span>
 118 |     | <span class='neutral'>     * @param _buf The encoded contract args</span>
 119 |     | <span class='neutral'>     */</span>
 120 |     | <span class='neutral'>    function swapSelector(bytes4 _newSelector, bytes memory _buf)</span>
 121 |     | <span class='neutral'>        internal</span>
 122 |     | <span class='neutral'>        pure</span>
 123 |     | <span class='neutral'>    {</span>
 124 |     | <span class='neutral'>        require(_buf.length &gt;= 4);</span>
 125 |     | <span class='neutral'>        uint256 _mask = LOW_28_MASK;</span>
 126 |     | <span class='neutral'>        assembly {</span>
 127 |     | <span class='neutral'>            // load the first word of</span>
 128 |     | <span class='neutral'>            let _word := mload(add(_buf, 0x20))</span>
 129 |     | <span class='neutral'>            // mask out the top 4 bytes</span>
 130 |     | <span class='neutral'>            // /x</span>
 131 |     | <span class='neutral'>            _word := and(_word, _mask)</span>
 132 |     | <span class='neutral'>            _word := or(_newSelector, _word)</span>
 133 |     | <span class='neutral'>            mstore(add(_buf, 0x20), _word)</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'>}</span>
 137 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/AssertHelper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./FuzzLibString.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @author Based on Crytic PropertiesHelper (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)</span>
   7 |     | <span class='neutral'>abstract contract AssertHelper {</span>
   8 |     | <span class='neutral'>    event AssertFail(string);</span>
   9 |     | <span class='neutral'>    event AssertEqFail(string);</span>
  10 |     | <span class='neutral'>    event AssertNeqFail(string);</span>
  11 |     | <span class='neutral'>    event AssertGteFail(string);</span>
  12 |     | <span class='neutral'>    event AssertGtFail(string);</span>
  13 |     | <span class='neutral'>    event AssertLteFail(string);</span>
  14 |     | <span class='neutral'>    event AssertLtFail(string);</span>
  15 |     | <span class='neutral'></span>
  16 | *   | <span class='executed'>    function assertWithMsg(bool b, string memory reason) internal {</span>
  17 | *   | <span class='executed'>        if (!b) {</span>
  18 | *   | <span class='executed'>            emit AssertFail(reason);</span>
  19 | *   | <span class='executed'>            assert(false);</span>
  20 |     | <span class='neutral'>        }</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /// @notice asserts that a is equal to b. Violations are logged using reason.</span>
  24 | *   | <span class='executed'>    function assertEq(</span>
  25 |     | <span class='neutral'>        uint256 a,</span>
  26 |     | <span class='neutral'>        uint256 b,</span>
  27 |     | <span class='neutral'>        string memory reason</span>
  28 |     | <span class='neutral'>    ) internal {</span>
  29 | *   | <span class='executed'>        if (a != b) {</span>
  30 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
  31 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
  32 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(</span>
  33 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  34 |     | <span class='unexecuted'>                aStr,</span>
  35 |     | <span class='neutral'>                &quot;!=&quot;,</span>
  36 |     | <span class='unexecuted'>                bStr,</span>
  37 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  38 |     | <span class='unexecuted'>                reason</span>
  39 |     | <span class='neutral'>            );</span>
  40 |     | <span class='unexecuted'>            emit AssertEqFail(string(assertMsg));</span>
  41 |     | <span class='unexecuted'>            assert(false);</span>
  42 |     | <span class='neutral'>        }</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /// @notice int256 version of assertEq</span>
  46 |     | <span class='neutral'>    function assertEq(</span>
  47 |     | <span class='neutral'>        int256 a,</span>
  48 |     | <span class='neutral'>        int256 b,</span>
  49 |     | <span class='neutral'>        string memory reason</span>
  50 |     | <span class='neutral'>    ) internal {</span>
  51 |     | <span class='neutral'>        if (a != b) {</span>
  52 |     | <span class='neutral'>            string memory aStr = FuzzLibString.toString(a);</span>
  53 |     | <span class='neutral'>            string memory bStr = FuzzLibString.toString(b);</span>
  54 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
  55 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  56 |     | <span class='neutral'>                aStr,</span>
  57 |     | <span class='neutral'>                &quot;!=&quot;,</span>
  58 |     | <span class='neutral'>                bStr,</span>
  59 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  60 |     | <span class='neutral'>                reason</span>
  61 |     | <span class='neutral'>            );</span>
  62 |     | <span class='neutral'>            emit AssertEqFail(string(assertMsg));</span>
  63 |     | <span class='neutral'>            assert(false);</span>
  64 |     | <span class='neutral'>        }</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /// @notice bytes4 version of assertEq</span>
  68 |     | <span class='neutral'>    function assertEq(</span>
  69 |     | <span class='neutral'>        bytes4 a,</span>
  70 |     | <span class='neutral'>        bytes4 b,</span>
  71 |     | <span class='neutral'>        string memory reason</span>
  72 |     | <span class='neutral'>    ) internal {</span>
  73 |     | <span class='neutral'>        if (a != b) {</span>
  74 |     | <span class='neutral'>            bytes memory aBytes = abi.encodePacked(a);</span>
  75 |     | <span class='neutral'>            bytes memory bBytes = abi.encodePacked(b);</span>
  76 |     | <span class='neutral'>            string memory aStr = FuzzLibString.toHexString(aBytes);</span>
  77 |     | <span class='neutral'>            string memory bStr = FuzzLibString.toHexString(bBytes);</span>
  78 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
  79 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  80 |     | <span class='neutral'>                aStr,</span>
  81 |     | <span class='neutral'>                &quot;!=&quot;,</span>
  82 |     | <span class='neutral'>                bStr,</span>
  83 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  84 |     | <span class='neutral'>                reason</span>
  85 |     | <span class='neutral'>            );</span>
  86 |     | <span class='neutral'>            emit AssertEqFail(string(assertMsg));</span>
  87 |     | <span class='neutral'>            assert(false);</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /// @notice asserts that a is not equal to b. Violations are logged using reason.</span>
  92 |     | <span class='neutral'>    function assertNeq(</span>
  93 |     | <span class='neutral'>        uint256 a,</span>
  94 |     | <span class='neutral'>        uint256 b,</span>
  95 |     | <span class='neutral'>        string memory reason</span>
  96 |     | <span class='neutral'>    ) internal {</span>
  97 |     | <span class='neutral'>        if (a == b) {</span>
  98 |     | <span class='neutral'>            string memory aStr = FuzzLibString.toString(a);</span>
  99 |     | <span class='neutral'>            string memory bStr = FuzzLibString.toString(b);</span>
 100 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 101 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 102 |     | <span class='neutral'>                aStr,</span>
 103 |     | <span class='neutral'>                &quot;==&quot;,</span>
 104 |     | <span class='neutral'>                bStr,</span>
 105 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
 106 |     | <span class='neutral'>                reason</span>
 107 |     | <span class='neutral'>            );</span>
 108 |     | <span class='neutral'>            emit AssertNeqFail(string(assertMsg));</span>
 109 |     | <span class='neutral'>            assert(false);</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /// @notice int256 version of assertNeq</span>
 114 |     | <span class='neutral'>    function assertNeq(</span>
 115 |     | <span class='neutral'>        int256 a,</span>
 116 |     | <span class='neutral'>        int256 b,</span>
 117 |     | <span class='neutral'>        string memory reason</span>
 118 |     | <span class='neutral'>    ) internal {</span>
 119 |     | <span class='neutral'>        if (a == b) {</span>
 120 |     | <span class='neutral'>            string memory aStr = FuzzLibString.toString(a);</span>
 121 |     | <span class='neutral'>            string memory bStr = FuzzLibString.toString(b);</span>
 122 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 123 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 124 |     | <span class='neutral'>                aStr,</span>
 125 |     | <span class='neutral'>                &quot;==&quot;,</span>
 126 |     | <span class='neutral'>                bStr,</span>
 127 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
 128 |     | <span class='neutral'>                reason</span>
 129 |     | <span class='neutral'>            );</span>
 130 |     | <span class='neutral'>            emit AssertNeqFail(string(assertMsg));</span>
 131 |     | <span class='neutral'>            assert(false);</span>
 132 |     | <span class='neutral'>        }</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.</span>
 136 | *   | <span class='executed'>    function assertGte(</span>
 137 |     | <span class='neutral'>        uint256 a,</span>
 138 |     | <span class='neutral'>        uint256 b,</span>
 139 |     | <span class='neutral'>        string memory reason</span>
 140 |     | <span class='neutral'>    ) internal {</span>
 141 | *   | <span class='executed'>        if (!(a &gt;= b)) {</span>
 142 | *   | <span class='executed'>            string memory aStr = FuzzLibString.toString(a);</span>
 143 | *   | <span class='executed'>            string memory bStr = FuzzLibString.toString(b);</span>
 144 | *   | <span class='executed'>            bytes memory assertMsg = abi.encodePacked(</span>
 145 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 146 | *   | <span class='executed'>                aStr,</span>
 147 |     | <span class='neutral'>                &quot;&lt;&quot;,</span>
 148 | *   | <span class='executed'>                bStr,</span>
 149 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 150 | *   | <span class='executed'>                reason</span>
 151 |     | <span class='neutral'>            );</span>
 152 | *   | <span class='executed'>            emit AssertGteFail(string(assertMsg));</span>
 153 |     | <span class='neutral'>            assert(false);</span>
 154 |     | <span class='neutral'>        }</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    /// @notice int256 version of assertGte</span>
 158 |     | <span class='neutral'>    function assertGte(</span>
 159 |     | <span class='neutral'>        int256 a,</span>
 160 |     | <span class='neutral'>        int256 b,</span>
 161 |     | <span class='neutral'>        string memory reason</span>
 162 |     | <span class='neutral'>    ) internal {</span>
 163 |     | <span class='neutral'>        if (!(a &gt;= b)) {</span>
 164 |     | <span class='neutral'>            string memory aStr = FuzzLibString.toString(a);</span>
 165 |     | <span class='neutral'>            string memory bStr = FuzzLibString.toString(b);</span>
 166 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 167 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 168 |     | <span class='neutral'>                aStr,</span>
 169 |     | <span class='neutral'>                &quot;&lt;&quot;,</span>
 170 |     | <span class='neutral'>                bStr,</span>
 171 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 172 |     | <span class='neutral'>                reason</span>
 173 |     | <span class='neutral'>            );</span>
 174 |     | <span class='neutral'>            emit AssertGteFail(string(assertMsg));</span>
 175 |     | <span class='neutral'>            assert(false);</span>
 176 |     | <span class='neutral'>        }</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    /// @notice asserts that a is greater than b. Violations are logged using reason.</span>
 180 | *   | <span class='executed'>    function assertGt(</span>
 181 |     | <span class='neutral'>        uint256 a,</span>
 182 |     | <span class='neutral'>        uint256 b,</span>
 183 |     | <span class='neutral'>        string memory reason</span>
 184 |     | <span class='neutral'>    ) internal {</span>
 185 | *   | <span class='executed'>        if (!(a &gt; b)) {</span>
 186 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 187 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 188 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(</span>
 189 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 190 |     | <span class='unexecuted'>                aStr,</span>
 191 |     | <span class='neutral'>                &quot;&lt;=&quot;,</span>
 192 |     | <span class='unexecuted'>                bStr,</span>
 193 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 194 |     | <span class='unexecuted'>                reason</span>
 195 |     | <span class='neutral'>            );</span>
 196 |     | <span class='unexecuted'>            emit AssertGtFail(string(assertMsg));</span>
 197 |     | <span class='neutral'>            assert(false);</span>
 198 |     | <span class='neutral'>        }</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>    /// @notice int256 version of assertGt</span>
 202 |     | <span class='neutral'>    function assertGt(</span>
 203 |     | <span class='neutral'>        int256 a,</span>
 204 |     | <span class='neutral'>        int256 b,</span>
 205 |     | <span class='neutral'>        string memory reason</span>
 206 |     | <span class='neutral'>    ) internal {</span>
 207 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 208 |     | <span class='neutral'>            string memory aStr = FuzzLibString.toString(a);</span>
 209 |     | <span class='neutral'>            string memory bStr = FuzzLibString.toString(b);</span>
 210 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 211 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 212 |     | <span class='neutral'>                aStr,</span>
 213 |     | <span class='neutral'>                &quot;&lt;=&quot;,</span>
 214 |     | <span class='neutral'>                bStr,</span>
 215 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 216 |     | <span class='neutral'>                reason</span>
 217 |     | <span class='neutral'>            );</span>
 218 |     | <span class='neutral'>            emit AssertGtFail(string(assertMsg));</span>
 219 |     | <span class='neutral'>            assert(false);</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    /// @notice asserts that a is less than or equal to b. Violations are logged using reason.</span>
 224 | *   | <span class='executed'>    function assertLte(</span>
 225 |     | <span class='neutral'>        uint256 a,</span>
 226 |     | <span class='neutral'>        uint256 b,</span>
 227 |     | <span class='neutral'>        string memory reason</span>
 228 |     | <span class='neutral'>    ) internal {</span>
 229 | *   | <span class='executed'>        if (!(a &lt;= b)) {</span>
 230 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 231 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 232 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(</span>
 233 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 234 |     | <span class='unexecuted'>                aStr,</span>
 235 |     | <span class='neutral'>                &quot;&gt;&quot;,</span>
 236 |     | <span class='unexecuted'>                bStr,</span>
 237 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 238 |     | <span class='unexecuted'>                reason</span>
 239 |     | <span class='neutral'>            );</span>
 240 | *   | <span class='executed'>            emit AssertLteFail(string(assertMsg));</span>
 241 | *   | <span class='executed'>            assert(false);</span>
 242 |     | <span class='neutral'>        }</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='neutral'>    /// @notice int256 version of assertLte</span>
 246 |     | <span class='neutral'>    function assertLte(</span>
 247 |     | <span class='neutral'>        int256 a,</span>
 248 |     | <span class='neutral'>        int256 b,</span>
 249 |     | <span class='neutral'>        string memory reason</span>
 250 |     | <span class='neutral'>    ) internal {</span>
 251 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 252 |     | <span class='neutral'>            string memory aStr = FuzzLibString.toString(a);</span>
 253 |     | <span class='neutral'>            string memory bStr = FuzzLibString.toString(b);</span>
 254 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 255 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 256 |     | <span class='neutral'>                aStr,</span>
 257 |     | <span class='neutral'>                &quot;&gt;&quot;,</span>
 258 |     | <span class='neutral'>                bStr,</span>
 259 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 260 |     | <span class='neutral'>                reason</span>
 261 |     | <span class='neutral'>            );</span>
 262 |     | <span class='neutral'>            emit AssertLteFail(string(assertMsg));</span>
 263 |     | <span class='neutral'>            assert(false);</span>
 264 |     | <span class='neutral'>        }</span>
 265 |     | <span class='neutral'>    }</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'>    /// @notice asserts that a is less than b. Violations are logged using reason.</span>
 268 | *   | <span class='executed'>    function assertLt(</span>
 269 |     | <span class='neutral'>        uint256 a,</span>
 270 |     | <span class='neutral'>        uint256 b,</span>
 271 |     | <span class='neutral'>        string memory reason</span>
 272 |     | <span class='neutral'>    ) internal {</span>
 273 | *   | <span class='executed'>        if (!(a &lt; b)) {</span>
 274 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 275 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 276 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(</span>
 277 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 278 |     | <span class='unexecuted'>                aStr,</span>
 279 |     | <span class='neutral'>                &quot;&gt;=&quot;,</span>
 280 |     | <span class='unexecuted'>                bStr,</span>
 281 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 282 |     | <span class='unexecuted'>                reason</span>
 283 |     | <span class='neutral'>            );</span>
 284 |     | <span class='unexecuted'>            emit AssertLtFail(string(assertMsg));</span>
 285 |     | <span class='neutral'>            assert(false);</span>
 286 |     | <span class='neutral'>        }</span>
 287 |     | <span class='neutral'>    }</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='neutral'>    /// @notice int256 version of assertLt</span>
 290 |     | <span class='neutral'>    function assertLt(</span>
 291 |     | <span class='neutral'>        int256 a,</span>
 292 |     | <span class='neutral'>        int256 b,</span>
 293 |     | <span class='neutral'>        string memory reason</span>
 294 |     | <span class='neutral'>    ) internal {</span>
 295 |     | <span class='neutral'>        if (!(a &lt; b)) {</span>
 296 |     | <span class='neutral'>            string memory aStr = FuzzLibString.toString(a);</span>
 297 |     | <span class='neutral'>            string memory bStr = FuzzLibString.toString(b);</span>
 298 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 299 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 300 |     | <span class='neutral'>                aStr,</span>
 301 |     | <span class='neutral'>                &quot;&gt;=&quot;,</span>
 302 |     | <span class='neutral'>                bStr,</span>
 303 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 304 |     | <span class='neutral'>                reason</span>
 305 |     | <span class='neutral'>            );</span>
 306 |     | <span class='neutral'>            emit AssertLtFail(string(assertMsg));</span>
 307 |     | <span class='neutral'>            assert(false);</span>
 308 |     | <span class='neutral'>        }</span>
 309 |     | <span class='neutral'>    }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    function assertRevertReasonNotEqual(</span>
 312 |     | <span class='neutral'>        bytes memory returnData,</span>
 313 |     | <span class='neutral'>        string memory reason</span>
 314 |     | <span class='neutral'>    ) internal {</span>
 315 |     | <span class='neutral'>        bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason);</span>
 316 |     | <span class='neutral'>        assertWithMsg(!isEqual, reason);</span>
 317 |     | <span class='neutral'>    }</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>    function assertRevertReasonEqual(</span>
 320 |     | <span class='neutral'>        bytes memory returnData,</span>
 321 |     | <span class='neutral'>        string memory reason</span>
 322 |     | <span class='neutral'>    ) internal {</span>
 323 |     | <span class='neutral'>        bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason);</span>
 324 |     | <span class='neutral'>        assertWithMsg(isEqual, reason);</span>
 325 |     | <span class='neutral'>    }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>    function assertRevertReasonEqual(</span>
 328 |     | <span class='neutral'>        bytes memory returnData,</span>
 329 |     | <span class='neutral'>        string memory reason1,</span>
 330 |     | <span class='neutral'>        string memory reason2</span>
 331 |     | <span class='neutral'>    ) internal {</span>
 332 |     | <span class='neutral'>        bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||</span>
 333 |     | <span class='neutral'>            FuzzLibString.isRevertReasonEqual(returnData, reason2);</span>
 334 |     | <span class='neutral'>        assertWithMsg(isEqual, string.concat(reason1, &quot; OR &quot;, reason2));</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='neutral'>    function assertRevertReasonEqual(</span>
 338 |     | <span class='neutral'>        bytes memory returnData,</span>
 339 |     | <span class='neutral'>        string memory reason1,</span>
 340 |     | <span class='neutral'>        string memory reason2,</span>
 341 |     | <span class='neutral'>        string memory reason3</span>
 342 |     | <span class='neutral'>    ) internal {</span>
 343 |     | <span class='neutral'>        bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||</span>
 344 |     | <span class='neutral'>            FuzzLibString.isRevertReasonEqual(returnData, reason2) ||</span>
 345 |     | <span class='neutral'>            FuzzLibString.isRevertReasonEqual(returnData, reason3);</span>
 346 |     | <span class='neutral'>        assertWithMsg(isEqual, string.concat(reason1, &quot; OR &quot;, reason2, &quot; OR &quot;, reason3));</span>
 347 |     | <span class='neutral'>    }</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='neutral'>    function assertRevertReasonEqual(</span>
 350 |     | <span class='neutral'>        bytes memory returnData,</span>
 351 |     | <span class='neutral'>        string memory reason1,</span>
 352 |     | <span class='neutral'>        string memory reason2,</span>
 353 |     | <span class='neutral'>        string memory reason3,</span>
 354 |     | <span class='neutral'>        string memory reason4</span>
 355 |     | <span class='neutral'>    ) internal {</span>
 356 |     | <span class='neutral'>        bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||</span>
 357 |     | <span class='neutral'>            FuzzLibString.isRevertReasonEqual(returnData, reason2) ||</span>
 358 |     | <span class='neutral'>            FuzzLibString.isRevertReasonEqual(returnData, reason3) ||</span>
 359 |     | <span class='neutral'>            FuzzLibString.isRevertReasonEqual(returnData, reason4);</span>
 360 |     | <span class='neutral'>        assertWithMsg(</span>
 361 |     | <span class='neutral'>            isEqual,</span>
 362 |     | <span class='neutral'>            string.concat(</span>
 363 |     | <span class='neutral'>                reason1,</span>
 364 |     | <span class='neutral'>                &quot; OR &quot;,</span>
 365 |     | <span class='neutral'>                reason2,</span>
 366 |     | <span class='neutral'>                &quot; OR &quot;,</span>
 367 |     | <span class='neutral'>                reason3,</span>
 368 |     | <span class='neutral'>                &quot; OR &quot;,</span>
 369 |     | <span class='neutral'>                reason4</span>
 370 |     | <span class='neutral'>            )</span>
 371 |     | <span class='neutral'>        );</span>
 372 |     | <span class='neutral'>    }</span>
 373 |     | <span class='neutral'>}</span>
 374 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/AssertWrapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./AssertHelper.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>abstract contract AssertWrapper is AssertHelper {</span>
  7 | *   | <span class='executed'>    function gt(uint256 a, uint256 b, string memory message) internal {</span>
  8 | *   | <span class='executed'>        assertGt(a, b, message);</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 | *   | <span class='executed'>    function lt(uint256 a, uint256 b, string memory message) internal {</span>
 12 | *   | <span class='executed'>        assertLt(a, b, message);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 | *   | <span class='executed'>    function gte(uint256 a, uint256 b, string memory message) internal {</span>
 16 | *   | <span class='executed'>        assertGte(a, b, message);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 | *   | <span class='executed'>    function lte(uint256 a, uint256 b, string memory message) internal {</span>
 20 | *   | <span class='executed'>        assertLte(a, b, message);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 | *   | <span class='executed'>    function eq(uint256 a, uint256 b, string memory message) internal {</span>
 24 | *   | <span class='executed'>        assertEq(a, b, message);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function neq(uint256 a, uint256 b, string memory message) internal {</span>
 28 |     | <span class='neutral'>        assertNeq(a, b, message);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 | *   | <span class='executed'>    function t(bool a, string memory message) internal {</span>
 32 | *   | <span class='executed'>        assertWithMsg(a, message);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'>}</span>
 35 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/ClampHelper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./FuzzLibString.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./AssertHelper.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/// @author Based on Crytic PropertiesHelper (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)</span>
   8 |     | <span class='neutral'>abstract contract ClampHelper is AssertHelper {</span>
   9 |     | <span class='neutral'>    event Clamped(string);</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    /// @notice Clamps value to be between low and high, both inclusive</span>
  12 | *   | <span class='executed'>    function clampBetween(</span>
  13 |     | <span class='neutral'>        uint256 value,</span>
  14 |     | <span class='neutral'>        uint256 low,</span>
  15 |     | <span class='neutral'>        uint256 high,</span>
  16 |     | <span class='neutral'>        bool enableLogs</span>
  17 | *   | <span class='executed'>    ) internal returns (uint256) {</span>
  18 | *   | <span class='executed'>        if (value &lt; low || value &gt; high) {</span>
  19 | *   | <span class='executed'>            uint256 ans = low + (value % (high - low + 1));</span>
  20 | *   | <span class='executed'>            if (enableLogs) {</span>
  21 | *   | <span class='executed'>                string memory valueStr = FuzzLibString.toString(value);</span>
  22 | *   | <span class='executed'>                string memory ansStr = FuzzLibString.toString(ans);</span>
  23 | *   | <span class='executed'>                bytes memory message = abi.encodePacked(</span>
  24 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
  25 | *   | <span class='executed'>                    valueStr,</span>
  26 |     | <span class='neutral'>                    &quot; to &quot;,</span>
  27 | *   | <span class='executed'>                    ansStr</span>
  28 |     | <span class='neutral'>                );</span>
  29 | *   | <span class='executed'>                emit Clamped(string(message));</span>
  30 |     | <span class='neutral'>            }</span>
  31 | *   | <span class='executed'>            return ans;</span>
  32 |     | <span class='neutral'>        }</span>
  33 | *   | <span class='executed'>        return value;</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /// @notice int256 version of clampBetween</span>
  37 |     | <span class='neutral'>    function clampBetween(</span>
  38 |     | <span class='neutral'>        int256 value,</span>
  39 |     | <span class='neutral'>        int256 low,</span>
  40 |     | <span class='neutral'>        int256 high,</span>
  41 |     | <span class='neutral'>        bool enableLogs</span>
  42 |     | <span class='neutral'>    ) internal returns (int256) {</span>
  43 |     | <span class='neutral'>        if (value &lt; low || value &gt; high) {</span>
  44 |     | <span class='neutral'>            int256 range = high - low + 1;</span>
  45 |     | <span class='neutral'>            int256 clamped = (value - low) % (range);</span>
  46 |     | <span class='neutral'>            if (clamped &lt; 0) clamped += range;</span>
  47 |     | <span class='neutral'>            int256 ans = low + clamped;</span>
  48 |     | <span class='neutral'>            if (enableLogs) {</span>
  49 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
  50 |     | <span class='neutral'>                string memory ansStr = FuzzLibString.toString(ans);</span>
  51 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
  52 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
  53 |     | <span class='neutral'>                    valueStr,</span>
  54 |     | <span class='neutral'>                    &quot; to &quot;,</span>
  55 |     | <span class='neutral'>                    ansStr</span>
  56 |     | <span class='neutral'>                );</span>
  57 |     | <span class='neutral'>                emit Clamped(string(message));</span>
  58 |     | <span class='neutral'>            }</span>
  59 |     | <span class='neutral'>            return ans;</span>
  60 |     | <span class='neutral'>        }</span>
  61 |     | <span class='neutral'>        return value;</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /// @notice clamps a to be less than b</span>
  65 |     | <span class='neutral'>    function clampLt(uint256 a, uint256 b, bool enableLogs) internal returns (uint256) {</span>
  66 |     | <span class='neutral'>        if (!(a &lt; b)) {</span>
  67 |     | <span class='neutral'>            assertNeq(</span>
  68 |     | <span class='neutral'>                b,</span>
  69 |     | <span class='neutral'>                0,</span>
  70 |     | <span class='neutral'>                &quot;clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions.&quot;</span>
  71 |     | <span class='neutral'>            );</span>
  72 |     | <span class='neutral'>            uint256 value = a % b;</span>
  73 |     | <span class='neutral'>            if (enableLogs) {</span>
  74 |     | <span class='neutral'>                string memory aStr = FuzzLibString.toString(a);</span>
  75 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
  76 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
  77 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
  78 |     | <span class='neutral'>                    aStr,</span>
  79 |     | <span class='neutral'>                    &quot; to &quot;,</span>
  80 |     | <span class='neutral'>                    valueStr</span>
  81 |     | <span class='neutral'>                );</span>
  82 |     | <span class='neutral'>                emit Clamped(string(message));</span>
  83 |     | <span class='neutral'>            }</span>
  84 |     | <span class='neutral'>            return value;</span>
  85 |     | <span class='neutral'>        }</span>
  86 |     | <span class='neutral'>        return a;</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /// @notice int256 version of clampLt</span>
  90 |     | <span class='neutral'>    function clampLt(int256 a, int256 b, bool enableLogs) internal returns (int256) {</span>
  91 |     | <span class='neutral'>        if (!(a &lt; b)) {</span>
  92 |     | <span class='neutral'>            int256 value = b - 1;</span>
  93 |     | <span class='neutral'>            if (enableLogs) {</span>
  94 |     | <span class='neutral'>                string memory aStr = FuzzLibString.toString(a);</span>
  95 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
  96 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
  97 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
  98 |     | <span class='neutral'>                    aStr,</span>
  99 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 100 |     | <span class='neutral'>                    valueStr</span>
 101 |     | <span class='neutral'>                );</span>
 102 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 103 |     | <span class='neutral'>            }</span>
 104 |     | <span class='neutral'>            return value;</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'>        return a;</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /// @notice clamps a to be less than or equal to b</span>
 110 |     | <span class='neutral'>    function clampLte(uint256 a, uint256 b, bool enableLogs) internal returns (uint256) {</span>
 111 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 112 |     | <span class='neutral'>            uint256 value = a % (b + 1);</span>
 113 |     | <span class='neutral'>            if (enableLogs) {</span>
 114 |     | <span class='neutral'>                string memory aStr = FuzzLibString.toString(a);</span>
 115 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 116 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 117 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 118 |     | <span class='neutral'>                    aStr,</span>
 119 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 120 |     | <span class='neutral'>                    valueStr</span>
 121 |     | <span class='neutral'>                );</span>
 122 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 123 |     | <span class='neutral'>            }</span>
 124 |     | <span class='neutral'>            return value;</span>
 125 |     | <span class='neutral'>        }</span>
 126 |     | <span class='neutral'>        return a;</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /// @notice int256 version of clampLte</span>
 130 |     | <span class='neutral'>    function clampLte(int256 a, int256 b, bool enableLogs) internal returns (int256) {</span>
 131 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 132 |     | <span class='neutral'>            int256 value = b;</span>
 133 |     | <span class='neutral'>            if (enableLogs) {</span>
 134 |     | <span class='neutral'>                string memory aStr = FuzzLibString.toString(a);</span>
 135 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 136 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 137 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 138 |     | <span class='neutral'>                    aStr,</span>
 139 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 140 |     | <span class='neutral'>                    valueStr</span>
 141 |     | <span class='neutral'>                );</span>
 142 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 143 |     | <span class='neutral'>            }</span>
 144 |     | <span class='neutral'>            return value;</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='neutral'>        return a;</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @notice clamps a to be greater than b</span>
 150 |     | <span class='neutral'>    function clampGt(uint256 a, uint256 b, bool enableLogs) internal returns (uint256) {</span>
 151 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 152 |     | <span class='neutral'>            assertNeq(</span>
 153 |     | <span class='neutral'>                b,</span>
 154 |     | <span class='neutral'>                type(uint256).max,</span>
 155 |     | <span class='neutral'>                &quot;clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions.&quot;</span>
 156 |     | <span class='neutral'>            );</span>
 157 |     | <span class='neutral'>            uint256 value = b + 1;</span>
 158 |     | <span class='neutral'>            if (enableLogs) {</span>
 159 |     | <span class='neutral'>                string memory aStr = FuzzLibString.toString(a);</span>
 160 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 161 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 162 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 163 |     | <span class='neutral'>                    aStr,</span>
 164 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 165 |     | <span class='neutral'>                    valueStr</span>
 166 |     | <span class='neutral'>                );</span>
 167 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 168 |     | <span class='neutral'>            }</span>
 169 |     | <span class='neutral'>            return value;</span>
 170 |     | <span class='neutral'>        } else {</span>
 171 |     | <span class='neutral'>            return a;</span>
 172 |     | <span class='neutral'>        }</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    /// @notice int256 version of clampGt</span>
 176 |     | <span class='neutral'>    function clampGt(int256 a, int256 b, bool enableLogs) internal returns (int256) {</span>
 177 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 178 |     | <span class='neutral'>            int256 value = b + 1;</span>
 179 |     | <span class='neutral'>            if (enableLogs) {</span>
 180 |     | <span class='neutral'>                string memory aStr = FuzzLibString.toString(a);</span>
 181 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 182 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 183 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 184 |     | <span class='neutral'>                    aStr,</span>
 185 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 186 |     | <span class='neutral'>                    valueStr</span>
 187 |     | <span class='neutral'>                );</span>
 188 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 189 |     | <span class='neutral'>            }</span>
 190 |     | <span class='neutral'>            return value;</span>
 191 |     | <span class='neutral'>        } else {</span>
 192 |     | <span class='neutral'>            return a;</span>
 193 |     | <span class='neutral'>        }</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    /// @notice clamps a to be greater than or equal to b</span>
 197 |     | <span class='neutral'>    function clampGte(uint256 a, uint256 b, bool enableLogs) internal returns (uint256) {</span>
 198 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 199 |     | <span class='neutral'>            uint256 value = b;</span>
 200 |     | <span class='neutral'>            if (enableLogs) {</span>
 201 |     | <span class='neutral'>                string memory aStr = FuzzLibString.toString(a);</span>
 202 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 203 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 204 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 205 |     | <span class='neutral'>                    aStr,</span>
 206 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 207 |     | <span class='neutral'>                    valueStr</span>
 208 |     | <span class='neutral'>                );</span>
 209 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 210 |     | <span class='neutral'>            }</span>
 211 |     | <span class='neutral'>            return value;</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>        return a;</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    /// @notice int256 version of clampGte</span>
 217 |     | <span class='neutral'>    function clampGte(int256 a, int256 b, bool enableLogs) internal returns (int256) {</span>
 218 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 219 |     | <span class='neutral'>            int256 value = b;</span>
 220 |     | <span class='neutral'>            if (enableLogs) {</span>
 221 |     | <span class='neutral'>                string memory aStr = FuzzLibString.toString(a);</span>
 222 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 223 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 224 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 225 |     | <span class='neutral'>                    aStr,</span>
 226 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 227 |     | <span class='neutral'>                    valueStr</span>
 228 |     | <span class='neutral'>                );</span>
 229 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 230 |     | <span class='neutral'>            }</span>
 231 |     | <span class='neutral'>            return value;</span>
 232 |     | <span class='neutral'>        }</span>
 233 |     | <span class='neutral'>        return a;</span>
 234 |     | <span class='neutral'>    }</span>
 235 |     | <span class='neutral'>}</span>
 236 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/ClampWrapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./ClampHelper.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>abstract contract ClampWrapper is ClampHelper {</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    /// @notice Clamps value to be between low and high, both inclusive</span>
  9 | *   | <span class='executed'>    function clampBetween(</span>
 10 |     | <span class='neutral'>        uint256 value,</span>
 11 |     | <span class='neutral'>        uint256 low,</span>
 12 |     | <span class='neutral'>        uint256 high</span>
 13 | *   | <span class='executed'>    ) internal returns (uint256) {</span>
 14 | *   | <span class='executed'>        return clampBetween(value, low, high, true);</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /// @notice int256 version of clampBetween</span>
 18 |     | <span class='neutral'>    function clampBetween(</span>
 19 |     | <span class='neutral'>        int256 value,</span>
 20 |     | <span class='neutral'>        int256 low,</span>
 21 |     | <span class='neutral'>        int256 high</span>
 22 |     | <span class='neutral'>    ) internal returns (int256) {</span>
 23 |     | <span class='neutral'>        return clampBetween(value, low, high, true);</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    /// @notice clamps a to be less than b</span>
 27 |     | <span class='neutral'>    function clampLt(uint256 a, uint256 b) internal returns (uint256) {</span>
 28 |     | <span class='neutral'>        return clampLt(a, b);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @notice int256 version of clampLt</span>
 32 |     | <span class='neutral'>    function clampLt(int256 a, int256 b) internal returns (int256) {</span>
 33 |     | <span class='neutral'>        return clampLt(a, b, true);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @notice clamps a to be less than or equal to b</span>
 37 |     | <span class='neutral'>    function clampLte(uint256 a, uint256 b) internal returns (uint256) {</span>
 38 |     | <span class='neutral'>        return clampLte(a, b, true);</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /// @notice int256 version of clampLte</span>
 42 |     | <span class='neutral'>    function clampLte(int256 a, int256 b) internal returns (int256) {</span>
 43 |     | <span class='neutral'>        return clampLte(a, b, true);</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    /// @notice clamps a to be greater than b</span>
 47 |     | <span class='neutral'>    function clampGt(uint256 a, uint256 b) internal returns (uint256) {</span>
 48 |     | <span class='neutral'>        return clampGt(a, b, true);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    /// @notice int256 version of clampGt</span>
 52 |     | <span class='neutral'>    function clampGt(int256 a, int256 b) internal returns (int256) {</span>
 53 |     | <span class='neutral'>        return clampGt(a, b, true);</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    /// @notice clamps a to be greater than or equal to b</span>
 57 |     | <span class='neutral'>    function clampGte(uint256 a, uint256 b) internal returns (uint256) {</span>
 58 |     | <span class='neutral'>        return clampGte(a, b, true);</span>
 59 |     | <span class='neutral'>    }</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='neutral'>    /// @notice int256 version of clampGte</span>
 62 |     | <span class='neutral'>    function clampGte(int256 a, int256 b) internal returns (int256) {</span>
 63 |     | <span class='neutral'>        return clampGte(a, b, true);</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'>}</span>
 66 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/Constants.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract Constants {</span>
  5 |     | <span class='neutral'>    // https://docs.soliditylang.org/en/latest/control-structures.html#panic-via-assert-and-error-via-require</span>
  6 |     | <span class='neutral'>    // 0x00: Used for generic compiler inserted panics.</span>
  7 |     | <span class='neutral'>    // 0x01: If you call assert with an argument that evaluates to false.</span>
  8 |     | <span class='neutral'>    // 0x11: If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.</span>
  9 |     | <span class='neutral'>    // 0x12; If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).</span>
 10 |     | <span class='neutral'>    // 0x21: If you convert a value that is too big or negative into an enum type.</span>
 11 |     | <span class='neutral'>    // 0x22: If you access a storage byte array that is incorrectly encoded.</span>
 12 |     | <span class='neutral'>    // 0x31: If you call .pop() on an empty array.</span>
 13 |     | <span class='neutral'>    // 0x32: If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i &gt;= x.length or i &lt; 0).</span>
 14 |     | <span class='neutral'>    // 0x41: If you allocate too much memory or create an array that is too large.</span>
 15 |     | <span class='neutral'>    // 0x51: If you call a zero-initialized variable of internal function type.</span>
 16 |     | <span class='neutral'>    uint256 internal constant PANIC_GENERAL = 0x00;</span>
 17 |     | <span class='neutral'>    uint256 internal constant PANIC_ASSERT = 0x01;</span>
 18 |     | <span class='neutral'>    uint256 internal constant PANIC_ARITHMETIC = 0x11;</span>
 19 |     | <span class='neutral'>    uint256 internal constant PANIC_DIVISION_BY_ZERO = 0x12;</span>
 20 |     | <span class='neutral'>    uint256 internal constant PANIC_ENUM_OUT_OF_BOUNDS = 0x21;</span>
 21 |     | <span class='neutral'>    uint256 internal constant PANIC_STORAGE_BYTES_ARRAY_ENCODING = 0x22;</span>
 22 |     | <span class='neutral'>    uint256 internal constant PANIC_POP_EMPTY_ARRAY = 0x31;</span>
 23 |     | <span class='neutral'>    uint256 internal constant PANIC_ARRAY_OUT_OF_BOUNDS = 0x32;</span>
 24 |     | <span class='neutral'>    uint256 internal constant PANIC_ALLOC_TOO_MUCH_MEMORY = 0x41;</span>
 25 |     | <span class='neutral'>    uint256 internal constant PANIC_ZERO_INIT_INTERNAL_FUNCTION = 0x51;</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/FuzzBase.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./Logging.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./Constants.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./AssertWrapper.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./ClampWrapper.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;./IHevm.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>abstract contract FuzzBase is AssertWrapper, ClampWrapper, Logging, Constants {</span>
 11 |     | <span class='unexecuted'>    IHevm internal vm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/FuzzLibString.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Efficient library for creating string representations of integers.</span>
   5 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)</span>
   6 |     | <span class='neutral'>/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)</span>
   7 |     | <span class='neutral'>/// @author Modified from Crytic Properties (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)</span>
   8 |     | <span class='unexecuted'>library FuzzLibString {</span>
   9 |     | <span class='neutral'>    bytes16 internal constant HEX_DIGITS = &quot;0123456789abcdef&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    function toString(int256 value) internal pure returns (string memory str) {</span>
  12 |     | <span class='neutral'>        uint256 absValue = value &gt;= 0 ? uint256(value) : uint256(-value);</span>
  13 |     | <span class='neutral'>        str = toString(absValue);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>        if (value &lt; 0) {</span>
  16 |     | <span class='neutral'>            str = string(abi.encodePacked(&quot;-&quot;, str));</span>
  17 |     | <span class='neutral'>        }</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 | *   | <span class='executed'>    function toString(uint256 value) internal pure returns (string memory str) {</span>
  21 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  22 |     | <span class='neutral'>        assembly {</span>
  23 |     | <span class='neutral'>            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes</span>
  24 |     | <span class='neutral'>            // to keep the free memory pointer word aligned. We&#39;ll need 1 word for the length, 1 word for the</span>
  25 |     | <span class='neutral'>            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.</span>
  26 | *   | <span class='executed'>            let newFreeMemoryPointer := add(mload(0x40), 160)</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>            // Update the free memory pointer to avoid overriding our string.</span>
  29 | *   | <span class='executed'>            mstore(0x40, newFreeMemoryPointer)</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>            // Assign str to the end of the zone of newly allocated memory.</span>
  32 | *   | <span class='executed'>            str := sub(newFreeMemoryPointer, 32)</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>            // Clean the last word of memory it may not be overwritten.</span>
  35 | *   | <span class='executed'>            mstore(str, 0)</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>            // Cache the end of the memory to calculate the length later.</span>
  38 | *   | <span class='executed'>            let end := str</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>            // We write the string from rightmost digit to leftmost digit.</span>
  41 |     | <span class='neutral'>            // The following is essentially a do-while loop that also handles the zero case.</span>
  42 |     | <span class='neutral'>            // prettier-ignore</span>
  43 | *   | <span class='executed'>            for { let temp := value } 1 {} {</span>
  44 |     | <span class='neutral'>                // Move the pointer 1 byte to the left.</span>
  45 | *   | <span class='executed'>                str := sub(str, 1)</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>                // Write the character to the pointer.</span>
  48 |     | <span class='neutral'>                // The ASCII index of the &#39;0&#39; character is 48.</span>
  49 | *   | <span class='executed'>                mstore8(str, add(48, mod(temp, 10)))</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>                // Keep dividing temp until zero.</span>
  52 | *   | <span class='executed'>                temp := div(temp, 10)</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>                 // prettier-ignore</span>
  55 | *   | <span class='executed'>                if iszero(temp) { break }</span>
  56 |     | <span class='neutral'>            }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>            // Compute and cache the final total length of the string.</span>
  59 | *   | <span class='executed'>            let length := sub(end, str)</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>            // Move the pointer 32 bytes leftwards to make room for the length.</span>
  62 | *   | <span class='executed'>            str := sub(str, 32)</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>            // Store the string&#39;s length at the start of memory allocated for our string.</span>
  65 | *   | <span class='executed'>            mstore(str, length)</span>
  66 |     | <span class='neutral'>        }</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    function toString(address value) internal pure returns (string memory str) {</span>
  70 |     | <span class='neutral'>        bytes memory s = new bytes(40);</span>
  71 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; 20; i++) {</span>
  72 |     | <span class='neutral'>            bytes1 b = bytes1(</span>
  73 |     | <span class='neutral'>                uint8(uint256(uint160(value)) / (2**(8 * (19 - i))))</span>
  74 |     | <span class='neutral'>            );</span>
  75 |     | <span class='neutral'>            bytes1 hi = bytes1(uint8(b) / 16);</span>
  76 |     | <span class='neutral'>            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));</span>
  77 |     | <span class='neutral'>            s[2 * i] = char(hi);</span>
  78 |     | <span class='neutral'>            s[2 * i + 1] = char(lo);</span>
  79 |     | <span class='neutral'>        }</span>
  80 |     | <span class='neutral'>        return string(s);</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    function char(bytes1 b) internal pure returns (bytes1 c) {</span>
  84 |     | <span class='neutral'>        if (uint8(b) &lt; 10) return bytes1(uint8(b) + 0x30);</span>
  85 |     | <span class='neutral'>        else return bytes1(uint8(b) + 0x57);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    // based on OZ&#39;s toHexString</span>
  89 |     | <span class='neutral'>    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol</span>
  90 |     | <span class='neutral'>    function toHexString(bytes memory value)</span>
  91 |     | <span class='neutral'>        internal</span>
  92 |     | <span class='neutral'>        pure</span>
  93 |     | <span class='neutral'>        returns (string memory)</span>
  94 |     | <span class='neutral'>    {</span>
  95 |     | <span class='neutral'>        bytes memory buffer = new bytes(2 * value.length + 2);</span>
  96 |     | <span class='neutral'>        buffer[0] = &quot;0&quot;;</span>
  97 |     | <span class='neutral'>        buffer[1] = &quot;x&quot;;</span>
  98 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; value.length; i++) {</span>
  99 |     | <span class='neutral'>            uint8 valueByte = uint8(value[i]);</span>
 100 |     | <span class='neutral'>            buffer[2 * i + 2] = HEX_DIGITS[valueByte &gt;&gt; 4];</span>
 101 |     | <span class='neutral'>            buffer[2 * i + 3] = HEX_DIGITS[valueByte &amp; 0xf];</span>
 102 |     | <span class='neutral'>        }</span>
 103 |     | <span class='neutral'>        return string(buffer);</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    // https://ethereum.stackexchange.com/a/83577</span>
 107 |     | <span class='neutral'>    function getRevertMsg(bytes memory returnData)</span>
 108 |     | <span class='neutral'>        internal</span>
 109 |     | <span class='neutral'>        pure</span>
 110 |     | <span class='neutral'>        returns (string memory)</span>
 111 |     | <span class='neutral'>    {</span>
 112 |     | <span class='neutral'>        // Check that the data has the right size: 4 bytes for signature + 32 bytes for panic code</span>
 113 |     | <span class='neutral'>        if (returnData.length == 4 + 32) {</span>
 114 |     | <span class='neutral'>            // Check that the data starts with the Panic signature</span>
 115 |     | <span class='neutral'>            bytes4 panicSignature = bytes4(keccak256(bytes(&quot;Panic(uint256)&quot;)));</span>
 116 |     | <span class='neutral'>            for (uint256 i = 0; i &lt; 4; i++) {</span>
 117 |     | <span class='neutral'>                if (returnData[i] != panicSignature[i])</span>
 118 |     | <span class='neutral'>                    return &quot;Undefined signature&quot;;</span>
 119 |     | <span class='neutral'>            }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>            uint256 panicCode;</span>
 122 |     | <span class='neutral'>            for (uint256 i = 4; i &lt; 36; i++) {</span>
 123 |     | <span class='neutral'>                panicCode = panicCode &lt;&lt; 8;</span>
 124 |     | <span class='neutral'>                panicCode |= uint8(returnData[i]);</span>
 125 |     | <span class='neutral'>            }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>            // Now convert the panic code into its string representation</span>
 128 |     | <span class='neutral'>            if (panicCode == 17) {</span>
 129 |     | <span class='neutral'>                return &quot;Panic(17)&quot;;</span>
 130 |     | <span class='neutral'>            }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>            // Add other panic codes as needed or return a generic &quot;Unknown panic&quot;</span>
 133 |     | <span class='neutral'>            return &quot;Undefined panic code&quot;;</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>        // If the returnData length is less than 68, then the transaction failed silently (without a revert message)</span>
 137 |     | <span class='neutral'>        if (returnData.length &lt; 68) return &quot;Transaction reverted silently&quot;;</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>        assembly {</span>
 140 |     | <span class='neutral'>            // Slice the sighash.</span>
 141 |     | <span class='neutral'>            returnData := add(returnData, 0x04)</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='neutral'>        return abi.decode(returnData, (string)); // All that remains is the revert string</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    function isRevertReasonEqual(bytes memory returnData, string memory reason)</span>
 147 |     | <span class='neutral'>        internal</span>
 148 |     | <span class='neutral'>        pure</span>
 149 |     | <span class='neutral'>        returns (bool)</span>
 150 |     | <span class='neutral'>    {</span>
 151 |     | <span class='neutral'>        return (keccak256(abi.encodePacked(getRevertMsg(returnData))) ==</span>
 152 |     | <span class='neutral'>            keccak256(abi.encodePacked(reason)));</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'>}</span>
 155 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/IHevm.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// https://github.com/ethereum/hevm/blob/main/doc/src/controlling-the-unit-testing-environment.md#cheat-codes</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IHevm {</span>
  7 |     | <span class='neutral'>    function warp(uint256 x) external;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function roll(uint256 x) external;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function store(</span>
 12 |     | <span class='neutral'>        address c,</span>
 13 |     | <span class='neutral'>        bytes32 loc,</span>
 14 |     | <span class='neutral'>        bytes32 val</span>
 15 |     | <span class='neutral'>    ) external;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function load(address c, bytes32 loc) external returns (bytes32 val);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function sign(uint256 sk, bytes32 digest)</span>
 20 |     | <span class='neutral'>        external</span>
 21 |     | <span class='neutral'>        returns (</span>
 22 |     | <span class='neutral'>            uint8 v,</span>
 23 |     | <span class='neutral'>            bytes32 r,</span>
 24 |     | <span class='neutral'>            bytes32 s</span>
 25 |     | <span class='neutral'>        );</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function addr(uint256 sk) external returns (address addr);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function ffi(string[] calldata) external returns (bytes memory);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function prank(address sender) external;</span>
 32 |     | <span class='neutral'>}</span>
 33 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/Logging.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>abstract contract Logging {</span>
   5 |     | <span class='neutral'>    event Log(string debugString);</span>
   6 |     | <span class='neutral'>    event LogString(string description, string data);</span>
   7 |     | <span class='neutral'>    event LogString(string prefix, string description, string data);</span>
   8 |     | <span class='neutral'>    event LogBytes(string description, bytes data);</span>
   9 |     | <span class='neutral'>    event LogBytes(string prefix, string description, bytes data);</span>
  10 |     | <span class='neutral'>    event LogUint(string description, uint256 data);</span>
  11 |     | <span class='neutral'>    event LogUint(string prefix, string description, uint256 data);</span>
  12 |     | <span class='neutral'>    event LogInt(string description, int256 data);</span>
  13 |     | <span class='neutral'>    event LogInt(string prefix, string description, int256 data);</span>
  14 |     | <span class='neutral'>    event LogAddress(string description, address data);</span>
  15 |     | <span class='neutral'>    event LogAddress(string prefix, string description, address data);</span>
  16 |     | <span class='neutral'>    event LogBool(string description, bool data);</span>
  17 |     | <span class='neutral'>    event LogBool(string prefix, string description, bool data);</span>
  18 |     | <span class='neutral'>    </span>
  19 |     | <span class='neutral'>    event AssertionFailed();</span>
  20 |     | <span class='neutral'>    event AssertionFailed(string description);</span>
  21 |     | <span class='neutral'>    event AssertionFailed(string description, string data);</span>
  22 |     | <span class='neutral'>    event AssertionFailed(string prefix, string description, string data);</span>
  23 |     | <span class='neutral'>    event AssertionFailed(string description, bytes data);</span>
  24 |     | <span class='neutral'>    event AssertionFailed(string prefix, string description, bytes data);</span>
  25 |     | <span class='neutral'>    event AssertionFailed(string description, uint256 data);</span>
  26 |     | <span class='neutral'>    event AssertionFailed(string prefix, string description, uint256 data);</span>
  27 |     | <span class='neutral'>    event AssertionFailed(string description, int256 data);</span>
  28 |     | <span class='neutral'>    event AssertionFailed(string prefix, string description, int256 data);</span>
  29 |     | <span class='neutral'>    event AssertionFailed(string description, address data);</span>
  30 |     | <span class='neutral'>    event AssertionFailed(string prefix, string description, address data);</span>
  31 |     | <span class='neutral'>    event AssertionFailed(string description, bool data);</span>
  32 |     | <span class='neutral'>    event AssertionFailed(string prefix, string description, bool data);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    function log(string memory debugString) internal {</span>
  35 |     | <span class='neutral'>        emit Log(debugString);</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    function log(string memory description, string memory data) internal {</span>
  39 |     | <span class='neutral'>        emit LogString(description, data);</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    function log(</span>
  43 |     | <span class='neutral'>        string memory prefix,</span>
  44 |     | <span class='neutral'>        string memory description,</span>
  45 |     | <span class='neutral'>        string memory data</span>
  46 |     | <span class='neutral'>    ) internal {</span>
  47 |     | <span class='neutral'>        emit LogString(prefix, description, data);</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    function log(string memory description, bytes memory data) internal {</span>
  51 |     | <span class='neutral'>        emit LogBytes(description, data);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    function log(</span>
  55 |     | <span class='neutral'>        string memory prefix,</span>
  56 |     | <span class='neutral'>        string memory description,</span>
  57 |     | <span class='neutral'>        bytes memory data</span>
  58 |     | <span class='neutral'>    ) internal {</span>
  59 |     | <span class='neutral'>        emit LogBytes(prefix, description, data);</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    function log(string memory description, uint256 data) internal {</span>
  63 |     | <span class='neutral'>        emit LogUint(description, data);</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    function log(</span>
  67 |     | <span class='neutral'>        string memory prefix,</span>
  68 |     | <span class='neutral'>        string memory description,</span>
  69 |     | <span class='neutral'>        uint256 data</span>
  70 |     | <span class='neutral'>    ) internal {</span>
  71 |     | <span class='neutral'>        emit LogUint(prefix, description, data);</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    function log(string memory description, int256 data) internal {</span>
  75 |     | <span class='neutral'>        emit LogInt(description, data);</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function log(</span>
  79 |     | <span class='neutral'>        string memory prefix,</span>
  80 |     | <span class='neutral'>        string memory description,</span>
  81 |     | <span class='neutral'>        int256 data</span>
  82 |     | <span class='neutral'>    ) internal {</span>
  83 |     | <span class='neutral'>        emit LogInt(prefix, description, data);</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>    function log(string memory description, address data) internal {</span>
  87 |     | <span class='unexecuted'>        emit LogAddress(description, data);</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    function log(</span>
  91 |     | <span class='neutral'>        string memory prefix,</span>
  92 |     | <span class='neutral'>        string memory description,</span>
  93 |     | <span class='neutral'>        address data</span>
  94 |     | <span class='neutral'>    ) internal {</span>
  95 |     | <span class='neutral'>        emit LogAddress(prefix, description, data);</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    function log(string memory description, bool data) internal {</span>
  99 |     | <span class='neutral'>        emit LogBool(description, data);</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    function log(</span>
 103 |     | <span class='neutral'>        string memory prefix,</span>
 104 |     | <span class='neutral'>        string memory description,</span>
 105 |     | <span class='neutral'>        bool data</span>
 106 |     | <span class='neutral'>    ) internal {</span>
 107 |     | <span class='neutral'>        emit LogBool(prefix, description, data);</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    function logFail() internal {</span>
 111 |     | <span class='neutral'>        emit AssertionFailed();</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function logFail(string memory debugString) internal {</span>
 115 |     | <span class='neutral'>        emit AssertionFailed(debugString);</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function logFail(string memory description, string memory data) internal {</span>
 119 |     | <span class='neutral'>        emit AssertionFailed(description, data);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    function logFail(</span>
 123 |     | <span class='neutral'>        string memory prefix,</span>
 124 |     | <span class='neutral'>        string memory description,</span>
 125 |     | <span class='neutral'>        string memory data</span>
 126 |     | <span class='neutral'>    ) internal {</span>
 127 |     | <span class='neutral'>        emit AssertionFailed(prefix, description, data);</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    function logFail(string memory description, bytes memory data) internal {</span>
 131 |     | <span class='neutral'>        emit AssertionFailed(description, data);</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    function logFail(</span>
 135 |     | <span class='neutral'>        string memory prefix,</span>
 136 |     | <span class='neutral'>        string memory description,</span>
 137 |     | <span class='neutral'>        bytes memory data</span>
 138 |     | <span class='neutral'>    ) internal {</span>
 139 |     | <span class='neutral'>        emit AssertionFailed(prefix, description, data);</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    function logFail(string memory description, uint256 data) internal {</span>
 143 |     | <span class='neutral'>        emit AssertionFailed(description, data);</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    function logFail(</span>
 147 |     | <span class='neutral'>        string memory prefix,</span>
 148 |     | <span class='neutral'>        string memory description,</span>
 149 |     | <span class='neutral'>        uint256 data</span>
 150 |     | <span class='neutral'>    ) internal {</span>
 151 |     | <span class='neutral'>        emit AssertionFailed(prefix, description, data);</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    function logFail(string memory description, int256 data) internal {</span>
 155 |     | <span class='neutral'>        emit AssertionFailed(description, data);</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function logFail(</span>
 159 |     | <span class='neutral'>        string memory prefix,</span>
 160 |     | <span class='neutral'>        string memory description,</span>
 161 |     | <span class='neutral'>        int256 data</span>
 162 |     | <span class='neutral'>    ) internal {</span>
 163 |     | <span class='neutral'>        emit AssertionFailed(prefix, description, data);</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    function logFail(string memory description, address data) internal {</span>
 167 |     | <span class='neutral'>        emit AssertionFailed(description, data);</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    function logFail(</span>
 171 |     | <span class='neutral'>        string memory prefix,</span>
 172 |     | <span class='neutral'>        string memory description,</span>
 173 |     | <span class='neutral'>        address data</span>
 174 |     | <span class='neutral'>    ) internal {</span>
 175 |     | <span class='neutral'>        emit AssertionFailed(prefix, description, data);</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>    function logFail(string memory description, bool data) internal {</span>
 179 |     | <span class='neutral'>        emit AssertionFailed(description, data);</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    function logFail(</span>
 183 |     | <span class='neutral'>        string memory prefix,</span>
 184 |     | <span class='neutral'>        string memory description,</span>
 185 |     | <span class='neutral'>        bool data</span>
 186 |     | <span class='neutral'>    ) internal {</span>
 187 |     | <span class='neutral'>        emit AssertionFailed(prefix, description, data);</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'>}</span>
 190 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 5 |     | <span class='neutral'></span>
 6 |     | <span class='neutral'>import &quot;../token/ERC20/IERC20.sol&quot;;</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/interfaces/IERC20Metadata.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 5 |     | <span class='neutral'></span>
 6 |     | <span class='neutral'>import &quot;../token/ERC20/extensions/IERC20Metadata.sol&quot;;</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/proxy/Proxy.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM</span>
  8 |     | <span class='neutral'> * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to</span>
  9 |     | <span class='neutral'> * be specified by overriding the virtual {_implementation} function.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a</span>
 12 |     | <span class='neutral'> * different contract through the {_delegate} function.</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * The success and return data of the delegated call will be returned back to the caller of the proxy.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Proxy {</span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Delegates the current call to `implementation`.</span>
 19 |     | <span class='neutral'>     *</span>
 20 |     | <span class='neutral'>     * This function does not return to its internal call site, it will return directly to the external caller.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='unexecuted'>    function _delegate(address implementation) internal virtual {</span>
 23 |     | <span class='neutral'>        assembly {</span>
 24 |     | <span class='neutral'>            // Copy msg.data. We take full control of memory in this inline assembly</span>
 25 |     | <span class='neutral'>            // block because it will not return to Solidity code. We overwrite the</span>
 26 |     | <span class='neutral'>            // Solidity scratch pad at memory position 0.</span>
 27 |     | <span class='unexecuted'>            calldatacopy(0, 0, calldatasize())</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>            // Call the implementation.</span>
 30 |     | <span class='neutral'>            // out and outsize are 0 because we don&#39;t know the size yet.</span>
 31 |     | <span class='unexecuted'>            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>            // Copy the returned data.</span>
 34 |     | <span class='unexecuted'>            returndatacopy(0, 0, returndatasize())</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>            switch result</span>
 37 |     | <span class='neutral'>            // delegatecall returns 0 on error.</span>
 38 |     | <span class='unexecuted'>            case 0 {</span>
 39 |     | <span class='unexecuted'>                revert(0, returndatasize())</span>
 40 |     | <span class='neutral'>            }</span>
 41 |     | <span class='neutral'>            default {</span>
 42 |     | <span class='unexecuted'>                return(0, returndatasize())</span>
 43 |     | <span class='neutral'>            }</span>
 44 |     | <span class='neutral'>        }</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /**</span>
 48 |     | <span class='neutral'>     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function</span>
 49 |     | <span class='neutral'>     * and {_fallback} should delegate.</span>
 50 |     | <span class='neutral'>     */</span>
 51 |     | <span class='neutral'>    function _implementation() internal view virtual returns (address);</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    /**</span>
 54 |     | <span class='neutral'>     * @dev Delegates the current call to the address returned by `_implementation()`.</span>
 55 |     | <span class='neutral'>     *</span>
 56 |     | <span class='neutral'>     * This function does not return to its internal call site, it will return directly to the external caller.</span>
 57 |     | <span class='neutral'>     */</span>
 58 |     | <span class='unexecuted'>    function _fallback() internal virtual {</span>
 59 |     | <span class='neutral'>        _beforeFallback();</span>
 60 |     | <span class='unexecuted'>        _delegate(_implementation());</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='neutral'>    /**</span>
 64 |     | <span class='neutral'>     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other</span>
 65 |     | <span class='neutral'>     * function in the contract matches the call data.</span>
 66 |     | <span class='neutral'>     */</span>
 67 |     | <span class='neutral'>    fallback() external payable virtual {</span>
 68 |     | <span class='unexecuted'>        _fallback();</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='neutral'>    /**</span>
 72 |     | <span class='neutral'>     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data</span>
 73 |     | <span class='neutral'>     * is empty.</span>
 74 |     | <span class='neutral'>     */</span>
 75 |     | <span class='neutral'>    receive() external payable virtual {</span>
 76 |     | <span class='unexecuted'>        _fallback();</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='neutral'>    /**</span>
 80 |     | <span class='neutral'>     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`</span>
 81 |     | <span class='neutral'>     * call, or as part of the Solidity `fallback` or `receive` functions.</span>
 82 |     | <span class='neutral'>     *</span>
 83 |     | <span class='neutral'>     * If overridden should call `super._beforeFallback()`.</span>
 84 |     | <span class='neutral'>     */</span>
 85 |     | <span class='neutral'>    function _beforeFallback() internal virtual {}</span>
 86 |     | <span class='neutral'>}</span>
 87 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/security/Pausable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../utils/Context.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Contract module which allows children to implement an emergency stop</span>
  10 |     | <span class='neutral'> * mechanism that can be triggered by an authorized account.</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='neutral'> * This module is used through inheritance. It will make available the</span>
  13 |     | <span class='neutral'> * modifiers `whenNotPaused` and `whenPaused`, which can be applied to</span>
  14 |     | <span class='neutral'> * the functions of your contract. Note that they will not be pausable by</span>
  15 |     | <span class='neutral'> * simply including this module, only once the modifiers are put in place.</span>
  16 |     | <span class='neutral'> */</span>
  17 |     | <span class='neutral'>abstract contract Pausable is Context {</span>
  18 |     | <span class='neutral'>    /**</span>
  19 |     | <span class='neutral'>     * @dev Emitted when the pause is triggered by `account`.</span>
  20 |     | <span class='neutral'>     */</span>
  21 |     | <span class='neutral'>    event Paused(address account);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /**</span>
  24 |     | <span class='neutral'>     * @dev Emitted when the pause is lifted by `account`.</span>
  25 |     | <span class='neutral'>     */</span>
  26 |     | <span class='neutral'>    event Unpaused(address account);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    bool private _paused;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Initializes the contract in unpaused state.</span>
  32 |     | <span class='neutral'>     */</span>
  33 |     | <span class='neutral'>    constructor() {</span>
  34 |     | <span class='unexecuted'>        _paused = false;</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    /**</span>
  38 |     | <span class='neutral'>     * @dev Modifier to make a function callable only when the contract is not paused.</span>
  39 |     | <span class='neutral'>     *</span>
  40 |     | <span class='neutral'>     * Requirements:</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='neutral'>     * - The contract must not be paused.</span>
  43 |     | <span class='neutral'>     */</span>
  44 |     | <span class='neutral'>    modifier whenNotPaused() {</span>
  45 |     | <span class='unexecuted'>        _requireNotPaused();</span>
  46 |     | <span class='unexecuted'>        _;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /**</span>
  50 |     | <span class='neutral'>     * @dev Modifier to make a function callable only when the contract is paused.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * Requirements:</span>
  53 |     | <span class='neutral'>     *</span>
  54 |     | <span class='neutral'>     * - The contract must be paused.</span>
  55 |     | <span class='neutral'>     */</span>
  56 |     | <span class='neutral'>    modifier whenPaused() {</span>
  57 |     | <span class='unexecuted'>        _requirePaused();</span>
  58 |     | <span class='neutral'>        _;</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /**</span>
  62 |     | <span class='neutral'>     * @dev Returns true if the contract is paused, and false otherwise.</span>
  63 |     | <span class='neutral'>     */</span>
  64 |     | <span class='unexecuted'>    function paused() public view virtual returns (bool) {</span>
  65 |     | <span class='unexecuted'>        return _paused;</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /**</span>
  69 |     | <span class='neutral'>     * @dev Throws if the contract is paused.</span>
  70 |     | <span class='neutral'>     */</span>
  71 |     | <span class='unexecuted'>    function _requireNotPaused() internal view virtual {</span>
  72 |     | <span class='unexecuted'>        require(!paused(), &quot;Pausable: paused&quot;);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /**</span>
  76 |     | <span class='neutral'>     * @dev Throws if the contract is not paused.</span>
  77 |     | <span class='neutral'>     */</span>
  78 |     | <span class='unexecuted'>    function _requirePaused() internal view virtual {</span>
  79 |     | <span class='unexecuted'>        require(paused(), &quot;Pausable: not paused&quot;);</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    /**</span>
  83 |     | <span class='neutral'>     * @dev Triggers stopped state.</span>
  84 |     | <span class='neutral'>     *</span>
  85 |     | <span class='neutral'>     * Requirements:</span>
  86 |     | <span class='neutral'>     *</span>
  87 |     | <span class='neutral'>     * - The contract must not be paused.</span>
  88 |     | <span class='neutral'>     */</span>
  89 |     | <span class='unexecuted'>    function _pause() internal virtual whenNotPaused {</span>
  90 |     | <span class='unexecuted'>        _paused = true;</span>
  91 |     | <span class='unexecuted'>        emit Paused(_msgSender());</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /**</span>
  95 |     | <span class='neutral'>     * @dev Returns to normal state.</span>
  96 |     | <span class='neutral'>     *</span>
  97 |     | <span class='neutral'>     * Requirements:</span>
  98 |     | <span class='neutral'>     *</span>
  99 |     | <span class='neutral'>     * - The contract must be paused.</span>
 100 |     | <span class='neutral'>     */</span>
 101 |     | <span class='unexecuted'>    function _unpause() internal virtual whenPaused {</span>
 102 |     | <span class='unexecuted'>        _paused = false;</span>
 103 |     | <span class='unexecuted'>        emit Unpaused(_msgSender());</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'>}</span>
 106 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Contract module that helps prevent reentrant calls to a function.</span>
  8 |     | <span class='neutral'> *</span>
  9 |     | <span class='neutral'> * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier</span>
 10 |     | <span class='neutral'> * available, which can be applied to functions to make sure there are no nested</span>
 11 |     | <span class='neutral'> * (reentrant) calls to them.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * Note that because there is a single `nonReentrant` guard, functions marked as</span>
 14 |     | <span class='neutral'> * `nonReentrant` may not call one another. This can be worked around by making</span>
 15 |     | <span class='neutral'> * those functions `private`, and then adding `external` `nonReentrant` entry</span>
 16 |     | <span class='neutral'> * points to them.</span>
 17 |     | <span class='neutral'> *</span>
 18 |     | <span class='neutral'> * TIP: If you would like to learn more about reentrancy and alternative ways</span>
 19 |     | <span class='neutral'> * to protect against it, check out our blog post</span>
 20 |     | <span class='neutral'> * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].</span>
 21 |     | <span class='neutral'> */</span>
 22 |     | <span class='neutral'>abstract contract ReentrancyGuard {</span>
 23 |     | <span class='neutral'>    // Booleans are more expensive than uint256 or any type that takes up a full</span>
 24 |     | <span class='neutral'>    // word because each write operation emits an extra SLOAD to first read the</span>
 25 |     | <span class='neutral'>    // slot&#39;s contents, replace the bits taken up by the boolean, and then write</span>
 26 |     | <span class='neutral'>    // back. This is the compiler&#39;s defense against contract upgrades and</span>
 27 |     | <span class='neutral'>    // pointer aliasing, and it cannot be disabled.</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    // The values being non-zero value makes deployment a bit more expensive,</span>
 30 |     | <span class='neutral'>    // but in exchange the refund on every call to nonReentrant will be lower in</span>
 31 |     | <span class='neutral'>    // amount. Since refunds are capped to a percentage of the total</span>
 32 |     | <span class='neutral'>    // transaction&#39;s gas, it is best to keep them low in cases like this one, to</span>
 33 |     | <span class='neutral'>    // increase the likelihood of the full refund coming into effect.</span>
 34 |     | <span class='unexecuted'>    uint256 private constant _NOT_ENTERED = 1;</span>
 35 |     | <span class='unexecuted'>    uint256 private constant _ENTERED = 2;</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    uint256 private _status;</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    constructor() {</span>
 40 |     | <span class='unexecuted'>        _status = _NOT_ENTERED;</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Prevents a contract from calling itself, directly or indirectly.</span>
 45 |     | <span class='neutral'>     * Calling a `nonReentrant` function from another `nonReentrant`</span>
 46 |     | <span class='neutral'>     * function is not supported. It is possible to prevent this from happening</span>
 47 |     | <span class='neutral'>     * by making the `nonReentrant` function external, and making it call a</span>
 48 |     | <span class='neutral'>     * `private` function that does the actual work.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    modifier nonReentrant() {</span>
 51 |     | <span class='unexecuted'>        _nonReentrantBefore();</span>
 52 |     | <span class='neutral'>        _;</span>
 53 |     | <span class='unexecuted'>        _nonReentrantAfter();</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='unexecuted'>    function _nonReentrantBefore() private {</span>
 57 |     | <span class='neutral'>        // On the first call to nonReentrant, _status will be _NOT_ENTERED</span>
 58 |     | <span class='unexecuted'>        require(_status != _ENTERED, &quot;ReentrancyGuard: reentrant call&quot;);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>        // Any calls to nonReentrant after this point will fail</span>
 61 |     | <span class='unexecuted'>        _status = _ENTERED;</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='unexecuted'>    function _nonReentrantAfter() private {</span>
 65 |     | <span class='neutral'>        // By storing the original value once again, a refund is triggered (see</span>
 66 |     | <span class='neutral'>        // https://eips.ethereum.org/EIPS/eip-2200)</span>
 67 |     | <span class='unexecuted'>        _status = _NOT_ENTERED;</span>
 68 |     | <span class='neutral'>    }</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>    /**</span>
 71 |     | <span class='neutral'>     * @dev Returns true if the reentrancy guard is currently set to &quot;entered&quot;, which indicates there is a</span>
 72 |     | <span class='neutral'>     * `nonReentrant` function in the call stack.</span>
 73 |     | <span class='neutral'>     */</span>
 74 |     | <span class='neutral'>    function _reentrancyGuardEntered() internal view returns (bool) {</span>
 75 |     | <span class='neutral'>        return _status == _ENTERED;</span>
 76 |     | <span class='neutral'>    }</span>
 77 |     | <span class='neutral'>}</span>
 78 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../utils/Context.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * This implementation is agnostic to the way tokens are created. This means</span>
  14 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  15 |     | <span class='neutral'> * For a generic mechanism see {ERC20PresetMinterPauser}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * TIP: For a detailed writeup see our guide</span>
  18 |     | <span class='neutral'> * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  19 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * The default value of {decimals} is 18. To change this, you should override</span>
  22 |     | <span class='neutral'> * this function so it returns a different value.</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  25 |     | <span class='neutral'> * instead returning `false` on failure. This behavior is nonetheless</span>
  26 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC20</span>
  27 |     | <span class='neutral'> * applications.</span>
  28 |     | <span class='neutral'> *</span>
  29 |     | <span class='neutral'> * Additionally, an {Approval} event is emitted on calls to {transferFrom}.</span>
  30 |     | <span class='neutral'> * This allows applications to reconstruct the allowance for all accounts just</span>
  31 |     | <span class='neutral'> * by listening to said events. Other implementations of the EIP may not emit</span>
  32 |     | <span class='neutral'> * these events, as it isn&#39;t required by the specification.</span>
  33 |     | <span class='neutral'> *</span>
  34 |     | <span class='neutral'> * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}</span>
  35 |     | <span class='neutral'> * functions have been added to mitigate the well-known issues around setting</span>
  36 |     | <span class='neutral'> * allowances. See {IERC20-approve}.</span>
  37 |     | <span class='neutral'> */</span>
  38 |     | <span class='unexecuted'>contract ERC20 is Context, IERC20, IERC20Metadata {</span>
  39 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    string private _name;</span>
  46 |     | <span class='neutral'>    string private _symbol;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}.</span>
  50 |     | <span class='neutral'>     *</span>
  51 |     | <span class='neutral'>     * All two of these values are immutable: they can only be set once during</span>
  52 |     | <span class='neutral'>     * construction.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_) {</span>
  55 |     | <span class='unexecuted'>        _name = name_;</span>
  56 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
  61 |     | <span class='neutral'>     */</span>
  62 | *   | <span class='executed'>    function name() public view virtual override returns (string memory) {</span>
  63 |     | <span class='unexecuted'>        return _name;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  68 |     | <span class='neutral'>     * name.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='unexecuted'>    function symbol() public view virtual override returns (string memory) {</span>
  71 |     | <span class='unexecuted'>        return _symbol;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  76 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  77 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  80 |     | <span class='neutral'>     * Ether and Wei. This is the default value returned by this function, unless</span>
  81 |     | <span class='neutral'>     * it&#39;s overridden.</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  84 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
  85 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='unexecuted'>    function decimals() public view virtual override returns (uint8) {</span>
  88 |     | <span class='unexecuted'>        return 18;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev See {IERC20-totalSupply}.</span>
  93 |     | <span class='neutral'>     */</span>
  94 | *   | <span class='executed'>    function totalSupply() public view virtual override returns (uint256) {</span>
  95 |     | <span class='unexecuted'>        return _totalSupply;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev See {IERC20-balanceOf}.</span>
 100 |     | <span class='neutral'>     */</span>
 101 | *   | <span class='executed'>    function balanceOf(address account) public view virtual override returns (uint256) {</span>
 102 | *   | <span class='executed'>        return _balances[account];</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /**</span>
 106 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * Requirements:</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 111 |     | <span class='neutral'>     * - the caller must have a balance of at least `amount`.</span>
 112 |     | <span class='neutral'>     */</span>
 113 | *   | <span class='executed'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
 114 |     | <span class='neutral'>        address owner = _msgSender();</span>
 115 | *   | <span class='executed'>        _transfer(owner, to, amount);</span>
 116 |     | <span class='neutral'>        return true;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev See {IERC20-allowance}.</span>
 121 |     | <span class='neutral'>     */</span>
 122 |     | <span class='unexecuted'>    function allowance(address owner, address spender) public view virtual override returns (uint256) {</span>
 123 | *   | <span class='executed'>        return _allowances[owner][spender];</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='neutral'>     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on</span>
 130 |     | <span class='neutral'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * Requirements:</span>
 133 |     | <span class='neutral'>     *</span>
 134 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 135 |     | <span class='neutral'>     */</span>
 136 | *   | <span class='executed'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
 137 |     | <span class='neutral'>        address owner = _msgSender();</span>
 138 | *   | <span class='executed'>        _approve(owner, spender, amount);</span>
 139 | *   | <span class='executed'>        return true;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @dev See {IERC20-transferFrom}.</span>
 144 |     | <span class='neutral'>     *</span>
 145 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance. This is not</span>
 146 |     | <span class='neutral'>     * required by the EIP. See the note at the beginning of {ERC20}.</span>
 147 |     | <span class='neutral'>     *</span>
 148 |     | <span class='neutral'>     * NOTE: Does not update the allowance if the current allowance</span>
 149 |     | <span class='neutral'>     * is the maximum `uint256`.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * Requirements:</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * - `from` and `to` cannot be the zero address.</span>
 154 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 155 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 156 |     | <span class='neutral'>     * `amount`.</span>
 157 |     | <span class='neutral'>     */</span>
 158 | *   | <span class='executed'>    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {</span>
 159 |     | <span class='neutral'>        address spender = _msgSender();</span>
 160 | *   | <span class='executed'>        _spendAllowance(from, spender, amount);</span>
 161 | *   | <span class='executed'>        _transfer(from, to, amount);</span>
 162 | *   | <span class='executed'>        return true;</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    /**</span>
 166 |     | <span class='neutral'>     * @dev Atomically increases the allowance granted to `spender` by the caller.</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 169 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 170 |     | <span class='neutral'>     *</span>
 171 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 172 |     | <span class='neutral'>     *</span>
 173 |     | <span class='neutral'>     * Requirements:</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 176 |     | <span class='neutral'>     */</span>
 177 |     | <span class='unexecuted'>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {</span>
 178 |     | <span class='neutral'>        address owner = _msgSender();</span>
 179 |     | <span class='unexecuted'>        _approve(owner, spender, allowance(owner, spender) + addedValue);</span>
 180 |     | <span class='neutral'>        return true;</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    /**</span>
 184 |     | <span class='neutral'>     * @dev Atomically decreases the allowance granted to `spender` by the caller.</span>
 185 |     | <span class='neutral'>     *</span>
 186 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 187 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 188 |     | <span class='neutral'>     *</span>
 189 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 190 |     | <span class='neutral'>     *</span>
 191 |     | <span class='neutral'>     * Requirements:</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 194 |     | <span class='neutral'>     * - `spender` must have allowance for the caller of at least</span>
 195 |     | <span class='neutral'>     * `subtractedValue`.</span>
 196 |     | <span class='neutral'>     */</span>
 197 |     | <span class='unexecuted'>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {</span>
 198 |     | <span class='neutral'>        address owner = _msgSender();</span>
 199 |     | <span class='neutral'>        uint256 currentAllowance = allowance(owner, spender);</span>
 200 | *   | <span class='executed'>        require(currentAllowance &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);</span>
 201 |     | <span class='neutral'>        unchecked {</span>
 202 |     | <span class='unexecuted'>            _approve(owner, spender, currentAllowance - subtractedValue);</span>
 203 |     | <span class='neutral'>        }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>        return true;</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    /**</span>
 209 |     | <span class='neutral'>     * @dev Moves `amount` of tokens from `from` to `to`.</span>
 210 |     | <span class='neutral'>     *</span>
 211 |     | <span class='neutral'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 212 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 213 |     | <span class='neutral'>     *</span>
 214 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 215 |     | <span class='neutral'>     *</span>
 216 |     | <span class='neutral'>     * Requirements:</span>
 217 |     | <span class='neutral'>     *</span>
 218 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 219 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 220 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 221 |     | <span class='neutral'>     */</span>
 222 | *   | <span class='executed'>    function _transfer(address from, address to, uint256 amount) internal virtual {</span>
 223 | *   | <span class='executed'>        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span>
 224 | *   | <span class='executed'>        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>        _beforeTokenTransfer(from, to, amount);</span>
 227 |     | <span class='neutral'></span>
 228 | *   | <span class='executed'>        uint256 fromBalance = _balances[from];</span>
 229 | *   | <span class='executed'>        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 230 |     | <span class='neutral'>        unchecked {</span>
 231 | *   | <span class='executed'>            _balances[from] = fromBalance - amount;</span>
 232 |     | <span class='neutral'>            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by</span>
 233 |     | <span class='neutral'>            // decrementing then incrementing.</span>
 234 | *   | <span class='executed'>            _balances[to] += amount;</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'></span>
 237 | *   | <span class='executed'>        emit Transfer(from, to, amount);</span>
 238 |     | <span class='neutral'></span>
 239 | *   | <span class='executed'>        _afterTokenTransfer(from, to, amount);</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    /** @dev Creates `amount` tokens and assigns them to `account`, increasing</span>
 243 |     | <span class='neutral'>     * the total supply.</span>
 244 |     | <span class='neutral'>     *</span>
 245 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 246 |     | <span class='neutral'>     *</span>
 247 |     | <span class='neutral'>     * Requirements:</span>
 248 |     | <span class='neutral'>     *</span>
 249 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 250 |     | <span class='neutral'>     */</span>
 251 | *   | <span class='executed'>    function _mint(address account, uint256 amount) internal virtual {</span>
 252 | *   | <span class='executed'>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>        _beforeTokenTransfer(address(0), account, amount);</span>
 255 |     | <span class='neutral'></span>
 256 | *   | <span class='executed'>        _totalSupply += amount;</span>
 257 |     | <span class='neutral'>        unchecked {</span>
 258 |     | <span class='neutral'>            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.</span>
 259 | *   | <span class='executed'>            _balances[account] += amount;</span>
 260 |     | <span class='neutral'>        }</span>
 261 | *   | <span class='executed'>        emit Transfer(address(0), account, amount);</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>        _afterTokenTransfer(address(0), account, amount);</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    /**</span>
 267 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, reducing the</span>
 268 |     | <span class='neutral'>     * total supply.</span>
 269 |     | <span class='neutral'>     *</span>
 270 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 271 |     | <span class='neutral'>     *</span>
 272 |     | <span class='neutral'>     * Requirements:</span>
 273 |     | <span class='neutral'>     *</span>
 274 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 275 |     | <span class='neutral'>     * - `account` must have at least `amount` tokens.</span>
 276 |     | <span class='neutral'>     */</span>
 277 | *   | <span class='executed'>    function _burn(address account, uint256 amount) internal virtual {</span>
 278 |     | <span class='unexecuted'>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>        _beforeTokenTransfer(account, address(0), amount);</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='unexecuted'>        uint256 accountBalance = _balances[account];</span>
 283 |     | <span class='unexecuted'>        require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 284 |     | <span class='neutral'>        unchecked {</span>
 285 |     | <span class='unexecuted'>            _balances[account] = accountBalance - amount;</span>
 286 |     | <span class='neutral'>            // Overflow not possible: amount &lt;= accountBalance &lt;= totalSupply.</span>
 287 |     | <span class='unexecuted'>            _totalSupply -= amount;</span>
 288 |     | <span class='neutral'>        }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='unexecuted'>        emit Transfer(account, address(0), amount);</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>        _afterTokenTransfer(account, address(0), amount);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    /**</span>
 296 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.</span>
 297 |     | <span class='neutral'>     *</span>
 298 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 299 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 300 |     | <span class='neutral'>     *</span>
 301 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 302 |     | <span class='neutral'>     *</span>
 303 |     | <span class='neutral'>     * Requirements:</span>
 304 |     | <span class='neutral'>     *</span>
 305 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 306 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 307 |     | <span class='neutral'>     */</span>
 308 | *   | <span class='executed'>    function _approve(address owner, address spender, uint256 amount) internal virtual {</span>
 309 | *   | <span class='executed'>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span>
 310 | *   | <span class='executed'>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span>
 311 |     | <span class='neutral'></span>
 312 | *   | <span class='executed'>        _allowances[owner][spender] = amount;</span>
 313 | *   | <span class='executed'>        emit Approval(owner, spender, amount);</span>
 314 |     | <span class='neutral'>    }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>    /**</span>
 317 |     | <span class='neutral'>     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.</span>
 318 |     | <span class='neutral'>     *</span>
 319 |     | <span class='neutral'>     * Does not update the allowance amount in case of infinite allowance.</span>
 320 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 321 |     | <span class='neutral'>     *</span>
 322 |     | <span class='neutral'>     * Might emit an {Approval} event.</span>
 323 |     | <span class='neutral'>     */</span>
 324 | *   | <span class='executed'>    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {</span>
 325 | *   | <span class='executed'>        uint256 currentAllowance = allowance(owner, spender);</span>
 326 | *   | <span class='executed'>        if (currentAllowance != type(uint256).max) {</span>
 327 | *   | <span class='executed'>            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span>
 328 |     | <span class='neutral'>            unchecked {</span>
 329 | *   | <span class='executed'>                _approve(owner, spender, currentAllowance - amount);</span>
 330 |     | <span class='neutral'>            }</span>
 331 |     | <span class='neutral'>        }</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>    /**</span>
 335 |     | <span class='neutral'>     * @dev Hook that is called before any transfer of tokens. This includes</span>
 336 |     | <span class='neutral'>     * minting and burning.</span>
 337 |     | <span class='neutral'>     *</span>
 338 |     | <span class='neutral'>     * Calling conditions:</span>
 339 |     | <span class='neutral'>     *</span>
 340 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 341 |     | <span class='neutral'>     * will be transferred to `to`.</span>
 342 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens will be minted for `to`.</span>
 343 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens will be burned.</span>
 344 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 345 |     | <span class='neutral'>     *</span>
 346 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 347 |     | <span class='neutral'>     */</span>
 348 |     | <span class='unexecuted'>    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>    /**</span>
 351 |     | <span class='neutral'>     * @dev Hook that is called after any transfer of tokens. This includes</span>
 352 |     | <span class='neutral'>     * minting and burning.</span>
 353 |     | <span class='neutral'>     *</span>
 354 |     | <span class='neutral'>     * Calling conditions:</span>
 355 |     | <span class='neutral'>     *</span>
 356 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 357 |     | <span class='neutral'>     * has been transferred to `to`.</span>
 358 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens have been minted for `to`.</span>
 359 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens have been burned.</span>
 360 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 361 |     | <span class='neutral'>     *</span>
 362 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 363 |     | <span class='neutral'>     */</span>
 364 |     | <span class='neutral'>    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 365 |     | <span class='neutral'>}</span>
 366 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 54 |     | <span class='neutral'>     *</span>
 55 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 56 |     | <span class='neutral'>     *</span>
 57 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 58 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 59 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 60 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 61 |     | <span class='neutral'>     * desired value afterwards:</span>
 62 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /**</span>
 69 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `from` to `to` using the</span>
 70 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 71 |     | <span class='neutral'>     * allowance.</span>
 72 |     | <span class='neutral'>     *</span>
 73 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 74 |     | <span class='neutral'>     *</span>
 75 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 76 |     | <span class='neutral'>     */</span>
 77 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Interface for the optional metadata functions from the ERC20 standard.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * _Available since v4.1._</span>
 12 |     | <span class='neutral'> */</span>
 13 |     | <span class='neutral'>interface IERC20Metadata is IERC20 {</span>
 14 |     | <span class='neutral'>    /**</span>
 15 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /**</span>
 20 |     | <span class='neutral'>     * @dev Returns the symbol of the token.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the decimals places of the token.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Adds the {permit} method, which can be used to change an account&#39;s ERC20 allowance (see {IERC20-allowance}) by</span>
 11 |     | <span class='neutral'> * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn&#39;t</span>
 12 |     | <span class='neutral'> * need to send a transaction, and thus is not required to hold Ether at all.</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='neutral'>interface IERC20Permit {</span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @dev Sets `value` as the allowance of `spender` over ``owner``&#39;s tokens,</span>
 17 |     | <span class='neutral'>     * given ``owner``&#39;s signed approval.</span>
 18 |     | <span class='neutral'>     *</span>
 19 |     | <span class='neutral'>     * IMPORTANT: The same issues {IERC20-approve} has related to transaction</span>
 20 |     | <span class='neutral'>     * ordering also apply here.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 23 |     | <span class='neutral'>     *</span>
 24 |     | <span class='neutral'>     * Requirements:</span>
 25 |     | <span class='neutral'>     *</span>
 26 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 27 |     | <span class='neutral'>     * - `deadline` must be a timestamp in the future.</span>
 28 |     | <span class='neutral'>     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`</span>
 29 |     | <span class='neutral'>     * over the EIP712-formatted function arguments.</span>
 30 |     | <span class='neutral'>     * - the signature must use ``owner``&#39;s current nonce (see {nonces}).</span>
 31 |     | <span class='neutral'>     *</span>
 32 |     | <span class='neutral'>     * For more information on the signature format, see the</span>
 33 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP</span>
 34 |     | <span class='neutral'>     * section].</span>
 35 |     | <span class='neutral'>     */</span>
 36 |     | <span class='neutral'>    function permit(</span>
 37 |     | <span class='neutral'>        address owner,</span>
 38 |     | <span class='neutral'>        address spender,</span>
 39 |     | <span class='neutral'>        uint256 value,</span>
 40 |     | <span class='neutral'>        uint256 deadline,</span>
 41 |     | <span class='neutral'>        uint8 v,</span>
 42 |     | <span class='neutral'>        bytes32 r,</span>
 43 |     | <span class='neutral'>        bytes32 s</span>
 44 |     | <span class='neutral'>    ) external;</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    /**</span>
 47 |     | <span class='neutral'>     * @dev Returns the current nonce for `owner`. This value must be</span>
 48 |     | <span class='neutral'>     * included whenever a signature is generated for {permit}.</span>
 49 |     | <span class='neutral'>     *</span>
 50 |     | <span class='neutral'>     * Every successful call to {permit} increases ``owner``&#39;s nonce by one. This</span>
 51 |     | <span class='neutral'>     * prevents a signature from being used multiple times.</span>
 52 |     | <span class='neutral'>     */</span>
 53 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint256);</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    /**</span>
 56 |     | <span class='neutral'>     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.</span>
 57 |     | <span class='neutral'>     */</span>
 58 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 59 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
 60 |     | <span class='neutral'>}</span>
 61 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../extensions/IERC20Permit.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../../utils/Address.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @title SafeERC20</span>
  12 |     | <span class='neutral'> * @dev Wrappers around ERC20 operations that throw on failure (when the token</span>
  13 |     | <span class='neutral'> * contract returns false). Tokens that return no value (and instead revert or</span>
  14 |     | <span class='neutral'> * throw on failure) are also supported, non-reverting calls are assumed to be</span>
  15 |     | <span class='neutral'> * successful.</span>
  16 |     | <span class='neutral'> * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,</span>
  17 |     | <span class='neutral'> * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='unexecuted'>library SafeERC20 {</span>
  20 |     | <span class='neutral'>    using Address for address;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,</span>
  24 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  25 |     | <span class='neutral'>     */</span>
  26 |     | <span class='unexecuted'>    function safeTransfer(IERC20 token, address to, uint256 value) internal {</span>
  27 |     | <span class='unexecuted'>        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the</span>
  32 |     | <span class='neutral'>     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='unexecuted'>    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {</span>
  35 |     | <span class='unexecuted'>        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev Deprecated. This function has issues similar to the ones found in</span>
  40 |     | <span class='neutral'>     * {IERC20-approve}, and its usage is discouraged.</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='neutral'>     * Whenever possible, use {safeIncreaseAllowance} and</span>
  43 |     | <span class='neutral'>     * {safeDecreaseAllowance} instead.</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='unexecuted'>    function safeApprove(IERC20 token, address spender, uint256 value) internal {</span>
  46 |     | <span class='neutral'>        // safeApprove should only be called when setting an initial allowance,</span>
  47 |     | <span class='neutral'>        // or when resetting it to zero. To increase and decrease it, use</span>
  48 |     | <span class='neutral'>        // &#39;safeIncreaseAllowance&#39; and &#39;safeDecreaseAllowance&#39;</span>
  49 |     | <span class='unexecuted'>        require(</span>
  50 |     | <span class='unexecuted'>            (value == 0) || (token.allowance(address(this), spender) == 0),</span>
  51 |     | <span class='neutral'>            &quot;SafeERC20: approve from non-zero to non-zero allowance&quot;</span>
  52 |     | <span class='neutral'>        );</span>
  53 |     | <span class='unexecuted'>        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Increase the calling contract&#39;s allowance toward `spender` by `value`. If `token` returns no value,</span>
  58 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  59 |     | <span class='neutral'>     */</span>
  60 |     | <span class='neutral'>    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {</span>
  61 |     | <span class='neutral'>        uint256 oldAllowance = token.allowance(address(this), spender);</span>
  62 |     | <span class='neutral'>        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /**</span>
  66 |     | <span class='neutral'>     * @dev Decrease the calling contract&#39;s allowance toward `spender` by `value`. If `token` returns no value,</span>
  67 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  68 |     | <span class='neutral'>     */</span>
  69 |     | <span class='neutral'>    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {</span>
  70 |     | <span class='neutral'>        unchecked {</span>
  71 |     | <span class='neutral'>            uint256 oldAllowance = token.allowance(address(this), spender);</span>
  72 |     | <span class='neutral'>            require(oldAllowance &gt;= value, &quot;SafeERC20: decreased allowance below zero&quot;);</span>
  73 |     | <span class='neutral'>            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /**</span>
  78 |     | <span class='neutral'>     * @dev Set the calling contract&#39;s allowance toward `spender` to `value`. If `token` returns no value,</span>
  79 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to</span>
  80 |     | <span class='neutral'>     * 0 before setting it to a non-zero value.</span>
  81 |     | <span class='neutral'>     */</span>
  82 |     | <span class='neutral'>    function forceApprove(IERC20 token, address spender, uint256 value) internal {</span>
  83 |     | <span class='neutral'>        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>        if (!_callOptionalReturnBool(token, approvalCall)) {</span>
  86 |     | <span class='neutral'>            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));</span>
  87 |     | <span class='neutral'>            _callOptionalReturn(token, approvalCall);</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.</span>
  93 |     | <span class='neutral'>     * Revert on invalid signature.</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='neutral'>    function safePermit(</span>
  96 |     | <span class='neutral'>        IERC20Permit token,</span>
  97 |     | <span class='neutral'>        address owner,</span>
  98 |     | <span class='neutral'>        address spender,</span>
  99 |     | <span class='neutral'>        uint256 value,</span>
 100 |     | <span class='neutral'>        uint256 deadline,</span>
 101 |     | <span class='neutral'>        uint8 v,</span>
 102 |     | <span class='neutral'>        bytes32 r,</span>
 103 |     | <span class='neutral'>        bytes32 s</span>
 104 |     | <span class='neutral'>    ) internal {</span>
 105 |     | <span class='neutral'>        uint256 nonceBefore = token.nonces(owner);</span>
 106 |     | <span class='neutral'>        token.permit(owner, spender, value, deadline, v, r, s);</span>
 107 |     | <span class='neutral'>        uint256 nonceAfter = token.nonces(owner);</span>
 108 |     | <span class='neutral'>        require(nonceAfter == nonceBefore + 1, &quot;SafeERC20: permit did not succeed&quot;);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /**</span>
 112 |     | <span class='neutral'>     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement</span>
 113 |     | <span class='neutral'>     * on the return value: the return value is optional (but if data is returned, it must not be false).</span>
 114 |     | <span class='neutral'>     * @param token The token targeted by the call.</span>
 115 |     | <span class='neutral'>     * @param data The call data (encoded using abi.encode or one of its variants).</span>
 116 |     | <span class='neutral'>     */</span>
 117 |     | <span class='unexecuted'>    function _callOptionalReturn(IERC20 token, bytes memory data) private {</span>
 118 |     | <span class='neutral'>        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since</span>
 119 |     | <span class='neutral'>        // we&#39;re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that</span>
 120 |     | <span class='neutral'>        // the target address contains contract code and also asserts for success in the low-level call.</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>        bytes memory returndata = address(token).functionCall(data, &quot;SafeERC20: low-level call failed&quot;);</span>
 123 |     | <span class='unexecuted'>        require(returndata.length == 0 || abi.decode(returndata, (bool)), &quot;SafeERC20: ERC20 operation did not succeed&quot;);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement</span>
 128 |     | <span class='neutral'>     * on the return value: the return value is optional (but if data is returned, it must not be false).</span>
 129 |     | <span class='neutral'>     * @param token The token targeted by the call.</span>
 130 |     | <span class='neutral'>     * @param data The call data (encoded using abi.encode or one of its variants).</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.</span>
 133 |     | <span class='neutral'>     */</span>
 134 |     | <span class='neutral'>    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {</span>
 135 |     | <span class='neutral'>        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since</span>
 136 |     | <span class='neutral'>        // we&#39;re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false</span>
 137 |     | <span class='neutral'>        // and not revert is the subcall reverts.</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>        (bool success, bytes memory returndata) = address(token).call(data);</span>
 140 |     | <span class='neutral'>        return</span>
 141 |     | <span class='neutral'>            success &amp;&amp; (returndata.length == 0 || abi.decode(returndata, (bool))) &amp;&amp; Address.isContract(address(token));</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'>}</span>
 144 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/utils/Address.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.1;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Collection of functions related to the address type</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='unexecuted'>library Address {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @dev Returns true if `account` is a contract.</span>
  12 |     | <span class='neutral'>     *</span>
  13 |     | <span class='neutral'>     * [IMPORTANT]</span>
  14 |     | <span class='neutral'>     * ====</span>
  15 |     | <span class='neutral'>     * It is unsafe to assume that an address for which this function returns</span>
  16 |     | <span class='neutral'>     * false is an externally-owned account (EOA) and not a contract.</span>
  17 |     | <span class='neutral'>     *</span>
  18 |     | <span class='neutral'>     * Among others, `isContract` will return false for the following</span>
  19 |     | <span class='neutral'>     * types of addresses:</span>
  20 |     | <span class='neutral'>     *</span>
  21 |     | <span class='neutral'>     *  - an externally-owned account</span>
  22 |     | <span class='neutral'>     *  - a contract in construction</span>
  23 |     | <span class='neutral'>     *  - an address where a contract will be created</span>
  24 |     | <span class='neutral'>     *  - an address where a contract lived, but was destroyed</span>
  25 |     | <span class='neutral'>     *</span>
  26 |     | <span class='neutral'>     * Furthermore, `isContract` will also return true if the target contract within</span>
  27 |     | <span class='neutral'>     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,</span>
  28 |     | <span class='neutral'>     * which only has an effect at the end of a transaction.</span>
  29 |     | <span class='neutral'>     * ====</span>
  30 |     | <span class='neutral'>     *</span>
  31 |     | <span class='neutral'>     * [IMPORTANT]</span>
  32 |     | <span class='neutral'>     * ====</span>
  33 |     | <span class='neutral'>     * You shouldn&#39;t rely on `isContract` to protect against flash loan attacks!</span>
  34 |     | <span class='neutral'>     *</span>
  35 |     | <span class='neutral'>     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets</span>
  36 |     | <span class='neutral'>     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract</span>
  37 |     | <span class='neutral'>     * constructor.</span>
  38 |     | <span class='neutral'>     * ====</span>
  39 |     | <span class='neutral'>     */</span>
  40 |     | <span class='neutral'>    function isContract(address account) internal view returns (bool) {</span>
  41 |     | <span class='neutral'>        // This method relies on extcodesize/address.code.length, which returns 0</span>
  42 |     | <span class='neutral'>        // for contracts in construction, since the code is only stored at the end</span>
  43 |     | <span class='neutral'>        // of the constructor execution.</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>        return account.code.length &gt; 0;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Replacement for Solidity&#39;s `transfer`: sends `amount` wei to</span>
  50 |     | <span class='neutral'>     * `recipient`, forwarding all available gas and reverting on errors.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost</span>
  53 |     | <span class='neutral'>     * of certain opcodes, possibly making contracts go over the 2300 gas limit</span>
  54 |     | <span class='neutral'>     * imposed by `transfer`, making them unable to receive funds via</span>
  55 |     | <span class='neutral'>     * `transfer`. {sendValue} removes this limitation.</span>
  56 |     | <span class='neutral'>     *</span>
  57 |     | <span class='neutral'>     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].</span>
  58 |     | <span class='neutral'>     *</span>
  59 |     | <span class='neutral'>     * IMPORTANT: because control is transferred to `recipient`, care must be</span>
  60 |     | <span class='neutral'>     * taken to not create reentrancy vulnerabilities. Consider using</span>
  61 |     | <span class='neutral'>     * {ReentrancyGuard} or the</span>
  62 |     | <span class='neutral'>     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].</span>
  63 |     | <span class='neutral'>     */</span>
  64 |     | <span class='neutral'>    function sendValue(address payable recipient, uint256 amount) internal {</span>
  65 |     | <span class='neutral'>        require(address(this).balance &gt;= amount, &quot;Address: insufficient balance&quot;);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>        (bool success, ) = recipient.call{value: amount}(&quot;&quot;);</span>
  68 |     | <span class='neutral'>        require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /**</span>
  72 |     | <span class='neutral'>     * @dev Performs a Solidity function call using a low level `call`. A</span>
  73 |     | <span class='neutral'>     * plain `call` is an unsafe replacement for a function call: use this</span>
  74 |     | <span class='neutral'>     * function instead.</span>
  75 |     | <span class='neutral'>     *</span>
  76 |     | <span class='neutral'>     * If `target` reverts with a revert reason, it is bubbled up by this</span>
  77 |     | <span class='neutral'>     * function (like regular Solidity function calls).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Returns the raw returned data. To convert to the expected return value,</span>
  80 |     | <span class='neutral'>     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].</span>
  81 |     | <span class='neutral'>     *</span>
  82 |     | <span class='neutral'>     * Requirements:</span>
  83 |     | <span class='neutral'>     *</span>
  84 |     | <span class='neutral'>     * - `target` must be a contract.</span>
  85 |     | <span class='neutral'>     * - calling `target` with `data` must not revert.</span>
  86 |     | <span class='neutral'>     *</span>
  87 |     | <span class='neutral'>     * _Available since v3.1._</span>
  88 |     | <span class='neutral'>     */</span>
  89 |     | <span class='unexecuted'>    function functionCall(address target, bytes memory data) internal returns (bytes memory) {</span>
  90 |     | <span class='unexecuted'>        return functionCallWithValue(target, data, 0, &quot;Address: low-level call failed&quot;);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /**</span>
  94 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with</span>
  95 |     | <span class='neutral'>     * `errorMessage` as a fallback revert reason when `target` reverts.</span>
  96 |     | <span class='neutral'>     *</span>
  97 |     | <span class='neutral'>     * _Available since v3.1._</span>
  98 |     | <span class='neutral'>     */</span>
  99 |     | <span class='unexecuted'>    function functionCall(</span>
 100 |     | <span class='neutral'>        address target,</span>
 101 |     | <span class='neutral'>        bytes memory data,</span>
 102 |     | <span class='neutral'>        string memory errorMessage</span>
 103 |     | <span class='unexecuted'>    ) internal returns (bytes memory) {</span>
 104 |     | <span class='unexecuted'>        return functionCallWithValue(target, data, 0, errorMessage);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 109 |     | <span class='neutral'>     * but also transferring `value` wei to `target`.</span>
 110 |     | <span class='neutral'>     *</span>
 111 |     | <span class='neutral'>     * Requirements:</span>
 112 |     | <span class='neutral'>     *</span>
 113 |     | <span class='neutral'>     * - the calling contract must have an ETH balance of at least `value`.</span>
 114 |     | <span class='neutral'>     * - the called Solidity function must be `payable`.</span>
 115 |     | <span class='neutral'>     *</span>
 116 |     | <span class='neutral'>     * _Available since v3.1._</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='unexecuted'>    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {</span>
 119 |     | <span class='unexecuted'>        return functionCallWithValue(target, data, value, &quot;Address: low-level call with value failed&quot;);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /**</span>
 123 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but</span>
 124 |     | <span class='neutral'>     * with `errorMessage` as a fallback revert reason when `target` reverts.</span>
 125 |     | <span class='neutral'>     *</span>
 126 |     | <span class='neutral'>     * _Available since v3.1._</span>
 127 |     | <span class='neutral'>     */</span>
 128 |     | <span class='unexecuted'>    function functionCallWithValue(</span>
 129 |     | <span class='neutral'>        address target,</span>
 130 |     | <span class='neutral'>        bytes memory data,</span>
 131 |     | <span class='neutral'>        uint256 value,</span>
 132 |     | <span class='neutral'>        string memory errorMessage</span>
 133 |     | <span class='unexecuted'>    ) internal returns (bytes memory) {</span>
 134 |     | <span class='unexecuted'>        require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);</span>
 135 |     | <span class='unexecuted'>        (bool success, bytes memory returndata) = target.call{value: value}(data);</span>
 136 |     | <span class='unexecuted'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /**</span>
 140 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 141 |     | <span class='neutral'>     * but performing a static call.</span>
 142 |     | <span class='neutral'>     *</span>
 143 |     | <span class='neutral'>     * _Available since v3.3._</span>
 144 |     | <span class='neutral'>     */</span>
 145 |     | <span class='neutral'>    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {</span>
 146 |     | <span class='neutral'>        return functionStaticCall(target, data, &quot;Address: low-level static call failed&quot;);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /**</span>
 150 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],</span>
 151 |     | <span class='neutral'>     * but performing a static call.</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * _Available since v3.3._</span>
 154 |     | <span class='neutral'>     */</span>
 155 |     | <span class='neutral'>    function functionStaticCall(</span>
 156 |     | <span class='neutral'>        address target,</span>
 157 |     | <span class='neutral'>        bytes memory data,</span>
 158 |     | <span class='neutral'>        string memory errorMessage</span>
 159 |     | <span class='neutral'>    ) internal view returns (bytes memory) {</span>
 160 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.staticcall(data);</span>
 161 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /**</span>
 165 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 166 |     | <span class='neutral'>     * but performing a delegate call.</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * _Available since v3.4._</span>
 169 |     | <span class='neutral'>     */</span>
 170 |     | <span class='unexecuted'>    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {</span>
 171 |     | <span class='unexecuted'>        return functionDelegateCall(target, data, &quot;Address: low-level delegate call failed&quot;);</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    /**</span>
 175 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],</span>
 176 |     | <span class='neutral'>     * but performing a delegate call.</span>
 177 |     | <span class='neutral'>     *</span>
 178 |     | <span class='neutral'>     * _Available since v3.4._</span>
 179 |     | <span class='neutral'>     */</span>
 180 |     | <span class='unexecuted'>    function functionDelegateCall(</span>
 181 |     | <span class='neutral'>        address target,</span>
 182 |     | <span class='neutral'>        bytes memory data,</span>
 183 |     | <span class='neutral'>        string memory errorMessage</span>
 184 |     | <span class='unexecuted'>    ) internal returns (bytes memory) {</span>
 185 |     | <span class='unexecuted'>        (bool success, bytes memory returndata) = target.delegatecall(data);</span>
 186 |     | <span class='unexecuted'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    /**</span>
 190 |     | <span class='neutral'>     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling</span>
 191 |     | <span class='neutral'>     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * _Available since v4.8._</span>
 194 |     | <span class='neutral'>     */</span>
 195 |     | <span class='unexecuted'>    function verifyCallResultFromTarget(</span>
 196 |     | <span class='neutral'>        address target,</span>
 197 |     | <span class='neutral'>        bool success,</span>
 198 |     | <span class='neutral'>        bytes memory returndata,</span>
 199 |     | <span class='neutral'>        string memory errorMessage</span>
 200 |     | <span class='unexecuted'>    ) internal view returns (bytes memory) {</span>
 201 |     | <span class='unexecuted'>        if (success) {</span>
 202 |     | <span class='unexecuted'>            if (returndata.length == 0) {</span>
 203 |     | <span class='neutral'>                // only check isContract if the call was successful and the return data is empty</span>
 204 |     | <span class='neutral'>                // otherwise we already know that it was a contract</span>
 205 |     | <span class='unexecuted'>                require(isContract(target), &quot;Address: call to non-contract&quot;);</span>
 206 |     | <span class='neutral'>            }</span>
 207 |     | <span class='unexecuted'>            return returndata;</span>
 208 |     | <span class='neutral'>        } else {</span>
 209 |     | <span class='unexecuted'>            _revert(returndata, errorMessage);</span>
 210 |     | <span class='neutral'>        }</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    /**</span>
 214 |     | <span class='neutral'>     * @dev Tool to verify that a low level call was successful, and revert if it wasn&#39;t, either by bubbling the</span>
 215 |     | <span class='neutral'>     * revert reason or using the provided one.</span>
 216 |     | <span class='neutral'>     *</span>
 217 |     | <span class='neutral'>     * _Available since v4.3._</span>
 218 |     | <span class='neutral'>     */</span>
 219 |     | <span class='neutral'>    function verifyCallResult(</span>
 220 |     | <span class='neutral'>        bool success,</span>
 221 |     | <span class='neutral'>        bytes memory returndata,</span>
 222 |     | <span class='neutral'>        string memory errorMessage</span>
 223 |     | <span class='neutral'>    ) internal pure returns (bytes memory) {</span>
 224 |     | <span class='neutral'>        if (success) {</span>
 225 |     | <span class='neutral'>            return returndata;</span>
 226 |     | <span class='neutral'>        } else {</span>
 227 |     | <span class='neutral'>            _revert(returndata, errorMessage);</span>
 228 |     | <span class='neutral'>        }</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    function _revert(bytes memory returndata, string memory errorMessage) private pure {</span>
 232 |     | <span class='neutral'>        // Look for revert reason and bubble it up if present</span>
 233 |     | <span class='unexecuted'>        if (returndata.length &gt; 0) {</span>
 234 |     | <span class='neutral'>            // The easiest way to bubble the revert reason is using memory via assembly</span>
 235 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 236 |     | <span class='neutral'>            assembly {</span>
 237 |     | <span class='unexecuted'>                let returndata_size := mload(returndata)</span>
 238 |     | <span class='unexecuted'>                revert(add(32, returndata), returndata_size)</span>
 239 |     | <span class='neutral'>            }</span>
 240 |     | <span class='neutral'>        } else {</span>
 241 |     | <span class='unexecuted'>            revert(errorMessage);</span>
 242 |     | <span class='neutral'>        }</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'>}</span>
 245 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 |     | <span class='unexecuted'>    function _msgSender() internal view virtual returns (address) {</span>
 18 | *   | <span class='executed'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev These functions deal with verification of Merkle Tree proofs.</span>
   8 |     | <span class='neutral'> *</span>
   9 |     | <span class='neutral'> * The tree and the proofs can be generated using our</span>
  10 |     | <span class='neutral'> * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].</span>
  11 |     | <span class='neutral'> * You will find a quickstart guide in the readme.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * WARNING: You should avoid using leaf values that are 64 bytes long prior to</span>
  14 |     | <span class='neutral'> * hashing, or use a hash function other than keccak256 for hashing leaves.</span>
  15 |     | <span class='neutral'> * This is because the concatenation of a sorted pair of internal nodes in</span>
  16 |     | <span class='neutral'> * the merkle tree could be reinterpreted as a leaf value.</span>
  17 |     | <span class='neutral'> * OpenZeppelin&#39;s JavaScript library generates merkle trees that are safe</span>
  18 |     | <span class='neutral'> * against this attack out of the box.</span>
  19 |     | <span class='neutral'> */</span>
  20 |     | <span class='unexecuted'>library MerkleProof {</span>
  21 |     | <span class='neutral'>    /**</span>
  22 |     | <span class='neutral'>     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree</span>
  23 |     | <span class='neutral'>     * defined by `root`. For this, a `proof` must be provided, containing</span>
  24 |     | <span class='neutral'>     * sibling hashes on the branch from the leaf to the root of the tree. Each</span>
  25 |     | <span class='neutral'>     * pair of leaves and each pair of pre-images are assumed to be sorted.</span>
  26 |     | <span class='neutral'>     */</span>
  27 |     | <span class='unexecuted'>    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {</span>
  28 |     | <span class='unexecuted'>        return processProof(proof, leaf) == root;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /**</span>
  32 |     | <span class='neutral'>     * @dev Calldata version of {verify}</span>
  33 |     | <span class='neutral'>     *</span>
  34 |     | <span class='neutral'>     * _Available since v4.7._</span>
  35 |     | <span class='neutral'>     */</span>
  36 |     | <span class='neutral'>    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {</span>
  37 |     | <span class='neutral'>        return processProofCalldata(proof, leaf) == root;</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /**</span>
  41 |     | <span class='neutral'>     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up</span>
  42 |     | <span class='neutral'>     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt</span>
  43 |     | <span class='neutral'>     * hash matches the root of the tree. When processing the proof, the pairs</span>
  44 |     | <span class='neutral'>     * of leafs &amp; pre-images are assumed to be sorted.</span>
  45 |     | <span class='neutral'>     *</span>
  46 |     | <span class='neutral'>     * _Available since v4.4._</span>
  47 |     | <span class='neutral'>     */</span>
  48 |     | <span class='unexecuted'>    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {</span>
  49 |     | <span class='unexecuted'>        bytes32 computedHash = leaf;</span>
  50 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; proof.length; i++) {</span>
  51 |     | <span class='unexecuted'>            computedHash = _hashPair(computedHash, proof[i]);</span>
  52 |     | <span class='neutral'>        }</span>
  53 |     | <span class='unexecuted'>        return computedHash;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Calldata version of {processProof}</span>
  58 |     | <span class='neutral'>     *</span>
  59 |     | <span class='neutral'>     * _Available since v4.7._</span>
  60 |     | <span class='neutral'>     */</span>
  61 |     | <span class='neutral'>    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {</span>
  62 |     | <span class='neutral'>        bytes32 computedHash = leaf;</span>
  63 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; proof.length; i++) {</span>
  64 |     | <span class='neutral'>            computedHash = _hashPair(computedHash, proof[i]);</span>
  65 |     | <span class='neutral'>        }</span>
  66 |     | <span class='neutral'>        return computedHash;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by</span>
  71 |     | <span class='neutral'>     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.</span>
  72 |     | <span class='neutral'>     *</span>
  73 |     | <span class='neutral'>     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.</span>
  74 |     | <span class='neutral'>     *</span>
  75 |     | <span class='neutral'>     * _Available since v4.7._</span>
  76 |     | <span class='neutral'>     */</span>
  77 |     | <span class='neutral'>    function multiProofVerify(</span>
  78 |     | <span class='neutral'>        bytes32[] memory proof,</span>
  79 |     | <span class='neutral'>        bool[] memory proofFlags,</span>
  80 |     | <span class='neutral'>        bytes32 root,</span>
  81 |     | <span class='neutral'>        bytes32[] memory leaves</span>
  82 |     | <span class='neutral'>    ) internal pure returns (bool) {</span>
  83 |     | <span class='neutral'>        return processMultiProof(proof, proofFlags, leaves) == root;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /**</span>
  87 |     | <span class='neutral'>     * @dev Calldata version of {multiProofVerify}</span>
  88 |     | <span class='neutral'>     *</span>
  89 |     | <span class='neutral'>     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.</span>
  90 |     | <span class='neutral'>     *</span>
  91 |     | <span class='neutral'>     * _Available since v4.7._</span>
  92 |     | <span class='neutral'>     */</span>
  93 |     | <span class='neutral'>    function multiProofVerifyCalldata(</span>
  94 |     | <span class='neutral'>        bytes32[] calldata proof,</span>
  95 |     | <span class='neutral'>        bool[] calldata proofFlags,</span>
  96 |     | <span class='neutral'>        bytes32 root,</span>
  97 |     | <span class='neutral'>        bytes32[] memory leaves</span>
  98 |     | <span class='neutral'>    ) internal pure returns (bool) {</span>
  99 |     | <span class='neutral'>        return processMultiProofCalldata(proof, proofFlags, leaves) == root;</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /**</span>
 103 |     | <span class='neutral'>     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction</span>
 104 |     | <span class='neutral'>     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another</span>
 105 |     | <span class='neutral'>     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false</span>
 106 |     | <span class='neutral'>     * respectively.</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree</span>
 109 |     | <span class='neutral'>     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the</span>
 110 |     | <span class='neutral'>     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).</span>
 111 |     | <span class='neutral'>     *</span>
 112 |     | <span class='neutral'>     * _Available since v4.7._</span>
 113 |     | <span class='neutral'>     */</span>
 114 |     | <span class='neutral'>    function processMultiProof(</span>
 115 |     | <span class='neutral'>        bytes32[] memory proof,</span>
 116 |     | <span class='neutral'>        bool[] memory proofFlags,</span>
 117 |     | <span class='neutral'>        bytes32[] memory leaves</span>
 118 |     | <span class='neutral'>    ) internal pure returns (bytes32 merkleRoot) {</span>
 119 |     | <span class='neutral'>        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by</span>
 120 |     | <span class='neutral'>        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the</span>
 121 |     | <span class='neutral'>        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of</span>
 122 |     | <span class='neutral'>        // the merkle tree.</span>
 123 |     | <span class='neutral'>        uint256 leavesLen = leaves.length;</span>
 124 |     | <span class='neutral'>        uint256 proofLen = proof.length;</span>
 125 |     | <span class='neutral'>        uint256 totalHashes = proofFlags.length;</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>        // Check proof validity.</span>
 128 |     | <span class='neutral'>        require(leavesLen + proofLen - 1 == totalHashes, &quot;MerkleProof: invalid multiproof&quot;);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>        // The xxxPos values are &quot;pointers&quot; to the next value to consume in each array. All accesses are done using</span>
 131 |     | <span class='neutral'>        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue&#39;s &quot;pop&quot;.</span>
 132 |     | <span class='neutral'>        bytes32[] memory hashes = new bytes32[](totalHashes);</span>
 133 |     | <span class='neutral'>        uint256 leafPos = 0;</span>
 134 |     | <span class='neutral'>        uint256 hashPos = 0;</span>
 135 |     | <span class='neutral'>        uint256 proofPos = 0;</span>
 136 |     | <span class='neutral'>        // At each step, we compute the next hash using two values:</span>
 137 |     | <span class='neutral'>        // - a value from the &quot;main queue&quot;. If not all leaves have been consumed, we get the next leaf, otherwise we</span>
 138 |     | <span class='neutral'>        //   get the next hash.</span>
 139 |     | <span class='neutral'>        // - depending on the flag, either another value from the &quot;main queue&quot; (merging branches) or an element from the</span>
 140 |     | <span class='neutral'>        //   `proof` array.</span>
 141 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; totalHashes; i++) {</span>
 142 |     | <span class='neutral'>            bytes32 a = leafPos &lt; leavesLen ? leaves[leafPos++] : hashes[hashPos++];</span>
 143 |     | <span class='neutral'>            bytes32 b = proofFlags[i]</span>
 144 |     | <span class='neutral'>                ? (leafPos &lt; leavesLen ? leaves[leafPos++] : hashes[hashPos++])</span>
 145 |     | <span class='neutral'>                : proof[proofPos++];</span>
 146 |     | <span class='neutral'>            hashes[i] = _hashPair(a, b);</span>
 147 |     | <span class='neutral'>        }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>        if (totalHashes &gt; 0) {</span>
 150 |     | <span class='neutral'>            require(proofPos == proofLen, &quot;MerkleProof: invalid multiproof&quot;);</span>
 151 |     | <span class='neutral'>            unchecked {</span>
 152 |     | <span class='neutral'>                return hashes[totalHashes - 1];</span>
 153 |     | <span class='neutral'>            }</span>
 154 |     | <span class='neutral'>        } else if (leavesLen &gt; 0) {</span>
 155 |     | <span class='neutral'>            return leaves[0];</span>
 156 |     | <span class='neutral'>        } else {</span>
 157 |     | <span class='neutral'>            return proof[0];</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    /**</span>
 162 |     | <span class='neutral'>     * @dev Calldata version of {processMultiProof}.</span>
 163 |     | <span class='neutral'>     *</span>
 164 |     | <span class='neutral'>     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.</span>
 165 |     | <span class='neutral'>     *</span>
 166 |     | <span class='neutral'>     * _Available since v4.7._</span>
 167 |     | <span class='neutral'>     */</span>
 168 |     | <span class='neutral'>    function processMultiProofCalldata(</span>
 169 |     | <span class='neutral'>        bytes32[] calldata proof,</span>
 170 |     | <span class='neutral'>        bool[] calldata proofFlags,</span>
 171 |     | <span class='neutral'>        bytes32[] memory leaves</span>
 172 |     | <span class='neutral'>    ) internal pure returns (bytes32 merkleRoot) {</span>
 173 |     | <span class='neutral'>        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by</span>
 174 |     | <span class='neutral'>        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the</span>
 175 |     | <span class='neutral'>        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of</span>
 176 |     | <span class='neutral'>        // the merkle tree.</span>
 177 |     | <span class='neutral'>        uint256 leavesLen = leaves.length;</span>
 178 |     | <span class='neutral'>        uint256 proofLen = proof.length;</span>
 179 |     | <span class='neutral'>        uint256 totalHashes = proofFlags.length;</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>        // Check proof validity.</span>
 182 |     | <span class='neutral'>        require(leavesLen + proofLen - 1 == totalHashes, &quot;MerkleProof: invalid multiproof&quot;);</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>        // The xxxPos values are &quot;pointers&quot; to the next value to consume in each array. All accesses are done using</span>
 185 |     | <span class='neutral'>        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue&#39;s &quot;pop&quot;.</span>
 186 |     | <span class='neutral'>        bytes32[] memory hashes = new bytes32[](totalHashes);</span>
 187 |     | <span class='neutral'>        uint256 leafPos = 0;</span>
 188 |     | <span class='neutral'>        uint256 hashPos = 0;</span>
 189 |     | <span class='neutral'>        uint256 proofPos = 0;</span>
 190 |     | <span class='neutral'>        // At each step, we compute the next hash using two values:</span>
 191 |     | <span class='neutral'>        // - a value from the &quot;main queue&quot;. If not all leaves have been consumed, we get the next leaf, otherwise we</span>
 192 |     | <span class='neutral'>        //   get the next hash.</span>
 193 |     | <span class='neutral'>        // - depending on the flag, either another value from the &quot;main queue&quot; (merging branches) or an element from the</span>
 194 |     | <span class='neutral'>        //   `proof` array.</span>
 195 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; totalHashes; i++) {</span>
 196 |     | <span class='neutral'>            bytes32 a = leafPos &lt; leavesLen ? leaves[leafPos++] : hashes[hashPos++];</span>
 197 |     | <span class='neutral'>            bytes32 b = proofFlags[i]</span>
 198 |     | <span class='neutral'>                ? (leafPos &lt; leavesLen ? leaves[leafPos++] : hashes[hashPos++])</span>
 199 |     | <span class='neutral'>                : proof[proofPos++];</span>
 200 |     | <span class='neutral'>            hashes[i] = _hashPair(a, b);</span>
 201 |     | <span class='neutral'>        }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>        if (totalHashes &gt; 0) {</span>
 204 |     | <span class='neutral'>            require(proofPos == proofLen, &quot;MerkleProof: invalid multiproof&quot;);</span>
 205 |     | <span class='neutral'>            unchecked {</span>
 206 |     | <span class='neutral'>                return hashes[totalHashes - 1];</span>
 207 |     | <span class='neutral'>            }</span>
 208 |     | <span class='neutral'>        } else if (leavesLen &gt; 0) {</span>
 209 |     | <span class='neutral'>            return leaves[0];</span>
 210 |     | <span class='neutral'>        } else {</span>
 211 |     | <span class='neutral'>            return proof[0];</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='unexecuted'>    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {</span>
 216 |     | <span class='unexecuted'>        return a &lt; b ? _efficientHash(a, b) : _efficientHash(b, a);</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='unexecuted'>    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {</span>
 220 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 221 |     | <span class='neutral'>        assembly {</span>
 222 |     | <span class='unexecuted'>            mstore(0x00, a)</span>
 223 |     | <span class='unexecuted'>            mstore(0x20, b)</span>
 224 |     | <span class='unexecuted'>            value := keccak256(0x00, 0x40)</span>
 225 |     | <span class='neutral'>        }</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'>}</span>
 228 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./IERC165.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Implementation of the {IERC165} interface.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check</span>
 12 |     | <span class='neutral'> * for the additional interface id that will be supported. For example:</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * ```solidity</span>
 15 |     | <span class='neutral'> * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 16 |     | <span class='neutral'> *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);</span>
 17 |     | <span class='neutral'> * }</span>
 18 |     | <span class='neutral'> * ```</span>
 19 |     | <span class='neutral'> *</span>
 20 |     | <span class='neutral'> * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.</span>
 21 |     | <span class='neutral'> */</span>
 22 |     | <span class='neutral'>abstract contract ERC165 is IERC165 {</span>
 23 |     | <span class='neutral'>    /**</span>
 24 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 27 |     | <span class='unexecuted'>        return interfaceId == type(IERC165).interfaceId;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC165 standard, as defined in the</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-165[EIP].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Implementers can declare support of contract interfaces, which can then be</span>
 11 |     | <span class='neutral'> * queried by others ({ERC165Checker}).</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * For an implementation, see {ERC165}.</span>
 14 |     | <span class='neutral'> */</span>
 15 |     | <span class='neutral'>interface IERC165 {</span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Returns true if this contract implements the interface defined by</span>
 18 |     | <span class='neutral'>     * `interfaceId`. See the corresponding</span>
 19 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]</span>
 20 |     | <span class='neutral'>     * to learn more about how these ids are created.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * This function call must use less than 30 000 gas.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) external view returns (bool);</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solady/src/tokens/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Simple ERC20 + EIP-2612 implementation.</span>
   5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)</span>
   6 |     | <span class='neutral'>/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)</span>
   7 |     | <span class='neutral'>/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)</span>
   8 |     | <span class='neutral'>///</span>
   9 |     | <span class='neutral'>/// @dev Note:</span>
  10 |     | <span class='neutral'>/// - The ERC20 standard allows minting and transferring to and from the zero address,</span>
  11 |     | <span class='neutral'>///   minting and transferring zero tokens, as well as self-approvals.</span>
  12 |     | <span class='neutral'>///   For performance, this implementation WILL NOT revert for such actions.</span>
  13 |     | <span class='neutral'>///   Please add any checks with overrides if desired.</span>
  14 |     | <span class='neutral'>/// - The `permit` function uses the ecrecover precompile (0x1).</span>
  15 |     | <span class='neutral'>///</span>
  16 |     | <span class='neutral'>/// If you are overriding:</span>
  17 |     | <span class='neutral'>/// - NEVER violate the ERC20 invariant:</span>
  18 |     | <span class='neutral'>///   the total sum of all balances must be equal to `totalSupply()`.</span>
  19 |     | <span class='neutral'>/// - Check that the overridden function is actually used in the function you want to</span>
  20 |     | <span class='neutral'>///   change the behavior of. Much of the code has been manually inlined for performance.</span>
  21 |     | <span class='neutral'>abstract contract ERC20 {</span>
  22 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  23 |     | <span class='neutral'>    /*                       CUSTOM ERRORS                        */</span>
  24 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /// @dev The total supply has overflowed.</span>
  27 |     | <span class='neutral'>    error TotalSupplyOverflow();</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    /// @dev The allowance has overflowed.</span>
  30 |     | <span class='neutral'>    error AllowanceOverflow();</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /// @dev The allowance has underflowed.</span>
  33 |     | <span class='neutral'>    error AllowanceUnderflow();</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /// @dev Insufficient balance.</span>
  36 |     | <span class='neutral'>    error InsufficientBalance();</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /// @dev Insufficient allowance.</span>
  39 |     | <span class='neutral'>    error InsufficientAllowance();</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /// @dev The permit is invalid.</span>
  42 |     | <span class='neutral'>    error InvalidPermit();</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /// @dev The permit has expired.</span>
  45 |     | <span class='neutral'>    error PermitExpired();</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  48 |     | <span class='neutral'>    /*                           EVENTS                           */</span>
  49 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.</span>
  52 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 amount);</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.</span>
  55 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 amount);</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    /// @dev `keccak256(bytes(&quot;Transfer(address,address,uint256)&quot;))`.</span>
  58 |     | <span class='neutral'>    uint256 private constant _TRANSFER_EVENT_SIGNATURE =</span>
  59 |     | <span class='neutral'>        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /// @dev `keccak256(bytes(&quot;Approval(address,address,uint256)&quot;))`.</span>
  62 |     | <span class='neutral'>    uint256 private constant _APPROVAL_EVENT_SIGNATURE =</span>
  63 |     | <span class='neutral'>        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  66 |     | <span class='neutral'>    /*                          STORAGE                           */</span>
  67 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /// @dev The storage slot for the total supply.</span>
  70 |     | <span class='neutral'>    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /// @dev The balance slot of `owner` is given by:</span>
  73 |     | <span class='neutral'>    /// ```</span>
  74 |     | <span class='neutral'>    ///     mstore(0x0c, _BALANCE_SLOT_SEED)</span>
  75 |     | <span class='neutral'>    ///     mstore(0x00, owner)</span>
  76 |     | <span class='neutral'>    ///     let balanceSlot := keccak256(0x0c, 0x20)</span>
  77 |     | <span class='neutral'>    /// ```</span>
  78 |     | <span class='neutral'>    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    /// @dev The allowance slot of (`owner`, `spender`) is given by:</span>
  81 |     | <span class='neutral'>    /// ```</span>
  82 |     | <span class='neutral'>    ///     mstore(0x20, spender)</span>
  83 |     | <span class='neutral'>    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)</span>
  84 |     | <span class='neutral'>    ///     mstore(0x00, owner)</span>
  85 |     | <span class='neutral'>    ///     let allowanceSlot := keccak256(0x0c, 0x34)</span>
  86 |     | <span class='neutral'>    /// ```</span>
  87 |     | <span class='neutral'>    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /// @dev The nonce slot of `owner` is given by:</span>
  90 |     | <span class='neutral'>    /// ```</span>
  91 |     | <span class='neutral'>    ///     mstore(0x0c, _NONCES_SLOT_SEED)</span>
  92 |     | <span class='neutral'>    ///     mstore(0x00, owner)</span>
  93 |     | <span class='neutral'>    ///     let nonceSlot := keccak256(0x0c, 0x20)</span>
  94 |     | <span class='neutral'>    /// ```</span>
  95 |     | <span class='neutral'>    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  98 |     | <span class='neutral'>    /*                         CONSTANTS                          */</span>
  99 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /// @dev `(_NONCES_SLOT_SEED &lt;&lt; 16) | 0x1901`.</span>
 102 |     | <span class='neutral'>    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /// @dev `keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;)`.</span>
 105 |     | <span class='neutral'>    bytes32 private constant _DOMAIN_TYPEHASH =</span>
 106 |     | <span class='neutral'>        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @dev `keccak256(&quot;1&quot;)`.</span>
 109 |     | <span class='neutral'>    bytes32 private constant _VERSION_HASH =</span>
 110 |     | <span class='neutral'>        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /// @dev `keccak256(&quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;)`.</span>
 113 |     | <span class='neutral'>    bytes32 private constant _PERMIT_TYPEHASH =</span>
 114 |     | <span class='neutral'>        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 117 |     | <span class='neutral'>    /*                       ERC20 METADATA                       */</span>
 118 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    /// @dev Returns the name of the token.</span>
 121 |     | <span class='neutral'>    function name() public view virtual returns (string memory);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /// @dev Returns the symbol of the token.</span>
 124 |     | <span class='neutral'>    function symbol() public view virtual returns (string memory);</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /// @dev Returns the decimals places of the token.</span>
 127 |     | <span class='neutral'>    function decimals() public view virtual returns (uint8) {</span>
 128 |     | <span class='neutral'>        return 18;</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 132 |     | <span class='neutral'>    /*                           ERC20                            */</span>
 133 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    /// @dev Returns the amount of tokens in existence.</span>
 136 |     | <span class='unexecuted'>    function totalSupply() public view virtual returns (uint256 result) {</span>
 137 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 138 |     | <span class='neutral'>        assembly {</span>
 139 |     | <span class='unexecuted'>            result := sload(_TOTAL_SUPPLY_SLOT)</span>
 140 |     | <span class='neutral'>        }</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /// @dev Returns the amount of tokens owned by `owner`.</span>
 144 |     | <span class='unexecuted'>    function balanceOf(address owner) public view virtual returns (uint256 result) {</span>
 145 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 146 |     | <span class='neutral'>        assembly {</span>
 147 |     | <span class='unexecuted'>            mstore(0x0c, _BALANCE_SLOT_SEED)</span>
 148 |     | <span class='unexecuted'>            mstore(0x00, owner)</span>
 149 |     | <span class='unexecuted'>            result := sload(keccak256(0x0c, 0x20))</span>
 150 |     | <span class='neutral'>        }</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.</span>
 154 |     | <span class='unexecuted'>    function allowance(address owner, address spender)</span>
 155 |     | <span class='neutral'>        public</span>
 156 |     | <span class='neutral'>        view</span>
 157 |     | <span class='neutral'>        virtual</span>
 158 |     | <span class='unexecuted'>        returns (uint256 result)</span>
 159 |     | <span class='neutral'>    {</span>
 160 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 161 |     | <span class='neutral'>        assembly {</span>
 162 |     | <span class='unexecuted'>            mstore(0x20, spender)</span>
 163 |     | <span class='unexecuted'>            mstore(0x0c, _ALLOWANCE_SLOT_SEED)</span>
 164 |     | <span class='unexecuted'>            mstore(0x00, owner)</span>
 165 |     | <span class='unexecuted'>            result := sload(keccak256(0x0c, 0x34))</span>
 166 |     | <span class='neutral'>        }</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>    /// @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 170 |     | <span class='neutral'>    ///</span>
 171 |     | <span class='neutral'>    /// Emits a {Approval} event.</span>
 172 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) public virtual returns (bool) {</span>
 173 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 174 |     | <span class='neutral'>        assembly {</span>
 175 |     | <span class='neutral'>            // Compute the allowance slot and store the amount.</span>
 176 |     | <span class='unexecuted'>            mstore(0x20, spender)</span>
 177 |     | <span class='unexecuted'>            mstore(0x0c, _ALLOWANCE_SLOT_SEED)</span>
 178 |     | <span class='unexecuted'>            mstore(0x00, caller())</span>
 179 |     | <span class='unexecuted'>            sstore(keccak256(0x0c, 0x34), amount)</span>
 180 |     | <span class='neutral'>            // Emit the {Approval} event.</span>
 181 |     | <span class='unexecuted'>            mstore(0x00, amount)</span>
 182 |     | <span class='unexecuted'>            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='unexecuted'>        return true;</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /// @dev Transfer `amount` tokens from the caller to `to`.</span>
 188 |     | <span class='neutral'>    ///</span>
 189 |     | <span class='neutral'>    /// Requirements:</span>
 190 |     | <span class='neutral'>    /// - `from` must at least have `amount`.</span>
 191 |     | <span class='neutral'>    ///</span>
 192 |     | <span class='neutral'>    /// Emits a {Transfer} event.</span>
 193 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public virtual returns (bool) {</span>
 194 |     | <span class='neutral'>        _beforeTokenTransfer(msg.sender, to, amount);</span>
 195 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 196 |     | <span class='neutral'>        assembly {</span>
 197 |     | <span class='neutral'>            // Compute the balance slot and load its value.</span>
 198 |     | <span class='unexecuted'>            mstore(0x0c, _BALANCE_SLOT_SEED)</span>
 199 |     | <span class='unexecuted'>            mstore(0x00, caller())</span>
 200 |     | <span class='unexecuted'>            let fromBalanceSlot := keccak256(0x0c, 0x20)</span>
 201 |     | <span class='unexecuted'>            let fromBalance := sload(fromBalanceSlot)</span>
 202 |     | <span class='neutral'>            // Revert if insufficient balance.</span>
 203 |     | <span class='unexecuted'>            if gt(amount, fromBalance) {</span>
 204 |     | <span class='unexecuted'>                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.</span>
 205 |     | <span class='unexecuted'>                revert(0x1c, 0x04)</span>
 206 |     | <span class='neutral'>            }</span>
 207 |     | <span class='neutral'>            // Subtract and store the updated balance.</span>
 208 |     | <span class='unexecuted'>            sstore(fromBalanceSlot, sub(fromBalance, amount))</span>
 209 |     | <span class='neutral'>            // Compute the balance slot of `to`.</span>
 210 |     | <span class='unexecuted'>            mstore(0x00, to)</span>
 211 |     | <span class='unexecuted'>            let toBalanceSlot := keccak256(0x0c, 0x20)</span>
 212 |     | <span class='neutral'>            // Add and store the updated balance of `to`.</span>
 213 |     | <span class='neutral'>            // Will not overflow because the sum of all user balances</span>
 214 |     | <span class='neutral'>            // cannot exceed the maximum uint256 value.</span>
 215 |     | <span class='unexecuted'>            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))</span>
 216 |     | <span class='neutral'>            // Emit the {Transfer} event.</span>
 217 |     | <span class='unexecuted'>            mstore(0x20, amount)</span>
 218 |     | <span class='unexecuted'>            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='neutral'>        _afterTokenTransfer(msg.sender, to, amount);</span>
 221 |     | <span class='unexecuted'>        return true;</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    /// @dev Transfers `amount` tokens from `from` to `to`.</span>
 225 |     | <span class='neutral'>    ///</span>
 226 |     | <span class='neutral'>    /// Note: Does not update the allowance if it is the maximum uint256 value.</span>
 227 |     | <span class='neutral'>    ///</span>
 228 |     | <span class='neutral'>    /// Requirements:</span>
 229 |     | <span class='neutral'>    /// - `from` must at least have `amount`.</span>
 230 |     | <span class='neutral'>    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.</span>
 231 |     | <span class='neutral'>    ///</span>
 232 |     | <span class='neutral'>    /// Emits a {Transfer} event.</span>
 233 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {</span>
 234 |     | <span class='neutral'>        _beforeTokenTransfer(from, to, amount);</span>
 235 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 236 |     | <span class='neutral'>        assembly {</span>
 237 |     | <span class='unexecuted'>            let from_ := shl(96, from)</span>
 238 |     | <span class='neutral'>            // Compute the allowance slot and load its value.</span>
 239 |     | <span class='unexecuted'>            mstore(0x20, caller())</span>
 240 |     | <span class='unexecuted'>            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))</span>
 241 |     | <span class='unexecuted'>            let allowanceSlot := keccak256(0x0c, 0x34)</span>
 242 |     | <span class='unexecuted'>            let allowance_ := sload(allowanceSlot)</span>
 243 |     | <span class='neutral'>            // If the allowance is not the maximum uint256 value.</span>
 244 |     | <span class='unexecuted'>            if add(allowance_, 1) {</span>
 245 |     | <span class='neutral'>                // Revert if the amount to be transferred exceeds the allowance.</span>
 246 |     | <span class='unexecuted'>                if gt(amount, allowance_) {</span>
 247 |     | <span class='unexecuted'>                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.</span>
 248 |     | <span class='unexecuted'>                    revert(0x1c, 0x04)</span>
 249 |     | <span class='neutral'>                }</span>
 250 |     | <span class='neutral'>                // Subtract and store the updated allowance.</span>
 251 |     | <span class='unexecuted'>                sstore(allowanceSlot, sub(allowance_, amount))</span>
 252 |     | <span class='neutral'>            }</span>
 253 |     | <span class='neutral'>            // Compute the balance slot and load its value.</span>
 254 |     | <span class='unexecuted'>            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))</span>
 255 |     | <span class='unexecuted'>            let fromBalanceSlot := keccak256(0x0c, 0x20)</span>
 256 |     | <span class='unexecuted'>            let fromBalance := sload(fromBalanceSlot)</span>
 257 |     | <span class='neutral'>            // Revert if insufficient balance.</span>
 258 |     | <span class='unexecuted'>            if gt(amount, fromBalance) {</span>
 259 |     | <span class='unexecuted'>                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.</span>
 260 |     | <span class='unexecuted'>                revert(0x1c, 0x04)</span>
 261 |     | <span class='neutral'>            }</span>
 262 |     | <span class='neutral'>            // Subtract and store the updated balance.</span>
 263 |     | <span class='unexecuted'>            sstore(fromBalanceSlot, sub(fromBalance, amount))</span>
 264 |     | <span class='neutral'>            // Compute the balance slot of `to`.</span>
 265 |     | <span class='unexecuted'>            mstore(0x00, to)</span>
 266 |     | <span class='unexecuted'>            let toBalanceSlot := keccak256(0x0c, 0x20)</span>
 267 |     | <span class='neutral'>            // Add and store the updated balance of `to`.</span>
 268 |     | <span class='neutral'>            // Will not overflow because the sum of all user balances</span>
 269 |     | <span class='neutral'>            // cannot exceed the maximum uint256 value.</span>
 270 |     | <span class='unexecuted'>            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))</span>
 271 |     | <span class='neutral'>            // Emit the {Transfer} event.</span>
 272 |     | <span class='unexecuted'>            mstore(0x20, amount)</span>
 273 |     | <span class='unexecuted'>            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))</span>
 274 |     | <span class='neutral'>        }</span>
 275 |     | <span class='neutral'>        _afterTokenTransfer(from, to, amount);</span>
 276 |     | <span class='unexecuted'>        return true;</span>
 277 |     | <span class='neutral'>    }</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 280 |     | <span class='neutral'>    /*                          EIP-2612                          */</span>
 281 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>    /// @dev For more performance, override to return the constant value</span>
 284 |     | <span class='neutral'>    /// of `keccak256(bytes(name()))` if `name()` will never change.</span>
 285 |     | <span class='neutral'>    function _constantNameHash() internal view virtual returns (bytes32 result) {}</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>    /// @dev Returns the current nonce for `owner`.</span>
 288 |     | <span class='neutral'>    /// This value is used to compute the signature for EIP-2612 permit.</span>
 289 |     | <span class='unexecuted'>    function nonces(address owner) public view virtual returns (uint256 result) {</span>
 290 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 291 |     | <span class='neutral'>        assembly {</span>
 292 |     | <span class='neutral'>            // Compute the nonce slot and load its value.</span>
 293 |     | <span class='unexecuted'>            mstore(0x0c, _NONCES_SLOT_SEED)</span>
 294 |     | <span class='unexecuted'>            mstore(0x00, owner)</span>
 295 |     | <span class='unexecuted'>            result := sload(keccak256(0x0c, 0x20))</span>
 296 |     | <span class='neutral'>        }</span>
 297 |     | <span class='neutral'>    }</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,</span>
 300 |     | <span class='neutral'>    /// authorized by a signed approval by `owner`.</span>
 301 |     | <span class='neutral'>    ///</span>
 302 |     | <span class='neutral'>    /// Emits a {Approval} event.</span>
 303 |     | <span class='unexecuted'>    function permit(</span>
 304 |     | <span class='neutral'>        address owner,</span>
 305 |     | <span class='neutral'>        address spender,</span>
 306 |     | <span class='neutral'>        uint256 value,</span>
 307 |     | <span class='neutral'>        uint256 deadline,</span>
 308 |     | <span class='neutral'>        uint8 v,</span>
 309 |     | <span class='neutral'>        bytes32 r,</span>
 310 |     | <span class='neutral'>        bytes32 s</span>
 311 |     | <span class='neutral'>    ) public virtual {</span>
 312 |     | <span class='unexecuted'>        bytes32 nameHash = _constantNameHash();</span>
 313 |     | <span class='neutral'>        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.</span>
 314 |     | <span class='unexecuted'>        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));</span>
 315 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 316 |     | <span class='neutral'>        assembly {</span>
 317 |     | <span class='neutral'>            // Revert if the block timestamp is greater than `deadline`.</span>
 318 |     | <span class='unexecuted'>            if gt(timestamp(), deadline) {</span>
 319 |     | <span class='unexecuted'>                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.</span>
 320 |     | <span class='unexecuted'>                revert(0x1c, 0x04)</span>
 321 |     | <span class='neutral'>            }</span>
 322 |     | <span class='unexecuted'>            let m := mload(0x40) // Grab the free memory pointer.</span>
 323 |     | <span class='neutral'>            // Clean the upper 96 bits.</span>
 324 |     | <span class='unexecuted'>            owner := shr(96, shl(96, owner))</span>
 325 |     | <span class='unexecuted'>            spender := shr(96, shl(96, spender))</span>
 326 |     | <span class='neutral'>            // Compute the nonce slot and load its value.</span>
 327 |     | <span class='unexecuted'>            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)</span>
 328 |     | <span class='unexecuted'>            mstore(0x00, owner)</span>
 329 |     | <span class='unexecuted'>            let nonceSlot := keccak256(0x0c, 0x20)</span>
 330 |     | <span class='unexecuted'>            let nonceValue := sload(nonceSlot)</span>
 331 |     | <span class='neutral'>            // Prepare the domain separator.</span>
 332 |     | <span class='unexecuted'>            mstore(m, _DOMAIN_TYPEHASH)</span>
 333 |     | <span class='unexecuted'>            mstore(add(m, 0x20), nameHash)</span>
 334 |     | <span class='unexecuted'>            mstore(add(m, 0x40), _VERSION_HASH)</span>
 335 |     | <span class='unexecuted'>            mstore(add(m, 0x60), chainid())</span>
 336 |     | <span class='unexecuted'>            mstore(add(m, 0x80), address())</span>
 337 |     | <span class='unexecuted'>            mstore(0x2e, keccak256(m, 0xa0))</span>
 338 |     | <span class='neutral'>            // Prepare the struct hash.</span>
 339 |     | <span class='unexecuted'>            mstore(m, _PERMIT_TYPEHASH)</span>
 340 |     | <span class='unexecuted'>            mstore(add(m, 0x20), owner)</span>
 341 |     | <span class='unexecuted'>            mstore(add(m, 0x40), spender)</span>
 342 |     | <span class='unexecuted'>            mstore(add(m, 0x60), value)</span>
 343 |     | <span class='unexecuted'>            mstore(add(m, 0x80), nonceValue)</span>
 344 |     | <span class='unexecuted'>            mstore(add(m, 0xa0), deadline)</span>
 345 |     | <span class='unexecuted'>            mstore(0x4e, keccak256(m, 0xc0))</span>
 346 |     | <span class='neutral'>            // Prepare the ecrecover calldata.</span>
 347 |     | <span class='unexecuted'>            mstore(0x00, keccak256(0x2c, 0x42))</span>
 348 |     | <span class='unexecuted'>            mstore(0x20, and(0xff, v))</span>
 349 |     | <span class='unexecuted'>            mstore(0x40, r)</span>
 350 |     | <span class='unexecuted'>            mstore(0x60, s)</span>
 351 |     | <span class='unexecuted'>            let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)</span>
 352 |     | <span class='neutral'>            // If the ecrecover fails, the returndatasize will be 0x00,</span>
 353 |     | <span class='neutral'>            // `owner` will be checked if it equals the hash at 0x00,</span>
 354 |     | <span class='neutral'>            // which evaluates to false (i.e. 0), and we will revert.</span>
 355 |     | <span class='neutral'>            // If the ecrecover succeeds, the returndatasize will be 0x20,</span>
 356 |     | <span class='neutral'>            // `owner` will be compared against the returned address at 0x20.</span>
 357 |     | <span class='unexecuted'>            if iszero(eq(mload(returndatasize()), owner)) {</span>
 358 |     | <span class='unexecuted'>                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.</span>
 359 |     | <span class='unexecuted'>                revert(0x1c, 0x04)</span>
 360 |     | <span class='neutral'>            }</span>
 361 |     | <span class='neutral'>            // Increment and store the updated nonce.</span>
 362 |     | <span class='unexecuted'>            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.</span>
 363 |     | <span class='neutral'>            // Compute the allowance slot and store the value.</span>
 364 |     | <span class='neutral'>            // The `owner` is already at slot 0x20.</span>
 365 |     | <span class='unexecuted'>            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))</span>
 366 |     | <span class='unexecuted'>            sstore(keccak256(0x2c, 0x34), value)</span>
 367 |     | <span class='neutral'>            // Emit the {Approval} event.</span>
 368 |     | <span class='unexecuted'>            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)</span>
 369 |     | <span class='unexecuted'>            mstore(0x40, m) // Restore the free memory pointer.</span>
 370 |     | <span class='unexecuted'>            mstore(0x60, 0) // Restore the zero pointer.</span>
 371 |     | <span class='neutral'>        }</span>
 372 |     | <span class='neutral'>    }</span>
 373 |     | <span class='neutral'></span>
 374 |     | <span class='neutral'>    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.</span>
 375 |     | <span class='unexecuted'>    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {</span>
 376 |     | <span class='neutral'>        bytes32 nameHash = _constantNameHash();</span>
 377 |     | <span class='neutral'>        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.</span>
 378 |     | <span class='unexecuted'>        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));</span>
 379 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 380 |     | <span class='unexecuted'>        assembly {</span>
 381 |     | <span class='unexecuted'>            let m := mload(0x40) // Grab the free memory pointer.</span>
 382 |     | <span class='unexecuted'>            mstore(m, _DOMAIN_TYPEHASH)</span>
 383 |     | <span class='unexecuted'>            mstore(add(m, 0x20), nameHash)</span>
 384 |     | <span class='unexecuted'>            mstore(add(m, 0x40), _VERSION_HASH)</span>
 385 |     | <span class='unexecuted'>            mstore(add(m, 0x60), chainid())</span>
 386 |     | <span class='unexecuted'>            mstore(add(m, 0x80), address())</span>
 387 |     | <span class='unexecuted'>            result := keccak256(m, 0xa0)</span>
 388 |     | <span class='neutral'>        }</span>
 389 |     | <span class='neutral'>    }</span>
 390 |     | <span class='neutral'></span>
 391 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 392 |     | <span class='neutral'>    /*                  INTERNAL MINT FUNCTIONS                   */</span>
 393 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 394 |     | <span class='neutral'></span>
 395 |     | <span class='neutral'>    /// @dev Mints `amount` tokens to `to`, increasing the total supply.</span>
 396 |     | <span class='neutral'>    ///</span>
 397 |     | <span class='neutral'>    /// Emits a {Transfer} event.</span>
 398 |     | <span class='unexecuted'>    function _mint(address to, uint256 amount) internal virtual {</span>
 399 |     | <span class='neutral'>        _beforeTokenTransfer(address(0), to, amount);</span>
 400 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 401 |     | <span class='neutral'>        assembly {</span>
 402 |     | <span class='unexecuted'>            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)</span>
 403 |     | <span class='unexecuted'>            let totalSupplyAfter := add(totalSupplyBefore, amount)</span>
 404 |     | <span class='neutral'>            // Revert if the total supply overflows.</span>
 405 |     | <span class='unexecuted'>            if lt(totalSupplyAfter, totalSupplyBefore) {</span>
 406 |     | <span class='unexecuted'>                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.</span>
 407 |     | <span class='unexecuted'>                revert(0x1c, 0x04)</span>
 408 |     | <span class='neutral'>            }</span>
 409 |     | <span class='neutral'>            // Store the updated total supply.</span>
 410 |     | <span class='unexecuted'>            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)</span>
 411 |     | <span class='neutral'>            // Compute the balance slot and load its value.</span>
 412 |     | <span class='unexecuted'>            mstore(0x0c, _BALANCE_SLOT_SEED)</span>
 413 |     | <span class='unexecuted'>            mstore(0x00, to)</span>
 414 |     | <span class='unexecuted'>            let toBalanceSlot := keccak256(0x0c, 0x20)</span>
 415 |     | <span class='neutral'>            // Add and store the updated balance.</span>
 416 |     | <span class='unexecuted'>            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))</span>
 417 |     | <span class='neutral'>            // Emit the {Transfer} event.</span>
 418 |     | <span class='unexecuted'>            mstore(0x20, amount)</span>
 419 |     | <span class='unexecuted'>            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))</span>
 420 |     | <span class='neutral'>        }</span>
 421 |     | <span class='neutral'>        _afterTokenTransfer(address(0), to, amount);</span>
 422 |     | <span class='neutral'>    }</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 425 |     | <span class='neutral'>    /*                  INTERNAL BURN FUNCTIONS                   */</span>
 426 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>    /// @dev Burns `amount` tokens from `from`, reducing the total supply.</span>
 429 |     | <span class='neutral'>    ///</span>
 430 |     | <span class='neutral'>    /// Emits a {Transfer} event.</span>
 431 |     | <span class='unexecuted'>    function _burn(address from, uint256 amount) internal virtual {</span>
 432 |     | <span class='neutral'>        _beforeTokenTransfer(from, address(0), amount);</span>
 433 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 434 |     | <span class='neutral'>        assembly {</span>
 435 |     | <span class='neutral'>            // Compute the balance slot and load its value.</span>
 436 |     | <span class='unexecuted'>            mstore(0x0c, _BALANCE_SLOT_SEED)</span>
 437 |     | <span class='unexecuted'>            mstore(0x00, from)</span>
 438 |     | <span class='unexecuted'>            let fromBalanceSlot := keccak256(0x0c, 0x20)</span>
 439 |     | <span class='unexecuted'>            let fromBalance := sload(fromBalanceSlot)</span>
 440 |     | <span class='neutral'>            // Revert if insufficient balance.</span>
 441 |     | <span class='unexecuted'>            if gt(amount, fromBalance) {</span>
 442 |     | <span class='unexecuted'>                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.</span>
 443 |     | <span class='unexecuted'>                revert(0x1c, 0x04)</span>
 444 |     | <span class='neutral'>            }</span>
 445 |     | <span class='neutral'>            // Subtract and store the updated balance.</span>
 446 |     | <span class='unexecuted'>            sstore(fromBalanceSlot, sub(fromBalance, amount))</span>
 447 |     | <span class='neutral'>            // Subtract and store the updated total supply.</span>
 448 |     | <span class='unexecuted'>            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))</span>
 449 |     | <span class='neutral'>            // Emit the {Transfer} event.</span>
 450 |     | <span class='unexecuted'>            mstore(0x00, amount)</span>
 451 |     | <span class='unexecuted'>            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)</span>
 452 |     | <span class='neutral'>        }</span>
 453 |     | <span class='neutral'>        _afterTokenTransfer(from, address(0), amount);</span>
 454 |     | <span class='neutral'>    }</span>
 455 |     | <span class='neutral'></span>
 456 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 457 |     | <span class='neutral'>    /*                INTERNAL TRANSFER FUNCTIONS                 */</span>
 458 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='neutral'>    /// @dev Moves `amount` of tokens from `from` to `to`.</span>
 461 |     | <span class='neutral'>    function _transfer(address from, address to, uint256 amount) internal virtual {</span>
 462 |     | <span class='neutral'>        _beforeTokenTransfer(from, to, amount);</span>
 463 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 464 |     | <span class='neutral'>        assembly {</span>
 465 |     | <span class='neutral'>            let from_ := shl(96, from)</span>
 466 |     | <span class='neutral'>            // Compute the balance slot and load its value.</span>
 467 |     | <span class='neutral'>            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))</span>
 468 |     | <span class='neutral'>            let fromBalanceSlot := keccak256(0x0c, 0x20)</span>
 469 |     | <span class='neutral'>            let fromBalance := sload(fromBalanceSlot)</span>
 470 |     | <span class='neutral'>            // Revert if insufficient balance.</span>
 471 |     | <span class='neutral'>            if gt(amount, fromBalance) {</span>
 472 |     | <span class='neutral'>                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.</span>
 473 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
 474 |     | <span class='neutral'>            }</span>
 475 |     | <span class='neutral'>            // Subtract and store the updated balance.</span>
 476 |     | <span class='neutral'>            sstore(fromBalanceSlot, sub(fromBalance, amount))</span>
 477 |     | <span class='neutral'>            // Compute the balance slot of `to`.</span>
 478 |     | <span class='neutral'>            mstore(0x00, to)</span>
 479 |     | <span class='neutral'>            let toBalanceSlot := keccak256(0x0c, 0x20)</span>
 480 |     | <span class='neutral'>            // Add and store the updated balance of `to`.</span>
 481 |     | <span class='neutral'>            // Will not overflow because the sum of all user balances</span>
 482 |     | <span class='neutral'>            // cannot exceed the maximum uint256 value.</span>
 483 |     | <span class='neutral'>            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))</span>
 484 |     | <span class='neutral'>            // Emit the {Transfer} event.</span>
 485 |     | <span class='neutral'>            mstore(0x20, amount)</span>
 486 |     | <span class='neutral'>            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))</span>
 487 |     | <span class='neutral'>        }</span>
 488 |     | <span class='neutral'>        _afterTokenTransfer(from, to, amount);</span>
 489 |     | <span class='neutral'>    }</span>
 490 |     | <span class='neutral'></span>
 491 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 492 |     | <span class='neutral'>    /*                INTERNAL ALLOWANCE FUNCTIONS                */</span>
 493 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 494 |     | <span class='neutral'></span>
 495 |     | <span class='neutral'>    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.</span>
 496 |     | <span class='neutral'>    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {</span>
 497 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 498 |     | <span class='neutral'>        assembly {</span>
 499 |     | <span class='neutral'>            // Compute the allowance slot and load its value.</span>
 500 |     | <span class='neutral'>            mstore(0x20, spender)</span>
 501 |     | <span class='neutral'>            mstore(0x0c, _ALLOWANCE_SLOT_SEED)</span>
 502 |     | <span class='neutral'>            mstore(0x00, owner)</span>
 503 |     | <span class='neutral'>            let allowanceSlot := keccak256(0x0c, 0x34)</span>
 504 |     | <span class='neutral'>            let allowance_ := sload(allowanceSlot)</span>
 505 |     | <span class='neutral'>            // If the allowance is not the maximum uint256 value.</span>
 506 |     | <span class='neutral'>            if add(allowance_, 1) {</span>
 507 |     | <span class='neutral'>                // Revert if the amount to be transferred exceeds the allowance.</span>
 508 |     | <span class='neutral'>                if gt(amount, allowance_) {</span>
 509 |     | <span class='neutral'>                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.</span>
 510 |     | <span class='neutral'>                    revert(0x1c, 0x04)</span>
 511 |     | <span class='neutral'>                }</span>
 512 |     | <span class='neutral'>                // Subtract and store the updated allowance.</span>
 513 |     | <span class='neutral'>                sstore(allowanceSlot, sub(allowance_, amount))</span>
 514 |     | <span class='neutral'>            }</span>
 515 |     | <span class='neutral'>        }</span>
 516 |     | <span class='neutral'>    }</span>
 517 |     | <span class='neutral'></span>
 518 |     | <span class='neutral'>    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.</span>
 519 |     | <span class='neutral'>    ///</span>
 520 |     | <span class='neutral'>    /// Emits a {Approval} event.</span>
 521 |     | <span class='neutral'>    function _approve(address owner, address spender, uint256 amount) internal virtual {</span>
 522 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 523 |     | <span class='neutral'>        assembly {</span>
 524 |     | <span class='neutral'>            let owner_ := shl(96, owner)</span>
 525 |     | <span class='neutral'>            // Compute the allowance slot and store the amount.</span>
 526 |     | <span class='neutral'>            mstore(0x20, spender)</span>
 527 |     | <span class='neutral'>            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))</span>
 528 |     | <span class='neutral'>            sstore(keccak256(0x0c, 0x34), amount)</span>
 529 |     | <span class='neutral'>            // Emit the {Approval} event.</span>
 530 |     | <span class='neutral'>            mstore(0x00, amount)</span>
 531 |     | <span class='neutral'>            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))</span>
 532 |     | <span class='neutral'>        }</span>
 533 |     | <span class='neutral'>    }</span>
 534 |     | <span class='neutral'></span>
 535 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 536 |     | <span class='neutral'>    /*                     HOOKS TO OVERRIDE                      */</span>
 537 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 538 |     | <span class='neutral'></span>
 539 |     | <span class='neutral'>    /// @dev Hook that is called before any transfer of tokens.</span>
 540 |     | <span class='neutral'>    /// This includes minting and burning.</span>
 541 |     | <span class='unexecuted'>    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 542 |     | <span class='neutral'></span>
 543 |     | <span class='neutral'>    /// @dev Hook that is called after any transfer of tokens.</span>
 544 |     | <span class='neutral'>    /// This includes minting and burning.</span>
 545 |     | <span class='neutral'>    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 546 |     | <span class='neutral'>}</span>
 547 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solady/src/utils/FixedPointMathLib.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>/// @notice Arithmetic library with operations for fixed-point numbers.</span>
    5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)</span>
    6 |     | <span class='neutral'>/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)</span>
    7 |     | <span class='unexecuted'>library FixedPointMathLib {</span>
    8 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
    9 |     | <span class='neutral'>    /*                       CUSTOM ERRORS                        */</span>
   10 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
   11 |     | <span class='neutral'></span>
   12 |     | <span class='neutral'>    /// @dev The operation failed, as the output exceeds the maximum value of uint256.</span>
   13 |     | <span class='neutral'>    error ExpOverflow();</span>
   14 |     | <span class='neutral'></span>
   15 |     | <span class='neutral'>    /// @dev The operation failed, as the output exceeds the maximum value of uint256.</span>
   16 |     | <span class='neutral'>    error FactorialOverflow();</span>
   17 |     | <span class='neutral'></span>
   18 |     | <span class='neutral'>    /// @dev The operation failed, due to an overflow.</span>
   19 |     | <span class='neutral'>    error RPowOverflow();</span>
   20 |     | <span class='neutral'></span>
   21 |     | <span class='neutral'>    /// @dev The mantissa is too big to fit.</span>
   22 |     | <span class='neutral'>    error MantissaOverflow();</span>
   23 |     | <span class='neutral'></span>
   24 |     | <span class='neutral'>    /// @dev The operation failed, due to an multiplication overflow.</span>
   25 |     | <span class='neutral'>    error MulWadFailed();</span>
   26 |     | <span class='neutral'></span>
   27 |     | <span class='neutral'>    /// @dev The operation failed, due to an multiplication overflow.</span>
   28 |     | <span class='neutral'>    error SMulWadFailed();</span>
   29 |     | <span class='neutral'></span>
   30 |     | <span class='neutral'>    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.</span>
   31 |     | <span class='neutral'>    error DivWadFailed();</span>
   32 |     | <span class='neutral'></span>
   33 |     | <span class='neutral'>    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.</span>
   34 |     | <span class='neutral'>    error SDivWadFailed();</span>
   35 |     | <span class='neutral'></span>
   36 |     | <span class='neutral'>    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.</span>
   37 |     | <span class='neutral'>    error MulDivFailed();</span>
   38 |     | <span class='neutral'></span>
   39 |     | <span class='neutral'>    /// @dev The division failed, as the denominator is zero.</span>
   40 |     | <span class='neutral'>    error DivFailed();</span>
   41 |     | <span class='neutral'></span>
   42 |     | <span class='neutral'>    /// @dev The full precision multiply-divide operation failed, either due</span>
   43 |     | <span class='neutral'>    /// to the result being larger than 256 bits, or a division by a zero.</span>
   44 |     | <span class='neutral'>    error FullMulDivFailed();</span>
   45 |     | <span class='neutral'></span>
   46 |     | <span class='neutral'>    /// @dev The output is undefined, as the input is less-than-or-equal to zero.</span>
   47 |     | <span class='neutral'>    error LnWadUndefined();</span>
   48 |     | <span class='neutral'></span>
   49 |     | <span class='neutral'>    /// @dev The input outside the acceptable domain.</span>
   50 |     | <span class='neutral'>    error OutOfDomain();</span>
   51 |     | <span class='neutral'></span>
   52 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
   53 |     | <span class='neutral'>    /*                         CONSTANTS                          */</span>
   54 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
   55 |     | <span class='neutral'></span>
   56 |     | <span class='neutral'>    /// @dev The scalar of ETH and most ERC20s.</span>
   57 |     | <span class='neutral'>    uint256 internal constant WAD = 1e18;</span>
   58 |     | <span class='neutral'></span>
   59 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
   60 |     | <span class='neutral'>    /*              SIMPLIFIED FIXED POINT OPERATIONS             */</span>
   61 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
   62 |     | <span class='neutral'></span>
   63 |     | <span class='neutral'>    /// @dev Equivalent to `(x * y) / WAD` rounded down.</span>
   64 |     | <span class='neutral'>    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
   65 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   66 |     | <span class='neutral'>        assembly {</span>
   67 |     | <span class='neutral'>            // Equivalent to `require(y == 0 || x &lt;= type(uint256).max / y)`.</span>
   68 |     | <span class='neutral'>            if mul(y, gt(x, div(not(0), y))) {</span>
   69 |     | <span class='neutral'>                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.</span>
   70 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
   71 |     | <span class='neutral'>            }</span>
   72 |     | <span class='neutral'>            z := div(mul(x, y), WAD)</span>
   73 |     | <span class='neutral'>        }</span>
   74 |     | <span class='neutral'>    }</span>
   75 |     | <span class='neutral'></span>
   76 |     | <span class='neutral'>    /// @dev Equivalent to `(x * y) / WAD` rounded down.</span>
   77 |     | <span class='neutral'>    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {</span>
   78 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   79 |     | <span class='neutral'>        assembly {</span>
   80 |     | <span class='neutral'>            z := mul(x, y)</span>
   81 |     | <span class='neutral'>            // Equivalent to `require((x == 0 || z / x == y) &amp;&amp; !(x == -1 &amp;&amp; y == type(int256).min))`.</span>
   82 |     | <span class='neutral'>            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {</span>
   83 |     | <span class='neutral'>                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.</span>
   84 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
   85 |     | <span class='neutral'>            }</span>
   86 |     | <span class='neutral'>            z := sdiv(z, WAD)</span>
   87 |     | <span class='neutral'>        }</span>
   88 |     | <span class='neutral'>    }</span>
   89 |     | <span class='neutral'></span>
   90 |     | <span class='neutral'>    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.</span>
   91 |     | <span class='neutral'>    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
   92 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   93 |     | <span class='neutral'>        assembly {</span>
   94 |     | <span class='neutral'>            z := div(mul(x, y), WAD)</span>
   95 |     | <span class='neutral'>        }</span>
   96 |     | <span class='neutral'>    }</span>
   97 |     | <span class='neutral'></span>
   98 |     | <span class='neutral'>    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.</span>
   99 |     | <span class='neutral'>    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {</span>
  100 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  101 |     | <span class='neutral'>        assembly {</span>
  102 |     | <span class='neutral'>            z := sdiv(mul(x, y), WAD)</span>
  103 |     | <span class='neutral'>        }</span>
  104 |     | <span class='neutral'>    }</span>
  105 |     | <span class='neutral'></span>
  106 |     | <span class='neutral'>    /// @dev Equivalent to `(x * y) / WAD` rounded up.</span>
  107 |     | <span class='neutral'>    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  108 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  109 |     | <span class='neutral'>        assembly {</span>
  110 |     | <span class='neutral'>            // Equivalent to `require(y == 0 || x &lt;= type(uint256).max / y)`.</span>
  111 |     | <span class='neutral'>            if mul(y, gt(x, div(not(0), y))) {</span>
  112 |     | <span class='neutral'>                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.</span>
  113 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  114 |     | <span class='neutral'>            }</span>
  115 |     | <span class='neutral'>            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))</span>
  116 |     | <span class='neutral'>        }</span>
  117 |     | <span class='neutral'>    }</span>
  118 |     | <span class='neutral'></span>
  119 |     | <span class='neutral'>    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.</span>
  120 |     | <span class='neutral'>    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  121 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  122 |     | <span class='neutral'>        assembly {</span>
  123 |     | <span class='neutral'>            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))</span>
  124 |     | <span class='neutral'>        }</span>
  125 |     | <span class='neutral'>    }</span>
  126 |     | <span class='neutral'></span>
  127 |     | <span class='neutral'>    /// @dev Equivalent to `(x * WAD) / y` rounded down.</span>
  128 |     | <span class='neutral'>    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  129 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  130 |     | <span class='neutral'>        assembly {</span>
  131 |     | <span class='neutral'>            // Equivalent to `require(y != 0 &amp;&amp; (WAD == 0 || x &lt;= type(uint256).max / WAD))`.</span>
  132 |     | <span class='neutral'>            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {</span>
  133 |     | <span class='neutral'>                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.</span>
  134 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  135 |     | <span class='neutral'>            }</span>
  136 |     | <span class='neutral'>            z := div(mul(x, WAD), y)</span>
  137 |     | <span class='neutral'>        }</span>
  138 |     | <span class='neutral'>    }</span>
  139 |     | <span class='neutral'></span>
  140 |     | <span class='neutral'>    /// @dev Equivalent to `(x * WAD) / y` rounded down.</span>
  141 |     | <span class='neutral'>    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {</span>
  142 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  143 |     | <span class='neutral'>        assembly {</span>
  144 |     | <span class='neutral'>            z := mul(x, WAD)</span>
  145 |     | <span class='neutral'>            // Equivalent to `require(y != 0 &amp;&amp; ((x * WAD) / WAD == x))`.</span>
  146 |     | <span class='neutral'>            if iszero(and(iszero(iszero(y)), eq(sdiv(z, WAD), x))) {</span>
  147 |     | <span class='neutral'>                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.</span>
  148 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  149 |     | <span class='neutral'>            }</span>
  150 |     | <span class='neutral'>            z := sdiv(mul(x, WAD), y)</span>
  151 |     | <span class='neutral'>        }</span>
  152 |     | <span class='neutral'>    }</span>
  153 |     | <span class='neutral'></span>
  154 |     | <span class='neutral'>    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.</span>
  155 |     | <span class='neutral'>    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  156 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  157 |     | <span class='neutral'>        assembly {</span>
  158 |     | <span class='neutral'>            z := div(mul(x, WAD), y)</span>
  159 |     | <span class='neutral'>        }</span>
  160 |     | <span class='neutral'>    }</span>
  161 |     | <span class='neutral'></span>
  162 |     | <span class='neutral'>    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.</span>
  163 |     | <span class='neutral'>    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {</span>
  164 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  165 |     | <span class='neutral'>        assembly {</span>
  166 |     | <span class='neutral'>            z := sdiv(mul(x, WAD), y)</span>
  167 |     | <span class='neutral'>        }</span>
  168 |     | <span class='neutral'>    }</span>
  169 |     | <span class='neutral'></span>
  170 |     | <span class='neutral'>    /// @dev Equivalent to `(x * WAD) / y` rounded up.</span>
  171 |     | <span class='neutral'>    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  172 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  173 |     | <span class='neutral'>        assembly {</span>
  174 |     | <span class='neutral'>            // Equivalent to `require(y != 0 &amp;&amp; (WAD == 0 || x &lt;= type(uint256).max / WAD))`.</span>
  175 |     | <span class='neutral'>            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {</span>
  176 |     | <span class='neutral'>                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.</span>
  177 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  178 |     | <span class='neutral'>            }</span>
  179 |     | <span class='neutral'>            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))</span>
  180 |     | <span class='neutral'>        }</span>
  181 |     | <span class='neutral'>    }</span>
  182 |     | <span class='neutral'></span>
  183 |     | <span class='neutral'>    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.</span>
  184 |     | <span class='neutral'>    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  185 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  186 |     | <span class='neutral'>        assembly {</span>
  187 |     | <span class='neutral'>            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))</span>
  188 |     | <span class='neutral'>        }</span>
  189 |     | <span class='neutral'>    }</span>
  190 |     | <span class='neutral'></span>
  191 |     | <span class='neutral'>    /// @dev Equivalent to `x` to the power of `y`.</span>
  192 |     | <span class='neutral'>    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.</span>
  193 |     | <span class='neutral'>    function powWad(int256 x, int256 y) internal pure returns (int256) {</span>
  194 |     | <span class='neutral'>        // Using `ln(x)` means `x` must be greater than 0.</span>
  195 |     | <span class='neutral'>        return expWad((lnWad(x) * y) / int256(WAD));</span>
  196 |     | <span class='neutral'>    }</span>
  197 |     | <span class='neutral'></span>
  198 |     | <span class='neutral'>    /// @dev Returns `exp(x)`, denominated in `WAD`.</span>
  199 |     | <span class='neutral'>    /// Credit to Remco Bloemen under MIT license: https://2.com/22/exp-ln</span>
  200 |     | <span class='neutral'>    function expWad(int256 x) internal pure returns (int256 r) {</span>
  201 |     | <span class='neutral'>        unchecked {</span>
  202 |     | <span class='neutral'>            // When the result is less than 0.5 we return zero.</span>
  203 |     | <span class='neutral'>            // This happens when `x &lt;= (log(1e-18) * 1e18) ~ -4.15e19`.</span>
  204 |     | <span class='neutral'>            if (x &lt;= -41446531673892822313) return r;</span>
  205 |     | <span class='neutral'></span>
  206 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
  207 |     | <span class='neutral'>            assembly {</span>
  208 |     | <span class='neutral'>                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as</span>
  209 |     | <span class='neutral'>                // an int. This happens when `x &gt;= floor(log((2**255 - 1) / 1e18) * 1e18)  135`.</span>
  210 |     | <span class='neutral'>                if iszero(slt(x, 135305999368893231589)) {</span>
  211 |     | <span class='neutral'>                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.</span>
  212 |     | <span class='neutral'>                    revert(0x1c, 0x04)</span>
  213 |     | <span class='neutral'>                }</span>
  214 |     | <span class='neutral'>            }</span>
  215 |     | <span class='neutral'></span>
  216 |     | <span class='neutral'>            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`</span>
  217 |     | <span class='neutral'>            // for more intermediate precision and a binary basis. This base conversion</span>
  218 |     | <span class='neutral'>            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.</span>
  219 |     | <span class='neutral'>            x = (x &lt;&lt; 78) / 5 ** 18;</span>
  220 |     | <span class='neutral'></span>
  221 |     | <span class='neutral'>            // Reduce range of x to (- ln 2,  ln 2) * 2**96 by factoring out powers</span>
  222 |     | <span class='neutral'>            // of two such that exp(x) = exp(x&#39;) * 2**k, where k is an integer.</span>
  223 |     | <span class='neutral'>            // Solving this gives k = round(x / log(2)) and x&#39; = x - k * log(2).</span>
  224 |     | <span class='neutral'>            int256 k = ((x &lt;&lt; 96) / 54916777467707473351141471128 + 2 ** 95) &gt;&gt; 96;</span>
  225 |     | <span class='neutral'>            x = x - k * 54916777467707473351141471128;</span>
  226 |     | <span class='neutral'></span>
  227 |     | <span class='neutral'>            // `k` is in the range `[-61, 195]`.</span>
  228 |     | <span class='neutral'></span>
  229 |     | <span class='neutral'>            // Evaluate using a (6, 7)-term rational approximation.</span>
  230 |     | <span class='neutral'>            // `p` is made monic, we&#39;ll multiply by a scale factor later.</span>
  231 |     | <span class='neutral'>            int256 y = x + 1346386616545796478920950773328;</span>
  232 |     | <span class='neutral'>            y = ((y * x) &gt;&gt; 96) + 57155421227552351082224309758442;</span>
  233 |     | <span class='neutral'>            int256 p = y + x - 94201549194550492254356042504812;</span>
  234 |     | <span class='neutral'>            p = ((p * y) &gt;&gt; 96) + 28719021644029726153956944680412240;</span>
  235 |     | <span class='neutral'>            p = p * x + (4385272521454847904659076985693276 &lt;&lt; 96);</span>
  236 |     | <span class='neutral'></span>
  237 |     | <span class='neutral'>            // We leave `p` in `2**192` basis so we don&#39;t need to scale it back up for the division.</span>
  238 |     | <span class='neutral'>            int256 q = x - 2855989394907223263936484059900;</span>
  239 |     | <span class='neutral'>            q = ((q * x) &gt;&gt; 96) + 50020603652535783019961831881945;</span>
  240 |     | <span class='neutral'>            q = ((q * x) &gt;&gt; 96) - 533845033583426703283633433725380;</span>
  241 |     | <span class='neutral'>            q = ((q * x) &gt;&gt; 96) + 3604857256930695427073651918091429;</span>
  242 |     | <span class='neutral'>            q = ((q * x) &gt;&gt; 96) - 14423608567350463180887372962807573;</span>
  243 |     | <span class='neutral'>            q = ((q * x) &gt;&gt; 96) + 26449188498355588339934803723976023;</span>
  244 |     | <span class='neutral'></span>
  245 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
  246 |     | <span class='neutral'>            assembly {</span>
  247 |     | <span class='neutral'>                // Div in assembly because solidity adds a zero check despite the unchecked.</span>
  248 |     | <span class='neutral'>                // The q polynomial won&#39;t have zeros in the domain as all its roots are complex.</span>
  249 |     | <span class='neutral'>                // No scaling is necessary because p is already `2**96` too large.</span>
  250 |     | <span class='neutral'>                r := sdiv(p, q)</span>
  251 |     | <span class='neutral'>            }</span>
  252 |     | <span class='neutral'></span>
  253 |     | <span class='neutral'>            // r should be in the range `(0.09, 0.25) * 2**96`.</span>
  254 |     | <span class='neutral'></span>
  255 |     | <span class='neutral'>            // We now need to multiply r by:</span>
  256 |     | <span class='neutral'>            // - The scale factor `s  6.031367120`.</span>
  257 |     | <span class='neutral'>            // - The `2**k` factor from the range reduction.</span>
  258 |     | <span class='neutral'>            // - The `1e18 / 2**96` factor for base conversion.</span>
  259 |     | <span class='neutral'>            // We do this all at once, with an intermediate result in `2**213`</span>
  260 |     | <span class='neutral'>            // basis, so the final right shift is always by a positive amount.</span>
  261 |     | <span class='neutral'>            r = int256(</span>
  262 |     | <span class='neutral'>                (uint256(r) * 3822833074963236453042738258902158003155416615667) &gt;&gt; uint256(195 - k)</span>
  263 |     | <span class='neutral'>            );</span>
  264 |     | <span class='neutral'>        }</span>
  265 |     | <span class='neutral'>    }</span>
  266 |     | <span class='neutral'></span>
  267 |     | <span class='neutral'>    /// @dev Returns `ln(x)`, denominated in `WAD`.</span>
  268 |     | <span class='neutral'>    /// Credit to Remco Bloemen under MIT license: https://2.com/22/exp-ln</span>
  269 |     | <span class='neutral'>    function lnWad(int256 x) internal pure returns (int256 r) {</span>
  270 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  271 |     | <span class='neutral'>        assembly {</span>
  272 |     | <span class='neutral'>            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.</span>
  273 |     | <span class='neutral'>            // We do this by multiplying by `2**96 / 10**18`. But since</span>
  274 |     | <span class='neutral'>            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here</span>
  275 |     | <span class='neutral'>            // and add `ln(2**96 / 10**18)` at the end.</span>
  276 |     | <span class='neutral'></span>
  277 |     | <span class='neutral'>            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.</span>
  278 |     | <span class='neutral'>            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))</span>
  279 |     | <span class='neutral'>            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))</span>
  280 |     | <span class='neutral'>            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))</span>
  281 |     | <span class='neutral'>            r := or(r, shl(4, lt(0xffff, shr(r, x))))</span>
  282 |     | <span class='neutral'>            r := or(r, shl(3, lt(0xff, shr(r, x))))</span>
  283 |     | <span class='neutral'>            // We place the check here for more optimal stack operations.</span>
  284 |     | <span class='neutral'>            if iszero(sgt(x, 0)) {</span>
  285 |     | <span class='neutral'>                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.</span>
  286 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  287 |     | <span class='neutral'>            }</span>
  288 |     | <span class='neutral'>            // forgefmt: disable-next-item</span>
  289 |     | <span class='neutral'>            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),</span>
  290 |     | <span class='neutral'>                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))</span>
  291 |     | <span class='neutral'></span>
  292 |     | <span class='neutral'>            // Reduce range of x to (1, 2) * 2**96</span>
  293 |     | <span class='neutral'>            // ln(2^k * x) = k * ln(2) + ln(x)</span>
  294 |     | <span class='neutral'>            x := shr(159, shl(r, x))</span>
  295 |     | <span class='neutral'></span>
  296 |     | <span class='neutral'>            // Evaluate using a (8, 8)-term rational approximation.</span>
  297 |     | <span class='neutral'>            // `p` is made monic, we will multiply by a scale factor later.</span>
  298 |     | <span class='neutral'>            // forgefmt: disable-next-item</span>
  299 |     | <span class='neutral'>            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.</span>
  300 |     | <span class='neutral'>                sar(96, mul(add(43456485725739037958740375743393,</span>
  301 |     | <span class='neutral'>                sar(96, mul(add(24828157081833163892658089445524,</span>
  302 |     | <span class='neutral'>                sar(96, mul(add(3273285459638523848632254066296,</span>
  303 |     | <span class='neutral'>                    x), x))), x))), x)), 11111509109440967052023855526967)</span>
  304 |     | <span class='neutral'>            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)</span>
  305 |     | <span class='neutral'>            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)</span>
  306 |     | <span class='neutral'>            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))</span>
  307 |     | <span class='neutral'>            // We leave `p` in `2**192` basis so we don&#39;t need to scale it back up for the division.</span>
  308 |     | <span class='neutral'></span>
  309 |     | <span class='neutral'>            // `q` is monic by convention.</span>
  310 |     | <span class='neutral'>            let q := add(5573035233440673466300451813936, x)</span>
  311 |     | <span class='neutral'>            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))</span>
  312 |     | <span class='neutral'>            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))</span>
  313 |     | <span class='neutral'>            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))</span>
  314 |     | <span class='neutral'>            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))</span>
  315 |     | <span class='neutral'>            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))</span>
  316 |     | <span class='neutral'>            q := add(909429971244387300277376558375, sar(96, mul(x, q)))</span>
  317 |     | <span class='neutral'></span>
  318 |     | <span class='neutral'>            // `p / q` is in the range `(0, 0.125) * 2**96`.</span>
  319 |     | <span class='neutral'></span>
  320 |     | <span class='neutral'>            // Finalization, we need to:</span>
  321 |     | <span class='neutral'>            // - Multiply by the scale factor `s = 5.549`.</span>
  322 |     | <span class='neutral'>            // - Add `ln(2**96 / 10**18)`.</span>
  323 |     | <span class='neutral'>            // - Add `k * ln(2)`.</span>
  324 |     | <span class='neutral'>            // - Multiply by `10**18 / 2**96 = 5**18 &gt;&gt; 78`.</span>
  325 |     | <span class='neutral'></span>
  326 |     | <span class='neutral'>            // The q polynomial is known not to have zeros in the domain.</span>
  327 |     | <span class='neutral'>            // No scaling required because p is already `2**96` too large.</span>
  328 |     | <span class='neutral'>            p := sdiv(p, q)</span>
  329 |     | <span class='neutral'>            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.</span>
  330 |     | <span class='neutral'>            p := mul(1677202110996718588342820967067443963516166, p)</span>
  331 |     | <span class='neutral'>            // Add `ln(2) * k * 5**18 * 2**192`.</span>
  332 |     | <span class='neutral'>            // forgefmt: disable-next-item</span>
  333 |     | <span class='neutral'>            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)</span>
  334 |     | <span class='neutral'>            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.</span>
  335 |     | <span class='neutral'>            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)</span>
  336 |     | <span class='neutral'>            // Base conversion: mul `2**18 / 2**192`.</span>
  337 |     | <span class='neutral'>            r := sar(174, p)</span>
  338 |     | <span class='neutral'>        }</span>
  339 |     | <span class='neutral'>    }</span>
  340 |     | <span class='neutral'></span>
  341 |     | <span class='neutral'>    /// @dev Returns `W_0(x)`, denominated in `WAD`.</span>
  342 |     | <span class='neutral'>    /// See: https://en.wikipedia.org/wiki/Lambert_W_function</span>
  343 |     | <span class='neutral'>    /// a.k.a. Product log function. This is an approximation of the principal branch.</span>
  344 |     | <span class='neutral'>    function lambertW0Wad(int256 x) internal pure returns (int256 w) {</span>
  345 |     | <span class='neutral'>        // forgefmt: disable-next-item</span>
  346 |     | <span class='neutral'>        unchecked {</span>
  347 |     | <span class='neutral'>            if ((w = x) &lt;= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.</span>
  348 |     | <span class='neutral'>            int256 wad = int256(WAD);</span>
  349 |     | <span class='neutral'>            int256 p = x;</span>
  350 |     | <span class='neutral'>            uint256 c; // Whether we need to avoid catastrophic cancellation.</span>
  351 |     | <span class='neutral'>            uint256 i = 4; // Number of iterations.</span>
  352 |     | <span class='neutral'>            if (w &lt;= 0x1ffffffffffff) {</span>
  353 |     | <span class='neutral'>                if (-0x4000000000000 &lt;= w) {</span>
  354 |     | <span class='neutral'>                    i = 1; // Inputs near zero only take one step to converge.</span>
  355 |     | <span class='neutral'>                } else if (w &lt;= -0x3ffffffffffffff) {</span>
  356 |     | <span class='neutral'>                    i = 32; // Inputs near `-1/e` take very long to converge.</span>
  357 |     | <span class='neutral'>                }</span>
  358 |     | <span class='neutral'>            } else if (w &gt;&gt; 63 == 0) {</span>
  359 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
  360 |     | <span class='neutral'>                assembly {</span>
  361 |     | <span class='neutral'>                    // Inline log2 for more performance, since the range is small.</span>
  362 |     | <span class='neutral'>                    let v := shr(49, w)</span>
  363 |     | <span class='neutral'>                    let l := shl(3, lt(0xff, v))</span>
  364 |     | <span class='neutral'>                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),</span>
  365 |     | <span class='neutral'>                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)</span>
  366 |     | <span class='neutral'>                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))</span>
  367 |     | <span class='neutral'>                    c := gt(l, 60)</span>
  368 |     | <span class='neutral'>                    i := add(2, add(gt(l, 53), c))</span>
  369 |     | <span class='neutral'>                }</span>
  370 |     | <span class='neutral'>            } else {</span>
  371 |     | <span class='neutral'>                int256 ll = lnWad(w = lnWad(w));</span>
  372 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
  373 |     | <span class='neutral'>                assembly {</span>
  374 |     | <span class='neutral'>                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.</span>
  375 |     | <span class='neutral'>                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))</span>
  376 |     | <span class='neutral'>                    i := add(3, iszero(shr(68, x)))</span>
  377 |     | <span class='neutral'>                    c := iszero(shr(143, x))</span>
  378 |     | <span class='neutral'>                }</span>
  379 |     | <span class='neutral'>                if (c == 0) {</span>
  380 |     | <span class='neutral'>                    do { // If `x` is big, use Newton&#39;s so that intermediate values won&#39;t overflow.</span>
  381 |     | <span class='neutral'>                        int256 e = expWad(w);</span>
  382 |     | <span class='neutral'>                        /// @solidity memory-safe-assembly</span>
  383 |     | <span class='neutral'>                        assembly {</span>
  384 |     | <span class='neutral'>                            let t := mul(w, div(e, wad))</span>
  385 |     | <span class='neutral'>                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))</span>
  386 |     | <span class='neutral'>                        }</span>
  387 |     | <span class='neutral'>                        if (p &lt;= w) break;</span>
  388 |     | <span class='neutral'>                        p = w;</span>
  389 |     | <span class='neutral'>                    } while (--i != 0);</span>
  390 |     | <span class='neutral'>                    /// @solidity memory-safe-assembly</span>
  391 |     | <span class='neutral'>                    assembly {</span>
  392 |     | <span class='neutral'>                        w := sub(w, sgt(w, 2))</span>
  393 |     | <span class='neutral'>                    }</span>
  394 |     | <span class='neutral'>                    return w;</span>
  395 |     | <span class='neutral'>                }</span>
  396 |     | <span class='neutral'>            }</span>
  397 |     | <span class='neutral'>            do { // Otherwise, use Halley&#39;s for faster convergence.</span>
  398 |     | <span class='neutral'>                int256 e = expWad(w);</span>
  399 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
  400 |     | <span class='neutral'>                assembly {</span>
  401 |     | <span class='neutral'>                    let t := add(w, wad)</span>
  402 |     | <span class='neutral'>                    let s := sub(mul(w, e), mul(x, wad))</span>
  403 |     | <span class='neutral'>                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))</span>
  404 |     | <span class='neutral'>                }</span>
  405 |     | <span class='neutral'>                if (p &lt;= w) break;</span>
  406 |     | <span class='neutral'>                p = w;</span>
  407 |     | <span class='neutral'>            } while (--i != c);</span>
  408 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
  409 |     | <span class='neutral'>            assembly {</span>
  410 |     | <span class='neutral'>                w := sub(w, sgt(w, 2))</span>
  411 |     | <span class='neutral'>            }</span>
  412 |     | <span class='neutral'>            // For certain ranges of `x`, we&#39;ll use the quadratic-rate recursive formula of</span>
  413 |     | <span class='neutral'>            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.</span>
  414 |     | <span class='neutral'>            if (c != 0) {</span>
  415 |     | <span class='neutral'>                int256 t = w | 1;</span>
  416 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
  417 |     | <span class='neutral'>                assembly {</span>
  418 |     | <span class='neutral'>                    x := sdiv(mul(x, wad), t)</span>
  419 |     | <span class='neutral'>                }</span>
  420 |     | <span class='neutral'>                x = (t * (wad + lnWad(x)));</span>
  421 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
  422 |     | <span class='neutral'>                assembly {</span>
  423 |     | <span class='neutral'>                    w := sdiv(x, add(wad, t))</span>
  424 |     | <span class='neutral'>                }</span>
  425 |     | <span class='neutral'>            }</span>
  426 |     | <span class='neutral'>        }</span>
  427 |     | <span class='neutral'>    }</span>
  428 |     | <span class='neutral'></span>
  429 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  430 |     | <span class='neutral'>    /*                  GENERAL NUMBER UTILITIES                  */</span>
  431 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  432 |     | <span class='neutral'></span>
  433 |     | <span class='neutral'>    /// @dev Calculates `floor(x * y / d)` with full precision.</span>
  434 |     | <span class='neutral'>    /// Throws if result overflows a uint256 or when `d` is zero.</span>
  435 |     | <span class='neutral'>    /// Credit to Remco Bloemen under MIT license: https://2.com/21/muldiv</span>
  436 |     | <span class='neutral'>    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {</span>
  437 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  438 |     | <span class='neutral'>        assembly {</span>
  439 |     | <span class='neutral'>            for {} 1 {} {</span>
  440 |     | <span class='neutral'>                // 512-bit multiply `[p1 p0] = x * y`.</span>
  441 |     | <span class='neutral'>                // Compute the product mod `2**256` and mod `2**256 - 1`</span>
  442 |     | <span class='neutral'>                // then use the Chinese Remainder Theorem to reconstruct</span>
  443 |     | <span class='neutral'>                // the 512 bit result. The result is stored in two 256</span>
  444 |     | <span class='neutral'>                // variables such that `product = p1 * 2**256 + p0`.</span>
  445 |     | <span class='neutral'></span>
  446 |     | <span class='neutral'>                // Least significant 256 bits of the product.</span>
  447 |     | <span class='neutral'>                result := mul(x, y) // Temporarily use `result` as `p0` to save gas.</span>
  448 |     | <span class='neutral'>                let mm := mulmod(x, y, not(0))</span>
  449 |     | <span class='neutral'>                // Most significant 256 bits of the product.</span>
  450 |     | <span class='neutral'>                let p1 := sub(mm, add(result, lt(mm, result)))</span>
  451 |     | <span class='neutral'></span>
  452 |     | <span class='neutral'>                // Handle non-overflow cases, 256 by 256 division.</span>
  453 |     | <span class='neutral'>                if iszero(p1) {</span>
  454 |     | <span class='neutral'>                    if iszero(d) {</span>
  455 |     | <span class='neutral'>                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.</span>
  456 |     | <span class='neutral'>                        revert(0x1c, 0x04)</span>
  457 |     | <span class='neutral'>                    }</span>
  458 |     | <span class='neutral'>                    result := div(result, d)</span>
  459 |     | <span class='neutral'>                    break</span>
  460 |     | <span class='neutral'>                }</span>
  461 |     | <span class='neutral'></span>
  462 |     | <span class='neutral'>                // Make sure the result is less than `2**256`. Also prevents `d == 0`.</span>
  463 |     | <span class='neutral'>                if iszero(gt(d, p1)) {</span>
  464 |     | <span class='neutral'>                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.</span>
  465 |     | <span class='neutral'>                    revert(0x1c, 0x04)</span>
  466 |     | <span class='neutral'>                }</span>
  467 |     | <span class='neutral'></span>
  468 |     | <span class='neutral'>                /*------------------- 512 by 256 division --------------------*/</span>
  469 |     | <span class='neutral'></span>
  470 |     | <span class='neutral'>                // Make division exact by subtracting the remainder from `[p1 p0]`.</span>
  471 |     | <span class='neutral'>                // Compute remainder using mulmod.</span>
  472 |     | <span class='neutral'>                let r := mulmod(x, y, d)</span>
  473 |     | <span class='neutral'>                // `t` is the least significant bit of `d`.</span>
  474 |     | <span class='neutral'>                // Always greater or equal to 1.</span>
  475 |     | <span class='neutral'>                let t := and(d, sub(0, d))</span>
  476 |     | <span class='neutral'>                // Divide `d` by `t`, which is a power of two.</span>
  477 |     | <span class='neutral'>                d := div(d, t)</span>
  478 |     | <span class='neutral'>                // Invert `d mod 2**256`</span>
  479 |     | <span class='neutral'>                // Now that `d` is an odd number, it has an inverse</span>
  480 |     | <span class='neutral'>                // modulo `2**256` such that `d * inv = 1 mod 2**256`.</span>
  481 |     | <span class='neutral'>                // Compute the inverse by starting with a seed that is correct</span>
  482 |     | <span class='neutral'>                // correct for four bits. That is, `d * inv = 1 mod 2**4`.</span>
  483 |     | <span class='neutral'>                let inv := xor(2, mul(3, d))</span>
  484 |     | <span class='neutral'>                // Now use Newton-Raphson iteration to improve the precision.</span>
  485 |     | <span class='neutral'>                // Thanks to Hensel&#39;s lifting lemma, this also works in modular</span>
  486 |     | <span class='neutral'>                // arithmetic, doubling the correct bits in each step.</span>
  487 |     | <span class='neutral'>                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8</span>
  488 |     | <span class='neutral'>                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16</span>
  489 |     | <span class='neutral'>                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32</span>
  490 |     | <span class='neutral'>                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64</span>
  491 |     | <span class='neutral'>                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128</span>
  492 |     | <span class='neutral'>                result :=</span>
  493 |     | <span class='neutral'>                    mul(</span>
  494 |     | <span class='neutral'>                        // Divide [p1 p0] by the factors of two.</span>
  495 |     | <span class='neutral'>                        // Shift in bits from `p1` into `p0`. For this we need</span>
  496 |     | <span class='neutral'>                        // to flip `t` such that it is `2**256 / t`.</span>
  497 |     | <span class='neutral'>                        or(</span>
  498 |     | <span class='neutral'>                            mul(sub(p1, gt(r, result)), add(div(sub(0, t), t), 1)),</span>
  499 |     | <span class='neutral'>                            div(sub(result, r), t)</span>
  500 |     | <span class='neutral'>                        ),</span>
  501 |     | <span class='neutral'>                        // inverse mod 2**256</span>
  502 |     | <span class='neutral'>                        mul(inv, sub(2, mul(d, inv)))</span>
  503 |     | <span class='neutral'>                    )</span>
  504 |     | <span class='neutral'>                break</span>
  505 |     | <span class='neutral'>            }</span>
  506 |     | <span class='neutral'>        }</span>
  507 |     | <span class='neutral'>    }</span>
  508 |     | <span class='neutral'></span>
  509 |     | <span class='neutral'>    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.</span>
  510 |     | <span class='neutral'>    /// Throws if result overflows a uint256 or when `d` is zero.</span>
  511 |     | <span class='neutral'>    /// Credit to Uniswap-v3-core under MIT license:</span>
  512 |     | <span class='neutral'>    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol</span>
  513 |     | <span class='neutral'>    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {</span>
  514 |     | <span class='neutral'>        result = fullMulDiv(x, y, d);</span>
  515 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  516 |     | <span class='neutral'>        assembly {</span>
  517 |     | <span class='neutral'>            if mulmod(x, y, d) {</span>
  518 |     | <span class='neutral'>                result := add(result, 1)</span>
  519 |     | <span class='neutral'>                if iszero(result) {</span>
  520 |     | <span class='neutral'>                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.</span>
  521 |     | <span class='neutral'>                    revert(0x1c, 0x04)</span>
  522 |     | <span class='neutral'>                }</span>
  523 |     | <span class='neutral'>            }</span>
  524 |     | <span class='neutral'>        }</span>
  525 |     | <span class='neutral'>    }</span>
  526 |     | <span class='neutral'></span>
  527 |     | <span class='neutral'>    /// @dev Returns `floor(x * y / d)`.</span>
  528 |     | <span class='neutral'>    /// Reverts if `x * y` overflows, or `d` is zero.</span>
  529 |     | <span class='neutral'>    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {</span>
  530 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  531 |     | <span class='neutral'>        assembly {</span>
  532 |     | <span class='neutral'>            // Equivalent to require(d != 0 &amp;&amp; (y == 0 || x &lt;= type(uint256).max / y))</span>
  533 |     | <span class='neutral'>            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {</span>
  534 |     | <span class='neutral'>                mstore(0x00, 0xad251c27) // `MulDivFailed()`.</span>
  535 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  536 |     | <span class='neutral'>            }</span>
  537 |     | <span class='neutral'>            z := div(mul(x, y), d)</span>
  538 |     | <span class='neutral'>        }</span>
  539 |     | <span class='neutral'>    }</span>
  540 |     | <span class='neutral'></span>
  541 |     | <span class='neutral'>    /// @dev Returns `ceil(x * y / d)`.</span>
  542 |     | <span class='neutral'>    /// Reverts if `x * y` overflows, or `d` is zero.</span>
  543 |     | <span class='neutral'>    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {</span>
  544 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  545 |     | <span class='neutral'>        assembly {</span>
  546 |     | <span class='neutral'>            // Equivalent to require(d != 0 &amp;&amp; (y == 0 || x &lt;= type(uint256).max / y))</span>
  547 |     | <span class='neutral'>            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {</span>
  548 |     | <span class='neutral'>                mstore(0x00, 0xad251c27) // `MulDivFailed()`.</span>
  549 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  550 |     | <span class='neutral'>            }</span>
  551 |     | <span class='neutral'>            z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))</span>
  552 |     | <span class='neutral'>        }</span>
  553 |     | <span class='neutral'>    }</span>
  554 |     | <span class='neutral'></span>
  555 |     | <span class='neutral'>    /// @dev Returns `ceil(x / d)`.</span>
  556 |     | <span class='neutral'>    /// Reverts if `d` is zero.</span>
  557 |     | <span class='neutral'>    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {</span>
  558 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  559 |     | <span class='neutral'>        assembly {</span>
  560 |     | <span class='neutral'>            if iszero(d) {</span>
  561 |     | <span class='neutral'>                mstore(0x00, 0x65244e4e) // `DivFailed()`.</span>
  562 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  563 |     | <span class='neutral'>            }</span>
  564 |     | <span class='neutral'>            z := add(iszero(iszero(mod(x, d))), div(x, d))</span>
  565 |     | <span class='neutral'>        }</span>
  566 |     | <span class='neutral'>    }</span>
  567 |     | <span class='neutral'></span>
  568 |     | <span class='neutral'>    /// @dev Returns `max(0, x - y)`.</span>
  569 |     | <span class='neutral'>    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  570 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  571 |     | <span class='neutral'>        assembly {</span>
  572 |     | <span class='neutral'>            z := mul(gt(x, y), sub(x, y))</span>
  573 |     | <span class='neutral'>        }</span>
  574 |     | <span class='neutral'>    }</span>
  575 |     | <span class='neutral'></span>
  576 |     | <span class='neutral'>    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.</span>
  577 |     | <span class='neutral'>    /// Reverts if the computation overflows.</span>
  578 |     | <span class='neutral'>    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {</span>
  579 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  580 |     | <span class='neutral'>        assembly {</span>
  581 |     | <span class='neutral'>            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.</span>
  582 |     | <span class='neutral'>            if x {</span>
  583 |     | <span class='neutral'>                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`</span>
  584 |     | <span class='neutral'>                let half := shr(1, b) // Divide `b` by 2.</span>
  585 |     | <span class='neutral'>                // Divide `y` by 2 every iteration.</span>
  586 |     | <span class='neutral'>                for { y := shr(1, y) } y { y := shr(1, y) } {</span>
  587 |     | <span class='neutral'>                    let xx := mul(x, x) // Store x squared.</span>
  588 |     | <span class='neutral'>                    let xxRound := add(xx, half) // Round to the nearest number.</span>
  589 |     | <span class='neutral'>                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.</span>
  590 |     | <span class='neutral'>                    if or(lt(xxRound, xx), shr(128, x)) {</span>
  591 |     | <span class='neutral'>                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.</span>
  592 |     | <span class='neutral'>                        revert(0x1c, 0x04)</span>
  593 |     | <span class='neutral'>                    }</span>
  594 |     | <span class='neutral'>                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.</span>
  595 |     | <span class='neutral'>                    // If `y` is odd:</span>
  596 |     | <span class='neutral'>                    if and(y, 1) {</span>
  597 |     | <span class='neutral'>                        let zx := mul(z, x) // Compute `z * x`.</span>
  598 |     | <span class='neutral'>                        let zxRound := add(zx, half) // Round to the nearest number.</span>
  599 |     | <span class='neutral'>                        // If `z * x` overflowed or `zx + half` overflowed:</span>
  600 |     | <span class='neutral'>                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {</span>
  601 |     | <span class='neutral'>                            // Revert if `x` is non-zero.</span>
  602 |     | <span class='neutral'>                            if iszero(iszero(x)) {</span>
  603 |     | <span class='neutral'>                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.</span>
  604 |     | <span class='neutral'>                                revert(0x1c, 0x04)</span>
  605 |     | <span class='neutral'>                            }</span>
  606 |     | <span class='neutral'>                        }</span>
  607 |     | <span class='neutral'>                        z := div(zxRound, b) // Return properly scaled `zxRound`.</span>
  608 |     | <span class='neutral'>                    }</span>
  609 |     | <span class='neutral'>                }</span>
  610 |     | <span class='neutral'>            }</span>
  611 |     | <span class='neutral'>        }</span>
  612 |     | <span class='neutral'>    }</span>
  613 |     | <span class='neutral'></span>
  614 |     | <span class='neutral'>    /// @dev Returns the square root of `x`.</span>
  615 |     | <span class='neutral'>    function sqrt(uint256 x) internal pure returns (uint256 z) {</span>
  616 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  617 |     | <span class='neutral'>        assembly {</span>
  618 |     | <span class='neutral'>            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.</span>
  619 |     | <span class='neutral'>            z := 181 // The &quot;correct&quot; value is 1, but this saves a multiplication later.</span>
  620 |     | <span class='neutral'></span>
  621 |     | <span class='neutral'>            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad</span>
  622 |     | <span class='neutral'>            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.</span>
  623 |     | <span class='neutral'></span>
  624 |     | <span class='neutral'>            // Let `y = x / 2**r`. We check `y &gt;= 2**(k + 8)`</span>
  625 |     | <span class='neutral'>            // but shift right by `k` bits to ensure that if `x &gt;= 256`, then `y &gt;= 256`.</span>
  626 |     | <span class='neutral'>            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))</span>
  627 |     | <span class='neutral'>            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))</span>
  628 |     | <span class='neutral'>            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))</span>
  629 |     | <span class='neutral'>            r := or(r, shl(4, lt(0xffffff, shr(r, x))))</span>
  630 |     | <span class='neutral'>            z := shl(shr(1, r), z)</span>
  631 |     | <span class='neutral'></span>
  632 |     | <span class='neutral'>            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could</span>
  633 |     | <span class='neutral'>            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.</span>
  634 |     | <span class='neutral'>            // We ensured `y &gt;= 256` so that the relative difference between `y` and `y+1` is small.</span>
  635 |     | <span class='neutral'>            // That&#39;s not possible if `x &lt; 256` but we can just verify those cases exhaustively.</span>
  636 |     | <span class='neutral'></span>
  637 |     | <span class='neutral'>            // Now, `z*z*y &lt;= x &lt; z*z*(y+1)`, and `y &lt;= 2**(16+8)`, and either `y &gt;= 256`, or `x &lt; 256`.</span>
  638 |     | <span class='neutral'>            // Correctness can be checked exhaustively for `x &lt; 256`, so we assume `y &gt;= 256`.</span>
  639 |     | <span class='neutral'>            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.</span>
  640 |     | <span class='neutral'></span>
  641 |     | <span class='neutral'>            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`</span>
  642 |     | <span class='neutral'>            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,</span>
  643 |     | <span class='neutral'>            // with largest error when `s = 1` and when `s = 256` or `1/256`.</span>
  644 |     | <span class='neutral'></span>
  645 |     | <span class='neutral'>            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.</span>
  646 |     | <span class='neutral'>            // Then we can estimate `sqrt(y)` using</span>
  647 |     | <span class='neutral'>            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.</span>
  648 |     | <span class='neutral'></span>
  649 |     | <span class='neutral'>            // There is no overflow risk here since `y &lt; 2**136` after the first branch above.</span>
  650 |     | <span class='neutral'>            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.</span>
  651 |     | <span class='neutral'></span>
  652 |     | <span class='neutral'>            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.</span>
  653 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
  654 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
  655 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
  656 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
  657 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
  658 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
  659 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
  660 |     | <span class='neutral'></span>
  661 |     | <span class='neutral'>            // If `x+1` is a perfect square, the Babylonian method cycles between</span>
  662 |     | <span class='neutral'>            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.</span>
  663 |     | <span class='neutral'>            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division</span>
  664 |     | <span class='neutral'>            z := sub(z, lt(div(x, z), z))</span>
  665 |     | <span class='neutral'>        }</span>
  666 |     | <span class='neutral'>    }</span>
  667 |     | <span class='neutral'></span>
  668 |     | <span class='neutral'>    /// @dev Returns the cube root of `x`.</span>
  669 |     | <span class='neutral'>    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:</span>
  670 |     | <span class='neutral'>    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy</span>
  671 |     | <span class='neutral'>    function cbrt(uint256 x) internal pure returns (uint256 z) {</span>
  672 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  673 |     | <span class='neutral'>        assembly {</span>
  674 |     | <span class='neutral'>            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))</span>
  675 |     | <span class='neutral'>            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))</span>
  676 |     | <span class='neutral'>            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))</span>
  677 |     | <span class='neutral'>            r := or(r, shl(4, lt(0xffff, shr(r, x))))</span>
  678 |     | <span class='neutral'>            r := or(r, shl(3, lt(0xff, shr(r, x))))</span>
  679 |     | <span class='neutral'></span>
  680 |     | <span class='neutral'>            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))</span>
  681 |     | <span class='neutral'></span>
  682 |     | <span class='neutral'>            z := div(add(add(div(x, mul(z, z)), z), z), 3)</span>
  683 |     | <span class='neutral'>            z := div(add(add(div(x, mul(z, z)), z), z), 3)</span>
  684 |     | <span class='neutral'>            z := div(add(add(div(x, mul(z, z)), z), z), 3)</span>
  685 |     | <span class='neutral'>            z := div(add(add(div(x, mul(z, z)), z), z), 3)</span>
  686 |     | <span class='neutral'>            z := div(add(add(div(x, mul(z, z)), z), z), 3)</span>
  687 |     | <span class='neutral'>            z := div(add(add(div(x, mul(z, z)), z), z), 3)</span>
  688 |     | <span class='neutral'>            z := div(add(add(div(x, mul(z, z)), z), z), 3)</span>
  689 |     | <span class='neutral'></span>
  690 |     | <span class='neutral'>            z := sub(z, lt(div(x, mul(z, z)), z))</span>
  691 |     | <span class='neutral'>        }</span>
  692 |     | <span class='neutral'>    }</span>
  693 |     | <span class='neutral'></span>
  694 |     | <span class='neutral'>    /// @dev Returns the square root of `x`, denominated in `WAD`.</span>
  695 |     | <span class='neutral'>    function sqrtWad(uint256 x) internal pure returns (uint256 z) {</span>
  696 |     | <span class='neutral'>        unchecked {</span>
  697 |     | <span class='neutral'>            z = 10 ** 9;</span>
  698 |     | <span class='neutral'>            if (x &lt;= type(uint256).max / 10 ** 36 - 1) {</span>
  699 |     | <span class='neutral'>                x *= 10 ** 18;</span>
  700 |     | <span class='neutral'>                z = 1;</span>
  701 |     | <span class='neutral'>            }</span>
  702 |     | <span class='neutral'>            z *= sqrt(x);</span>
  703 |     | <span class='neutral'>        }</span>
  704 |     | <span class='neutral'>    }</span>
  705 |     | <span class='neutral'></span>
  706 |     | <span class='neutral'>    /// @dev Returns the cube root of `x`, denominated in `WAD`.</span>
  707 |     | <span class='neutral'>    function cbrtWad(uint256 x) internal pure returns (uint256 z) {</span>
  708 |     | <span class='neutral'>        unchecked {</span>
  709 |     | <span class='neutral'>            z = 10 ** 12;</span>
  710 |     | <span class='neutral'>            if (x &lt;= (type(uint256).max / 10 ** 36) * 10 ** 18 - 1) {</span>
  711 |     | <span class='neutral'>                if (x &gt;= type(uint256).max / 10 ** 36) {</span>
  712 |     | <span class='neutral'>                    x *= 10 ** 18;</span>
  713 |     | <span class='neutral'>                    z = 10 ** 6;</span>
  714 |     | <span class='neutral'>                } else {</span>
  715 |     | <span class='neutral'>                    x *= 10 ** 36;</span>
  716 |     | <span class='neutral'>                    z = 1;</span>
  717 |     | <span class='neutral'>                }</span>
  718 |     | <span class='neutral'>            }</span>
  719 |     | <span class='neutral'>            z *= cbrt(x);</span>
  720 |     | <span class='neutral'>        }</span>
  721 |     | <span class='neutral'>    }</span>
  722 |     | <span class='neutral'></span>
  723 |     | <span class='neutral'>    /// @dev Returns the factorial of `x`.</span>
  724 |     | <span class='neutral'>    function factorial(uint256 x) internal pure returns (uint256 result) {</span>
  725 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  726 |     | <span class='neutral'>        assembly {</span>
  727 |     | <span class='neutral'>            if iszero(lt(x, 58)) {</span>
  728 |     | <span class='neutral'>                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.</span>
  729 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  730 |     | <span class='neutral'>            }</span>
  731 |     | <span class='neutral'>            for { result := 1 } x { x := sub(x, 1) } { result := mul(result, x) }</span>
  732 |     | <span class='neutral'>        }</span>
  733 |     | <span class='neutral'>    }</span>
  734 |     | <span class='neutral'></span>
  735 |     | <span class='neutral'>    /// @dev Returns the log2 of `x`.</span>
  736 |     | <span class='neutral'>    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.</span>
  737 |     | <span class='neutral'>    /// Returns 0 if `x` is zero.</span>
  738 |     | <span class='neutral'>    function log2(uint256 x) internal pure returns (uint256 r) {</span>
  739 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  740 |     | <span class='neutral'>        assembly {</span>
  741 |     | <span class='neutral'>            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))</span>
  742 |     | <span class='neutral'>            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))</span>
  743 |     | <span class='neutral'>            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))</span>
  744 |     | <span class='neutral'>            r := or(r, shl(4, lt(0xffff, shr(r, x))))</span>
  745 |     | <span class='neutral'>            r := or(r, shl(3, lt(0xff, shr(r, x))))</span>
  746 |     | <span class='neutral'>            // forgefmt: disable-next-item</span>
  747 |     | <span class='neutral'>            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),</span>
  748 |     | <span class='neutral'>                0x0706060506020504060203020504030106050205030304010505030400000000))</span>
  749 |     | <span class='neutral'>        }</span>
  750 |     | <span class='neutral'>    }</span>
  751 |     | <span class='neutral'></span>
  752 |     | <span class='neutral'>    /// @dev Returns the log2 of `x`, rounded up.</span>
  753 |     | <span class='neutral'>    /// Returns 0 if `x` is zero.</span>
  754 |     | <span class='neutral'>    function log2Up(uint256 x) internal pure returns (uint256 r) {</span>
  755 |     | <span class='neutral'>        r = log2(x);</span>
  756 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  757 |     | <span class='neutral'>        assembly {</span>
  758 |     | <span class='neutral'>            r := add(r, lt(shl(r, 1), x))</span>
  759 |     | <span class='neutral'>        }</span>
  760 |     | <span class='neutral'>    }</span>
  761 |     | <span class='neutral'></span>
  762 |     | <span class='neutral'>    /// @dev Returns the log10 of `x`.</span>
  763 |     | <span class='neutral'>    /// Returns 0 if `x` is zero.</span>
  764 |     | <span class='neutral'>    function log10(uint256 x) internal pure returns (uint256 r) {</span>
  765 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  766 |     | <span class='neutral'>        assembly {</span>
  767 |     | <span class='neutral'>            if iszero(lt(x, 100000000000000000000000000000000000000)) {</span>
  768 |     | <span class='neutral'>                x := div(x, 100000000000000000000000000000000000000)</span>
  769 |     | <span class='neutral'>                r := 38</span>
  770 |     | <span class='neutral'>            }</span>
  771 |     | <span class='neutral'>            if iszero(lt(x, 100000000000000000000)) {</span>
  772 |     | <span class='neutral'>                x := div(x, 100000000000000000000)</span>
  773 |     | <span class='neutral'>                r := add(r, 20)</span>
  774 |     | <span class='neutral'>            }</span>
  775 |     | <span class='neutral'>            if iszero(lt(x, 10000000000)) {</span>
  776 |     | <span class='neutral'>                x := div(x, 10000000000)</span>
  777 |     | <span class='neutral'>                r := add(r, 10)</span>
  778 |     | <span class='neutral'>            }</span>
  779 |     | <span class='neutral'>            if iszero(lt(x, 100000)) {</span>
  780 |     | <span class='neutral'>                x := div(x, 100000)</span>
  781 |     | <span class='neutral'>                r := add(r, 5)</span>
  782 |     | <span class='neutral'>            }</span>
  783 |     | <span class='neutral'>            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))</span>
  784 |     | <span class='neutral'>        }</span>
  785 |     | <span class='neutral'>    }</span>
  786 |     | <span class='neutral'></span>
  787 |     | <span class='neutral'>    /// @dev Returns the log10 of `x`, rounded up.</span>
  788 |     | <span class='neutral'>    /// Returns 0 if `x` is zero.</span>
  789 |     | <span class='neutral'>    function log10Up(uint256 x) internal pure returns (uint256 r) {</span>
  790 |     | <span class='neutral'>        r = log10(x);</span>
  791 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  792 |     | <span class='neutral'>        assembly {</span>
  793 |     | <span class='neutral'>            r := add(r, lt(exp(10, r), x))</span>
  794 |     | <span class='neutral'>        }</span>
  795 |     | <span class='neutral'>    }</span>
  796 |     | <span class='neutral'></span>
  797 |     | <span class='neutral'>    /// @dev Returns the log256 of `x`.</span>
  798 |     | <span class='neutral'>    /// Returns 0 if `x` is zero.</span>
  799 |     | <span class='neutral'>    function log256(uint256 x) internal pure returns (uint256 r) {</span>
  800 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  801 |     | <span class='neutral'>        assembly {</span>
  802 |     | <span class='neutral'>            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))</span>
  803 |     | <span class='neutral'>            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))</span>
  804 |     | <span class='neutral'>            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))</span>
  805 |     | <span class='neutral'>            r := or(r, shl(4, lt(0xffff, shr(r, x))))</span>
  806 |     | <span class='neutral'>            r := or(shr(3, r), lt(0xff, shr(r, x)))</span>
  807 |     | <span class='neutral'>        }</span>
  808 |     | <span class='neutral'>    }</span>
  809 |     | <span class='neutral'></span>
  810 |     | <span class='neutral'>    /// @dev Returns the log256 of `x`, rounded up.</span>
  811 |     | <span class='neutral'>    /// Returns 0 if `x` is zero.</span>
  812 |     | <span class='neutral'>    function log256Up(uint256 x) internal pure returns (uint256 r) {</span>
  813 |     | <span class='neutral'>        r = log256(x);</span>
  814 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  815 |     | <span class='neutral'>        assembly {</span>
  816 |     | <span class='neutral'>            r := add(r, lt(shl(shl(3, r), 1), x))</span>
  817 |     | <span class='neutral'>        }</span>
  818 |     | <span class='neutral'>    }</span>
  819 |     | <span class='neutral'></span>
  820 |     | <span class='neutral'>    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.</span>
  821 |     | <span class='neutral'>    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).</span>
  822 |     | <span class='neutral'>    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {</span>
  823 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  824 |     | <span class='neutral'>        assembly {</span>
  825 |     | <span class='neutral'>            mantissa := x</span>
  826 |     | <span class='neutral'>            if mantissa {</span>
  827 |     | <span class='neutral'>                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {</span>
  828 |     | <span class='neutral'>                    mantissa := div(mantissa, 1000000000000000000000000000000000)</span>
  829 |     | <span class='neutral'>                    exponent := 33</span>
  830 |     | <span class='neutral'>                }</span>
  831 |     | <span class='neutral'>                if iszero(mod(mantissa, 10000000000000000000)) {</span>
  832 |     | <span class='neutral'>                    mantissa := div(mantissa, 10000000000000000000)</span>
  833 |     | <span class='neutral'>                    exponent := add(exponent, 19)</span>
  834 |     | <span class='neutral'>                }</span>
  835 |     | <span class='neutral'>                if iszero(mod(mantissa, 1000000000000)) {</span>
  836 |     | <span class='neutral'>                    mantissa := div(mantissa, 1000000000000)</span>
  837 |     | <span class='neutral'>                    exponent := add(exponent, 12)</span>
  838 |     | <span class='neutral'>                }</span>
  839 |     | <span class='neutral'>                if iszero(mod(mantissa, 1000000)) {</span>
  840 |     | <span class='neutral'>                    mantissa := div(mantissa, 1000000)</span>
  841 |     | <span class='neutral'>                    exponent := add(exponent, 6)</span>
  842 |     | <span class='neutral'>                }</span>
  843 |     | <span class='neutral'>                if iszero(mod(mantissa, 10000)) {</span>
  844 |     | <span class='neutral'>                    mantissa := div(mantissa, 10000)</span>
  845 |     | <span class='neutral'>                    exponent := add(exponent, 4)</span>
  846 |     | <span class='neutral'>                }</span>
  847 |     | <span class='neutral'>                if iszero(mod(mantissa, 100)) {</span>
  848 |     | <span class='neutral'>                    mantissa := div(mantissa, 100)</span>
  849 |     | <span class='neutral'>                    exponent := add(exponent, 2)</span>
  850 |     | <span class='neutral'>                }</span>
  851 |     | <span class='neutral'>                if iszero(mod(mantissa, 10)) {</span>
  852 |     | <span class='neutral'>                    mantissa := div(mantissa, 10)</span>
  853 |     | <span class='neutral'>                    exponent := add(exponent, 1)</span>
  854 |     | <span class='neutral'>                }</span>
  855 |     | <span class='neutral'>            }</span>
  856 |     | <span class='neutral'>        }</span>
  857 |     | <span class='neutral'>    }</span>
  858 |     | <span class='neutral'></span>
  859 |     | <span class='neutral'>    /// @dev Convenience function for packing `x` into a smaller number using `sci`.</span>
  860 |     | <span class='neutral'>    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).</span>
  861 |     | <span class='neutral'>    /// The `exponent` will be in bits [0..6] (the lower 7 bits).</span>
  862 |     | <span class='neutral'>    /// Use `SafeCastLib` to safely ensure that the `packed` number is small</span>
  863 |     | <span class='neutral'>    /// enough to fit in the desired unsigned integer type:</span>
  864 |     | <span class='neutral'>    /// ```</span>
  865 |     | <span class='neutral'>    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));</span>
  866 |     | <span class='neutral'>    /// ```</span>
  867 |     | <span class='neutral'>    function packSci(uint256 x) internal pure returns (uint256 packed) {</span>
  868 |     | <span class='neutral'>        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.</span>
  869 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  870 |     | <span class='neutral'>        assembly {</span>
  871 |     | <span class='neutral'>            if shr(249, x) {</span>
  872 |     | <span class='neutral'>                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.</span>
  873 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  874 |     | <span class='neutral'>            }</span>
  875 |     | <span class='neutral'>            packed := or(shl(7, x), packed)</span>
  876 |     | <span class='neutral'>        }</span>
  877 |     | <span class='neutral'>    }</span>
  878 |     | <span class='neutral'></span>
  879 |     | <span class='neutral'>    /// @dev Convenience function for unpacking a packed number from `packSci`.</span>
  880 |     | <span class='neutral'>    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {</span>
  881 |     | <span class='neutral'>        unchecked {</span>
  882 |     | <span class='neutral'>            unpacked = (packed &gt;&gt; 7) * 10 ** (packed &amp; 0x7f);</span>
  883 |     | <span class='neutral'>        }</span>
  884 |     | <span class='neutral'>    }</span>
  885 |     | <span class='neutral'></span>
  886 |     | <span class='neutral'>    /// @dev Returns the average of `x` and `y`.</span>
  887 |     | <span class='neutral'>    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  888 |     | <span class='neutral'>        unchecked {</span>
  889 |     | <span class='neutral'>            z = (x &amp; y) + ((x ^ y) &gt;&gt; 1);</span>
  890 |     | <span class='neutral'>        }</span>
  891 |     | <span class='neutral'>    }</span>
  892 |     | <span class='neutral'></span>
  893 |     | <span class='neutral'>    /// @dev Returns the average of `x` and `y`.</span>
  894 |     | <span class='neutral'>    function avg(int256 x, int256 y) internal pure returns (int256 z) {</span>
  895 |     | <span class='neutral'>        unchecked {</span>
  896 |     | <span class='neutral'>            z = (x &gt;&gt; 1) + (y &gt;&gt; 1) + (((x &amp; 1) + (y &amp; 1)) &gt;&gt; 1);</span>
  897 |     | <span class='neutral'>        }</span>
  898 |     | <span class='neutral'>    }</span>
  899 |     | <span class='neutral'></span>
  900 |     | <span class='neutral'>    /// @dev Returns the absolute value of `x`.</span>
  901 |     | <span class='neutral'>    function abs(int256 x) internal pure returns (uint256 z) {</span>
  902 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  903 |     | <span class='neutral'>        assembly {</span>
  904 |     | <span class='neutral'>            z := xor(sub(0, shr(255, x)), add(sub(0, shr(255, x)), x))</span>
  905 |     | <span class='neutral'>        }</span>
  906 |     | <span class='neutral'>    }</span>
  907 |     | <span class='neutral'></span>
  908 |     | <span class='neutral'>    /// @dev Returns the absolute distance between `x` and `y`.</span>
  909 |     | <span class='neutral'>    function dist(int256 x, int256 y) internal pure returns (uint256 z) {</span>
  910 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  911 |     | <span class='neutral'>        assembly {</span>
  912 |     | <span class='neutral'>            z := xor(mul(xor(sub(y, x), sub(x, y)), sgt(x, y)), sub(y, x))</span>
  913 |     | <span class='neutral'>        }</span>
  914 |     | <span class='neutral'>    }</span>
  915 |     | <span class='neutral'></span>
  916 |     | <span class='neutral'>    /// @dev Returns the minimum of `x` and `y`.</span>
  917 |     | <span class='neutral'>    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  918 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  919 |     | <span class='neutral'>        assembly {</span>
  920 |     | <span class='neutral'>            z := xor(x, mul(xor(x, y), lt(y, x)))</span>
  921 |     | <span class='neutral'>        }</span>
  922 |     | <span class='neutral'>    }</span>
  923 |     | <span class='neutral'></span>
  924 |     | <span class='neutral'>    /// @dev Returns the minimum of `x` and `y`.</span>
  925 |     | <span class='neutral'>    function min(int256 x, int256 y) internal pure returns (int256 z) {</span>
  926 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  927 |     | <span class='neutral'>        assembly {</span>
  928 |     | <span class='neutral'>            z := xor(x, mul(xor(x, y), slt(y, x)))</span>
  929 |     | <span class='neutral'>        }</span>
  930 |     | <span class='neutral'>    }</span>
  931 |     | <span class='neutral'></span>
  932 |     | <span class='neutral'>    /// @dev Returns the maximum of `x` and `y`.</span>
  933 |     | <span class='neutral'>    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  934 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  935 |     | <span class='neutral'>        assembly {</span>
  936 |     | <span class='neutral'>            z := xor(x, mul(xor(x, y), gt(y, x)))</span>
  937 |     | <span class='neutral'>        }</span>
  938 |     | <span class='neutral'>    }</span>
  939 |     | <span class='neutral'></span>
  940 |     | <span class='neutral'>    /// @dev Returns the maximum of `x` and `y`.</span>
  941 |     | <span class='neutral'>    function max(int256 x, int256 y) internal pure returns (int256 z) {</span>
  942 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  943 |     | <span class='neutral'>        assembly {</span>
  944 |     | <span class='neutral'>            z := xor(x, mul(xor(x, y), sgt(y, x)))</span>
  945 |     | <span class='neutral'>        }</span>
  946 |     | <span class='neutral'>    }</span>
  947 |     | <span class='neutral'></span>
  948 |     | <span class='neutral'>    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.</span>
  949 |     | <span class='neutral'>    function clamp(uint256 x, uint256 minValue, uint256 maxValue)</span>
  950 |     | <span class='neutral'>        internal</span>
  951 |     | <span class='neutral'>        pure</span>
  952 |     | <span class='neutral'>        returns (uint256 z)</span>
  953 |     | <span class='neutral'>    {</span>
  954 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  955 |     | <span class='neutral'>        assembly {</span>
  956 |     | <span class='neutral'>            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))</span>
  957 |     | <span class='neutral'>            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))</span>
  958 |     | <span class='neutral'>        }</span>
  959 |     | <span class='neutral'>    }</span>
  960 |     | <span class='neutral'></span>
  961 |     | <span class='neutral'>    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.</span>
  962 |     | <span class='neutral'>    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {</span>
  963 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  964 |     | <span class='neutral'>        assembly {</span>
  965 |     | <span class='neutral'>            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))</span>
  966 |     | <span class='neutral'>            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))</span>
  967 |     | <span class='neutral'>        }</span>
  968 |     | <span class='neutral'>    }</span>
  969 |     | <span class='neutral'></span>
  970 |     | <span class='neutral'>    /// @dev Returns greatest common divisor of `x` and `y`.</span>
  971 |     | <span class='neutral'>    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  972 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  973 |     | <span class='neutral'>        assembly {</span>
  974 |     | <span class='neutral'>            for { z := x } y {} {</span>
  975 |     | <span class='neutral'>                let t := y</span>
  976 |     | <span class='neutral'>                y := mod(z, y)</span>
  977 |     | <span class='neutral'>                z := t</span>
  978 |     | <span class='neutral'>            }</span>
  979 |     | <span class='neutral'>        }</span>
  980 |     | <span class='neutral'>    }</span>
  981 |     | <span class='neutral'></span>
  982 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  983 |     | <span class='neutral'>    /*                   RAW NUMBER OPERATIONS                    */</span>
  984 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  985 |     | <span class='neutral'></span>
  986 |     | <span class='neutral'>    /// @dev Returns `x + y`, without checking for overflow.</span>
  987 |     | <span class='neutral'>    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  988 |     | <span class='neutral'>        unchecked {</span>
  989 |     | <span class='neutral'>            z = x + y;</span>
  990 |     | <span class='neutral'>        }</span>
  991 |     | <span class='neutral'>    }</span>
  992 |     | <span class='neutral'></span>
  993 |     | <span class='neutral'>    /// @dev Returns `x + y`, without checking for overflow.</span>
  994 |     | <span class='neutral'>    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {</span>
  995 |     | <span class='neutral'>        unchecked {</span>
  996 |     | <span class='neutral'>            z = x + y;</span>
  997 |     | <span class='neutral'>        }</span>
  998 |     | <span class='neutral'>    }</span>
  999 |     | <span class='neutral'></span>
 1000 |     | <span class='neutral'>    /// @dev Returns `x - y`, without checking for underflow.</span>
 1001 |     | <span class='neutral'>    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 1002 |     | <span class='neutral'>        unchecked {</span>
 1003 |     | <span class='neutral'>            z = x - y;</span>
 1004 |     | <span class='neutral'>        }</span>
 1005 |     | <span class='neutral'>    }</span>
 1006 |     | <span class='neutral'></span>
 1007 |     | <span class='neutral'>    /// @dev Returns `x - y`, without checking for underflow.</span>
 1008 |     | <span class='neutral'>    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {</span>
 1009 |     | <span class='neutral'>        unchecked {</span>
 1010 |     | <span class='neutral'>            z = x - y;</span>
 1011 |     | <span class='neutral'>        }</span>
 1012 |     | <span class='neutral'>    }</span>
 1013 |     | <span class='neutral'></span>
 1014 |     | <span class='neutral'>    /// @dev Returns `x * y`, without checking for overflow.</span>
 1015 |     | <span class='neutral'>    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 1016 |     | <span class='neutral'>        unchecked {</span>
 1017 |     | <span class='neutral'>            z = x * y;</span>
 1018 |     | <span class='neutral'>        }</span>
 1019 |     | <span class='neutral'>    }</span>
 1020 |     | <span class='neutral'></span>
 1021 |     | <span class='neutral'>    /// @dev Returns `x * y`, without checking for overflow.</span>
 1022 |     | <span class='neutral'>    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {</span>
 1023 |     | <span class='neutral'>        unchecked {</span>
 1024 |     | <span class='neutral'>            z = x * y;</span>
 1025 |     | <span class='neutral'>        }</span>
 1026 |     | <span class='neutral'>    }</span>
 1027 |     | <span class='neutral'></span>
 1028 |     | <span class='neutral'>    /// @dev Returns `x / y`, returning 0 if `y` is zero.</span>
 1029 |     | <span class='neutral'>    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 1030 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1031 |     | <span class='neutral'>        assembly {</span>
 1032 |     | <span class='neutral'>            z := div(x, y)</span>
 1033 |     | <span class='neutral'>        }</span>
 1034 |     | <span class='neutral'>    }</span>
 1035 |     | <span class='neutral'></span>
 1036 |     | <span class='neutral'>    /// @dev Returns `x / y`, returning 0 if `y` is zero.</span>
 1037 |     | <span class='neutral'>    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {</span>
 1038 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1039 |     | <span class='neutral'>        assembly {</span>
 1040 |     | <span class='neutral'>            z := sdiv(x, y)</span>
 1041 |     | <span class='neutral'>        }</span>
 1042 |     | <span class='neutral'>    }</span>
 1043 |     | <span class='neutral'></span>
 1044 |     | <span class='neutral'>    /// @dev Returns `x % y`, returning 0 if `y` is zero.</span>
 1045 |     | <span class='neutral'>    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 1046 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1047 |     | <span class='neutral'>        assembly {</span>
 1048 |     | <span class='neutral'>            z := mod(x, y)</span>
 1049 |     | <span class='neutral'>        }</span>
 1050 |     | <span class='neutral'>    }</span>
 1051 |     | <span class='neutral'></span>
 1052 |     | <span class='neutral'>    /// @dev Returns `x % y`, returning 0 if `y` is zero.</span>
 1053 |     | <span class='neutral'>    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {</span>
 1054 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1055 |     | <span class='neutral'>        assembly {</span>
 1056 |     | <span class='neutral'>            z := smod(x, y)</span>
 1057 |     | <span class='neutral'>        }</span>
 1058 |     | <span class='neutral'>    }</span>
 1059 |     | <span class='neutral'></span>
 1060 |     | <span class='neutral'>    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.</span>
 1061 |     | <span class='neutral'>    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {</span>
 1062 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1063 |     | <span class='neutral'>        assembly {</span>
 1064 |     | <span class='neutral'>            z := addmod(x, y, d)</span>
 1065 |     | <span class='neutral'>        }</span>
 1066 |     | <span class='neutral'>    }</span>
 1067 |     | <span class='neutral'></span>
 1068 |     | <span class='neutral'>    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.</span>
 1069 |     | <span class='neutral'>    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {</span>
 1070 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1071 |     | <span class='neutral'>        assembly {</span>
 1072 |     | <span class='neutral'>            z := mulmod(x, y, d)</span>
 1073 |     | <span class='neutral'>        }</span>
 1074 |     | <span class='neutral'>    }</span>
 1075 |     | <span class='neutral'>}</span>
 1076 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solady/src/utils/LibClone.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>/// @notice Minimal proxy library.</span>
    5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)</span>
    6 |     | <span class='neutral'>/// @author Minimal proxy by 0age (https://github.com/0age)</span>
    7 |     | <span class='neutral'>/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon &amp; Natalie</span>
    8 |     | <span class='neutral'>/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)</span>
    9 |     | <span class='neutral'>/// @author Minimal ERC1967 proxy by jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)</span>
   10 |     | <span class='neutral'>///</span>
   11 |     | <span class='neutral'>/// @dev Minimal proxy:</span>
   12 |     | <span class='neutral'>/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,</span>
   13 |     | <span class='neutral'>/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,</span>
   14 |     | <span class='neutral'>/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.</span>
   15 |     | <span class='neutral'>///</span>
   16 |     | <span class='neutral'>/// @dev Minimal proxy (PUSH0 variant):</span>
   17 |     | <span class='neutral'>/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.</span>
   18 |     | <span class='neutral'>/// It is optimized first for minimal runtime gas, then for minimal bytecode.</span>
   19 |     | <span class='neutral'>/// The PUSH0 clone functions are intentionally postfixed with a jarring &quot;_PUSH0&quot; as</span>
   20 |     | <span class='neutral'>/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.</span>
   21 |     | <span class='neutral'>/// Please use with caution.</span>
   22 |     | <span class='neutral'>///</span>
   23 |     | <span class='neutral'>/// @dev Clones with immutable args (CWIA):</span>
   24 |     | <span class='neutral'>/// The implementation of CWIA here implements a `receive()` method that emits the</span>
   25 |     | <span class='neutral'>/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,</span>
   26 |     | <span class='neutral'>/// enabling us to accept hard gas-capped `sends` &amp; `transfers` for maximum backwards</span>
   27 |     | <span class='neutral'>/// composability. The minimal proxy implementation does not offer this feature.</span>
   28 |     | <span class='neutral'>///</span>
   29 |     | <span class='neutral'>/// @dev Minimal ERC1967 proxy:</span>
   30 |     | <span class='neutral'>/// An minimal ERC1967 proxy, intended to be upgraded with UUPS.</span>
   31 |     | <span class='neutral'>/// This is NOT the same as ERC1967Factory&#39;s transparent proxy, which includes admin logic.</span>
   32 |     | <span class='neutral'>///</span>
   33 |     | <span class='neutral'>/// @dev ERC1967I proxy:</span>
   34 |     | <span class='neutral'>/// An variant of the minimal ERC1967 proxy, with a special code path that activates</span>
   35 |     | <span class='neutral'>/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the</span>
   36 |     | <span class='neutral'>/// `implementation` address. The returned implementation is guaranteed to be valid if the</span>
   37 |     | <span class='neutral'>/// keccak256 of the proxy&#39;s code is equal to `ERC1967I_CODE_HASH`.</span>
   38 |     | <span class='unexecuted'>library LibClone {</span>
   39 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
   40 |     | <span class='neutral'>    /*                         CONSTANTS                          */</span>
   41 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
   42 |     | <span class='neutral'></span>
   43 |     | <span class='neutral'>    /// @dev The keccak256 of the deployed code for the ERC1967 proxy.</span>
   44 |     | <span class='neutral'>    bytes32 internal constant ERC1967_CODE_HASH =</span>
   45 |     | <span class='neutral'>        0xaaa52c8cc8a0e3fd27ce756cc6b4e70c51423e9b597b11f32d3e49f8b1fc890d;</span>
   46 |     | <span class='neutral'></span>
   47 |     | <span class='neutral'>    /// @dev The keccak256 of the deployed code for the ERC1967I proxy.</span>
   48 |     | <span class='neutral'>    bytes32 internal constant ERC1967I_CODE_HASH =</span>
   49 |     | <span class='neutral'>        0xce700223c0d4cea4583409accfc45adac4a093b3519998a9cbbe1504dadba6f7;</span>
   50 |     | <span class='neutral'></span>
   51 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
   52 |     | <span class='neutral'>    /*                       CUSTOM ERRORS                        */</span>
   53 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
   54 |     | <span class='neutral'></span>
   55 |     | <span class='neutral'>    /// @dev Unable to deploy the clone.</span>
   56 |     | <span class='neutral'>    error DeploymentFailed();</span>
   57 |     | <span class='neutral'></span>
   58 |     | <span class='neutral'>    /// @dev The salt must start with either the zero address or `by`.</span>
   59 |     | <span class='neutral'>    error SaltDoesNotStartWith();</span>
   60 |     | <span class='neutral'></span>
   61 |     | <span class='neutral'>    /// @dev The ETH transfer has failed.</span>
   62 |     | <span class='neutral'>    error ETHTransferFailed();</span>
   63 |     | <span class='neutral'></span>
   64 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
   65 |     | <span class='neutral'>    /*                  MINIMAL PROXY OPERATIONS                  */</span>
   66 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
   67 |     | <span class='neutral'></span>
   68 |     | <span class='neutral'>    /// @dev Deploys a clone of `implementation`.</span>
   69 |     | <span class='unexecuted'>    function clone(address implementation) internal returns (address instance) {</span>
   70 |     | <span class='unexecuted'>        instance = clone(0, implementation);</span>
   71 |     | <span class='neutral'>    }</span>
   72 |     | <span class='neutral'></span>
   73 |     | <span class='neutral'>    /// @dev Deploys a clone of `implementation`.</span>
   74 |     | <span class='neutral'>    /// Deposits `value` ETH during deployment.</span>
   75 |     | <span class='unexecuted'>    function clone(uint256 value, address implementation) internal returns (address instance) {</span>
   76 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   77 |     | <span class='neutral'>        assembly {</span>
   78 |     | <span class='neutral'>            /**</span>
   79 |     | <span class='neutral'>             * --------------------------------------------------------------------------+</span>
   80 |     | <span class='neutral'>             * CREATION (9 bytes)                                                        |</span>
   81 |     | <span class='neutral'>             * --------------------------------------------------------------------------|</span>
   82 |     | <span class='neutral'>             * Opcode     | Mnemonic          | Stack     | Memory                       |</span>
   83 |     | <span class='neutral'>             * --------------------------------------------------------------------------|</span>
   84 |     | <span class='neutral'>             * 60 runSize | PUSH1 runSize     | r         |                              |</span>
   85 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE    | 0 r       |                              |</span>
   86 |     | <span class='neutral'>             * 81         | DUP2              | r 0 r     |                              |</span>
   87 |     | <span class='neutral'>             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |</span>
   88 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |</span>
   89 |     | <span class='neutral'>             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |</span>
   90 |     | <span class='neutral'>             * f3         | RETURN            |           | [0..runSize): runtime code   |</span>
   91 |     | <span class='neutral'>             * --------------------------------------------------------------------------|</span>
   92 |     | <span class='neutral'>             * RUNTIME (44 bytes)                                                        |</span>
   93 |     | <span class='neutral'>             * --------------------------------------------------------------------------|</span>
   94 |     | <span class='neutral'>             * Opcode  | Mnemonic       | Stack                  | Memory                |</span>
   95 |     | <span class='neutral'>             * --------------------------------------------------------------------------|</span>
   96 |     | <span class='neutral'>             *                                                                           |</span>
   97 |     | <span class='neutral'>             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |</span>
   98 |     | <span class='neutral'>             * 3d      | RETURNDATASIZE | 0                      |                       |</span>
   99 |     | <span class='neutral'>             * 3d      | RETURNDATASIZE | 0 0                    |                       |</span>
  100 |     | <span class='neutral'>             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |</span>
  101 |     | <span class='neutral'>             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |</span>
  102 |     | <span class='neutral'>             *                                                                           |</span>
  103 |     | <span class='neutral'>             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |</span>
  104 |     | <span class='neutral'>             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |</span>
  105 |     | <span class='neutral'>             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |</span>
  106 |     | <span class='neutral'>             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |</span>
  107 |     | <span class='neutral'>             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |</span>
  108 |     | <span class='neutral'>             *                                                                           |</span>
  109 |     | <span class='neutral'>             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |</span>
  110 |     | <span class='neutral'>             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |</span>
  111 |     | <span class='neutral'>             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |</span>
  112 |     | <span class='neutral'>             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |</span>
  113 |     | <span class='neutral'>             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |</span>
  114 |     | <span class='neutral'>             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |</span>
  115 |     | <span class='neutral'>             *                                                                           |</span>
  116 |     | <span class='neutral'>             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |</span>
  117 |     | <span class='neutral'>             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |</span>
  118 |     | <span class='neutral'>             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |</span>
  119 |     | <span class='neutral'>             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |</span>
  120 |     | <span class='neutral'>             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |</span>
  121 |     | <span class='neutral'>             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |</span>
  122 |     | <span class='neutral'>             *                                                                           |</span>
  123 |     | <span class='neutral'>             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |</span>
  124 |     | <span class='neutral'>             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |</span>
  125 |     | <span class='neutral'>             *                                                                           |</span>
  126 |     | <span class='neutral'>             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  127 |     | <span class='neutral'>             * fd      | REVERT         |                        | [0..rds): returndata  |</span>
  128 |     | <span class='neutral'>             *                                                                           |</span>
  129 |     | <span class='neutral'>             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  130 |     | <span class='neutral'>             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |</span>
  131 |     | <span class='neutral'>             * f3      | RETURN         |                        | [0..rds): returndata  |</span>
  132 |     | <span class='neutral'>             * --------------------------------------------------------------------------+</span>
  133 |     | <span class='neutral'>             */</span>
  134 |     | <span class='unexecuted'>            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)</span>
  135 |     | <span class='unexecuted'>            mstore(0x14, implementation)</span>
  136 |     | <span class='unexecuted'>            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)</span>
  137 |     | <span class='unexecuted'>            instance := create(value, 0x0c, 0x35)</span>
  138 |     | <span class='unexecuted'>            if iszero(instance) {</span>
  139 |     | <span class='unexecuted'>                mstore(0x00, 0x30116425) // `DeploymentFailed()`.</span>
  140 |     | <span class='unexecuted'>                revert(0x1c, 0x04)</span>
  141 |     | <span class='neutral'>            }</span>
  142 |     | <span class='unexecuted'>            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.</span>
  143 |     | <span class='neutral'>        }</span>
  144 |     | <span class='neutral'>    }</span>
  145 |     | <span class='neutral'></span>
  146 |     | <span class='neutral'>    /// @dev Deploys a deterministic clone of `implementation` with `salt`.</span>
  147 | *   | <span class='executed'>    function cloneDeterministic(address implementation, bytes32 salt)</span>
  148 |     | <span class='neutral'>        internal</span>
  149 | *   | <span class='executed'>        returns (address instance)</span>
  150 |     | <span class='neutral'>    {</span>
  151 | *   | <span class='executed'>        instance = cloneDeterministic(0, implementation, salt);</span>
  152 |     | <span class='neutral'>    }</span>
  153 |     | <span class='neutral'></span>
  154 |     | <span class='neutral'>    /// @dev Deploys a deterministic clone of `implementation` with `salt`.</span>
  155 |     | <span class='neutral'>    /// Deposits `value` ETH during deployment.</span>
  156 | *   | <span class='executed'>    function cloneDeterministic(uint256 value, address implementation, bytes32 salt)</span>
  157 |     | <span class='neutral'>        internal</span>
  158 | *   | <span class='executed'>        returns (address instance)</span>
  159 |     | <span class='neutral'>    {</span>
  160 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  161 |     | <span class='neutral'>        assembly {</span>
  162 | *   | <span class='executed'>            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)</span>
  163 | *   | <span class='executed'>            mstore(0x14, implementation)</span>
  164 | *   | <span class='executed'>            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)</span>
  165 | *   | <span class='executed'>            instance := create2(value, 0x0c, 0x35, salt)</span>
  166 | *   | <span class='executed'>            if iszero(instance) {</span>
  167 | *   | <span class='executed'>                mstore(0x00, 0x30116425) // `DeploymentFailed()`.</span>
  168 | *   | <span class='executed'>                revert(0x1c, 0x04)</span>
  169 |     | <span class='neutral'>            }</span>
  170 | *   | <span class='executed'>            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.</span>
  171 |     | <span class='neutral'>        }</span>
  172 |     | <span class='neutral'>    }</span>
  173 |     | <span class='neutral'></span>
  174 |     | <span class='neutral'>    /// @dev Returns the initialization code of the clone of `implementation`.</span>
  175 |     | <span class='neutral'>    function initCode(address implementation) internal pure returns (bytes memory result) {</span>
  176 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  177 |     | <span class='neutral'>        assembly {</span>
  178 |     | <span class='neutral'>            result := mload(0x40)</span>
  179 |     | <span class='neutral'>            mstore(add(result, 0x40), 0x5af43d3d93803e602a57fd5bf30000000000000000000000)</span>
  180 |     | <span class='neutral'>            mstore(add(result, 0x28), implementation)</span>
  181 |     | <span class='neutral'>            mstore(add(result, 0x14), 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)</span>
  182 |     | <span class='neutral'>            mstore(result, 0x35) // Store the length.</span>
  183 |     | <span class='neutral'>            mstore(0x40, add(result, 0x60)) // Allocate memory.</span>
  184 |     | <span class='neutral'>        }</span>
  185 |     | <span class='neutral'>    }</span>
  186 |     | <span class='neutral'></span>
  187 |     | <span class='neutral'>    /// @dev Returns the initialization code hash of the clone of `implementation`.</span>
  188 |     | <span class='neutral'>    /// Used for mining vanity addresses with create2crunch.</span>
  189 |     | <span class='unexecuted'>    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {</span>
  190 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  191 |     | <span class='neutral'>        assembly {</span>
  192 |     | <span class='unexecuted'>            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)</span>
  193 |     | <span class='unexecuted'>            mstore(0x14, implementation)</span>
  194 |     | <span class='unexecuted'>            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)</span>
  195 |     | <span class='unexecuted'>            hash := keccak256(0x0c, 0x35)</span>
  196 |     | <span class='unexecuted'>            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.</span>
  197 |     | <span class='neutral'>        }</span>
  198 |     | <span class='neutral'>    }</span>
  199 |     | <span class='neutral'></span>
  200 |     | <span class='neutral'>    /// @dev Returns the address of the deterministic clone of `implementation`,</span>
  201 |     | <span class='neutral'>    /// with `salt` by `deployer`.</span>
  202 |     | <span class='neutral'>    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.</span>
  203 |     | <span class='unexecuted'>    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)</span>
  204 |     | <span class='neutral'>        internal</span>
  205 |     | <span class='neutral'>        pure</span>
  206 |     | <span class='unexecuted'>        returns (address predicted)</span>
  207 |     | <span class='neutral'>    {</span>
  208 |     | <span class='unexecuted'>        bytes32 hash = initCodeHash(implementation);</span>
  209 |     | <span class='unexecuted'>        predicted = predictDeterministicAddress(hash, salt, deployer);</span>
  210 |     | <span class='neutral'>    }</span>
  211 |     | <span class='neutral'></span>
  212 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  213 |     | <span class='neutral'>    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */</span>
  214 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  215 |     | <span class='neutral'></span>
  216 |     | <span class='neutral'>    /// @dev Deploys a PUSH0 clone of `implementation`.</span>
  217 |     | <span class='neutral'>    function clone_PUSH0(address implementation) internal returns (address instance) {</span>
  218 |     | <span class='neutral'>        instance = clone_PUSH0(0, implementation);</span>
  219 |     | <span class='neutral'>    }</span>
  220 |     | <span class='neutral'></span>
  221 |     | <span class='neutral'>    /// @dev Deploys a PUSH0 clone of `implementation`.</span>
  222 |     | <span class='neutral'>    /// Deposits `value` ETH during deployment.</span>
  223 |     | <span class='neutral'>    function clone_PUSH0(uint256 value, address implementation)</span>
  224 |     | <span class='neutral'>        internal</span>
  225 |     | <span class='neutral'>        returns (address instance)</span>
  226 |     | <span class='neutral'>    {</span>
  227 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  228 |     | <span class='neutral'>        assembly {</span>
  229 |     | <span class='neutral'>            /**</span>
  230 |     | <span class='neutral'>             * --------------------------------------------------------------------------+</span>
  231 |     | <span class='neutral'>             * CREATION (9 bytes)                                                        |</span>
  232 |     | <span class='neutral'>             * --------------------------------------------------------------------------|</span>
  233 |     | <span class='neutral'>             * Opcode     | Mnemonic          | Stack     | Memory                       |</span>
  234 |     | <span class='neutral'>             * --------------------------------------------------------------------------|</span>
  235 |     | <span class='neutral'>             * 60 runSize | PUSH1 runSize     | r         |                              |</span>
  236 |     | <span class='neutral'>             * 5f         | PUSH0             | 0 r       |                              |</span>
  237 |     | <span class='neutral'>             * 81         | DUP2              | r 0 r     |                              |</span>
  238 |     | <span class='neutral'>             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |</span>
  239 |     | <span class='neutral'>             * 5f         | PUSH0             | 0 o r 0 r |                              |</span>
  240 |     | <span class='neutral'>             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |</span>
  241 |     | <span class='neutral'>             * f3         | RETURN            |           | [0..runSize): runtime code   |</span>
  242 |     | <span class='neutral'>             * --------------------------------------------------------------------------|</span>
  243 |     | <span class='neutral'>             * RUNTIME (45 bytes)                                                        |</span>
  244 |     | <span class='neutral'>             * --------------------------------------------------------------------------|</span>
  245 |     | <span class='neutral'>             * Opcode  | Mnemonic       | Stack                  | Memory                |</span>
  246 |     | <span class='neutral'>             * --------------------------------------------------------------------------|</span>
  247 |     | <span class='neutral'>             *                                                                           |</span>
  248 |     | <span class='neutral'>             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |</span>
  249 |     | <span class='neutral'>             * 5f      | PUSH0          | 0                      |                       |</span>
  250 |     | <span class='neutral'>             * 5f      | PUSH0          | 0 0                    |                       |</span>
  251 |     | <span class='neutral'>             *                                                                           |</span>
  252 |     | <span class='neutral'>             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |</span>
  253 |     | <span class='neutral'>             * 36      | CALLDATASIZE   | cds 0 0                |                       |</span>
  254 |     | <span class='neutral'>             * 5f      | PUSH0          | 0 cds 0 0              |                       |</span>
  255 |     | <span class='neutral'>             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |</span>
  256 |     | <span class='neutral'>             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |</span>
  257 |     | <span class='neutral'>             *                                                                           |</span>
  258 |     | <span class='neutral'>             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |</span>
  259 |     | <span class='neutral'>             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |</span>
  260 |     | <span class='neutral'>             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |</span>
  261 |     | <span class='neutral'>             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |</span>
  262 |     | <span class='neutral'>             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |</span>
  263 |     | <span class='neutral'>             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |</span>
  264 |     | <span class='neutral'>             *                                                                           |</span>
  265 |     | <span class='neutral'>             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |</span>
  266 |     | <span class='neutral'>             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |</span>
  267 |     | <span class='neutral'>             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |</span>
  268 |     | <span class='neutral'>             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |</span>
  269 |     | <span class='neutral'>             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |</span>
  270 |     | <span class='neutral'>             *                                                                           |</span>
  271 |     | <span class='neutral'>             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |</span>
  272 |     | <span class='neutral'>             * 57      | JUMPI          |                        | [0..rds): returndata  |</span>
  273 |     | <span class='neutral'>             *                                                                           |</span>
  274 |     | <span class='neutral'>             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  275 |     | <span class='neutral'>             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |</span>
  276 |     | <span class='neutral'>             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |</span>
  277 |     | <span class='neutral'>             * fd      | REVERT         |                        | [0..rds): returndata  |</span>
  278 |     | <span class='neutral'>             *                                                                           |</span>
  279 |     | <span class='neutral'>             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  280 |     | <span class='neutral'>             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |</span>
  281 |     | <span class='neutral'>             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |</span>
  282 |     | <span class='neutral'>             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |</span>
  283 |     | <span class='neutral'>             * f3      | RETURN         |                        | [0..rds): returndata  |</span>
  284 |     | <span class='neutral'>             * --------------------------------------------------------------------------+</span>
  285 |     | <span class='neutral'>             */</span>
  286 |     | <span class='neutral'>            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16</span>
  287 |     | <span class='neutral'>            mstore(0x14, implementation) // 20</span>
  288 |     | <span class='neutral'>            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9</span>
  289 |     | <span class='neutral'>            instance := create(value, 0x0e, 0x36)</span>
  290 |     | <span class='neutral'>            if iszero(instance) {</span>
  291 |     | <span class='neutral'>                mstore(0x00, 0x30116425) // `DeploymentFailed()`.</span>
  292 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  293 |     | <span class='neutral'>            }</span>
  294 |     | <span class='neutral'>            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.</span>
  295 |     | <span class='neutral'>        }</span>
  296 |     | <span class='neutral'>    }</span>
  297 |     | <span class='neutral'></span>
  298 |     | <span class='neutral'>    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.</span>
  299 |     | <span class='neutral'>    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)</span>
  300 |     | <span class='neutral'>        internal</span>
  301 |     | <span class='neutral'>        returns (address instance)</span>
  302 |     | <span class='neutral'>    {</span>
  303 |     | <span class='neutral'>        instance = cloneDeterministic_PUSH0(0, implementation, salt);</span>
  304 |     | <span class='neutral'>    }</span>
  305 |     | <span class='neutral'></span>
  306 |     | <span class='neutral'>    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.</span>
  307 |     | <span class='neutral'>    /// Deposits `value` ETH during deployment.</span>
  308 |     | <span class='neutral'>    function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt)</span>
  309 |     | <span class='neutral'>        internal</span>
  310 |     | <span class='neutral'>        returns (address instance)</span>
  311 |     | <span class='neutral'>    {</span>
  312 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  313 |     | <span class='neutral'>        assembly {</span>
  314 |     | <span class='neutral'>            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16</span>
  315 |     | <span class='neutral'>            mstore(0x14, implementation) // 20</span>
  316 |     | <span class='neutral'>            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9</span>
  317 |     | <span class='neutral'>            instance := create2(value, 0x0e, 0x36, salt)</span>
  318 |     | <span class='neutral'>            if iszero(instance) {</span>
  319 |     | <span class='neutral'>                mstore(0x00, 0x30116425) // `DeploymentFailed()`.</span>
  320 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  321 |     | <span class='neutral'>            }</span>
  322 |     | <span class='neutral'>            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.</span>
  323 |     | <span class='neutral'>        }</span>
  324 |     | <span class='neutral'>    }</span>
  325 |     | <span class='neutral'></span>
  326 |     | <span class='neutral'>    /// @dev Returns the initialization code of the PUSH0 clone of `implementation`.</span>
  327 |     | <span class='neutral'>    function initCode_PUSH0(address implementation) internal pure returns (bytes memory result) {</span>
  328 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  329 |     | <span class='neutral'>        assembly {</span>
  330 |     | <span class='neutral'>            result := mload(0x40)</span>
  331 |     | <span class='neutral'>            mstore(add(result, 0x40), 0x5af43d5f5f3e6029573d5ffd5b3d5ff300000000000000000000) // 16</span>
  332 |     | <span class='neutral'>            mstore(add(result, 0x26), implementation) // 20</span>
  333 |     | <span class='neutral'>            mstore(add(result, 0x12), 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9</span>
  334 |     | <span class='neutral'>            mstore(result, 0x36) // Store the length.</span>
  335 |     | <span class='neutral'>            mstore(0x40, add(result, 0x60)) // Allocate memory.</span>
  336 |     | <span class='neutral'>        }</span>
  337 |     | <span class='neutral'>    }</span>
  338 |     | <span class='neutral'></span>
  339 |     | <span class='neutral'>    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.</span>
  340 |     | <span class='neutral'>    /// Used for mining vanity addresses with create2crunch.</span>
  341 |     | <span class='neutral'>    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {</span>
  342 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  343 |     | <span class='neutral'>        assembly {</span>
  344 |     | <span class='neutral'>            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16</span>
  345 |     | <span class='neutral'>            mstore(0x14, implementation) // 20</span>
  346 |     | <span class='neutral'>            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9</span>
  347 |     | <span class='neutral'>            hash := keccak256(0x0e, 0x36)</span>
  348 |     | <span class='neutral'>            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.</span>
  349 |     | <span class='neutral'>        }</span>
  350 |     | <span class='neutral'>    }</span>
  351 |     | <span class='neutral'></span>
  352 |     | <span class='neutral'>    /// @dev Returns the address of the deterministic PUSH0 clone of `implementation`,</span>
  353 |     | <span class='neutral'>    /// with `salt` by `deployer`.</span>
  354 |     | <span class='neutral'>    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.</span>
  355 |     | <span class='neutral'>    function predictDeterministicAddress_PUSH0(</span>
  356 |     | <span class='neutral'>        address implementation,</span>
  357 |     | <span class='neutral'>        bytes32 salt,</span>
  358 |     | <span class='neutral'>        address deployer</span>
  359 |     | <span class='neutral'>    ) internal pure returns (address predicted) {</span>
  360 |     | <span class='neutral'>        bytes32 hash = initCodeHash_PUSH0(implementation);</span>
  361 |     | <span class='neutral'>        predicted = predictDeterministicAddress(hash, salt, deployer);</span>
  362 |     | <span class='neutral'>    }</span>
  363 |     | <span class='neutral'></span>
  364 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  365 |     | <span class='neutral'>    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */</span>
  366 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  367 |     | <span class='neutral'></span>
  368 |     | <span class='neutral'>    // Note: This implementation of CWIA differs from the original implementation.</span>
  369 |     | <span class='neutral'>    // If the calldata is empty, it will emit a `ReceiveETH(uint256)` event and skip the `DELEGATECALL`.</span>
  370 |     | <span class='neutral'></span>
  371 |     | <span class='neutral'>    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.</span>
  372 |     | <span class='neutral'>    function clone(address implementation, bytes memory data) internal returns (address instance) {</span>
  373 |     | <span class='neutral'>        instance = clone(0, implementation, data);</span>
  374 |     | <span class='neutral'>    }</span>
  375 |     | <span class='neutral'></span>
  376 |     | <span class='neutral'>    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.</span>
  377 |     | <span class='neutral'>    /// Deposits `value` ETH during deployment.</span>
  378 |     | <span class='neutral'>    function clone(uint256 value, address implementation, bytes memory data)</span>
  379 |     | <span class='neutral'>        internal</span>
  380 |     | <span class='neutral'>        returns (address instance)</span>
  381 |     | <span class='neutral'>    {</span>
  382 |     | <span class='neutral'>        assembly {</span>
  383 |     | <span class='neutral'>            // Compute the boundaries of the data and cache the memory slots around it.</span>
  384 |     | <span class='neutral'>            let mBefore3 := mload(sub(data, 0x60))</span>
  385 |     | <span class='neutral'>            let mBefore2 := mload(sub(data, 0x40))</span>
  386 |     | <span class='neutral'>            let mBefore1 := mload(sub(data, 0x20))</span>
  387 |     | <span class='neutral'>            let dataLength := mload(data)</span>
  388 |     | <span class='neutral'>            let dataEnd := add(add(data, 0x20), dataLength)</span>
  389 |     | <span class='neutral'>            let mAfter1 := mload(dataEnd)</span>
  390 |     | <span class='neutral'></span>
  391 |     | <span class='neutral'>            // +2 bytes for telling how much data there is appended to the call.</span>
  392 |     | <span class='neutral'>            let extraLength := add(dataLength, 2)</span>
  393 |     | <span class='neutral'>            // The `creationSize` is `extraLength + 108`</span>
  394 |     | <span class='neutral'>            // The `runSize` is `creationSize - 10`.</span>
  395 |     | <span class='neutral'></span>
  396 |     | <span class='neutral'>            /**</span>
  397 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------------------------+</span>
  398 |     | <span class='neutral'>             * CREATION (10 bytes)                                                                                |</span>
  399 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------------------------|</span>
  400 |     | <span class='neutral'>             * Opcode     | Mnemonic          | Stack     | Memory                                                |</span>
  401 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------------------------|</span>
  402 |     | <span class='neutral'>             * 61 runSize | PUSH2 runSize     | r         |                                                       |</span>
  403 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |</span>
  404 |     | <span class='neutral'>             * 81         | DUP2              | r 0 r     |                                                       |</span>
  405 |     | <span class='neutral'>             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |</span>
  406 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |</span>
  407 |     | <span class='neutral'>             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |</span>
  408 |     | <span class='neutral'>             * f3         | RETURN            |           | [0..runSize): runtime code                            |</span>
  409 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------------------------|</span>
  410 |     | <span class='neutral'>             * RUNTIME (98 bytes + extraLength)                                                                   |</span>
  411 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------------------------|</span>
  412 |     | <span class='neutral'>             * Opcode   | Mnemonic       | Stack                    | Memory                                      |</span>
  413 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------------------------|</span>
  414 |     | <span class='neutral'>             *                                                                                                    |</span>
  415 |     | <span class='neutral'>             * ::: if no calldata, emit event &amp; return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |</span>
  416 |     | <span class='neutral'>             * 36       | CALLDATASIZE   | cds                      |                                             |</span>
  417 |     | <span class='neutral'>             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |</span>
  418 |     | <span class='neutral'>             * 57       | JUMPI          |                          |                                             |</span>
  419 |     | <span class='neutral'>             * 34       | CALLVALUE      | cv                       |                                             |</span>
  420 |     | <span class='neutral'>             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |</span>
  421 |     | <span class='neutral'>             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |</span>
  422 |     | <span class='neutral'>             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |</span>
  423 |     | <span class='neutral'>             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |</span>
  424 |     | <span class='neutral'>             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |</span>
  425 |     | <span class='neutral'>             * a1       | LOG1           |                          | [0..0x20): callvalue                        |</span>
  426 |     | <span class='neutral'>             * 00       | STOP           |                          | [0..0x20): callvalue                        |</span>
  427 |     | <span class='neutral'>             * 5b       | JUMPDEST       |                          |                                             |</span>
  428 |     | <span class='neutral'>             *                                                                                                    |</span>
  429 |     | <span class='neutral'>             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  430 |     | <span class='neutral'>             * 36       | CALLDATASIZE   | cds                      |                                             |</span>
  431 |     | <span class='neutral'>             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |</span>
  432 |     | <span class='neutral'>             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |</span>
  433 |     | <span class='neutral'>             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |</span>
  434 |     | <span class='neutral'>             *                                                                                                    |</span>
  435 |     | <span class='neutral'>             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  436 |     | <span class='neutral'>             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |</span>
  437 |     | <span class='neutral'>             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |</span>
  438 |     | <span class='neutral'>             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |</span>
  439 |     | <span class='neutral'>             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |</span>
  440 |     | <span class='neutral'>             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |</span>
  441 |     | <span class='neutral'>             *                                                                                                    |</span>
  442 |     | <span class='neutral'>             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  443 |     | <span class='neutral'>             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |</span>
  444 |     | <span class='neutral'>             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |</span>
  445 |     | <span class='neutral'>             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |</span>
  446 |     | <span class='neutral'>             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |</span>
  447 |     | <span class='neutral'>             *                                                                                                    |</span>
  448 |     | <span class='neutral'>             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  449 |     | <span class='neutral'>             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |</span>
  450 |     | <span class='neutral'>             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |</span>
  451 |     | <span class='neutral'>             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |</span>
  452 |     | <span class='neutral'>             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |</span>
  453 |     | <span class='neutral'>             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |</span>
  454 |     | <span class='neutral'>             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |</span>
  455 |     | <span class='neutral'>             *                                                                                                    |</span>
  456 |     | <span class='neutral'>             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  457 |     | <span class='neutral'>             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |</span>
  458 |     | <span class='neutral'>             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |</span>
  459 |     | <span class='neutral'>             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |</span>
  460 |     | <span class='neutral'>             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |</span>
  461 |     | <span class='neutral'>             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |</span>
  462 |     | <span class='neutral'>             *                                                                                                    |</span>
  463 |     | <span class='neutral'>             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |</span>
  464 |     | <span class='neutral'>             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |</span>
  465 |     | <span class='neutral'>             *                                                                                                    |</span>
  466 |     | <span class='neutral'>             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  467 |     | <span class='neutral'>             * fd       | REVERT         |                          | [0..rds): returndata                        |</span>
  468 |     | <span class='neutral'>             *                                                                                                    |</span>
  469 |     | <span class='neutral'>             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  470 |     | <span class='neutral'>             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |</span>
  471 |     | <span class='neutral'>             * f3       | RETURN         |                          | [0..rds): returndata                        |</span>
  472 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------------------------+</span>
  473 |     | <span class='neutral'>             */</span>
  474 |     | <span class='neutral'>            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.</span>
  475 |     | <span class='neutral'>            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.</span>
  476 |     | <span class='neutral'>            // Write the rest of the bytecode.</span>
  477 |     | <span class='neutral'>            mstore(</span>
  478 |     | <span class='neutral'>                sub(data, 0x21),</span>
  479 |     | <span class='neutral'>                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)</span>
  480 |     | <span class='neutral'>            )</span>
  481 |     | <span class='neutral'>            // `keccak256(&quot;ReceiveETH(uint256)&quot;)`</span>
  482 |     | <span class='neutral'>            mstore(</span>
  483 |     | <span class='neutral'>                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff</span>
  484 |     | <span class='neutral'>            )</span>
  485 |     | <span class='neutral'>            mstore(</span>
  486 |     | <span class='neutral'>                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.</span>
  487 |     | <span class='neutral'>                // The actual EVM limit may be smaller and may change over time.</span>
  488 |     | <span class='neutral'>                sub(data, add(0x59, lt(extraLength, 0xff9e))),</span>
  489 |     | <span class='neutral'>                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)</span>
  490 |     | <span class='neutral'>            )</span>
  491 |     | <span class='neutral'>            mstore(dataEnd, shl(0xf0, extraLength))</span>
  492 |     | <span class='neutral'></span>
  493 |     | <span class='neutral'>            instance := create(value, sub(data, 0x4c), add(extraLength, 0x6c))</span>
  494 |     | <span class='neutral'>            if iszero(instance) {</span>
  495 |     | <span class='neutral'>                mstore(0x00, 0x30116425) // `DeploymentFailed()`.</span>
  496 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  497 |     | <span class='neutral'>            }</span>
  498 |     | <span class='neutral'></span>
  499 |     | <span class='neutral'>            // Restore the overwritten memory surrounding `data`.</span>
  500 |     | <span class='neutral'>            mstore(dataEnd, mAfter1)</span>
  501 |     | <span class='neutral'>            mstore(data, dataLength)</span>
  502 |     | <span class='neutral'>            mstore(sub(data, 0x20), mBefore1)</span>
  503 |     | <span class='neutral'>            mstore(sub(data, 0x40), mBefore2)</span>
  504 |     | <span class='neutral'>            mstore(sub(data, 0x60), mBefore3)</span>
  505 |     | <span class='neutral'>        }</span>
  506 |     | <span class='neutral'>    }</span>
  507 |     | <span class='neutral'></span>
  508 |     | <span class='neutral'>    /// @dev Deploys a deterministic clone of `implementation`</span>
  509 |     | <span class='neutral'>    /// with immutable arguments encoded in `data` and `salt`.</span>
  510 |     | <span class='neutral'>    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)</span>
  511 |     | <span class='neutral'>        internal</span>
  512 |     | <span class='neutral'>        returns (address instance)</span>
  513 |     | <span class='neutral'>    {</span>
  514 |     | <span class='neutral'>        instance = cloneDeterministic(0, implementation, data, salt);</span>
  515 |     | <span class='neutral'>    }</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='neutral'>    /// @dev Deploys a deterministic clone of `implementation`</span>
  518 |     | <span class='neutral'>    /// with immutable arguments encoded in `data` and `salt`.</span>
  519 |     | <span class='neutral'>    function cloneDeterministic(</span>
  520 |     | <span class='neutral'>        uint256 value,</span>
  521 |     | <span class='neutral'>        address implementation,</span>
  522 |     | <span class='neutral'>        bytes memory data,</span>
  523 |     | <span class='neutral'>        bytes32 salt</span>
  524 |     | <span class='neutral'>    ) internal returns (address instance) {</span>
  525 |     | <span class='neutral'>        assembly {</span>
  526 |     | <span class='neutral'>            // Compute the boundaries of the data and cache the memory slots around it.</span>
  527 |     | <span class='neutral'>            let mBefore3 := mload(sub(data, 0x60))</span>
  528 |     | <span class='neutral'>            let mBefore2 := mload(sub(data, 0x40))</span>
  529 |     | <span class='neutral'>            let mBefore1 := mload(sub(data, 0x20))</span>
  530 |     | <span class='neutral'>            let dataLength := mload(data)</span>
  531 |     | <span class='neutral'>            let dataEnd := add(add(data, 0x20), dataLength)</span>
  532 |     | <span class='neutral'>            let mAfter1 := mload(dataEnd)</span>
  533 |     | <span class='neutral'></span>
  534 |     | <span class='neutral'>            // +2 bytes for telling how much data there is appended to the call.</span>
  535 |     | <span class='neutral'>            let extraLength := add(dataLength, 2)</span>
  536 |     | <span class='neutral'></span>
  537 |     | <span class='neutral'>            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.</span>
  538 |     | <span class='neutral'>            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.</span>
  539 |     | <span class='neutral'>            // Write the rest of the bytecode.</span>
  540 |     | <span class='neutral'>            mstore(</span>
  541 |     | <span class='neutral'>                sub(data, 0x21),</span>
  542 |     | <span class='neutral'>                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)</span>
  543 |     | <span class='neutral'>            )</span>
  544 |     | <span class='neutral'>            // `keccak256(&quot;ReceiveETH(uint256)&quot;)`</span>
  545 |     | <span class='neutral'>            mstore(</span>
  546 |     | <span class='neutral'>                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff</span>
  547 |     | <span class='neutral'>            )</span>
  548 |     | <span class='neutral'>            mstore(</span>
  549 |     | <span class='neutral'>                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.</span>
  550 |     | <span class='neutral'>                // The actual EVM limit may be smaller and may change over time.</span>
  551 |     | <span class='neutral'>                sub(data, add(0x59, lt(extraLength, 0xff9e))),</span>
  552 |     | <span class='neutral'>                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)</span>
  553 |     | <span class='neutral'>            )</span>
  554 |     | <span class='neutral'>            mstore(dataEnd, shl(0xf0, extraLength))</span>
  555 |     | <span class='neutral'></span>
  556 |     | <span class='neutral'>            instance := create2(value, sub(data, 0x4c), add(extraLength, 0x6c), salt)</span>
  557 |     | <span class='neutral'>            if iszero(instance) {</span>
  558 |     | <span class='neutral'>                mstore(0x00, 0x30116425) // `DeploymentFailed()`.</span>
  559 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  560 |     | <span class='neutral'>            }</span>
  561 |     | <span class='neutral'></span>
  562 |     | <span class='neutral'>            // Restore the overwritten memory surrounding `data`.</span>
  563 |     | <span class='neutral'>            mstore(dataEnd, mAfter1)</span>
  564 |     | <span class='neutral'>            mstore(data, dataLength)</span>
  565 |     | <span class='neutral'>            mstore(sub(data, 0x20), mBefore1)</span>
  566 |     | <span class='neutral'>            mstore(sub(data, 0x40), mBefore2)</span>
  567 |     | <span class='neutral'>            mstore(sub(data, 0x60), mBefore3)</span>
  568 |     | <span class='neutral'>        }</span>
  569 |     | <span class='neutral'>    }</span>
  570 |     | <span class='neutral'></span>
  571 |     | <span class='neutral'>    /// @dev Returns the initialization code hash of the clone of `implementation`</span>
  572 |     | <span class='neutral'>    /// using immutable arguments encoded in `data`.</span>
  573 |     | <span class='neutral'>    function initCode(address implementation, bytes memory data)</span>
  574 |     | <span class='neutral'>        internal</span>
  575 |     | <span class='neutral'>        pure</span>
  576 |     | <span class='neutral'>        returns (bytes memory result)</span>
  577 |     | <span class='neutral'>    {</span>
  578 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  579 |     | <span class='neutral'>        assembly {</span>
  580 |     | <span class='neutral'>            result := mload(0x40)</span>
  581 |     | <span class='neutral'>            let dataLength := mload(data)</span>
  582 |     | <span class='neutral'></span>
  583 |     | <span class='neutral'>            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.</span>
  584 |     | <span class='neutral'>            // The actual EVM limit may be smaller and may change over time.</span>
  585 |     | <span class='neutral'>            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))</span>
  586 |     | <span class='neutral'></span>
  587 |     | <span class='neutral'>            let o := add(result, 0x8c)</span>
  588 |     | <span class='neutral'>            let end := add(o, dataLength)</span>
  589 |     | <span class='neutral'></span>
  590 |     | <span class='neutral'>            // Copy the `data` into `result`.</span>
  591 |     | <span class='neutral'>            for { let d := sub(add(data, 0x20), o) } 1 {} {</span>
  592 |     | <span class='neutral'>                mstore(o, mload(add(o, d)))</span>
  593 |     | <span class='neutral'>                o := add(o, 0x20)</span>
  594 |     | <span class='neutral'>                if iszero(lt(o, end)) { break }</span>
  595 |     | <span class='neutral'>            }</span>
  596 |     | <span class='neutral'></span>
  597 |     | <span class='neutral'>            // +2 bytes for telling how much data there is appended to the call.</span>
  598 |     | <span class='neutral'>            let extraLength := add(dataLength, 2)</span>
  599 |     | <span class='neutral'></span>
  600 |     | <span class='neutral'>            mstore(add(result, 0x6c), 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.</span>
  601 |     | <span class='neutral'>            mstore(add(result, 0x5f), implementation) // Write the address of the implementation.</span>
  602 |     | <span class='neutral'>            // Write the rest of the bytecode.</span>
  603 |     | <span class='neutral'>            mstore(</span>
  604 |     | <span class='neutral'>                add(result, 0x4b),</span>
  605 |     | <span class='neutral'>                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)</span>
  606 |     | <span class='neutral'>            )</span>
  607 |     | <span class='neutral'>            // `keccak256(&quot;ReceiveETH(uint256)&quot;)`</span>
  608 |     | <span class='neutral'>            mstore(</span>
  609 |     | <span class='neutral'>                add(result, 0x32),</span>
  610 |     | <span class='neutral'>                0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff</span>
  611 |     | <span class='neutral'>            )</span>
  612 |     | <span class='neutral'>            mstore(</span>
  613 |     | <span class='neutral'>                add(result, 0x12),</span>
  614 |     | <span class='neutral'>                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)</span>
  615 |     | <span class='neutral'>            )</span>
  616 |     | <span class='neutral'>            mstore(end, shl(0xf0, extraLength))</span>
  617 |     | <span class='neutral'>            mstore(add(end, 0x02), 0) // Zeroize the slot after the result.</span>
  618 |     | <span class='neutral'>            mstore(result, add(extraLength, 0x6c)) // Store the length.</span>
  619 |     | <span class='neutral'>            mstore(0x40, add(0x22, end)) // Allocate memory.</span>
  620 |     | <span class='neutral'>        }</span>
  621 |     | <span class='neutral'>    }</span>
  622 |     | <span class='neutral'></span>
  623 |     | <span class='neutral'>    /// @dev Returns the initialization code hash of the clone of `implementation`</span>
  624 |     | <span class='neutral'>    /// using immutable arguments encoded in `data`.</span>
  625 |     | <span class='neutral'>    /// Used for mining vanity addresses with create2crunch.</span>
  626 |     | <span class='neutral'>    function initCodeHash(address implementation, bytes memory data)</span>
  627 |     | <span class='neutral'>        internal</span>
  628 |     | <span class='neutral'>        pure</span>
  629 |     | <span class='neutral'>        returns (bytes32 hash)</span>
  630 |     | <span class='neutral'>    {</span>
  631 |     | <span class='neutral'>        assembly {</span>
  632 |     | <span class='neutral'>            // Compute the boundaries of the data and cache the memory slots around it.</span>
  633 |     | <span class='neutral'>            let mBefore3 := mload(sub(data, 0x60))</span>
  634 |     | <span class='neutral'>            let mBefore2 := mload(sub(data, 0x40))</span>
  635 |     | <span class='neutral'>            let mBefore1 := mload(sub(data, 0x20))</span>
  636 |     | <span class='neutral'>            let dataLength := mload(data)</span>
  637 |     | <span class='neutral'>            let dataEnd := add(add(data, 0x20), dataLength)</span>
  638 |     | <span class='neutral'>            let mAfter1 := mload(dataEnd)</span>
  639 |     | <span class='neutral'></span>
  640 |     | <span class='neutral'>            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.</span>
  641 |     | <span class='neutral'>            // The actual EVM limit may be smaller and may change over time.</span>
  642 |     | <span class='neutral'>            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))</span>
  643 |     | <span class='neutral'></span>
  644 |     | <span class='neutral'>            // +2 bytes for telling how much data there is appended to the call.</span>
  645 |     | <span class='neutral'>            let extraLength := add(dataLength, 2)</span>
  646 |     | <span class='neutral'></span>
  647 |     | <span class='neutral'>            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.</span>
  648 |     | <span class='neutral'>            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.</span>
  649 |     | <span class='neutral'>            // Write the rest of the bytecode.</span>
  650 |     | <span class='neutral'>            mstore(</span>
  651 |     | <span class='neutral'>                sub(data, 0x21),</span>
  652 |     | <span class='neutral'>                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)</span>
  653 |     | <span class='neutral'>            )</span>
  654 |     | <span class='neutral'>            // `keccak256(&quot;ReceiveETH(uint256)&quot;)`</span>
  655 |     | <span class='neutral'>            mstore(</span>
  656 |     | <span class='neutral'>                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff</span>
  657 |     | <span class='neutral'>            )</span>
  658 |     | <span class='neutral'>            mstore(</span>
  659 |     | <span class='neutral'>                sub(data, 0x5a),</span>
  660 |     | <span class='neutral'>                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)</span>
  661 |     | <span class='neutral'>            )</span>
  662 |     | <span class='neutral'>            mstore(dataEnd, shl(0xf0, extraLength))</span>
  663 |     | <span class='neutral'></span>
  664 |     | <span class='neutral'>            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))</span>
  665 |     | <span class='neutral'></span>
  666 |     | <span class='neutral'>            // Restore the overwritten memory surrounding `data`.</span>
  667 |     | <span class='neutral'>            mstore(dataEnd, mAfter1)</span>
  668 |     | <span class='neutral'>            mstore(data, dataLength)</span>
  669 |     | <span class='neutral'>            mstore(sub(data, 0x20), mBefore1)</span>
  670 |     | <span class='neutral'>            mstore(sub(data, 0x40), mBefore2)</span>
  671 |     | <span class='neutral'>            mstore(sub(data, 0x60), mBefore3)</span>
  672 |     | <span class='neutral'>        }</span>
  673 |     | <span class='neutral'>    }</span>
  674 |     | <span class='neutral'></span>
  675 |     | <span class='neutral'>    /// @dev Returns the address of the deterministic clone of</span>
  676 |     | <span class='neutral'>    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.</span>
  677 |     | <span class='neutral'>    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.</span>
  678 |     | <span class='neutral'>    function predictDeterministicAddress(</span>
  679 |     | <span class='neutral'>        address implementation,</span>
  680 |     | <span class='neutral'>        bytes memory data,</span>
  681 |     | <span class='neutral'>        bytes32 salt,</span>
  682 |     | <span class='neutral'>        address deployer</span>
  683 |     | <span class='neutral'>    ) internal pure returns (address predicted) {</span>
  684 |     | <span class='neutral'>        bytes32 hash = initCodeHash(implementation, data);</span>
  685 |     | <span class='neutral'>        predicted = predictDeterministicAddress(hash, salt, deployer);</span>
  686 |     | <span class='neutral'>    }</span>
  687 |     | <span class='neutral'></span>
  688 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  689 |     | <span class='neutral'>    /*              MINIMAL ERC1967 PROXY OPERATIONS              */</span>
  690 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  691 |     | <span class='neutral'></span>
  692 |     | <span class='neutral'>    // Note: The ERC1967 proxy here is intended to be upgraded with UUPS.</span>
  693 |     | <span class='neutral'>    // This is NOT the same as ERC1967Factory&#39;s transparent proxy, which includes admin logic.</span>
  694 |     | <span class='neutral'></span>
  695 |     | <span class='neutral'>    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.</span>
  696 |     | <span class='neutral'>    function deployERC1967(address implementation) internal returns (address instance) {</span>
  697 |     | <span class='neutral'>        instance = deployERC1967(0, implementation);</span>
  698 |     | <span class='neutral'>    }</span>
  699 |     | <span class='neutral'></span>
  700 |     | <span class='neutral'>    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.</span>
  701 |     | <span class='neutral'>    /// Deposits `value` ETH during deployment.</span>
  702 |     | <span class='neutral'>    function deployERC1967(uint256 value, address implementation)</span>
  703 |     | <span class='neutral'>        internal</span>
  704 |     | <span class='neutral'>        returns (address instance)</span>
  705 |     | <span class='neutral'>    {</span>
  706 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  707 |     | <span class='neutral'>        assembly {</span>
  708 |     | <span class='neutral'>            /**</span>
  709 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------+</span>
  710 |     | <span class='neutral'>             * CREATION (34 bytes)                                                              |</span>
  711 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------|</span>
  712 |     | <span class='neutral'>             * Opcode     | Mnemonic       | Stack            | Memory                          |</span>
  713 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------|</span>
  714 |     | <span class='neutral'>             * 60 runSize | PUSH1 runSize  | r                |                                 |</span>
  715 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0 r              |                                 |</span>
  716 |     | <span class='neutral'>             * 81         | DUP2           | r 0 r            |                                 |</span>
  717 |     | <span class='neutral'>             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |</span>
  718 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |</span>
  719 |     | <span class='neutral'>             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |</span>
  720 |     | <span class='neutral'>             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |</span>
  721 |     | <span class='neutral'>             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |</span>
  722 |     | <span class='neutral'>             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |</span>
  723 |     | <span class='neutral'>             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |</span>
  724 |     | <span class='neutral'>             * f3         | RETURN         |                  | [0..runSize): runtime code      |</span>
  725 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------|</span>
  726 |     | <span class='neutral'>             * RUNTIME (61 bytes)                                                               |</span>
  727 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------|</span>
  728 |     | <span class='neutral'>             * Opcode     | Mnemonic       | Stack            | Memory                          |</span>
  729 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------|</span>
  730 |     | <span class='neutral'>             *                                                                                  |</span>
  731 |     | <span class='neutral'>             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  732 |     | <span class='neutral'>             * 36         | CALLDATASIZE   | cds              |                                 |</span>
  733 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0 cds            |                                 |</span>
  734 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |</span>
  735 |     | <span class='neutral'>             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |</span>
  736 |     | <span class='neutral'>             *                                                                                  |</span>
  737 |     | <span class='neutral'>             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |</span>
  738 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0                |                                 |</span>
  739 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0 0              |                                 |</span>
  740 |     | <span class='neutral'>             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |</span>
  741 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |</span>
  742 |     | <span class='neutral'>             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |</span>
  743 |     | <span class='neutral'>             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |</span>
  744 |     | <span class='neutral'>             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |</span>
  745 |     | <span class='neutral'>             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |</span>
  746 |     | <span class='neutral'>             *                                                                                  |</span>
  747 |     | <span class='neutral'>             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  748 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |</span>
  749 |     | <span class='neutral'>             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |</span>
  750 |     | <span class='neutral'>             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |</span>
  751 |     | <span class='neutral'>             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |</span>
  752 |     | <span class='neutral'>             *                                                                                  |</span>
  753 |     | <span class='neutral'>             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |</span>
  754 |     | <span class='neutral'>             * 60 0x38    | PUSH1 0x38     | dest succ        | [0..returndatasize): returndata |</span>
  755 |     | <span class='neutral'>             * 57         | JUMPI          |                  | [0..returndatasize): returndata |</span>
  756 |     | <span class='neutral'>             *                                                                                  |</span>
  757 |     | <span class='neutral'>             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  758 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |</span>
  759 |     | <span class='neutral'>             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |</span>
  760 |     | <span class='neutral'>             * fd         | REVERT         |                  | [0..returndatasize): returndata |</span>
  761 |     | <span class='neutral'>             *                                                                                  |</span>
  762 |     | <span class='neutral'>             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |</span>
  763 |     | <span class='neutral'>             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |</span>
  764 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |</span>
  765 |     | <span class='neutral'>             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |</span>
  766 |     | <span class='neutral'>             * f3         | RETURN         |                  | [0..returndatasize): returndata |</span>
  767 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------+</span>
  768 |     | <span class='neutral'>             */</span>
  769 |     | <span class='neutral'>            let m := mload(0x40) // Cache the free memory pointer.</span>
  770 |     | <span class='neutral'>            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)</span>
  771 |     | <span class='neutral'>            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)</span>
  772 |     | <span class='neutral'>            mstore(0x20, 0x6009)</span>
  773 |     | <span class='neutral'>            mstore(0x1e, implementation)</span>
  774 |     | <span class='neutral'>            mstore(0x0a, 0x603d3d8160223d3973)</span>
  775 |     | <span class='neutral'>            instance := create(value, 0x21, 0x5f)</span>
  776 |     | <span class='neutral'>            if iszero(instance) {</span>
  777 |     | <span class='neutral'>                mstore(0x00, 0x30116425) // `DeploymentFailed()`.</span>
  778 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  779 |     | <span class='neutral'>            }</span>
  780 |     | <span class='neutral'>            mstore(0x40, m) // Restore the free memory pointer.</span>
  781 |     | <span class='neutral'>            mstore(0x60, 0) // Restore the zero slot.</span>
  782 |     | <span class='neutral'>        }</span>
  783 |     | <span class='neutral'>    }</span>
  784 |     | <span class='neutral'></span>
  785 |     | <span class='neutral'>    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.</span>
  786 |     | <span class='neutral'>    function deployDeterministicERC1967(address implementation, bytes32 salt)</span>
  787 |     | <span class='neutral'>        internal</span>
  788 |     | <span class='neutral'>        returns (address instance)</span>
  789 |     | <span class='neutral'>    {</span>
  790 |     | <span class='neutral'>        instance = deployDeterministicERC1967(0, implementation, salt);</span>
  791 |     | <span class='neutral'>    }</span>
  792 |     | <span class='neutral'></span>
  793 |     | <span class='neutral'>    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.</span>
  794 |     | <span class='neutral'>    /// Deposits `value` ETH during deployment.</span>
  795 |     | <span class='neutral'>    function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt)</span>
  796 |     | <span class='neutral'>        internal</span>
  797 |     | <span class='neutral'>        returns (address instance)</span>
  798 |     | <span class='neutral'>    {</span>
  799 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  800 |     | <span class='neutral'>        assembly {</span>
  801 |     | <span class='neutral'>            let m := mload(0x40) // Cache the free memory pointer.</span>
  802 |     | <span class='neutral'>            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)</span>
  803 |     | <span class='neutral'>            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)</span>
  804 |     | <span class='neutral'>            mstore(0x20, 0x6009)</span>
  805 |     | <span class='neutral'>            mstore(0x1e, implementation)</span>
  806 |     | <span class='neutral'>            mstore(0x0a, 0x603d3d8160223d3973)</span>
  807 |     | <span class='neutral'>            instance := create2(value, 0x21, 0x5f, salt)</span>
  808 |     | <span class='neutral'>            if iszero(instance) {</span>
  809 |     | <span class='neutral'>                mstore(0x00, 0x30116425) // `DeploymentFailed()`.</span>
  810 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  811 |     | <span class='neutral'>            }</span>
  812 |     | <span class='neutral'>            mstore(0x40, m) // Restore the free memory pointer.</span>
  813 |     | <span class='neutral'>            mstore(0x60, 0) // Restore the zero slot.</span>
  814 |     | <span class='neutral'>        }</span>
  815 |     | <span class='neutral'>    }</span>
  816 |     | <span class='neutral'></span>
  817 |     | <span class='neutral'>    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.</span>
  818 |     | <span class='neutral'>    /// Note: This method is intended for use in ERC4337 factories,</span>
  819 |     | <span class='neutral'>    /// which are expected to NOT revert if the proxy is already deployed.</span>
  820 |     | <span class='neutral'>    function createDeterministicERC1967(address implementation, bytes32 salt)</span>
  821 |     | <span class='neutral'>        internal</span>
  822 |     | <span class='neutral'>        returns (bool alreadyDeployed, address instance)</span>
  823 |     | <span class='neutral'>    {</span>
  824 |     | <span class='neutral'>        return createDeterministicERC1967(0, implementation, salt);</span>
  825 |     | <span class='neutral'>    }</span>
  826 |     | <span class='neutral'></span>
  827 |     | <span class='neutral'>    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.</span>
  828 |     | <span class='neutral'>    /// Deposits `value` ETH during deployment.</span>
  829 |     | <span class='neutral'>    /// Note: This method is intended for use in ERC4337 factories,</span>
  830 |     | <span class='neutral'>    /// which are expected to NOT revert if the proxy is already deployed.</span>
  831 |     | <span class='neutral'>    function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt)</span>
  832 |     | <span class='neutral'>        internal</span>
  833 |     | <span class='neutral'>        returns (bool alreadyDeployed, address instance)</span>
  834 |     | <span class='neutral'>    {</span>
  835 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  836 |     | <span class='neutral'>        assembly {</span>
  837 |     | <span class='neutral'>            let m := mload(0x40) // Cache the free memory pointer.</span>
  838 |     | <span class='neutral'>            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)</span>
  839 |     | <span class='neutral'>            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)</span>
  840 |     | <span class='neutral'>            mstore(0x20, 0x6009)</span>
  841 |     | <span class='neutral'>            mstore(0x1e, implementation)</span>
  842 |     | <span class='neutral'>            mstore(0x0a, 0x603d3d8160223d3973)</span>
  843 |     | <span class='neutral'>            // Compute and store the bytecode hash.</span>
  844 |     | <span class='neutral'>            mstore(add(m, 0x35), keccak256(0x21, 0x5f))</span>
  845 |     | <span class='neutral'>            mstore(m, shl(88, address()))</span>
  846 |     | <span class='neutral'>            mstore8(m, 0xff) // Write the prefix.</span>
  847 |     | <span class='neutral'>            mstore(add(m, 0x15), salt)</span>
  848 |     | <span class='neutral'>            instance := keccak256(m, 0x55)</span>
  849 |     | <span class='neutral'>            for {} 1 {} {</span>
  850 |     | <span class='neutral'>                if iszero(extcodesize(instance)) {</span>
  851 |     | <span class='neutral'>                    instance := create2(value, 0x21, 0x5f, salt)</span>
  852 |     | <span class='neutral'>                    if iszero(instance) {</span>
  853 |     | <span class='neutral'>                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.</span>
  854 |     | <span class='neutral'>                        revert(0x1c, 0x04)</span>
  855 |     | <span class='neutral'>                    }</span>
  856 |     | <span class='neutral'>                    break</span>
  857 |     | <span class='neutral'>                }</span>
  858 |     | <span class='neutral'>                alreadyDeployed := 1</span>
  859 |     | <span class='neutral'>                if iszero(value) { break }</span>
  860 |     | <span class='neutral'>                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {</span>
  861 |     | <span class='neutral'>                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.</span>
  862 |     | <span class='neutral'>                    revert(0x1c, 0x04)</span>
  863 |     | <span class='neutral'>                }</span>
  864 |     | <span class='neutral'>                break</span>
  865 |     | <span class='neutral'>            }</span>
  866 |     | <span class='neutral'>            mstore(0x40, m) // Restore the free memory pointer.</span>
  867 |     | <span class='neutral'>            mstore(0x60, 0) // Restore the zero slot.</span>
  868 |     | <span class='neutral'>        }</span>
  869 |     | <span class='neutral'>    }</span>
  870 |     | <span class='neutral'></span>
  871 |     | <span class='neutral'>    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.</span>
  872 |     | <span class='neutral'>    function initCodeERC1967(address implementation) internal pure returns (bytes memory result) {</span>
  873 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  874 |     | <span class='neutral'>        assembly {</span>
  875 |     | <span class='neutral'>            result := mload(0x40)</span>
  876 |     | <span class='neutral'>            mstore(</span>
  877 |     | <span class='neutral'>                add(result, 0x60),</span>
  878 |     | <span class='neutral'>                0x3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f300</span>
  879 |     | <span class='neutral'>            )</span>
  880 |     | <span class='neutral'>            mstore(</span>
  881 |     | <span class='neutral'>                add(result, 0x40),</span>
  882 |     | <span class='neutral'>                0x55f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076cc</span>
  883 |     | <span class='neutral'>            )</span>
  884 |     | <span class='neutral'>            mstore(add(result, 0x20), or(shl(24, implementation), 0x600951))</span>
  885 |     | <span class='neutral'>            mstore(add(result, 0x09), 0x603d3d8160223d3973)</span>
  886 |     | <span class='neutral'>            mstore(result, 0x5f) // Store the length.</span>
  887 |     | <span class='neutral'>            mstore(0x40, add(result, 0x80)) // Allocate memory.</span>
  888 |     | <span class='neutral'>        }</span>
  889 |     | <span class='neutral'>    }</span>
  890 |     | <span class='neutral'></span>
  891 |     | <span class='neutral'>    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.</span>
  892 |     | <span class='neutral'>    /// Used for mining vanity addresses with create2crunch.</span>
  893 |     | <span class='neutral'>    function initCodeHashERC1967(address implementation) internal pure returns (bytes32 hash) {</span>
  894 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  895 |     | <span class='neutral'>        assembly {</span>
  896 |     | <span class='neutral'>            let m := mload(0x40) // Cache the free memory pointer.</span>
  897 |     | <span class='neutral'>            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)</span>
  898 |     | <span class='neutral'>            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)</span>
  899 |     | <span class='neutral'>            mstore(0x20, 0x6009)</span>
  900 |     | <span class='neutral'>            mstore(0x1e, implementation)</span>
  901 |     | <span class='neutral'>            mstore(0x0a, 0x603d3d8160223d3973)</span>
  902 |     | <span class='neutral'>            hash := keccak256(0x21, 0x5f)</span>
  903 |     | <span class='neutral'>            mstore(0x40, m) // Restore the free memory pointer.</span>
  904 |     | <span class='neutral'>            mstore(0x60, 0) // Restore the zero slot.</span>
  905 |     | <span class='neutral'>        }</span>
  906 |     | <span class='neutral'>    }</span>
  907 |     | <span class='neutral'></span>
  908 |     | <span class='neutral'>    /// @dev Returns the address of the deterministic ERC1967 proxy of `implementation`,</span>
  909 |     | <span class='neutral'>    /// with `salt` by `deployer`.</span>
  910 |     | <span class='neutral'>    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.</span>
  911 |     | <span class='neutral'>    function predictDeterministicAddressERC1967(</span>
  912 |     | <span class='neutral'>        address implementation,</span>
  913 |     | <span class='neutral'>        bytes32 salt,</span>
  914 |     | <span class='neutral'>        address deployer</span>
  915 |     | <span class='neutral'>    ) internal pure returns (address predicted) {</span>
  916 |     | <span class='neutral'>        bytes32 hash = initCodeHashERC1967(implementation);</span>
  917 |     | <span class='neutral'>        predicted = predictDeterministicAddress(hash, salt, deployer);</span>
  918 |     | <span class='neutral'>    }</span>
  919 |     | <span class='neutral'></span>
  920 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  921 |     | <span class='neutral'>    /*                 ERC1967I PROXY OPERATIONS                  */</span>
  922 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  923 |     | <span class='neutral'></span>
  924 |     | <span class='neutral'>    // Note: This proxy has a special code path that activates if `calldatasize() == 1`.</span>
  925 |     | <span class='neutral'>    // This code path skips the delegatecall and directly returns the `implementation` address.</span>
  926 |     | <span class='neutral'>    // The returned implementation is guaranteed to be valid if the keccak256 of the</span>
  927 |     | <span class='neutral'>    // proxy&#39;s code is equal to `ERC1967I_CODE_HASH`.</span>
  928 |     | <span class='neutral'></span>
  929 |     | <span class='neutral'>    /// @dev Deploys a minimal ERC1967I proxy with `implementation`.</span>
  930 |     | <span class='neutral'>    function deployERC1967I(address implementation) internal returns (address instance) {</span>
  931 |     | <span class='neutral'>        instance = deployERC1967I(0, implementation);</span>
  932 |     | <span class='neutral'>    }</span>
  933 |     | <span class='neutral'></span>
  934 |     | <span class='neutral'>    /// @dev Deploys a ERC1967I proxy with `implementation`.</span>
  935 |     | <span class='neutral'>    /// Deposits `value` ETH during deployment.</span>
  936 |     | <span class='neutral'>    function deployERC1967I(uint256 value, address implementation)</span>
  937 |     | <span class='neutral'>        internal</span>
  938 |     | <span class='neutral'>        returns (address instance)</span>
  939 |     | <span class='neutral'>    {</span>
  940 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  941 |     | <span class='neutral'>        assembly {</span>
  942 |     | <span class='neutral'>            /**</span>
  943 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------+</span>
  944 |     | <span class='neutral'>             * CREATION (34 bytes)                                                              |</span>
  945 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------|</span>
  946 |     | <span class='neutral'>             * Opcode     | Mnemonic       | Stack            | Memory                          |</span>
  947 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------|</span>
  948 |     | <span class='neutral'>             * 60 runSize | PUSH1 runSize  | r                |                                 |</span>
  949 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0 r              |                                 |</span>
  950 |     | <span class='neutral'>             * 81         | DUP2           | r 0 r            |                                 |</span>
  951 |     | <span class='neutral'>             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |</span>
  952 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |</span>
  953 |     | <span class='neutral'>             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |</span>
  954 |     | <span class='neutral'>             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |</span>
  955 |     | <span class='neutral'>             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |</span>
  956 |     | <span class='neutral'>             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |</span>
  957 |     | <span class='neutral'>             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |</span>
  958 |     | <span class='neutral'>             * f3         | RETURN         |                  | [0..runSize): runtime code      |</span>
  959 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------|</span>
  960 |     | <span class='neutral'>             * RUNTIME (82 bytes)                                                               |</span>
  961 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------|</span>
  962 |     | <span class='neutral'>             * Opcode     | Mnemonic       | Stack            | Memory                          |</span>
  963 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------|</span>
  964 |     | <span class='neutral'>             *                                                                                  |</span>
  965 |     | <span class='neutral'>             * ::: check calldatasize ::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  966 |     | <span class='neutral'>             * 36         | CALLDATASIZE   | cds              |                                 |</span>
  967 |     | <span class='neutral'>             * 58         | PC             | 1 cds            |                                 |</span>
  968 |     | <span class='neutral'>             * 14         | EQ             | eqs              |                                 |</span>
  969 |     | <span class='neutral'>             * 60 0x43    | PUSH1 0x43     | dest eqs         |                                 |</span>
  970 |     | <span class='neutral'>             * 57         | JUMPI          |                  |                                 |</span>
  971 |     | <span class='neutral'>             *                                                                                  |</span>
  972 |     | <span class='neutral'>             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  973 |     | <span class='neutral'>             * 36         | CALLDATASIZE   | cds              |                                 |</span>
  974 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0 cds            |                                 |</span>
  975 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |</span>
  976 |     | <span class='neutral'>             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |</span>
  977 |     | <span class='neutral'>             *                                                                                  |</span>
  978 |     | <span class='neutral'>             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |</span>
  979 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0                |                                 |</span>
  980 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0 0              |                                 |</span>
  981 |     | <span class='neutral'>             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |</span>
  982 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |</span>
  983 |     | <span class='neutral'>             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |</span>
  984 |     | <span class='neutral'>             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |</span>
  985 |     | <span class='neutral'>             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |</span>
  986 |     | <span class='neutral'>             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |</span>
  987 |     | <span class='neutral'>             *                                                                                  |</span>
  988 |     | <span class='neutral'>             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  989 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |</span>
  990 |     | <span class='neutral'>             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |</span>
  991 |     | <span class='neutral'>             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |</span>
  992 |     | <span class='neutral'>             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |</span>
  993 |     | <span class='neutral'>             *                                                                                  |</span>
  994 |     | <span class='neutral'>             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |</span>
  995 |     | <span class='neutral'>             * 60 0x3E    | PUSH1 0x3E     | dest succ        | [0..returndatasize): returndata |</span>
  996 |     | <span class='neutral'>             * 57         | JUMPI          |                  | [0..returndatasize): returndata |</span>
  997 |     | <span class='neutral'>             *                                                                                  |</span>
  998 |     | <span class='neutral'>             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |</span>
  999 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |</span>
 1000 |     | <span class='neutral'>             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |</span>
 1001 |     | <span class='neutral'>             * fd         | REVERT         |                  | [0..returndatasize): returndata |</span>
 1002 |     | <span class='neutral'>             *                                                                                  |</span>
 1003 |     | <span class='neutral'>             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |</span>
 1004 |     | <span class='neutral'>             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |</span>
 1005 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |</span>
 1006 |     | <span class='neutral'>             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |</span>
 1007 |     | <span class='neutral'>             * f3         | RETURN         |                  | [0..returndatasize): returndata |</span>
 1008 |     | <span class='neutral'>             *                                                                                  |</span>
 1009 |     | <span class='neutral'>             * ::: implementation , return :::::::::::::::::::::::::::::::::::::::::::::::::::: |</span>
 1010 |     | <span class='neutral'>             * 5b         | JUMPDEST       |                  |                                 |</span>
 1011 |     | <span class='neutral'>             * 60 0x20    | PUSH1 0x20     | 32               |                                 |</span>
 1012 |     | <span class='neutral'>             * 60 0x0F    | PUSH1 0x0F     | o 32             |                                 |</span>
 1013 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0 o 32           |                                 |</span>
 1014 |     | <span class='neutral'>             * 39         | CODECOPY       |                  | [0..32): implementation slot    |</span>
 1015 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0                | [0..32): implementation slot    |</span>
 1016 |     | <span class='neutral'>             * 51         | MLOAD          | slot             | [0..32): implementation slot    |</span>
 1017 |     | <span class='neutral'>             * 54         | SLOAD          | impl             | [0..32): implementation slot    |</span>
 1018 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0 impl           | [0..32): implementation slot    |</span>
 1019 |     | <span class='neutral'>             * 52         | MSTORE         |                  | [0..32): implementation address |</span>
 1020 |     | <span class='neutral'>             * 59         | MSIZE          | 32               | [0..32): implementation address |</span>
 1021 |     | <span class='neutral'>             * 3d         | RETURNDATASIZE | 0 32             | [0..32): implementation address |</span>
 1022 |     | <span class='neutral'>             * f3         | RETURN         |                  | [0..32): implementation address |</span>
 1023 |     | <span class='neutral'>             *                                                                                  |</span>
 1024 |     | <span class='neutral'>             * ---------------------------------------------------------------------------------+</span>
 1025 |     | <span class='neutral'>             */</span>
 1026 |     | <span class='neutral'>            let m := mload(0x40) // Cache the free memory pointer.</span>
 1027 |     | <span class='neutral'>            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)</span>
 1028 |     | <span class='neutral'>            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)</span>
 1029 |     | <span class='neutral'>            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)</span>
 1030 |     | <span class='neutral'>            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))</span>
 1031 |     | <span class='neutral'>            instance := create(value, 0x0c, 0x74)</span>
 1032 |     | <span class='neutral'>            if iszero(instance) {</span>
 1033 |     | <span class='neutral'>                mstore(0x00, 0x30116425) // `DeploymentFailed()`.</span>
 1034 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
 1035 |     | <span class='neutral'>            }</span>
 1036 |     | <span class='neutral'>            mstore(0x40, m) // Restore the free memory pointer.</span>
 1037 |     | <span class='neutral'>            mstore(0x60, 0) // Restore the zero slot.</span>
 1038 |     | <span class='neutral'>        }</span>
 1039 |     | <span class='neutral'>    }</span>
 1040 |     | <span class='neutral'></span>
 1041 |     | <span class='neutral'>    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.</span>
 1042 |     | <span class='neutral'>    function deployDeterministicERC1967I(address implementation, bytes32 salt)</span>
 1043 |     | <span class='neutral'>        internal</span>
 1044 |     | <span class='neutral'>        returns (address instance)</span>
 1045 |     | <span class='neutral'>    {</span>
 1046 |     | <span class='neutral'>        instance = deployDeterministicERC1967I(0, implementation, salt);</span>
 1047 |     | <span class='neutral'>    }</span>
 1048 |     | <span class='neutral'></span>
 1049 |     | <span class='neutral'>    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.</span>
 1050 |     | <span class='neutral'>    /// Deposits `value` ETH during deployment.</span>
 1051 |     | <span class='neutral'>    function deployDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)</span>
 1052 |     | <span class='neutral'>        internal</span>
 1053 |     | <span class='neutral'>        returns (address instance)</span>
 1054 |     | <span class='neutral'>    {</span>
 1055 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1056 |     | <span class='neutral'>        assembly {</span>
 1057 |     | <span class='neutral'>            let m := mload(0x40) // Cache the free memory pointer.</span>
 1058 |     | <span class='neutral'>            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)</span>
 1059 |     | <span class='neutral'>            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)</span>
 1060 |     | <span class='neutral'>            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)</span>
 1061 |     | <span class='neutral'>            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))</span>
 1062 |     | <span class='neutral'>            instance := create2(value, 0x0c, 0x74, salt)</span>
 1063 |     | <span class='neutral'>            if iszero(instance) {</span>
 1064 |     | <span class='neutral'>                mstore(0x00, 0x30116425) // `DeploymentFailed()`.</span>
 1065 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
 1066 |     | <span class='neutral'>            }</span>
 1067 |     | <span class='neutral'>            mstore(0x40, m) // Restore the free memory pointer.</span>
 1068 |     | <span class='neutral'>            mstore(0x60, 0) // Restore the zero slot.</span>
 1069 |     | <span class='neutral'>        }</span>
 1070 |     | <span class='neutral'>    }</span>
 1071 |     | <span class='neutral'></span>
 1072 |     | <span class='neutral'>    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.</span>
 1073 |     | <span class='neutral'>    /// Note: This method is intended for use in ERC4337 factories,</span>
 1074 |     | <span class='neutral'>    /// which are expected to NOT revert if the proxy is already deployed.</span>
 1075 |     | <span class='neutral'>    function createDeterministicERC1967I(address implementation, bytes32 salt)</span>
 1076 |     | <span class='neutral'>        internal</span>
 1077 |     | <span class='neutral'>        returns (bool alreadyDeployed, address instance)</span>
 1078 |     | <span class='neutral'>    {</span>
 1079 |     | <span class='neutral'>        return createDeterministicERC1967I(0, implementation, salt);</span>
 1080 |     | <span class='neutral'>    }</span>
 1081 |     | <span class='neutral'></span>
 1082 |     | <span class='neutral'>    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.</span>
 1083 |     | <span class='neutral'>    /// Deposits `value` ETH during deployment.</span>
 1084 |     | <span class='neutral'>    /// Note: This method is intended for use in ERC4337 factories,</span>
 1085 |     | <span class='neutral'>    /// which are expected to NOT revert if the proxy is already deployed.</span>
 1086 |     | <span class='neutral'>    function createDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)</span>
 1087 |     | <span class='neutral'>        internal</span>
 1088 |     | <span class='neutral'>        returns (bool alreadyDeployed, address instance)</span>
 1089 |     | <span class='neutral'>    {</span>
 1090 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1091 |     | <span class='neutral'>        assembly {</span>
 1092 |     | <span class='neutral'>            let m := mload(0x40) // Cache the free memory pointer.</span>
 1093 |     | <span class='neutral'>            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)</span>
 1094 |     | <span class='neutral'>            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)</span>
 1095 |     | <span class='neutral'>            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)</span>
 1096 |     | <span class='neutral'>            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))</span>
 1097 |     | <span class='neutral'>            // Compute and store the bytecode hash.</span>
 1098 |     | <span class='neutral'>            mstore(add(m, 0x35), keccak256(0x0c, 0x74))</span>
 1099 |     | <span class='neutral'>            mstore(m, shl(88, address()))</span>
 1100 |     | <span class='neutral'>            mstore8(m, 0xff) // Write the prefix.</span>
 1101 |     | <span class='neutral'>            mstore(add(m, 0x15), salt)</span>
 1102 |     | <span class='neutral'>            instance := keccak256(m, 0x55)</span>
 1103 |     | <span class='neutral'>            for {} 1 {} {</span>
 1104 |     | <span class='neutral'>                if iszero(extcodesize(instance)) {</span>
 1105 |     | <span class='neutral'>                    instance := create2(value, 0x0c, 0x74, salt)</span>
 1106 |     | <span class='neutral'>                    if iszero(instance) {</span>
 1107 |     | <span class='neutral'>                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.</span>
 1108 |     | <span class='neutral'>                        revert(0x1c, 0x04)</span>
 1109 |     | <span class='neutral'>                    }</span>
 1110 |     | <span class='neutral'>                    break</span>
 1111 |     | <span class='neutral'>                }</span>
 1112 |     | <span class='neutral'>                alreadyDeployed := 1</span>
 1113 |     | <span class='neutral'>                if iszero(value) { break }</span>
 1114 |     | <span class='neutral'>                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {</span>
 1115 |     | <span class='neutral'>                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.</span>
 1116 |     | <span class='neutral'>                    revert(0x1c, 0x04)</span>
 1117 |     | <span class='neutral'>                }</span>
 1118 |     | <span class='neutral'>                break</span>
 1119 |     | <span class='neutral'>            }</span>
 1120 |     | <span class='neutral'>            mstore(0x40, m) // Restore the free memory pointer.</span>
 1121 |     | <span class='neutral'>            mstore(0x60, 0) // Restore the zero slot.</span>
 1122 |     | <span class='neutral'>        }</span>
 1123 |     | <span class='neutral'>    }</span>
 1124 |     | <span class='neutral'></span>
 1125 |     | <span class='neutral'>    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.</span>
 1126 |     | <span class='neutral'>    function initCodeERC1967I(address implementation) internal pure returns (bytes memory result) {</span>
 1127 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1128 |     | <span class='neutral'>        assembly {</span>
 1129 |     | <span class='neutral'>            result := mload(0x40)</span>
 1130 |     | <span class='neutral'>            mstore(</span>
 1131 |     | <span class='neutral'>                add(result, 0x74),</span>
 1132 |     | <span class='neutral'>                0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3</span>
 1133 |     | <span class='neutral'>            )</span>
 1134 |     | <span class='neutral'>            mstore(</span>
 1135 |     | <span class='neutral'>                add(result, 0x54),</span>
 1136 |     | <span class='neutral'>                0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4</span>
 1137 |     | <span class='neutral'>            )</span>
 1138 |     | <span class='neutral'>            mstore(add(result, 0x34), 0x600f5155f3365814604357363d3d373d3d363d7f360894)</span>
 1139 |     | <span class='neutral'>            mstore(add(result, 0x1d), implementation)</span>
 1140 |     | <span class='neutral'>            mstore(add(result, 0x09), 0x60523d8160223d3973)</span>
 1141 |     | <span class='neutral'>            mstore(add(result, 0x94), 0)</span>
 1142 |     | <span class='neutral'>            mstore(result, 0x74) // Store the length.</span>
 1143 |     | <span class='neutral'>            mstore(0x40, add(result, 0xa0)) // Allocate memory.</span>
 1144 |     | <span class='neutral'>        }</span>
 1145 |     | <span class='neutral'>    }</span>
 1146 |     | <span class='neutral'></span>
 1147 |     | <span class='neutral'>    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.</span>
 1148 |     | <span class='neutral'>    /// Used for mining vanity addresses with create2crunch.</span>
 1149 |     | <span class='neutral'>    function initCodeHashERC1967I(address implementation) internal pure returns (bytes32 hash) {</span>
 1150 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1151 |     | <span class='neutral'>        assembly {</span>
 1152 |     | <span class='neutral'>            let m := mload(0x40) // Cache the free memory pointer.</span>
 1153 |     | <span class='neutral'>            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)</span>
 1154 |     | <span class='neutral'>            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)</span>
 1155 |     | <span class='neutral'>            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)</span>
 1156 |     | <span class='neutral'>            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))</span>
 1157 |     | <span class='neutral'>            hash := keccak256(0x0c, 0x74)</span>
 1158 |     | <span class='neutral'>            mstore(0x40, m) // Restore the free memory pointer.</span>
 1159 |     | <span class='neutral'>            mstore(0x60, 0) // Restore the zero slot.</span>
 1160 |     | <span class='neutral'>        }</span>
 1161 |     | <span class='neutral'>    }</span>
 1162 |     | <span class='neutral'></span>
 1163 |     | <span class='neutral'>    /// @dev Returns the address of the deterministic ERC1967I proxy of `implementation`,</span>
 1164 |     | <span class='neutral'>    /// with `salt` by `deployer`.</span>
 1165 |     | <span class='neutral'>    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.</span>
 1166 |     | <span class='neutral'>    function predictDeterministicAddressERC1967I(</span>
 1167 |     | <span class='neutral'>        address implementation,</span>
 1168 |     | <span class='neutral'>        bytes32 salt,</span>
 1169 |     | <span class='neutral'>        address deployer</span>
 1170 |     | <span class='neutral'>    ) internal pure returns (address predicted) {</span>
 1171 |     | <span class='neutral'>        bytes32 hash = initCodeHashERC1967I(implementation);</span>
 1172 |     | <span class='neutral'>        predicted = predictDeterministicAddress(hash, salt, deployer);</span>
 1173 |     | <span class='neutral'>    }</span>
 1174 |     | <span class='neutral'></span>
 1175 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 1176 |     | <span class='neutral'>    /*                      OTHER OPERATIONS                      */</span>
 1177 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 1178 |     | <span class='neutral'></span>
 1179 |     | <span class='neutral'>    /// @dev Returns the address when a contract with initialization code hash,</span>
 1180 |     | <span class='neutral'>    /// `hash`, is deployed with `salt`, by `deployer`.</span>
 1181 |     | <span class='neutral'>    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.</span>
 1182 |     | <span class='unexecuted'>    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)</span>
 1183 |     | <span class='neutral'>        internal</span>
 1184 |     | <span class='neutral'>        pure</span>
 1185 |     | <span class='unexecuted'>        returns (address predicted)</span>
 1186 |     | <span class='neutral'>    {</span>
 1187 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1188 |     | <span class='neutral'>        assembly {</span>
 1189 |     | <span class='neutral'>            // Compute and store the bytecode hash.</span>
 1190 |     | <span class='unexecuted'>            mstore8(0x00, 0xff) // Write the prefix.</span>
 1191 |     | <span class='unexecuted'>            mstore(0x35, hash)</span>
 1192 |     | <span class='unexecuted'>            mstore(0x01, shl(96, deployer))</span>
 1193 |     | <span class='unexecuted'>            mstore(0x15, salt)</span>
 1194 |     | <span class='unexecuted'>            predicted := keccak256(0x00, 0x55)</span>
 1195 |     | <span class='unexecuted'>            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.</span>
 1196 |     | <span class='neutral'>        }</span>
 1197 |     | <span class='neutral'>    }</span>
 1198 |     | <span class='neutral'></span>
 1199 |     | <span class='neutral'>    /// @dev Requires that `salt` starts with either the zero address or `by`.</span>
 1200 |     | <span class='neutral'>    function checkStartsWith(bytes32 salt, address by) internal pure {</span>
 1201 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1202 |     | <span class='neutral'>        assembly {</span>
 1203 |     | <span class='neutral'>            // If the salt does not start with the zero address or `by`.</span>
 1204 |     | <span class='neutral'>            if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {</span>
 1205 |     | <span class='neutral'>                mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.</span>
 1206 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
 1207 |     | <span class='neutral'>            }</span>
 1208 |     | <span class='neutral'>        }</span>
 1209 |     | <span class='neutral'>    }</span>
 1210 |     | <span class='neutral'>}</span>
 1211 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solady/src/utils/ReentrancyGuard.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @notice Reentrancy guard mixin.</span>
  5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ReentrancyGuard.sol)</span>
  6 |     | <span class='neutral'>abstract contract ReentrancyGuard {</span>
  7 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  8 |     | <span class='neutral'>    /*                       CUSTOM ERRORS                        */</span>
  9 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    /// @dev Unauthorized reentrant call.</span>
 12 |     | <span class='neutral'>    error Reentrancy();</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 15 |     | <span class='neutral'>    /*                          STORAGE                           */</span>
 16 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /// @dev Equivalent to: `uint72(bytes9(keccak256(&quot;_REENTRANCY_GUARD_SLOT&quot;)))`.</span>
 19 |     | <span class='neutral'>    /// 9 bytes is large enough to avoid collisions with lower slots,</span>
 20 |     | <span class='neutral'>    /// but not too large to result in excessive bytecode bloat.</span>
 21 |     | <span class='neutral'>    uint256 private constant _REENTRANCY_GUARD_SLOT = 0x929eee149b4bd21268;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 24 |     | <span class='neutral'>    /*                      REENTRANCY GUARD                      */</span>
 25 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    /// @dev Guards a function from reentrancy.</span>
 28 |     | <span class='neutral'>    modifier nonReentrant() virtual {</span>
 29 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 30 |     | <span class='neutral'>        assembly {</span>
 31 |     | <span class='unexecuted'>            if eq(sload(_REENTRANCY_GUARD_SLOT), address()) {</span>
 32 |     | <span class='unexecuted'>                mstore(0x00, 0xab143c06) // `Reentrancy()`.</span>
 33 |     | <span class='unexecuted'>                revert(0x1c, 0x04)</span>
 34 |     | <span class='neutral'>            }</span>
 35 |     | <span class='unexecuted'>            sstore(_REENTRANCY_GUARD_SLOT, address())</span>
 36 |     | <span class='neutral'>        }</span>
 37 |     | <span class='unexecuted'>        _;</span>
 38 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 39 |     | <span class='neutral'>        assembly {</span>
 40 |     | <span class='unexecuted'>            sstore(_REENTRANCY_GUARD_SLOT, codesize())</span>
 41 |     | <span class='neutral'>        }</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    /// @dev Guards a view function from read-only reentrancy.</span>
 45 |     | <span class='neutral'>    modifier nonReadReentrant() virtual {</span>
 46 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 47 |     | <span class='neutral'>        assembly {</span>
 48 | *   | <span class='executed'>            if eq(sload(_REENTRANCY_GUARD_SLOT), address()) {</span>
 49 |     | <span class='unexecuted'>                mstore(0x00, 0xab143c06) // `Reentrancy()`.</span>
 50 |     | <span class='unexecuted'>                revert(0x1c, 0x04)</span>
 51 |     | <span class='neutral'>            }</span>
 52 |     | <span class='neutral'>        }</span>
 53 | *   | <span class='executed'>        _;</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'>}</span>
 56 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solady/src/utils/SafeCastLib.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Safe integer casting library that reverts on overflow.</span>
   5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeCastLib.sol)</span>
   6 |     | <span class='neutral'>/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)</span>
   7 |     | <span class='unexecuted'>library SafeCastLib {</span>
   8 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
   9 |     | <span class='neutral'>    /*                       CUSTOM ERRORS                        */</span>
  10 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    error Overflow();</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  15 |     | <span class='neutral'>    /*          UNSIGNED INTEGER SAFE CASTING OPERATIONS          */</span>
  16 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    function toUint8(uint256 x) internal pure returns (uint8) {</span>
  19 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 8) _revertOverflow();</span>
  20 |     | <span class='neutral'>        return uint8(x);</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    function toUint16(uint256 x) internal pure returns (uint16) {</span>
  24 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 16) _revertOverflow();</span>
  25 |     | <span class='neutral'>        return uint16(x);</span>
  26 |     | <span class='neutral'>    }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function toUint24(uint256 x) internal pure returns (uint24) {</span>
  29 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 24) _revertOverflow();</span>
  30 |     | <span class='neutral'>        return uint24(x);</span>
  31 |     | <span class='neutral'>    }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    function toUint32(uint256 x) internal pure returns (uint32) {</span>
  34 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 32) _revertOverflow();</span>
  35 |     | <span class='neutral'>        return uint32(x);</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    function toUint40(uint256 x) internal pure returns (uint40) {</span>
  39 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 40) _revertOverflow();</span>
  40 |     | <span class='neutral'>        return uint40(x);</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    function toUint48(uint256 x) internal pure returns (uint48) {</span>
  44 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 48) _revertOverflow();</span>
  45 |     | <span class='neutral'>        return uint48(x);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function toUint56(uint256 x) internal pure returns (uint56) {</span>
  49 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 56) _revertOverflow();</span>
  50 |     | <span class='neutral'>        return uint56(x);</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    function toUint64(uint256 x) internal pure returns (uint64) {</span>
  54 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 64) _revertOverflow();</span>
  55 |     | <span class='neutral'>        return uint64(x);</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    function toUint72(uint256 x) internal pure returns (uint72) {</span>
  59 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 72) _revertOverflow();</span>
  60 |     | <span class='neutral'>        return uint72(x);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    function toUint80(uint256 x) internal pure returns (uint80) {</span>
  64 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 80) _revertOverflow();</span>
  65 |     | <span class='neutral'>        return uint80(x);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function toUint88(uint256 x) internal pure returns (uint88) {</span>
  69 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 88) _revertOverflow();</span>
  70 |     | <span class='neutral'>        return uint88(x);</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    function toUint96(uint256 x) internal pure returns (uint96) {</span>
  74 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 96) _revertOverflow();</span>
  75 |     | <span class='neutral'>        return uint96(x);</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function toUint104(uint256 x) internal pure returns (uint104) {</span>
  79 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 104) _revertOverflow();</span>
  80 |     | <span class='neutral'>        return uint104(x);</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>    function toUint112(uint256 x) internal pure returns (uint112) {</span>
  84 |     | <span class='unexecuted'>        if (x &gt;= 1 &lt;&lt; 112) _revertOverflow();</span>
  85 |     | <span class='unexecuted'>        return uint112(x);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function toUint120(uint256 x) internal pure returns (uint120) {</span>
  89 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 120) _revertOverflow();</span>
  90 |     | <span class='neutral'>        return uint120(x);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    function toUint128(uint256 x) internal pure returns (uint128) {</span>
  94 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 128) _revertOverflow();</span>
  95 |     | <span class='neutral'>        return uint128(x);</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    function toUint136(uint256 x) internal pure returns (uint136) {</span>
  99 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 136) _revertOverflow();</span>
 100 |     | <span class='neutral'>        return uint136(x);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function toUint144(uint256 x) internal pure returns (uint144) {</span>
 104 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 144) _revertOverflow();</span>
 105 |     | <span class='neutral'>        return uint144(x);</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    function toUint152(uint256 x) internal pure returns (uint152) {</span>
 109 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 152) _revertOverflow();</span>
 110 |     | <span class='neutral'>        return uint152(x);</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    function toUint160(uint256 x) internal pure returns (uint160) {</span>
 114 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 160) _revertOverflow();</span>
 115 |     | <span class='neutral'>        return uint160(x);</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function toUint168(uint256 x) internal pure returns (uint168) {</span>
 119 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 168) _revertOverflow();</span>
 120 |     | <span class='neutral'>        return uint168(x);</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    function toUint176(uint256 x) internal pure returns (uint176) {</span>
 124 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 176) _revertOverflow();</span>
 125 |     | <span class='neutral'>        return uint176(x);</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    function toUint184(uint256 x) internal pure returns (uint184) {</span>
 129 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 184) _revertOverflow();</span>
 130 |     | <span class='neutral'>        return uint184(x);</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    function toUint192(uint256 x) internal pure returns (uint192) {</span>
 134 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 192) _revertOverflow();</span>
 135 |     | <span class='neutral'>        return uint192(x);</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    function toUint200(uint256 x) internal pure returns (uint200) {</span>
 139 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 200) _revertOverflow();</span>
 140 |     | <span class='neutral'>        return uint200(x);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    function toUint208(uint256 x) internal pure returns (uint208) {</span>
 144 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 208) _revertOverflow();</span>
 145 |     | <span class='neutral'>        return uint208(x);</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    function toUint216(uint256 x) internal pure returns (uint216) {</span>
 149 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 216) _revertOverflow();</span>
 150 |     | <span class='neutral'>        return uint216(x);</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    function toUint224(uint256 x) internal pure returns (uint224) {</span>
 154 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 224) _revertOverflow();</span>
 155 |     | <span class='neutral'>        return uint224(x);</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function toUint232(uint256 x) internal pure returns (uint232) {</span>
 159 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 232) _revertOverflow();</span>
 160 |     | <span class='neutral'>        return uint232(x);</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    function toUint240(uint256 x) internal pure returns (uint240) {</span>
 164 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 240) _revertOverflow();</span>
 165 |     | <span class='neutral'>        return uint240(x);</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    function toUint248(uint256 x) internal pure returns (uint248) {</span>
 169 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 248) _revertOverflow();</span>
 170 |     | <span class='neutral'>        return uint248(x);</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 174 |     | <span class='neutral'>    /*           SIGNED INTEGER SAFE CASTING OPERATIONS           */</span>
 175 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    function toInt8(int256 x) internal pure returns (int8) {</span>
 178 |     | <span class='neutral'>        int8 y = int8(x);</span>
 179 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 180 |     | <span class='neutral'>        return y;</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    function toInt16(int256 x) internal pure returns (int16) {</span>
 184 |     | <span class='neutral'>        int16 y = int16(x);</span>
 185 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 186 |     | <span class='neutral'>        return y;</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    function toInt24(int256 x) internal pure returns (int24) {</span>
 190 |     | <span class='neutral'>        int24 y = int24(x);</span>
 191 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 192 |     | <span class='neutral'>        return y;</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    function toInt32(int256 x) internal pure returns (int32) {</span>
 196 |     | <span class='neutral'>        int32 y = int32(x);</span>
 197 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 198 |     | <span class='neutral'>        return y;</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>    function toInt40(int256 x) internal pure returns (int40) {</span>
 202 |     | <span class='neutral'>        int40 y = int40(x);</span>
 203 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 204 |     | <span class='neutral'>        return y;</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>    function toInt48(int256 x) internal pure returns (int48) {</span>
 208 |     | <span class='neutral'>        int48 y = int48(x);</span>
 209 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 210 |     | <span class='neutral'>        return y;</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    function toInt56(int256 x) internal pure returns (int56) {</span>
 214 |     | <span class='neutral'>        int56 y = int56(x);</span>
 215 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 216 |     | <span class='neutral'>        return y;</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>    function toInt64(int256 x) internal pure returns (int64) {</span>
 220 |     | <span class='neutral'>        int64 y = int64(x);</span>
 221 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 222 |     | <span class='neutral'>        return y;</span>
 223 |     | <span class='neutral'>    }</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>    function toInt72(int256 x) internal pure returns (int72) {</span>
 226 |     | <span class='neutral'>        int72 y = int72(x);</span>
 227 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 228 |     | <span class='neutral'>        return y;</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    function toInt80(int256 x) internal pure returns (int80) {</span>
 232 |     | <span class='neutral'>        int80 y = int80(x);</span>
 233 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 234 |     | <span class='neutral'>        return y;</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    function toInt88(int256 x) internal pure returns (int88) {</span>
 238 |     | <span class='neutral'>        int88 y = int88(x);</span>
 239 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 240 |     | <span class='neutral'>        return y;</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    function toInt96(int256 x) internal pure returns (int96) {</span>
 244 |     | <span class='neutral'>        int96 y = int96(x);</span>
 245 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 246 |     | <span class='neutral'>        return y;</span>
 247 |     | <span class='neutral'>    }</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='neutral'>    function toInt104(int256 x) internal pure returns (int104) {</span>
 250 |     | <span class='neutral'>        int104 y = int104(x);</span>
 251 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 252 |     | <span class='neutral'>        return y;</span>
 253 |     | <span class='neutral'>    }</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>    function toInt112(int256 x) internal pure returns (int112) {</span>
 256 |     | <span class='neutral'>        int112 y = int112(x);</span>
 257 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 258 |     | <span class='neutral'>        return y;</span>
 259 |     | <span class='neutral'>    }</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>    function toInt120(int256 x) internal pure returns (int120) {</span>
 262 |     | <span class='neutral'>        int120 y = int120(x);</span>
 263 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 264 |     | <span class='neutral'>        return y;</span>
 265 |     | <span class='neutral'>    }</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'>    function toInt128(int256 x) internal pure returns (int128) {</span>
 268 |     | <span class='neutral'>        int128 y = int128(x);</span>
 269 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 270 |     | <span class='neutral'>        return y;</span>
 271 |     | <span class='neutral'>    }</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='neutral'>    function toInt136(int256 x) internal pure returns (int136) {</span>
 274 |     | <span class='neutral'>        int136 y = int136(x);</span>
 275 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 276 |     | <span class='neutral'>        return y;</span>
 277 |     | <span class='neutral'>    }</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='neutral'>    function toInt144(int256 x) internal pure returns (int144) {</span>
 280 |     | <span class='neutral'>        int144 y = int144(x);</span>
 281 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 282 |     | <span class='neutral'>        return y;</span>
 283 |     | <span class='neutral'>    }</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>    function toInt152(int256 x) internal pure returns (int152) {</span>
 286 |     | <span class='neutral'>        int152 y = int152(x);</span>
 287 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 288 |     | <span class='neutral'>        return y;</span>
 289 |     | <span class='neutral'>    }</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='neutral'>    function toInt160(int256 x) internal pure returns (int160) {</span>
 292 |     | <span class='neutral'>        int160 y = int160(x);</span>
 293 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 294 |     | <span class='neutral'>        return y;</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    function toInt168(int256 x) internal pure returns (int168) {</span>
 298 |     | <span class='neutral'>        int168 y = int168(x);</span>
 299 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 300 |     | <span class='neutral'>        return y;</span>
 301 |     | <span class='neutral'>    }</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>    function toInt176(int256 x) internal pure returns (int176) {</span>
 304 |     | <span class='neutral'>        int176 y = int176(x);</span>
 305 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 306 |     | <span class='neutral'>        return y;</span>
 307 |     | <span class='neutral'>    }</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='neutral'>    function toInt184(int256 x) internal pure returns (int184) {</span>
 310 |     | <span class='neutral'>        int184 y = int184(x);</span>
 311 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 312 |     | <span class='neutral'>        return y;</span>
 313 |     | <span class='neutral'>    }</span>
 314 |     | <span class='neutral'></span>
 315 |     | <span class='neutral'>    function toInt192(int256 x) internal pure returns (int192) {</span>
 316 |     | <span class='neutral'>        int192 y = int192(x);</span>
 317 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 318 |     | <span class='neutral'>        return y;</span>
 319 |     | <span class='neutral'>    }</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='neutral'>    function toInt200(int256 x) internal pure returns (int200) {</span>
 322 |     | <span class='neutral'>        int200 y = int200(x);</span>
 323 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 324 |     | <span class='neutral'>        return y;</span>
 325 |     | <span class='neutral'>    }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>    function toInt208(int256 x) internal pure returns (int208) {</span>
 328 |     | <span class='neutral'>        int208 y = int208(x);</span>
 329 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 330 |     | <span class='neutral'>        return y;</span>
 331 |     | <span class='neutral'>    }</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='neutral'>    function toInt216(int256 x) internal pure returns (int216) {</span>
 334 |     | <span class='neutral'>        int216 y = int216(x);</span>
 335 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 336 |     | <span class='neutral'>        return y;</span>
 337 |     | <span class='neutral'>    }</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='neutral'>    function toInt224(int256 x) internal pure returns (int224) {</span>
 340 |     | <span class='neutral'>        int224 y = int224(x);</span>
 341 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 342 |     | <span class='neutral'>        return y;</span>
 343 |     | <span class='neutral'>    }</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>    function toInt232(int256 x) internal pure returns (int232) {</span>
 346 |     | <span class='neutral'>        int232 y = int232(x);</span>
 347 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 348 |     | <span class='neutral'>        return y;</span>
 349 |     | <span class='neutral'>    }</span>
 350 |     | <span class='neutral'></span>
 351 |     | <span class='neutral'>    function toInt240(int256 x) internal pure returns (int240) {</span>
 352 |     | <span class='neutral'>        int240 y = int240(x);</span>
 353 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 354 |     | <span class='neutral'>        return y;</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>    function toInt248(int256 x) internal pure returns (int248) {</span>
 358 |     | <span class='neutral'>        int248 y = int248(x);</span>
 359 |     | <span class='neutral'>        if (x != y) _revertOverflow();</span>
 360 |     | <span class='neutral'>        return y;</span>
 361 |     | <span class='neutral'>    }</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 364 |     | <span class='neutral'>    /*               OTHER SAFE CASTING OPERATIONS                */</span>
 365 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 366 |     | <span class='neutral'></span>
 367 |     | <span class='neutral'>    function toInt256(uint256 x) internal pure returns (int256) {</span>
 368 |     | <span class='neutral'>        if (x &gt;= 1 &lt;&lt; 255) _revertOverflow();</span>
 369 |     | <span class='neutral'>        return int256(x);</span>
 370 |     | <span class='neutral'>    }</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>    function toUint256(int256 x) internal pure returns (uint256) {</span>
 373 |     | <span class='neutral'>        if (x &lt; 0) _revertOverflow();</span>
 374 |     | <span class='neutral'>        return uint256(x);</span>
 375 |     | <span class='neutral'>    }</span>
 376 |     | <span class='neutral'></span>
 377 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 378 |     | <span class='neutral'>    /*                      PRIVATE HELPERS                       */</span>
 379 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='unexecuted'>    function _revertOverflow() private pure {</span>
 382 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 383 |     | <span class='neutral'>        assembly {</span>
 384 |     | <span class='neutral'>            // Store the function selector of `Overflow()`.</span>
 385 |     | <span class='unexecuted'>            mstore(0x00, 0x35278d12)</span>
 386 |     | <span class='neutral'>            // Revert with (offset, size).</span>
 387 |     | <span class='unexecuted'>            revert(0x1c, 0x04)</span>
 388 |     | <span class='neutral'>        }</span>
 389 |     | <span class='neutral'>    }</span>
 390 |     | <span class='neutral'>}</span>
 391 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solady/src/utils/SafeTransferLib.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.</span>
   5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)</span>
   6 |     | <span class='neutral'>/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)</span>
   7 |     | <span class='neutral'>///</span>
   8 |     | <span class='neutral'>/// @dev Note:</span>
   9 |     | <span class='neutral'>/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.</span>
  10 |     | <span class='neutral'>/// - For ERC20s, this implementation won&#39;t check that a token has code,</span>
  11 |     | <span class='neutral'>///   responsibility is delegated to the caller.</span>
  12 |     | <span class='unexecuted'>library SafeTransferLib {</span>
  13 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  14 |     | <span class='neutral'>    /*                       CUSTOM ERRORS                        */</span>
  15 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @dev The ETH transfer has failed.</span>
  18 |     | <span class='neutral'>    error ETHTransferFailed();</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    /// @dev The ERC20 `transferFrom` has failed.</span>
  21 |     | <span class='neutral'>    error TransferFromFailed();</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /// @dev The ERC20 `transfer` has failed.</span>
  24 |     | <span class='neutral'>    error TransferFailed();</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /// @dev The ERC20 `approve` has failed.</span>
  27 |     | <span class='neutral'>    error ApproveFailed();</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  30 |     | <span class='neutral'>    /*                         CONSTANTS                          */</span>
  31 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.</span>
  34 |     | <span class='neutral'>    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /// @dev Suggested gas stipend for contract receiving ETH to perform a few</span>
  37 |     | <span class='neutral'>    /// storage reads and writes, but low enough to prevent griefing.</span>
  38 |     | <span class='neutral'>    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  41 |     | <span class='neutral'>    /*                       ETH OPERATIONS                       */</span>
  42 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.</span>
  45 |     | <span class='neutral'>    //</span>
  46 |     | <span class='neutral'>    // The regular variants:</span>
  47 |     | <span class='neutral'>    // - Forwards all remaining gas to the target.</span>
  48 |     | <span class='neutral'>    // - Reverts if the target reverts.</span>
  49 |     | <span class='neutral'>    // - Reverts if the current contract has insufficient balance.</span>
  50 |     | <span class='neutral'>    //</span>
  51 |     | <span class='neutral'>    // The force variants:</span>
  52 |     | <span class='neutral'>    // - Forwards with an optional gas stipend</span>
  53 |     | <span class='neutral'>    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).</span>
  54 |     | <span class='neutral'>    // - If the target reverts, or if the gas stipend is exhausted,</span>
  55 |     | <span class='neutral'>    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.</span>
  56 |     | <span class='neutral'>    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.</span>
  57 |     | <span class='neutral'>    // - Reverts if the current contract has insufficient balance.</span>
  58 |     | <span class='neutral'>    //</span>
  59 |     | <span class='neutral'>    // The try variants:</span>
  60 |     | <span class='neutral'>    // - Forwards with a mandatory gas stipend.</span>
  61 |     | <span class='neutral'>    // - Instead of reverting, returns whether the transfer succeeded.</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /// @dev Sends `amount` (in wei) ETH to `to`.</span>
  64 |     | <span class='unexecuted'>    function safeTransferETH(address to, uint256 amount) internal {</span>
  65 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  66 |     | <span class='neutral'>        assembly {</span>
  67 |     | <span class='unexecuted'>            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {</span>
  68 |     | <span class='unexecuted'>                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.</span>
  69 |     | <span class='unexecuted'>                revert(0x1c, 0x04)</span>
  70 |     | <span class='neutral'>            }</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /// @dev Sends all the ETH in the current contract to `to`.</span>
  75 |     | <span class='neutral'>    function safeTransferAllETH(address to) internal {</span>
  76 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  77 |     | <span class='neutral'>        assembly {</span>
  78 |     | <span class='neutral'>            // Transfer all the ETH and check if it succeeded or not.</span>
  79 |     | <span class='neutral'>            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {</span>
  80 |     | <span class='neutral'>                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.</span>
  81 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  82 |     | <span class='neutral'>            }</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.</span>
  87 |     | <span class='neutral'>    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {</span>
  88 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  89 |     | <span class='neutral'>        assembly {</span>
  90 |     | <span class='neutral'>            if lt(selfbalance(), amount) {</span>
  91 |     | <span class='neutral'>                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.</span>
  92 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  93 |     | <span class='neutral'>            }</span>
  94 |     | <span class='neutral'>            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {</span>
  95 |     | <span class='neutral'>                mstore(0x00, to) // Store the address in scratch space.</span>
  96 |     | <span class='neutral'>                mstore8(0x0b, 0x73) // Opcode `PUSH20`.</span>
  97 |     | <span class='neutral'>                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.</span>
  98 |     | <span class='neutral'>                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.</span>
  99 |     | <span class='neutral'>            }</span>
 100 |     | <span class='neutral'>        }</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.</span>
 104 |     | <span class='neutral'>    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {</span>
 105 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 106 |     | <span class='neutral'>        assembly {</span>
 107 |     | <span class='neutral'>            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {</span>
 108 |     | <span class='neutral'>                mstore(0x00, to) // Store the address in scratch space.</span>
 109 |     | <span class='neutral'>                mstore8(0x0b, 0x73) // Opcode `PUSH20`.</span>
 110 |     | <span class='neutral'>                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.</span>
 111 |     | <span class='neutral'>                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.</span>
 112 |     | <span class='neutral'>            }</span>
 113 |     | <span class='neutral'>        }</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.</span>
 117 |     | <span class='neutral'>    function forceSafeTransferETH(address to, uint256 amount) internal {</span>
 118 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 119 |     | <span class='neutral'>        assembly {</span>
 120 |     | <span class='neutral'>            if lt(selfbalance(), amount) {</span>
 121 |     | <span class='neutral'>                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.</span>
 122 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
 123 |     | <span class='neutral'>            }</span>
 124 |     | <span class='neutral'>            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {</span>
 125 |     | <span class='neutral'>                mstore(0x00, to) // Store the address in scratch space.</span>
 126 |     | <span class='neutral'>                mstore8(0x0b, 0x73) // Opcode `PUSH20`.</span>
 127 |     | <span class='neutral'>                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.</span>
 128 |     | <span class='neutral'>                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.</span>
 129 |     | <span class='neutral'>            }</span>
 130 |     | <span class='neutral'>        }</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.</span>
 134 |     | <span class='neutral'>    function forceSafeTransferAllETH(address to) internal {</span>
 135 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 136 |     | <span class='neutral'>        assembly {</span>
 137 |     | <span class='neutral'>            // forgefmt: disable-next-item</span>
 138 |     | <span class='neutral'>            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {</span>
 139 |     | <span class='neutral'>                mstore(0x00, to) // Store the address in scratch space.</span>
 140 |     | <span class='neutral'>                mstore8(0x0b, 0x73) // Opcode `PUSH20`.</span>
 141 |     | <span class='neutral'>                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.</span>
 142 |     | <span class='neutral'>                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.</span>
 143 |     | <span class='neutral'>            }</span>
 144 |     | <span class='neutral'>        }</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.</span>
 148 |     | <span class='neutral'>    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)</span>
 149 |     | <span class='neutral'>        internal</span>
 150 |     | <span class='neutral'>        returns (bool success)</span>
 151 |     | <span class='neutral'>    {</span>
 152 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 153 |     | <span class='neutral'>        assembly {</span>
 154 |     | <span class='neutral'>            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.</span>
 159 |     | <span class='neutral'>    function trySafeTransferAllETH(address to, uint256 gasStipend)</span>
 160 |     | <span class='neutral'>        internal</span>
 161 |     | <span class='neutral'>        returns (bool success)</span>
 162 |     | <span class='neutral'>    {</span>
 163 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 164 |     | <span class='neutral'>        assembly {</span>
 165 |     | <span class='neutral'>            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)</span>
 166 |     | <span class='neutral'>        }</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 170 |     | <span class='neutral'>    /*                      ERC20 OPERATIONS                      */</span>
 171 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.</span>
 174 |     | <span class='neutral'>    /// Reverts upon failure.</span>
 175 |     | <span class='neutral'>    ///</span>
 176 |     | <span class='neutral'>    /// The `from` account must have at least `amount` approved for</span>
 177 |     | <span class='neutral'>    /// the current contract to manage.</span>
 178 | *   | <span class='executed'>    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {</span>
 179 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 180 |     | <span class='neutral'>        assembly {</span>
 181 | *   | <span class='executed'>            let m := mload(0x40) // Cache the free memory pointer.</span>
 182 | *   | <span class='executed'>            mstore(0x60, amount) // Store the `amount` argument.</span>
 183 | *   | <span class='executed'>            mstore(0x40, to) // Store the `to` argument.</span>
 184 | *   | <span class='executed'>            mstore(0x2c, shl(96, from)) // Store the `from` argument.</span>
 185 | *   | <span class='executed'>            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.</span>
 186 |     | <span class='neutral'>            // Perform the transfer, reverting upon failure.</span>
 187 | *   | <span class='executed'>            if iszero(</span>
 188 | *   | <span class='executed'>                and( // The arguments of `and` are evaluated from right to left.</span>
 189 | *   | <span class='executed'>                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.</span>
 190 | *   | <span class='executed'>                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)</span>
 191 |     | <span class='neutral'>                )</span>
 192 |     | <span class='neutral'>            ) {</span>
 193 | *   | <span class='executed'>                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.</span>
 194 | *   | <span class='executed'>                revert(0x1c, 0x04)</span>
 195 |     | <span class='neutral'>            }</span>
 196 | *   | <span class='executed'>            mstore(0x60, 0) // Restore the zero slot to zero.</span>
 197 | *   | <span class='executed'>            mstore(0x40, m) // Restore the free memory pointer.</span>
 198 |     | <span class='neutral'>        }</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>    /// @dev Sends all of ERC20 `token` from `from` to `to`.</span>
 202 |     | <span class='neutral'>    /// Reverts upon failure.</span>
 203 |     | <span class='neutral'>    ///</span>
 204 |     | <span class='neutral'>    /// The `from` account must have their entire balance approved for</span>
 205 |     | <span class='neutral'>    /// the current contract to manage.</span>
 206 |     | <span class='neutral'>    function safeTransferAllFrom(address token, address from, address to)</span>
 207 |     | <span class='neutral'>        internal</span>
 208 |     | <span class='neutral'>        returns (uint256 amount)</span>
 209 |     | <span class='neutral'>    {</span>
 210 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 211 |     | <span class='neutral'>        assembly {</span>
 212 |     | <span class='neutral'>            let m := mload(0x40) // Cache the free memory pointer.</span>
 213 |     | <span class='neutral'>            mstore(0x40, to) // Store the `to` argument.</span>
 214 |     | <span class='neutral'>            mstore(0x2c, shl(96, from)) // Store the `from` argument.</span>
 215 |     | <span class='neutral'>            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.</span>
 216 |     | <span class='neutral'>            // Read the balance, reverting upon failure.</span>
 217 |     | <span class='neutral'>            if iszero(</span>
 218 |     | <span class='neutral'>                and( // The arguments of `and` are evaluated from right to left.</span>
 219 |     | <span class='neutral'>                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.</span>
 220 |     | <span class='neutral'>                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)</span>
 221 |     | <span class='neutral'>                )</span>
 222 |     | <span class='neutral'>            ) {</span>
 223 |     | <span class='neutral'>                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.</span>
 224 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
 225 |     | <span class='neutral'>            }</span>
 226 |     | <span class='neutral'>            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.</span>
 227 |     | <span class='neutral'>            amount := mload(0x60) // The `amount` is already at 0x60. We&#39;ll need to return it.</span>
 228 |     | <span class='neutral'>            // Perform the transfer, reverting upon failure.</span>
 229 |     | <span class='neutral'>            if iszero(</span>
 230 |     | <span class='neutral'>                and( // The arguments of `and` are evaluated from right to left.</span>
 231 |     | <span class='neutral'>                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.</span>
 232 |     | <span class='neutral'>                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)</span>
 233 |     | <span class='neutral'>                )</span>
 234 |     | <span class='neutral'>            ) {</span>
 235 |     | <span class='neutral'>                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.</span>
 236 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
 237 |     | <span class='neutral'>            }</span>
 238 |     | <span class='neutral'>            mstore(0x60, 0) // Restore the zero slot to zero.</span>
 239 |     | <span class='neutral'>            mstore(0x40, m) // Restore the free memory pointer.</span>
 240 |     | <span class='neutral'>        }</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.</span>
 244 |     | <span class='neutral'>    /// Reverts upon failure.</span>
 245 |     | <span class='unexecuted'>    function safeTransfer(address token, address to, uint256 amount) internal {</span>
 246 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 247 |     | <span class='neutral'>        assembly {</span>
 248 |     | <span class='unexecuted'>            mstore(0x14, to) // Store the `to` argument.</span>
 249 |     | <span class='unexecuted'>            mstore(0x34, amount) // Store the `amount` argument.</span>
 250 |     | <span class='unexecuted'>            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.</span>
 251 |     | <span class='neutral'>            // Perform the transfer, reverting upon failure.</span>
 252 |     | <span class='unexecuted'>            if iszero(</span>
 253 |     | <span class='unexecuted'>                and( // The arguments of `and` are evaluated from right to left.</span>
 254 |     | <span class='unexecuted'>                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.</span>
 255 |     | <span class='unexecuted'>                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)</span>
 256 |     | <span class='neutral'>                )</span>
 257 |     | <span class='neutral'>            ) {</span>
 258 |     | <span class='unexecuted'>                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.</span>
 259 |     | <span class='unexecuted'>                revert(0x1c, 0x04)</span>
 260 |     | <span class='neutral'>            }</span>
 261 |     | <span class='unexecuted'>            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.</span>
 262 |     | <span class='neutral'>        }</span>
 263 |     | <span class='neutral'>    }</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>    /// @dev Sends all of ERC20 `token` from the current contract to `to`.</span>
 266 |     | <span class='neutral'>    /// Reverts upon failure.</span>
 267 |     | <span class='neutral'>    function safeTransferAll(address token, address to) internal returns (uint256 amount) {</span>
 268 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 269 |     | <span class='neutral'>        assembly {</span>
 270 |     | <span class='neutral'>            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.</span>
 271 |     | <span class='neutral'>            mstore(0x20, address()) // Store the address of the current contract.</span>
 272 |     | <span class='neutral'>            // Read the balance, reverting upon failure.</span>
 273 |     | <span class='neutral'>            if iszero(</span>
 274 |     | <span class='neutral'>                and( // The arguments of `and` are evaluated from right to left.</span>
 275 |     | <span class='neutral'>                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.</span>
 276 |     | <span class='neutral'>                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)</span>
 277 |     | <span class='neutral'>                )</span>
 278 |     | <span class='neutral'>            ) {</span>
 279 |     | <span class='neutral'>                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.</span>
 280 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
 281 |     | <span class='neutral'>            }</span>
 282 |     | <span class='neutral'>            mstore(0x14, to) // Store the `to` argument.</span>
 283 |     | <span class='neutral'>            amount := mload(0x34) // The `amount` is already at 0x34. We&#39;ll need to return it.</span>
 284 |     | <span class='neutral'>            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.</span>
 285 |     | <span class='neutral'>            // Perform the transfer, reverting upon failure.</span>
 286 |     | <span class='neutral'>            if iszero(</span>
 287 |     | <span class='neutral'>                and( // The arguments of `and` are evaluated from right to left.</span>
 288 |     | <span class='neutral'>                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.</span>
 289 |     | <span class='neutral'>                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)</span>
 290 |     | <span class='neutral'>                )</span>
 291 |     | <span class='neutral'>            ) {</span>
 292 |     | <span class='neutral'>                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.</span>
 293 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
 294 |     | <span class='neutral'>            }</span>
 295 |     | <span class='neutral'>            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.</span>
 296 |     | <span class='neutral'>        }</span>
 297 |     | <span class='neutral'>    }</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.</span>
 300 |     | <span class='neutral'>    /// Reverts upon failure.</span>
 301 |     | <span class='unexecuted'>    function safeApprove(address token, address to, uint256 amount) internal {</span>
 302 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 303 |     | <span class='neutral'>        assembly {</span>
 304 |     | <span class='unexecuted'>            mstore(0x14, to) // Store the `to` argument.</span>
 305 |     | <span class='unexecuted'>            mstore(0x34, amount) // Store the `amount` argument.</span>
 306 |     | <span class='unexecuted'>            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.</span>
 307 |     | <span class='neutral'>            // Perform the approval, reverting upon failure.</span>
 308 |     | <span class='unexecuted'>            if iszero(</span>
 309 |     | <span class='unexecuted'>                and( // The arguments of `and` are evaluated from right to left.</span>
 310 |     | <span class='unexecuted'>                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.</span>
 311 |     | <span class='unexecuted'>                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)</span>
 312 |     | <span class='neutral'>                )</span>
 313 |     | <span class='neutral'>            ) {</span>
 314 |     | <span class='unexecuted'>                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.</span>
 315 |     | <span class='unexecuted'>                revert(0x1c, 0x04)</span>
 316 |     | <span class='neutral'>            }</span>
 317 |     | <span class='unexecuted'>            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.</span>
 318 |     | <span class='neutral'>        }</span>
 319 |     | <span class='neutral'>    }</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='neutral'>    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.</span>
 322 |     | <span class='neutral'>    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,</span>
 323 |     | <span class='neutral'>    /// then retries the approval again (some tokens, e.g. USDT, requires this).</span>
 324 |     | <span class='neutral'>    /// Reverts upon failure.</span>
 325 |     | <span class='neutral'>    function safeApproveWithRetry(address token, address to, uint256 amount) internal {</span>
 326 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 327 |     | <span class='neutral'>        assembly {</span>
 328 |     | <span class='neutral'>            mstore(0x14, to) // Store the `to` argument.</span>
 329 |     | <span class='neutral'>            mstore(0x34, amount) // Store the `amount` argument.</span>
 330 |     | <span class='neutral'>            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.</span>
 331 |     | <span class='neutral'>            // Perform the approval, retrying upon failure.</span>
 332 |     | <span class='neutral'>            if iszero(</span>
 333 |     | <span class='neutral'>                and( // The arguments of `and` are evaluated from right to left.</span>
 334 |     | <span class='neutral'>                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.</span>
 335 |     | <span class='neutral'>                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)</span>
 336 |     | <span class='neutral'>                )</span>
 337 |     | <span class='neutral'>            ) {</span>
 338 |     | <span class='neutral'>                mstore(0x34, 0) // Store 0 for the `amount`.</span>
 339 |     | <span class='neutral'>                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.</span>
 340 |     | <span class='neutral'>                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.</span>
 341 |     | <span class='neutral'>                mstore(0x34, amount) // Store back the original `amount`.</span>
 342 |     | <span class='neutral'>                // Retry the approval, reverting upon failure.</span>
 343 |     | <span class='neutral'>                if iszero(</span>
 344 |     | <span class='neutral'>                    and(</span>
 345 |     | <span class='neutral'>                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.</span>
 346 |     | <span class='neutral'>                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)</span>
 347 |     | <span class='neutral'>                    )</span>
 348 |     | <span class='neutral'>                ) {</span>
 349 |     | <span class='neutral'>                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.</span>
 350 |     | <span class='neutral'>                    revert(0x1c, 0x04)</span>
 351 |     | <span class='neutral'>                }</span>
 352 |     | <span class='neutral'>            }</span>
 353 |     | <span class='neutral'>            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.</span>
 354 |     | <span class='neutral'>        }</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>    /// @dev Returns the amount of ERC20 `token` owned by `account`.</span>
 358 |     | <span class='neutral'>    /// Returns zero if the `token` does not exist.</span>
 359 | *   | <span class='executed'>    function balanceOf(address token, address account) internal view returns (uint256 amount) {</span>
 360 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 361 |     | <span class='neutral'>        assembly {</span>
 362 | *   | <span class='executed'>            mstore(0x14, account) // Store the `account` argument.</span>
 363 | *   | <span class='executed'>            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.</span>
 364 | *   | <span class='executed'>            amount :=</span>
 365 | *   | <span class='executed'>                mul(</span>
 366 | *   | <span class='executed'>                    mload(0x20),</span>
 367 | *   | <span class='executed'>                    and( // The arguments of `and` are evaluated from right to left.</span>
 368 | *   | <span class='executed'>                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.</span>
 369 | *   | <span class='executed'>                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)</span>
 370 |     | <span class='neutral'>                    )</span>
 371 |     | <span class='neutral'>                )</span>
 372 |     | <span class='neutral'>        }</span>
 373 |     | <span class='neutral'>    }</span>
 374 |     | <span class='neutral'>}</span>
 375 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solmate/src/auth/Owned.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @notice Simple single owner authorization mixin.</span>
  5 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)</span>
  6 |     | <span class='neutral'>abstract contract Owned {</span>
  7 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  8 |     | <span class='neutral'>                                 EVENTS</span>
  9 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    event OwnershipTransferred(address indexed user, address indexed newOwner);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 14 |     | <span class='neutral'>                            OWNERSHIP STORAGE</span>
 15 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    address public owner;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    modifier onlyOwner() virtual {</span>
 20 |     | <span class='unexecuted'>        require(msg.sender == owner, &quot;UNAUTHORIZED&quot;);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>        _;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 26 |     | <span class='neutral'>                               CONSTRUCTOR</span>
 27 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>    constructor(address _owner) {</span>
 30 |     | <span class='unexecuted'>        owner = _owner;</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>        emit OwnershipTransferred(address(0), _owner);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 36 |     | <span class='neutral'>                             OWNERSHIP LOGIC</span>
 37 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>    function transferOwnership(address newOwner) public virtual onlyOwner {</span>
 40 |     | <span class='unexecuted'>        owner = newOwner;</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='unexecuted'>        emit OwnershipTransferred(msg.sender, newOwner);</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'>}</span>
 45 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solmate/src/tokens/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.</span>
   5 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)</span>
   6 |     | <span class='neutral'>/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)</span>
   7 |     | <span class='neutral'>/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.</span>
   8 |     | <span class='neutral'>abstract contract ERC20 {</span>
   9 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  10 |     | <span class='neutral'>                                 EVENTS</span>
  11 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 amount);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 amount);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  18 |     | <span class='neutral'>                            METADATA STORAGE</span>
  19 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    string public name;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    string public symbol;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    uint8 public immutable decimals;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  28 |     | <span class='neutral'>                              ERC20 STORAGE</span>
  29 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    uint256 public totalSupply;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public balanceOf;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  38 |     | <span class='neutral'>                            EIP-2612 STORAGE</span>
  39 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    uint256 internal immutable INITIAL_CHAIN_ID;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public nonces;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  48 |     | <span class='neutral'>                               CONSTRUCTOR</span>
  49 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    constructor(</span>
  52 |     | <span class='neutral'>        string memory _name,</span>
  53 |     | <span class='neutral'>        string memory _symbol,</span>
  54 |     | <span class='neutral'>        uint8 _decimals</span>
  55 |     | <span class='neutral'>    ) {</span>
  56 |     | <span class='unexecuted'>        name = _name;</span>
  57 |     | <span class='unexecuted'>        symbol = _symbol;</span>
  58 |     | <span class='unexecuted'>        decimals = _decimals;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>        INITIAL_CHAIN_ID = block.chainid;</span>
  61 |     | <span class='unexecuted'>        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  65 |     | <span class='neutral'>                               ERC20 LOGIC</span>
  66 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) public virtual returns (bool) {</span>
  69 |     | <span class='unexecuted'>        allowance[msg.sender][spender] = amount;</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>        emit Approval(msg.sender, spender, amount);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        return true;</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public virtual returns (bool) {</span>
  77 |     | <span class='unexecuted'>        balanceOf[msg.sender] -= amount;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        // Cannot overflow because the sum of all user</span>
  80 |     | <span class='neutral'>        // balances can&#39;t exceed the max uint256 value.</span>
  81 |     | <span class='neutral'>        unchecked {</span>
  82 |     | <span class='unexecuted'>            balanceOf[to] += amount;</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>        emit Transfer(msg.sender, to, amount);</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        return true;</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>    function transferFrom(</span>
  91 |     | <span class='neutral'>        address from,</span>
  92 |     | <span class='neutral'>        address to,</span>
  93 |     | <span class='neutral'>        uint256 amount</span>
  94 |     | <span class='unexecuted'>    ) public virtual returns (bool) {</span>
  95 |     | <span class='unexecuted'>        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>        balanceOf[from] -= amount;</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>        // Cannot overflow because the sum of all user</span>
 102 |     | <span class='neutral'>        // balances can&#39;t exceed the max uint256 value.</span>
 103 |     | <span class='neutral'>        unchecked {</span>
 104 |     | <span class='unexecuted'>            balanceOf[to] += amount;</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>        emit Transfer(from, to, amount);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        return true;</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 113 |     | <span class='neutral'>                             EIP-2612 LOGIC</span>
 114 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>    function permit(</span>
 117 |     | <span class='neutral'>        address owner,</span>
 118 |     | <span class='neutral'>        address spender,</span>
 119 |     | <span class='neutral'>        uint256 value,</span>
 120 |     | <span class='neutral'>        uint256 deadline,</span>
 121 |     | <span class='neutral'>        uint8 v,</span>
 122 |     | <span class='neutral'>        bytes32 r,</span>
 123 |     | <span class='neutral'>        bytes32 s</span>
 124 |     | <span class='neutral'>    ) public virtual {</span>
 125 |     | <span class='unexecuted'>        require(deadline &gt;= block.timestamp, &quot;PERMIT_DEADLINE_EXPIRED&quot;);</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>        // Unchecked because the only math done is incrementing</span>
 128 |     | <span class='neutral'>        // the owner&#39;s nonce which cannot realistically overflow.</span>
 129 |     | <span class='neutral'>        unchecked {</span>
 130 |     | <span class='unexecuted'>            address recoveredAddress = ecrecover(</span>
 131 |     | <span class='unexecuted'>                keccak256(</span>
 132 |     | <span class='unexecuted'>                    abi.encodePacked(</span>
 133 |     | <span class='neutral'>                        &quot;\x19\x01&quot;,</span>
 134 |     | <span class='unexecuted'>                        DOMAIN_SEPARATOR(),</span>
 135 |     | <span class='unexecuted'>                        keccak256(</span>
 136 |     | <span class='unexecuted'>                            abi.encode(</span>
 137 |     | <span class='unexecuted'>                                keccak256(</span>
 138 |     | <span class='neutral'>                                    &quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;</span>
 139 |     | <span class='neutral'>                                ),</span>
 140 |     | <span class='neutral'>                                owner,</span>
 141 |     | <span class='neutral'>                                spender,</span>
 142 |     | <span class='neutral'>                                value,</span>
 143 |     | <span class='unexecuted'>                                nonces[owner]++,</span>
 144 |     | <span class='neutral'>                                deadline</span>
 145 |     | <span class='neutral'>                            )</span>
 146 |     | <span class='neutral'>                        )</span>
 147 |     | <span class='neutral'>                    )</span>
 148 |     | <span class='neutral'>                ),</span>
 149 |     | <span class='neutral'>                v,</span>
 150 |     | <span class='neutral'>                r,</span>
 151 |     | <span class='neutral'>                s</span>
 152 |     | <span class='neutral'>            );</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>            require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &quot;INVALID_SIGNER&quot;);</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>            allowance[recoveredAddress][spender] = value;</span>
 157 |     | <span class='neutral'>        }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>        emit Approval(owner, spender, value);</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='unexecuted'>    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {</span>
 163 |     | <span class='unexecuted'>        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>    function computeDomainSeparator() internal view virtual returns (bytes32) {</span>
 167 |     | <span class='unexecuted'>        return</span>
 168 |     | <span class='unexecuted'>            keccak256(</span>
 169 |     | <span class='unexecuted'>                abi.encode(</span>
 170 |     | <span class='unexecuted'>                    keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;),</span>
 171 |     | <span class='unexecuted'>                    keccak256(bytes(name)),</span>
 172 |     | <span class='unexecuted'>                    keccak256(&quot;1&quot;),</span>
 173 |     | <span class='unexecuted'>                    block.chainid,</span>
 174 |     | <span class='unexecuted'>                    address(this)</span>
 175 |     | <span class='neutral'>                )</span>
 176 |     | <span class='neutral'>            );</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 180 |     | <span class='neutral'>                        INTERNAL MINT/BURN LOGIC</span>
 181 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='unexecuted'>    function _mint(address to, uint256 amount) internal virtual {</span>
 184 |     | <span class='unexecuted'>        totalSupply += amount;</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>        // Cannot overflow because the sum of all user</span>
 187 |     | <span class='neutral'>        // balances can&#39;t exceed the max uint256 value.</span>
 188 |     | <span class='neutral'>        unchecked {</span>
 189 |     | <span class='unexecuted'>            balanceOf[to] += amount;</span>
 190 |     | <span class='neutral'>        }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='unexecuted'>        emit Transfer(address(0), to, amount);</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>    function _burn(address from, uint256 amount) internal virtual {</span>
 196 |     | <span class='unexecuted'>        balanceOf[from] -= amount;</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>        // Cannot underflow because a user&#39;s balance</span>
 199 |     | <span class='neutral'>        // will never be larger than the total supply.</span>
 200 |     | <span class='neutral'>        unchecked {</span>
 201 |     | <span class='unexecuted'>            totalSupply -= amount;</span>
 202 |     | <span class='neutral'>        }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='unexecuted'>        emit Transfer(from, address(0), amount);</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'>}</span>
 207 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solmate/src/utils/Bytes32AddressLib.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @notice Library for converting between addresses and bytes32 values.</span>
  5 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Bytes32AddressLib.sol)</span>
  6 |     | <span class='unexecuted'>library Bytes32AddressLib {</span>
  7 |     | <span class='unexecuted'>    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {</span>
  8 |     | <span class='unexecuted'>        return address(uint160(uint256(bytesValue)));</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {</span>
 12 |     | <span class='neutral'>        return bytes32(bytes20(addressValue));</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solmate/src/utils/CREATE3.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Bytes32AddressLib} from &quot;./Bytes32AddressLib.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @notice Deploy to deterministic addresses without an initcode factor.</span>
  7 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)</span>
  8 |     | <span class='neutral'>/// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)</span>
  9 |     | <span class='unexecuted'>library CREATE3 {</span>
 10 |     | <span class='neutral'>    using Bytes32AddressLib for bytes32;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    //--------------------------------------------------------------------------------//</span>
 13 |     | <span class='neutral'>    // Opcode     | Opcode + Arguments    | Description      | Stack View             //</span>
 14 |     | <span class='neutral'>    //--------------------------------------------------------------------------------//</span>
 15 |     | <span class='neutral'>    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //</span>
 16 |     | <span class='neutral'>    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //</span>
 17 |     | <span class='neutral'>    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //</span>
 18 |     | <span class='neutral'>    // 0x37       |  0x37                 | CALLDATACOPY     |                        //</span>
 19 |     | <span class='neutral'>    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //</span>
 20 |     | <span class='neutral'>    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //</span>
 21 |     | <span class='neutral'>    // 0x34       |  0x34                 | CALLVALUE        | value 0 size           //</span>
 22 |     | <span class='neutral'>    // 0xf0       |  0xf0                 | CREATE           | newContract            //</span>
 23 |     | <span class='neutral'>    //--------------------------------------------------------------------------------//</span>
 24 |     | <span class='neutral'>    // Opcode     | Opcode + Arguments    | Description      | Stack View             //</span>
 25 |     | <span class='neutral'>    //--------------------------------------------------------------------------------//</span>
 26 |     | <span class='neutral'>    // 0x67       |  0x67XXXXXXXXXXXXXXXX | PUSH8 bytecode   | bytecode               //</span>
 27 |     | <span class='neutral'>    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 bytecode             //</span>
 28 |     | <span class='neutral'>    // 0x52       |  0x52                 | MSTORE           |                        //</span>
 29 |     | <span class='neutral'>    // 0x60       |  0x6008               | PUSH1 08         | 8                      //</span>
 30 |     | <span class='neutral'>    // 0x60       |  0x6018               | PUSH1 18         | 24 8                   //</span>
 31 |     | <span class='neutral'>    // 0xf3       |  0xf3                 | RETURN           |                        //</span>
 32 |     | <span class='neutral'>    //--------------------------------------------------------------------------------//</span>
 33 |     | <span class='neutral'>    bytes internal constant PROXY_BYTECODE = hex&quot;67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3&quot;;</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>    bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function deploy(</span>
 38 |     | <span class='neutral'>        bytes32 salt,</span>
 39 |     | <span class='neutral'>        bytes memory creationCode,</span>
 40 |     | <span class='neutral'>        uint256 value</span>
 41 |     | <span class='unexecuted'>    ) internal returns (address deployed) {</span>
 42 |     | <span class='unexecuted'>        bytes memory proxyChildBytecode = PROXY_BYTECODE;</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='unexecuted'>        address proxy;</span>
 45 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 46 |     | <span class='neutral'>        assembly {</span>
 47 |     | <span class='neutral'>            // Deploy a new contract with our pre-made bytecode via CREATE2.</span>
 48 |     | <span class='neutral'>            // We start 32 bytes into the code to avoid copying the byte length.</span>
 49 |     | <span class='unexecuted'>            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)</span>
 50 |     | <span class='neutral'>        }</span>
 51 |     | <span class='unexecuted'>        require(proxy != address(0), &quot;DEPLOYMENT_FAILED&quot;);</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='unexecuted'>        deployed = getDeployed(salt);</span>
 54 |     | <span class='unexecuted'>        (bool success, ) = proxy.call{value: value}(creationCode);</span>
 55 |     | <span class='unexecuted'>        require(success &amp;&amp; deployed.code.length != 0, &quot;INITIALIZATION_FAILED&quot;);</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='unexecuted'>    function getDeployed(bytes32 salt) internal view returns (address) {</span>
 59 |     | <span class='unexecuted'>        address proxy = keccak256(</span>
 60 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 61 |     | <span class='neutral'>                // Prefix:</span>
 62 |     | <span class='unexecuted'>                bytes1(0xFF),</span>
 63 |     | <span class='neutral'>                // Creator:</span>
 64 |     | <span class='unexecuted'>                address(this),</span>
 65 |     | <span class='neutral'>                // Salt:</span>
 66 |     | <span class='neutral'>                salt,</span>
 67 |     | <span class='neutral'>                // Bytecode hash:</span>
 68 |     | <span class='neutral'>                PROXY_BYTECODE_HASH</span>
 69 |     | <span class='neutral'>            )</span>
 70 |     | <span class='neutral'>        ).fromLast20Bytes();</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>        return</span>
 73 |     | <span class='unexecuted'>            keccak256(</span>
 74 |     | <span class='unexecuted'>                abi.encodePacked(</span>
 75 |     | <span class='neutral'>                    // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01)</span>
 76 |     | <span class='neutral'>                    // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)</span>
 77 |     | <span class='neutral'>                    hex&quot;d6_94&quot;,</span>
 78 |     | <span class='neutral'>                    proxy,</span>
 79 |     | <span class='neutral'>                    hex&quot;01&quot; // Nonce of the proxy contract (1)</span>
 80 |     | <span class='neutral'>                )</span>
 81 |     | <span class='neutral'>            ).fromLast20Bytes();</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'>}</span>
 84 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solmate/src/utils/FixedPointMathLib.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Arithmetic library with operations for fixed-point numbers.</span>
   5 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)</span>
   6 |     | <span class='neutral'>/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)</span>
   7 |     | <span class='unexecuted'>library FixedPointMathLib {</span>
   8 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
   9 |     | <span class='neutral'>                    SIMPLIFIED FIXED POINT OPERATIONS</span>
  10 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    uint256 internal constant MAX_UINT256 = 2**256 - 1;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {</span>
  17 |     | <span class='neutral'>        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {</span>
  21 |     | <span class='neutral'>        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {</span>
  25 |     | <span class='neutral'>        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.</span>
  26 |     | <span class='neutral'>    }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {</span>
  29 |     | <span class='neutral'>        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  33 |     | <span class='neutral'>                    LOW LEVEL FIXED POINT OPERATIONS</span>
  34 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    function mulDivDown(</span>
  37 |     | <span class='neutral'>        uint256 x,</span>
  38 |     | <span class='neutral'>        uint256 y,</span>
  39 |     | <span class='neutral'>        uint256 denominator</span>
  40 |     | <span class='unexecuted'>    ) internal pure returns (uint256 z) {</span>
  41 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  42 |     | <span class='neutral'>        assembly {</span>
  43 |     | <span class='neutral'>            // Equivalent to require(denominator != 0 &amp;&amp; (y == 0 || x &lt;= type(uint256).max / y))</span>
  44 |     | <span class='unexecuted'>            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {</span>
  45 |     | <span class='unexecuted'>                revert(0, 0)</span>
  46 |     | <span class='neutral'>            }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>            // Divide x * y by the denominator.</span>
  49 |     | <span class='unexecuted'>            z := div(mul(x, y), denominator)</span>
  50 |     | <span class='neutral'>        }</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>    function mulDivUp(</span>
  54 |     | <span class='neutral'>        uint256 x,</span>
  55 |     | <span class='neutral'>        uint256 y,</span>
  56 |     | <span class='neutral'>        uint256 denominator</span>
  57 |     | <span class='unexecuted'>    ) internal pure returns (uint256 z) {</span>
  58 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  59 |     | <span class='neutral'>        assembly {</span>
  60 |     | <span class='neutral'>            // Equivalent to require(denominator != 0 &amp;&amp; (y == 0 || x &lt;= type(uint256).max / y))</span>
  61 |     | <span class='unexecuted'>            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {</span>
  62 |     | <span class='unexecuted'>                revert(0, 0)</span>
  63 |     | <span class='neutral'>            }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>            // If x * y modulo the denominator is strictly greater than 0,</span>
  66 |     | <span class='neutral'>            // 1 is added to round up the division of x * y by the denominator.</span>
  67 |     | <span class='unexecuted'>            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))</span>
  68 |     | <span class='neutral'>        }</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    function rpow(</span>
  72 |     | <span class='neutral'>        uint256 x,</span>
  73 |     | <span class='neutral'>        uint256 n,</span>
  74 |     | <span class='neutral'>        uint256 scalar</span>
  75 |     | <span class='neutral'>    ) internal pure returns (uint256 z) {</span>
  76 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  77 |     | <span class='neutral'>        assembly {</span>
  78 |     | <span class='neutral'>            switch x</span>
  79 |     | <span class='neutral'>            case 0 {</span>
  80 |     | <span class='neutral'>                switch n</span>
  81 |     | <span class='neutral'>                case 0 {</span>
  82 |     | <span class='neutral'>                    // 0 ** 0 = 1</span>
  83 |     | <span class='neutral'>                    z := scalar</span>
  84 |     | <span class='neutral'>                }</span>
  85 |     | <span class='neutral'>                default {</span>
  86 |     | <span class='neutral'>                    // 0 ** n = 0</span>
  87 |     | <span class='neutral'>                    z := 0</span>
  88 |     | <span class='neutral'>                }</span>
  89 |     | <span class='neutral'>            }</span>
  90 |     | <span class='neutral'>            default {</span>
  91 |     | <span class='neutral'>                switch mod(n, 2)</span>
  92 |     | <span class='neutral'>                case 0 {</span>
  93 |     | <span class='neutral'>                    // If n is even, store scalar in z for now.</span>
  94 |     | <span class='neutral'>                    z := scalar</span>
  95 |     | <span class='neutral'>                }</span>
  96 |     | <span class='neutral'>                default {</span>
  97 |     | <span class='neutral'>                    // If n is odd, store x in z for now.</span>
  98 |     | <span class='neutral'>                    z := x</span>
  99 |     | <span class='neutral'>                }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>                // Shifting right by 1 is like dividing by 2.</span>
 102 |     | <span class='neutral'>                let half := shr(1, scalar)</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>                for {</span>
 105 |     | <span class='neutral'>                    // Shift n right by 1 before looping to halve it.</span>
 106 |     | <span class='neutral'>                    n := shr(1, n)</span>
 107 |     | <span class='neutral'>                } n {</span>
 108 |     | <span class='neutral'>                    // Shift n right by 1 each iteration to halve it.</span>
 109 |     | <span class='neutral'>                    n := shr(1, n)</span>
 110 |     | <span class='neutral'>                } {</span>
 111 |     | <span class='neutral'>                    // Revert immediately if x ** 2 would overflow.</span>
 112 |     | <span class='neutral'>                    // Equivalent to iszero(eq(div(xx, x), x)) here.</span>
 113 |     | <span class='neutral'>                    if shr(128, x) {</span>
 114 |     | <span class='neutral'>                        revert(0, 0)</span>
 115 |     | <span class='neutral'>                    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>                    // Store x squared.</span>
 118 |     | <span class='neutral'>                    let xx := mul(x, x)</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>                    // Round to the nearest number.</span>
 121 |     | <span class='neutral'>                    let xxRound := add(xx, half)</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>                    // Revert if xx + half overflowed.</span>
 124 |     | <span class='neutral'>                    if lt(xxRound, xx) {</span>
 125 |     | <span class='neutral'>                        revert(0, 0)</span>
 126 |     | <span class='neutral'>                    }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>                    // Set x to scaled xxRound.</span>
 129 |     | <span class='neutral'>                    x := div(xxRound, scalar)</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>                    // If n is even:</span>
 132 |     | <span class='neutral'>                    if mod(n, 2) {</span>
 133 |     | <span class='neutral'>                        // Compute z * x.</span>
 134 |     | <span class='neutral'>                        let zx := mul(z, x)</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>                        // If z * x overflowed:</span>
 137 |     | <span class='neutral'>                        if iszero(eq(div(zx, x), z)) {</span>
 138 |     | <span class='neutral'>                            // Revert if x is non-zero.</span>
 139 |     | <span class='neutral'>                            if iszero(iszero(x)) {</span>
 140 |     | <span class='neutral'>                                revert(0, 0)</span>
 141 |     | <span class='neutral'>                            }</span>
 142 |     | <span class='neutral'>                        }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>                        // Round to the nearest number.</span>
 145 |     | <span class='neutral'>                        let zxRound := add(zx, half)</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>                        // Revert if zx + half overflowed.</span>
 148 |     | <span class='neutral'>                        if lt(zxRound, zx) {</span>
 149 |     | <span class='neutral'>                            revert(0, 0)</span>
 150 |     | <span class='neutral'>                        }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>                        // Return properly scaled zxRound.</span>
 153 |     | <span class='neutral'>                        z := div(zxRound, scalar)</span>
 154 |     | <span class='neutral'>                    }</span>
 155 |     | <span class='neutral'>                }</span>
 156 |     | <span class='neutral'>            }</span>
 157 |     | <span class='neutral'>        }</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 161 |     | <span class='neutral'>                        GENERAL NUMBER UTILITIES</span>
 162 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    function sqrt(uint256 x) internal pure returns (uint256 z) {</span>
 165 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 166 |     | <span class='neutral'>        assembly {</span>
 167 |     | <span class='neutral'>            let y := x // We start y at x, which will help us make our initial estimate.</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>            z := 181 // The &quot;correct&quot; value is 1, but this saves a multiplication later.</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad</span>
 172 |     | <span class='neutral'>            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>            // We check y &gt;= 2^(k + 8) but shift right by k bits</span>
 175 |     | <span class='neutral'>            // each branch to ensure that if x &gt;= 256, then y &gt;= 256.</span>
 176 |     | <span class='neutral'>            if iszero(lt(y, 0x10000000000000000000000000000000000)) {</span>
 177 |     | <span class='neutral'>                y := shr(128, y)</span>
 178 |     | <span class='neutral'>                z := shl(64, z)</span>
 179 |     | <span class='neutral'>            }</span>
 180 |     | <span class='neutral'>            if iszero(lt(y, 0x1000000000000000000)) {</span>
 181 |     | <span class='neutral'>                y := shr(64, y)</span>
 182 |     | <span class='neutral'>                z := shl(32, z)</span>
 183 |     | <span class='neutral'>            }</span>
 184 |     | <span class='neutral'>            if iszero(lt(y, 0x10000000000)) {</span>
 185 |     | <span class='neutral'>                y := shr(32, y)</span>
 186 |     | <span class='neutral'>                z := shl(16, z)</span>
 187 |     | <span class='neutral'>            }</span>
 188 |     | <span class='neutral'>            if iszero(lt(y, 0x1000000)) {</span>
 189 |     | <span class='neutral'>                y := shr(16, y)</span>
 190 |     | <span class='neutral'>                z := shl(8, z)</span>
 191 |     | <span class='neutral'>            }</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>            // Goal was to get z*z*y within a small factor of x. More iterations could</span>
 194 |     | <span class='neutral'>            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).</span>
 195 |     | <span class='neutral'>            // We ensured y &gt;= 256 so that the relative difference between y and y+1 is small.</span>
 196 |     | <span class='neutral'>            // That&#39;s not possible if x &lt; 256 but we can just verify those cases exhaustively.</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>            // Now, z*z*y &lt;= x &lt; z*z*(y+1), and y &lt;= 2^(16+8), and either y &gt;= 256, or x &lt; 256.</span>
 199 |     | <span class='neutral'>            // Correctness can be checked exhaustively for x &lt; 256, so we assume y &gt;= 256.</span>
 200 |     | <span class='neutral'>            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range</span>
 203 |     | <span class='neutral'>            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate</span>
 206 |     | <span class='neutral'>            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>            // There is no overflow risk here since y &lt; 2^136 after the first branch above.</span>
 209 |     | <span class='neutral'>            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.</span>
 212 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
 213 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
 214 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
 215 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
 216 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
 217 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
 218 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>            // If x+1 is a perfect square, the Babylonian method cycles between</span>
 221 |     | <span class='neutral'>            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.</span>
 222 |     | <span class='neutral'>            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division</span>
 223 |     | <span class='neutral'>            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.</span>
 224 |     | <span class='neutral'>            // If you don&#39;t care whether the floor or ceil square root is returned, you can remove this statement.</span>
 225 |     | <span class='neutral'>            z := sub(z, lt(div(x, z), z))</span>
 226 |     | <span class='neutral'>        }</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 230 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 231 |     | <span class='neutral'>        assembly {</span>
 232 |     | <span class='neutral'>            // Mod x by y. Note this will return</span>
 233 |     | <span class='neutral'>            // 0 instead of reverting if y is zero.</span>
 234 |     | <span class='neutral'>            z := mod(x, y)</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {</span>
 239 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 240 |     | <span class='neutral'>        assembly {</span>
 241 |     | <span class='neutral'>            // Divide x by y. Note this will return</span>
 242 |     | <span class='neutral'>            // 0 instead of reverting if y is zero.</span>
 243 |     | <span class='neutral'>            r := div(x, y)</span>
 244 |     | <span class='neutral'>        }</span>
 245 |     | <span class='neutral'>    }</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 248 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 249 |     | <span class='neutral'>        assembly {</span>
 250 |     | <span class='neutral'>            // Add 1 to x * y if x % y &gt; 0. Note this will</span>
 251 |     | <span class='neutral'>            // return 0 instead of reverting if y is zero.</span>
 252 |     | <span class='neutral'>            z := add(gt(mod(x, y), 0), div(x, y))</span>
 253 |     | <span class='neutral'>        }</span>
 254 |     | <span class='neutral'>    }</span>
 255 |     | <span class='neutral'>}</span>
 256 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solmate/src/utils/ReentrancyGuard.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @notice Gas optimized reentrancy protection for smart contracts.</span>
  5 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)</span>
  6 |     | <span class='neutral'>/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)</span>
  7 |     | <span class='neutral'>abstract contract ReentrancyGuard {</span>
  8 |     | <span class='unexecuted'>    uint256 private locked = 1;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    modifier nonReentrant() virtual {</span>
 11 |     | <span class='unexecuted'>        require(locked == 1, &quot;REENTRANCY&quot;);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>        locked = 2;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>        _;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>        locked = 1;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solmate/src/utils/SafeTransferLib.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ERC20} from &quot;../tokens/ERC20.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.</span>
   7 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)</span>
   8 |     | <span class='neutral'>/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.</span>
   9 |     | <span class='neutral'>/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.</span>
  10 |     | <span class='unexecuted'>library SafeTransferLib {</span>
  11 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  12 |     | <span class='neutral'>                             ETH OPERATIONS</span>
  13 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    function safeTransferETH(address to, uint256 amount) internal {</span>
  16 |     | <span class='neutral'>        bool success;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  19 |     | <span class='neutral'>        assembly {</span>
  20 |     | <span class='neutral'>            // Transfer the ETH and store if it succeeded or not.</span>
  21 |     | <span class='neutral'>            success := call(gas(), to, amount, 0, 0, 0, 0)</span>
  22 |     | <span class='neutral'>        }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>        require(success, &quot;ETH_TRANSFER_FAILED&quot;);</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  28 |     | <span class='neutral'>                            ERC20 OPERATIONS</span>
  29 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    function safeTransferFrom(</span>
  32 |     | <span class='neutral'>        ERC20 token,</span>
  33 |     | <span class='neutral'>        address from,</span>
  34 |     | <span class='neutral'>        address to,</span>
  35 |     | <span class='neutral'>        uint256 amount</span>
  36 |     | <span class='unexecuted'>    ) internal {</span>
  37 |     | <span class='unexecuted'>        bool success;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  40 |     | <span class='neutral'>        assembly {</span>
  41 |     | <span class='neutral'>            // Get a pointer to some free memory.</span>
  42 |     | <span class='unexecuted'>            let freeMemoryPointer := mload(0x40)</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>            // Write the abi-encoded calldata into memory, beginning with the function selector.</span>
  45 |     | <span class='unexecuted'>            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)</span>
  46 |     | <span class='unexecuted'>            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the &quot;from&quot; argument.</span>
  47 |     | <span class='unexecuted'>            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the &quot;to&quot; argument.</span>
  48 |     | <span class='unexecuted'>            mstore(add(freeMemoryPointer, 68), amount) // Append the &quot;amount&quot; argument. Masking not required as it&#39;s a full 32 byte type.</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>            success := and(</span>
  51 |     | <span class='neutral'>                // Set success to whether the call reverted, if not we check it either</span>
  52 |     | <span class='neutral'>                // returned exactly 1 (can&#39;t just be non-zero data), or had no return data.</span>
  53 |     | <span class='unexecuted'>                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),</span>
  54 |     | <span class='neutral'>                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.</span>
  55 |     | <span class='neutral'>                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.</span>
  56 |     | <span class='neutral'>                // Counterintuitively, this call must be positioned second to the or() call in the</span>
  57 |     | <span class='neutral'>                // surrounding and() call or else returndatasize() will be zero during the computation.</span>
  58 |     | <span class='unexecuted'>                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)</span>
  59 |     | <span class='neutral'>            )</span>
  60 |     | <span class='neutral'>        }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>        require(success, &quot;TRANSFER_FROM_FAILED&quot;);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function safeTransfer(</span>
  66 |     | <span class='neutral'>        ERC20 token,</span>
  67 |     | <span class='neutral'>        address to,</span>
  68 |     | <span class='neutral'>        uint256 amount</span>
  69 |     | <span class='neutral'>    ) internal {</span>
  70 |     | <span class='unexecuted'>        bool success;</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  73 |     | <span class='neutral'>        assembly {</span>
  74 |     | <span class='neutral'>            // Get a pointer to some free memory.</span>
  75 |     | <span class='unexecuted'>            let freeMemoryPointer := mload(0x40)</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>            // Write the abi-encoded calldata into memory, beginning with the function selector.</span>
  78 |     | <span class='unexecuted'>            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)</span>
  79 |     | <span class='unexecuted'>            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the &quot;to&quot; argument.</span>
  80 |     | <span class='unexecuted'>            mstore(add(freeMemoryPointer, 36), amount) // Append the &quot;amount&quot; argument. Masking not required as it&#39;s a full 32 byte type.</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>            success := and(</span>
  83 |     | <span class='neutral'>                // Set success to whether the call reverted, if not we check it either</span>
  84 |     | <span class='neutral'>                // returned exactly 1 (can&#39;t just be non-zero data), or had no return data.</span>
  85 |     | <span class='unexecuted'>                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),</span>
  86 |     | <span class='neutral'>                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.</span>
  87 |     | <span class='neutral'>                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.</span>
  88 |     | <span class='neutral'>                // Counterintuitively, this call must be positioned second to the or() call in the</span>
  89 |     | <span class='neutral'>                // surrounding and() call or else returndatasize() will be zero during the computation.</span>
  90 |     | <span class='unexecuted'>                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)</span>
  91 |     | <span class='neutral'>            )</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        require(success, &quot;TRANSFER_FAILED&quot;);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    function safeApprove(</span>
  98 |     | <span class='neutral'>        ERC20 token,</span>
  99 |     | <span class='neutral'>        address to,</span>
 100 |     | <span class='neutral'>        uint256 amount</span>
 101 |     | <span class='neutral'>    ) internal {</span>
 102 |     | <span class='neutral'>        bool success;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 105 |     | <span class='neutral'>        assembly {</span>
 106 |     | <span class='neutral'>            // Get a pointer to some free memory.</span>
 107 |     | <span class='neutral'>            let freeMemoryPointer := mload(0x40)</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>            // Write the abi-encoded calldata into memory, beginning with the function selector.</span>
 110 |     | <span class='neutral'>            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)</span>
 111 |     | <span class='neutral'>            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the &quot;to&quot; argument.</span>
 112 |     | <span class='neutral'>            mstore(add(freeMemoryPointer, 36), amount) // Append the &quot;amount&quot; argument. Masking not required as it&#39;s a full 32 byte type.</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>            success := and(</span>
 115 |     | <span class='neutral'>                // Set success to whether the call reverted, if not we check it either</span>
 116 |     | <span class='neutral'>                // returned exactly 1 (can&#39;t just be non-zero data), or had no return data.</span>
 117 |     | <span class='neutral'>                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),</span>
 118 |     | <span class='neutral'>                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.</span>
 119 |     | <span class='neutral'>                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.</span>
 120 |     | <span class='neutral'>                // Counterintuitively, this call must be positioned second to the or() call in the</span>
 121 |     | <span class='neutral'>                // surrounding and() call or else returndatasize() will be zero during the computation.</span>
 122 |     | <span class='neutral'>                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)</span>
 123 |     | <span class='neutral'>            )</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>        require(success, &quot;APPROVE_FAILED&quot;);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'>}</span>
 129 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/DegenBox.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>// The BentoBox</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>//    .                 </span>
   5 |     | <span class='neutral'>//   .              </span>
   6 |     | <span class='neutral'>//   .     </span>
   7 |     | <span class='neutral'>//   ..</span>
   8 |     | <span class='neutral'>//            </span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>// This contract stores funds, handles their transfers, supports flash loans and strategies.</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>// Copyright (c) 2021 BoringCrypto - All rights reserved</span>
  13 |     | <span class='neutral'>// Twitter: @Boring_Crypto</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>// Special thanks to Keno for all his hard work and support</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>// Version 22-Mar-2021</span>
  18 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  21 |     | <span class='neutral'>// solhint-disable not-rely-on-time</span>
  22 |     | <span class='neutral'>// solhint-disable no-inline-assembly</span>
  23 |     | <span class='neutral'>import {IERC20, ERC20} from &quot;BoringSolidity/ERC20.sol&quot;;</span>
  24 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  25 |     | <span class='neutral'>import {RebaseLibrary, Rebase} from &quot;BoringSolidity/libraries/BoringRebase.sol&quot;;</span>
  26 |     | <span class='neutral'>import {BoringOwnable} from &quot;BoringSolidity/BoringOwnable.sol&quot;;</span>
  27 |     | <span class='neutral'>import {BoringBatchable} from &quot;BoringSolidity/BoringBatchable.sol&quot;;</span>
  28 |     | <span class='neutral'>import {BoringMath, BoringMath128} from &quot;BoringSolidity/libraries/BoringMath.sol&quot;;</span>
  29 |     | <span class='neutral'>import {IStrategy} from &quot;interfaces/IStrategy.sol&quot;;</span>
  30 |     | <span class='neutral'>import {IBentoBoxV1, IFlashBorrower, IBatchFlashBorrower} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  31 |     | <span class='neutral'>import {IWETH} from &quot;interfaces/IWETH.sol&quot;;</span>
  32 |     | <span class='neutral'>import {MasterContractManager} from &quot;mixins/MasterContractManager.sol&quot;;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>/// @title DegenBox</span>
  35 |     | <span class='neutral'>/// @author BoringCrypto, Keno</span>
  36 |     | <span class='neutral'>/// @notice The BentoBox is a vault for tokens. The stored tokens can be flash loaned and used in strategies.</span>
  37 |     | <span class='neutral'>/// Yield from this will go to the token depositors.</span>
  38 |     | <span class='neutral'>/// Rebasing tokens ARE NOT supported and WILL cause loss of funds.</span>
  39 |     | <span class='neutral'>/// Any funds transfered directly onto the BentoBox will be lost, use the deposit function instead.</span>
  40 |     | <span class='unexecuted'>contract DegenBox is MasterContractManager, BoringBatchable {</span>
  41 |     | <span class='neutral'>    using BoringMath for uint256;</span>
  42 |     | <span class='neutral'>    using BoringMath128 for uint128;</span>
  43 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
  44 |     | <span class='neutral'>    using RebaseLibrary for Rebase;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    // ************** //</span>
  47 |     | <span class='neutral'>    // *** EVENTS *** //</span>
  48 |     | <span class='neutral'>    // ************** //</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    event LogDeposit(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);</span>
  51 |     | <span class='neutral'>    event LogWithdraw(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);</span>
  52 |     | <span class='neutral'>    event LogTransfer(IERC20 indexed token, address indexed from, address indexed to, uint256 share);</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    event LogFlashLoan(address indexed borrower, IERC20 indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    event LogStrategyTargetPercentage(IERC20 indexed token, uint256 targetPercentage);</span>
  57 |     | <span class='neutral'>    event LogStrategyQueued(IERC20 indexed token, IStrategy indexed strategy);</span>
  58 |     | <span class='neutral'>    event LogStrategySet(IERC20 indexed token, IStrategy indexed strategy);</span>
  59 |     | <span class='neutral'>    event LogStrategyInvest(IERC20 indexed token, uint256 amount);</span>
  60 |     | <span class='neutral'>    event LogStrategyDivest(IERC20 indexed token, uint256 amount);</span>
  61 |     | <span class='neutral'>    event LogStrategyProfit(IERC20 indexed token, uint256 amount);</span>
  62 |     | <span class='neutral'>    event LogStrategyLoss(IERC20 indexed token, uint256 amount);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    // *************** //</span>
  65 |     | <span class='neutral'>    // *** STRUCTS *** //</span>
  66 |     | <span class='neutral'>    // *************** //</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    struct StrategyData {</span>
  69 |     | <span class='neutral'>        uint64 strategyStartDate;</span>
  70 |     | <span class='neutral'>        uint64 targetPercentage;</span>
  71 |     | <span class='neutral'>        uint128 balance; // the balance of the strategy that BentoBox thinks is in there</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    // ******************************** //</span>
  75 |     | <span class='neutral'>    // *** CONSTANTS AND IMMUTABLES *** //</span>
  76 |     | <span class='neutral'>    // ******************************** //</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    // V2 - Can they be private?</span>
  79 |     | <span class='neutral'>    // V2: Private to save gas, to verify it&#39;s correct, check the constructor arguments</span>
  80 |     | <span class='neutral'>    IERC20 internal immutable wethToken;</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    IERC20 private constant USE_ETHEREUM = IERC20(address(0));</span>
  83 |     | <span class='unexecuted'>    uint256 private constant FLASH_LOAN_FEE = 50; // 0.05%</span>
  84 |     | <span class='unexecuted'>    uint256 private constant FLASH_LOAN_FEE_PRECISION = 1e5;</span>
  85 |     | <span class='unexecuted'>    uint256 private constant STRATEGY_DELAY = 3 days;</span>
  86 |     | <span class='unexecuted'>    uint256 private constant MAX_TARGET_PERCENTAGE = 95; // 95%</span>
  87 |     | <span class='unexecuted'>    uint256 private constant MINIMUM_SHARE_BALANCE = 1000; // To prevent the ratio going off</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    // ***************** //</span>
  90 |     | <span class='neutral'>    // *** VARIABLES *** //</span>
  91 |     | <span class='neutral'>    // ***************** //</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    // Balance per token per address/contract in shares</span>
  94 |     | <span class='unexecuted'>    mapping(IERC20 =&gt; mapping(address =&gt; uint256)) public balanceOf;</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    // Rebase from amount to share</span>
  97 |     | <span class='unexecuted'>    mapping(IERC20 =&gt; Rebase) public totals;</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>    mapping(IERC20 =&gt; IStrategy) public strategy;</span>
 100 |     | <span class='unexecuted'>    mapping(IERC20 =&gt; IStrategy) public pendingStrategy;</span>
 101 |     | <span class='unexecuted'>    mapping(IERC20 =&gt; StrategyData) public strategyData;</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    // ******************* //</span>
 104 |     | <span class='neutral'>    // *** CONSTRUCTOR *** //</span>
 105 |     | <span class='neutral'>    // ******************* //</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>    constructor(IERC20 wethToken_) {</span>
 108 |     | <span class='unexecuted'>        wethToken = wethToken_;</span>
 109 |     | <span class='unexecuted'>        _configure();</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    function _configure() internal virtual {}</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    // ***************** //</span>
 115 |     | <span class='neutral'>    // *** MODIFIERS *** //</span>
 116 |     | <span class='neutral'>    // ***************** //</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    /// Modifier to check if the msg.sender is allowed to use funds belonging to the &#39;from&#39; address.</span>
 119 |     | <span class='neutral'>    /// If &#39;from&#39; is msg.sender, it&#39;s allowed.</span>
 120 |     | <span class='neutral'>    /// If &#39;from&#39; is the BentoBox itself, it&#39;s allowed. Any ETH, token balances (above the known balances) or BentoBox balances</span>
 121 |     | <span class='neutral'>    /// can be taken by anyone.</span>
 122 |     | <span class='neutral'>    /// This is to enable skimming, not just for deposits, but also for withdrawals or transfers, enabling better composability.</span>
 123 |     | <span class='neutral'>    /// If &#39;from&#39; is a clone of a masterContract AND the &#39;from&#39; address has approved that masterContract, it&#39;s allowed.</span>
 124 |     | <span class='neutral'>    modifier allowed(address from) {</span>
 125 |     | <span class='unexecuted'>        if (from != msg.sender &amp;&amp; from != address(this)) {</span>
 126 |     | <span class='neutral'>            // From is sender or you are skimming</span>
 127 |     | <span class='unexecuted'>            address masterContract = masterContractOf[msg.sender];</span>
 128 |     | <span class='unexecuted'>            require(masterContract != address(0), &quot;BentoBox: no masterContract&quot;);</span>
 129 |     | <span class='unexecuted'>            require(masterContractApproved[masterContract][from], &quot;BentoBox: Transfer not approved&quot;);</span>
 130 |     | <span class='neutral'>        }</span>
 131 |     | <span class='unexecuted'>        _;</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    // ************************** //</span>
 135 |     | <span class='neutral'>    // *** INTERNAL FUNCTIONS *** //</span>
 136 |     | <span class='neutral'>    // ************************** //</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    /// @dev Returns the total balance of `token` this contracts holds,</span>
 139 |     | <span class='neutral'>    /// plus the total amount this contract thinks the strategy holds.</span>
 140 |     | <span class='unexecuted'>    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {</span>
 141 |     | <span class='unexecuted'>        amount = token.balanceOf(address(this)).add(strategyData[token].balance);</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    // ************************ //</span>
 145 |     | <span class='neutral'>    // *** PUBLIC FUNCTIONS *** //</span>
 146 |     | <span class='neutral'>    // ************************ //</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    /// @dev Helper function to represent an `amount` of `token` in shares.</span>
 149 |     | <span class='neutral'>    /// @param token The ERC-20 token.</span>
 150 |     | <span class='neutral'>    /// @param amount The `token` amount.</span>
 151 |     | <span class='neutral'>    /// @param roundUp If the result `share` should be rounded up.</span>
 152 |     | <span class='neutral'>    /// @return share The token amount represented in shares.</span>
 153 |     | <span class='unexecuted'>    function toShare(IERC20 token, uint256 amount, bool roundUp) external view returns (uint256 share) {</span>
 154 |     | <span class='unexecuted'>        share = totals[token].toBase(amount, roundUp);</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    /// @dev Helper function represent shares back into the `token` amount.</span>
 158 |     | <span class='neutral'>    /// @param token The ERC-20 token.</span>
 159 |     | <span class='neutral'>    /// @param share The amount of shares.</span>
 160 |     | <span class='neutral'>    /// @param roundUp If the result should be rounded up.</span>
 161 |     | <span class='neutral'>    /// @return amount The share amount back into native representation.</span>
 162 |     | <span class='unexecuted'>    function toAmount(IERC20 token, uint256 share, bool roundUp) external view returns (uint256 amount) {</span>
 163 |     | <span class='unexecuted'>        amount = totals[token].toElastic(share, roundUp);</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.</span>
 167 |     | <span class='neutral'>    /// @param token_ The ERC-20 token to deposit.</span>
 168 |     | <span class='neutral'>    /// @param from which account to pull the tokens.</span>
 169 |     | <span class='neutral'>    /// @param to which account to push the tokens.</span>
 170 |     | <span class='neutral'>    /// @param amount Token amount in native representation to deposit.</span>
 171 |     | <span class='neutral'>    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.</span>
 172 |     | <span class='neutral'>    /// @return amountOut The amount deposited.</span>
 173 |     | <span class='neutral'>    /// @return shareOut The deposited amount repesented in shares.</span>
 174 |     | <span class='unexecuted'>    function deposit(</span>
 175 |     | <span class='neutral'>        IERC20 token_,</span>
 176 |     | <span class='neutral'>        address from,</span>
 177 |     | <span class='neutral'>        address to,</span>
 178 |     | <span class='neutral'>        uint256 amount,</span>
 179 |     | <span class='neutral'>        uint256 share</span>
 180 |     | <span class='unexecuted'>    ) public payable allowed(from) returns (uint256 amountOut, uint256 shareOut) {</span>
 181 |     | <span class='neutral'>        // Checks</span>
 182 |     | <span class='unexecuted'>        require(to != address(0), &quot;BentoBox: to not set&quot;); // To avoid a bad UI from burning funds</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>        // Effects</span>
 185 |     | <span class='unexecuted'>        IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;</span>
 186 |     | <span class='unexecuted'>        _onBeforeDeposit(token, from, to, amount, share);</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='unexecuted'>        Rebase memory total = totals[token];</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>        // If a new token gets added, the tokenSupply call checks that this is a deployed contract. Needed for security.</span>
 191 |     | <span class='unexecuted'>        require(total.elastic != 0 || token.totalSupply() &gt; 0, &quot;BentoBox: No tokens&quot;);</span>
 192 |     | <span class='unexecuted'>        if (share == 0) {</span>
 193 |     | <span class='neutral'>            // value of the share may be lower than the amount due to rounding, that&#39;s ok</span>
 194 |     | <span class='unexecuted'>            share = total.toBase(amount, false);</span>
 195 |     | <span class='neutral'>            // Any deposit should lead to at least the minimum share balance, otherwise it&#39;s ignored (no amount taken)</span>
 196 |     | <span class='unexecuted'>            if (total.base.add(share.to128()) &lt; MINIMUM_SHARE_BALANCE) {</span>
 197 |     | <span class='unexecuted'>                return (0, 0);</span>
 198 |     | <span class='neutral'>            }</span>
 199 |     | <span class='neutral'>        } else {</span>
 200 |     | <span class='neutral'>            // amount may be lower than the value of share due to rounding, in that case, add 1 to amount (Always round up)</span>
 201 |     | <span class='unexecuted'>            amount = total.toElastic(share, true);</span>
 202 |     | <span class='neutral'>        }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>        // In case of skimming, check that only the skimmable amount is taken.</span>
 205 |     | <span class='neutral'>        // For ETH, the full balance is available, so no need to check.</span>
 206 |     | <span class='neutral'>        // During flashloans the _tokenBalanceOf is lower than &#39;reality&#39;, so skimming deposits will mostly fail during a flashloan.</span>
 207 |     | <span class='unexecuted'>        require(</span>
 208 |     | <span class='unexecuted'>            from != address(this) || token_ == USE_ETHEREUM || amount &lt;= _tokenBalanceOf(token).sub(total.elastic),</span>
 209 |     | <span class='neutral'>            &quot;BentoBox: Skim too much&quot;</span>
 210 |     | <span class='neutral'>        );</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='unexecuted'>        balanceOf[token][to] = balanceOf[token][to].add(share);</span>
 213 |     | <span class='unexecuted'>        total.base = total.base.add(share.to128());</span>
 214 |     | <span class='unexecuted'>        total.elastic = total.elastic.add(amount.to128());</span>
 215 |     | <span class='unexecuted'>        totals[token] = total;</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>        // Interactions</span>
 218 |     | <span class='neutral'>        // During the first deposit, we check that this token is &#39;real&#39;</span>
 219 |     | <span class='unexecuted'>        if (token_ == USE_ETHEREUM) {</span>
 220 |     | <span class='neutral'>            // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)</span>
 221 |     | <span class='neutral'>            // X2: If the WETH implementation is faulty or malicious, it will block adding ETH (but we know the WETH implementation)</span>
 222 |     | <span class='unexecuted'>            IWETH(address(wethToken)).deposit{value: amount}();</span>
 223 |     | <span class='unexecuted'>        } else if (from != address(this)) {</span>
 224 |     | <span class='neutral'>            // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)</span>
 225 |     | <span class='neutral'>            // X2: If the token implementation is faulty or malicious, it may block adding tokens. Good.</span>
 226 |     | <span class='unexecuted'>            token.safeTransferFrom(from, address(this), amount);</span>
 227 |     | <span class='neutral'>        }</span>
 228 |     | <span class='unexecuted'>        emit LogDeposit(token, from, to, amount, share);</span>
 229 |     | <span class='unexecuted'>        amountOut = amount;</span>
 230 |     | <span class='unexecuted'>        shareOut = share;</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>    /// @notice Withdraws an amount of `token` from a user account.</span>
 234 |     | <span class='neutral'>    /// @param token_ The ERC-20 token to withdraw.</span>
 235 |     | <span class='neutral'>    /// @param from which user to pull the tokens.</span>
 236 |     | <span class='neutral'>    /// @param to which user to push the tokens.</span>
 237 |     | <span class='neutral'>    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.</span>
 238 |     | <span class='neutral'>    /// @param share Like above, but `share` takes precedence over `amount`.</span>
 239 |     | <span class='unexecuted'>    function withdraw(</span>
 240 |     | <span class='neutral'>        IERC20 token_,</span>
 241 |     | <span class='neutral'>        address from,</span>
 242 |     | <span class='neutral'>        address to,</span>
 243 |     | <span class='neutral'>        uint256 amount,</span>
 244 |     | <span class='neutral'>        uint256 share</span>
 245 |     | <span class='unexecuted'>    ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {</span>
 246 |     | <span class='neutral'>        // Checks</span>
 247 |     | <span class='unexecuted'>        require(to != address(0), &quot;BentoBox: to not set&quot;); // To avoid a bad UI from burning funds</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='neutral'>        // Effects</span>
 250 |     | <span class='unexecuted'>        IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;</span>
 251 |     | <span class='unexecuted'>        Rebase memory total = totals[token];</span>
 252 |     | <span class='unexecuted'>        if (share == 0) {</span>
 253 |     | <span class='neutral'>            // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)</span>
 254 |     | <span class='unexecuted'>            share = total.toBase(amount, true);</span>
 255 |     | <span class='neutral'>        } else {</span>
 256 |     | <span class='neutral'>            // amount may be lower than the value of share due to rounding, that&#39;s ok</span>
 257 |     | <span class='unexecuted'>            amount = total.toElastic(share, false);</span>
 258 |     | <span class='neutral'>        }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='unexecuted'>        balanceOf[token][from] = balanceOf[token][from].sub(share);</span>
 261 |     | <span class='unexecuted'>        total.elastic = total.elastic.sub(amount.to128());</span>
 262 |     | <span class='unexecuted'>        total.base = total.base.sub(share.to128());</span>
 263 |     | <span class='neutral'>        // There have to be at least 1000 shares left to prevent reseting the share/amount ratio (unless it&#39;s fully emptied)</span>
 264 |     | <span class='unexecuted'>        require(total.base &gt;= MINIMUM_SHARE_BALANCE || total.base == 0, &quot;BentoBox: cannot empty&quot;);</span>
 265 |     | <span class='unexecuted'>        totals[token] = total;</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'>        // Interactions</span>
 268 |     | <span class='unexecuted'>        if (token_ == USE_ETHEREUM) {</span>
 269 |     | <span class='neutral'>            // X2, X3: A revert or big gas usage in the WETH contract could block withdrawals, but WETH9 is fine.</span>
 270 |     | <span class='unexecuted'>            IWETH(address(wethToken)).withdraw(amount);</span>
 271 |     | <span class='neutral'>            // X2, X3: A revert or big gas usage could block, however, the to address is under control of the caller.</span>
 272 |     | <span class='unexecuted'>            (bool success, ) = to.call{value: amount}(&quot;&quot;);</span>
 273 |     | <span class='unexecuted'>            require(success, &quot;BentoBox: ETH transfer failed&quot;);</span>
 274 |     | <span class='neutral'>        } else {</span>
 275 |     | <span class='neutral'>            // X2, X3: A malicious token could block withdrawal of just THAT token.</span>
 276 |     | <span class='neutral'>            //         masterContracts may want to take care not to rely on withdraw always succeeding.</span>
 277 |     | <span class='unexecuted'>            token.safeTransfer(to, amount);</span>
 278 |     | <span class='neutral'>        }</span>
 279 |     | <span class='unexecuted'>        emit LogWithdraw(token, from, to, amount, share);</span>
 280 |     | <span class='neutral'>        amountOut = amount;</span>
 281 |     | <span class='neutral'>        shareOut = share;</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>    /// @notice Transfer shares from a user account to another one.</span>
 285 |     | <span class='neutral'>    /// @param token The ERC-20 token to transfer.</span>
 286 |     | <span class='neutral'>    /// @param from which user to pull the tokens.</span>
 287 |     | <span class='neutral'>    /// @param to which user to push the tokens.</span>
 288 |     | <span class='neutral'>    /// @param share The amount of `token` in shares.</span>
 289 |     | <span class='neutral'>    // Clones of master contracts can transfer from any account that has approved them</span>
 290 |     | <span class='neutral'>    // F3 - Can it be combined with another similar function?</span>
 291 |     | <span class='neutral'>    // F3: This isn&#39;t combined with transferMultiple for gas optimization</span>
 292 |     | <span class='unexecuted'>    function transfer(IERC20 token, address from, address to, uint256 share) public allowed(from) {</span>
 293 |     | <span class='neutral'>        // Checks</span>
 294 |     | <span class='unexecuted'>        require(to != address(0), &quot;BentoBox: to not set&quot;); // To avoid a bad UI from burning funds</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='neutral'>        // Effects</span>
 297 |     | <span class='unexecuted'>        balanceOf[token][from] = balanceOf[token][from].sub(share);</span>
 298 |     | <span class='unexecuted'>        balanceOf[token][to] = balanceOf[token][to].add(share);</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='unexecuted'>        emit LogTransfer(token, from, to, share);</span>
 301 |     | <span class='neutral'>    }</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>    /// @notice Transfer shares from a user account to multiple other ones.</span>
 304 |     | <span class='neutral'>    /// @param token The ERC-20 token to transfer.</span>
 305 |     | <span class='neutral'>    /// @param from which user to pull the tokens.</span>
 306 |     | <span class='neutral'>    /// @param tos The receivers of the tokens.</span>
 307 |     | <span class='neutral'>    /// @param shares The amount of `token` in shares for each receiver in `tos`.</span>
 308 |     | <span class='neutral'>    // F3 - Can it be combined with another similar function?</span>
 309 |     | <span class='neutral'>    // F3: This isn&#39;t combined with transfer for gas optimization</span>
 310 |     | <span class='unexecuted'>    function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) public allowed(from) {</span>
 311 |     | <span class='neutral'>        // Checks</span>
 312 |     | <span class='unexecuted'>        require(tos[0] != address(0), &quot;BentoBox: to[0] not set&quot;); // To avoid a bad UI from burning funds</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>        // Effects</span>
 315 |     | <span class='unexecuted'>        uint256 totalAmount;</span>
 316 |     | <span class='unexecuted'>        uint256 len = tos.length;</span>
 317 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; len; i++) {</span>
 318 |     | <span class='unexecuted'>            address to = tos[i];</span>
 319 |     | <span class='unexecuted'>            balanceOf[token][to] = balanceOf[token][to].add(shares[i]);</span>
 320 |     | <span class='unexecuted'>            totalAmount = totalAmount.add(shares[i]);</span>
 321 |     | <span class='unexecuted'>            emit LogTransfer(token, from, to, shares[i]);</span>
 322 |     | <span class='neutral'>        }</span>
 323 |     | <span class='unexecuted'>        balanceOf[token][from] = balanceOf[token][from].sub(totalAmount);</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>    /// @notice Flashloan ability.</span>
 327 |     | <span class='neutral'>    /// @param borrower The address of the contract that implements and conforms to `IFlashBorrower` and handles the flashloan.</span>
 328 |     | <span class='neutral'>    /// @param receiver Address of the token receiver.</span>
 329 |     | <span class='neutral'>    /// @param token The address of the token to receive.</span>
 330 |     | <span class='neutral'>    /// @param amount of the tokens to receive.</span>
 331 |     | <span class='neutral'>    /// @param data The calldata to pass to the `borrower` contract.</span>
 332 |     | <span class='neutral'>    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)</span>
 333 |     | <span class='neutral'>    // F5: Not possible to follow this here, reentrancy has been reviewed</span>
 334 |     | <span class='neutral'>    // F6 - Check for front-running possibilities, such as the approve function (SWC-114)</span>
 335 |     | <span class='neutral'>    // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.</span>
 336 |     | <span class='unexecuted'>    function flashLoan(IFlashBorrower borrower, address receiver, IERC20 token, uint256 amount, bytes calldata data) public {</span>
 337 |     | <span class='unexecuted'>        uint256 fee = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;</span>
 338 |     | <span class='unexecuted'>        token.safeTransfer(receiver, amount);</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='unexecuted'>        borrower.onFlashLoan(msg.sender, token, amount, fee, data);</span>
 341 |     | <span class='neutral'></span>
 342 |     | <span class='unexecuted'>        require(_tokenBalanceOf(token) &gt;= totals[token].addElastic(fee.to128()), &quot;BentoBox: Wrong amount&quot;);</span>
 343 |     | <span class='unexecuted'>        emit LogFlashLoan(address(borrower), token, amount, fee, receiver);</span>
 344 |     | <span class='neutral'>    }</span>
 345 |     | <span class='neutral'></span>
 346 |     | <span class='neutral'>    /// @notice Support for batched flashloans. Useful to request multiple different `tokens` in a single transaction.</span>
 347 |     | <span class='neutral'>    /// @param borrower The address of the contract that implements and conforms to `IBatchFlashBorrower` and handles the flashloan.</span>
 348 |     | <span class='neutral'>    /// @param receivers An array of the token receivers. A one-to-one mapping with `tokens` and `amounts`.</span>
 349 |     | <span class='neutral'>    /// @param tokens The addresses of the tokens.</span>
 350 |     | <span class='neutral'>    /// @param amounts of the tokens for each receiver.</span>
 351 |     | <span class='neutral'>    /// @param data The calldata to pass to the `borrower` contract.</span>
 352 |     | <span class='neutral'>    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)</span>
 353 |     | <span class='neutral'>    // F5: Not possible to follow this here, reentrancy has been reviewed</span>
 354 |     | <span class='neutral'>    // F6 - Check for front-running possibilities, such as the approve function (SWC-114)</span>
 355 |     | <span class='neutral'>    // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.</span>
 356 |     | <span class='unexecuted'>    function batchFlashLoan(</span>
 357 |     | <span class='neutral'>        IBatchFlashBorrower borrower,</span>
 358 |     | <span class='neutral'>        address[] calldata receivers,</span>
 359 |     | <span class='neutral'>        IERC20[] calldata tokens,</span>
 360 |     | <span class='neutral'>        uint256[] calldata amounts,</span>
 361 |     | <span class='neutral'>        bytes calldata data</span>
 362 |     | <span class='neutral'>    ) public {</span>
 363 |     | <span class='unexecuted'>        uint256[] memory fees = new uint256[](tokens.length);</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='unexecuted'>        uint256 len = tokens.length;</span>
 366 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; len; i++) {</span>
 367 |     | <span class='unexecuted'>            uint256 amount = amounts[i];</span>
 368 |     | <span class='unexecuted'>            fees[i] = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;</span>
 369 |     | <span class='neutral'></span>
 370 |     | <span class='unexecuted'>            tokens[i].safeTransfer(receivers[i], amounts[i]);</span>
 371 |     | <span class='neutral'>        }</span>
 372 |     | <span class='neutral'></span>
 373 |     | <span class='unexecuted'>        borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data);</span>
 374 |     | <span class='neutral'></span>
 375 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; len; i++) {</span>
 376 |     | <span class='unexecuted'>            IERC20 token = tokens[i];</span>
 377 |     | <span class='unexecuted'>            require(_tokenBalanceOf(token) &gt;= totals[token].addElastic(fees[i].to128()), &quot;BentoBox: Wrong amount&quot;);</span>
 378 |     | <span class='unexecuted'>            emit LogFlashLoan(address(borrower), token, amounts[i], fees[i], receivers[i]);</span>
 379 |     | <span class='neutral'>        }</span>
 380 |     | <span class='neutral'>    }</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='neutral'>    /// @notice Sets the target percentage of the strategy for `token`.</span>
 383 |     | <span class='neutral'>    /// @dev Only the owner of this contract is allowed to change this.</span>
 384 |     | <span class='neutral'>    /// @param token The address of the token that maps to a strategy to change.</span>
 385 |     | <span class='neutral'>    /// @param targetPercentage_ The new target in percent. Must be lesser or equal to `MAX_TARGET_PERCENTAGE`.</span>
 386 |     | <span class='unexecuted'>    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) public onlyOwner {</span>
 387 |     | <span class='neutral'>        // Checks</span>
 388 |     | <span class='unexecuted'>        require(targetPercentage_ &lt;= MAX_TARGET_PERCENTAGE, &quot;StrategyManager: Target too high&quot;);</span>
 389 |     | <span class='neutral'></span>
 390 |     | <span class='neutral'>        // Effects</span>
 391 |     | <span class='unexecuted'>        strategyData[token].targetPercentage = targetPercentage_;</span>
 392 |     | <span class='unexecuted'>        emit LogStrategyTargetPercentage(token, targetPercentage_);</span>
 393 |     | <span class='neutral'>    }</span>
 394 |     | <span class='neutral'></span>
 395 |     | <span class='neutral'>    /// @notice Sets the contract address of a new strategy that conforms to `IStrategy` for `token`.</span>
 396 |     | <span class='neutral'>    /// Must be called twice with the same arguments.</span>
 397 |     | <span class='neutral'>    /// A new strategy becomes pending first and can be activated once `STRATEGY_DELAY` is over.</span>
 398 |     | <span class='neutral'>    /// @dev Only the owner of this contract is allowed to change this.</span>
 399 |     | <span class='neutral'>    /// @param token The address of the token that maps to a strategy to change.</span>
 400 |     | <span class='neutral'>    /// @param newStrategy The address of the contract that conforms to `IStrategy`.</span>
 401 |     | <span class='neutral'>    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)</span>
 402 |     | <span class='neutral'>    // F5: Total amount is updated AFTER interaction. But strategy is under our control.</span>
 403 |     | <span class='neutral'>    // C4 - Use block.timestamp only for long intervals (SWC-116)</span>
 404 |     | <span class='neutral'>    // C4: block.timestamp is used for a period of 2 weeks, which is long enough</span>
 405 |     | <span class='unexecuted'>    function setStrategy(IERC20 token, IStrategy newStrategy) public onlyOwner {</span>
 406 |     | <span class='unexecuted'>        StrategyData memory data = strategyData[token];</span>
 407 |     | <span class='unexecuted'>        IStrategy pending = pendingStrategy[token];</span>
 408 |     | <span class='unexecuted'>        if (data.strategyStartDate == 0 || pending != newStrategy) {</span>
 409 |     | <span class='unexecuted'>            pendingStrategy[token] = newStrategy;</span>
 410 |     | <span class='neutral'>            // C1 - All math done through BoringMath (SWC-101)</span>
 411 |     | <span class='neutral'>            // C1: Our sun will swallow the earth well before this overflows</span>
 412 |     | <span class='unexecuted'>            data.strategyStartDate = (block.timestamp + STRATEGY_DELAY).to64();</span>
 413 |     | <span class='unexecuted'>            emit LogStrategyQueued(token, newStrategy);</span>
 414 |     | <span class='neutral'>        } else {</span>
 415 |     | <span class='unexecuted'>            require(data.strategyStartDate != 0 &amp;&amp; block.timestamp &gt;= data.strategyStartDate, &quot;StrategyManager: Too early&quot;);</span>
 416 |     | <span class='unexecuted'>            if (address(strategy[token]) != address(0)) {</span>
 417 |     | <span class='unexecuted'>                int256 balanceChange = strategy[token].exit(data.balance);</span>
 418 |     | <span class='neutral'>                // Effects</span>
 419 |     | <span class='unexecuted'>                if (balanceChange &gt; 0) {</span>
 420 |     | <span class='unexecuted'>                    uint256 add = uint256(balanceChange);</span>
 421 |     | <span class='unexecuted'>                    totals[token].addElastic(add);</span>
 422 |     | <span class='unexecuted'>                    emit LogStrategyProfit(token, add);</span>
 423 |     | <span class='unexecuted'>                } else if (balanceChange &lt; 0) {</span>
 424 |     | <span class='unexecuted'>                    uint256 sub = uint256(-balanceChange);</span>
 425 |     | <span class='unexecuted'>                    totals[token].subElastic(sub);</span>
 426 |     | <span class='unexecuted'>                    emit LogStrategyLoss(token, sub);</span>
 427 |     | <span class='neutral'>                }</span>
 428 |     | <span class='neutral'></span>
 429 |     | <span class='unexecuted'>                emit LogStrategyDivest(token, data.balance);</span>
 430 |     | <span class='neutral'>            }</span>
 431 |     | <span class='unexecuted'>            strategy[token] = pending;</span>
 432 |     | <span class='unexecuted'>            data.strategyStartDate = 0;</span>
 433 |     | <span class='unexecuted'>            data.balance = 0;</span>
 434 |     | <span class='unexecuted'>            pendingStrategy[token] = IStrategy(address(0));</span>
 435 |     | <span class='unexecuted'>            emit LogStrategySet(token, newStrategy);</span>
 436 |     | <span class='neutral'>        }</span>
 437 |     | <span class='unexecuted'>        strategyData[token] = data;</span>
 438 |     | <span class='neutral'>    }</span>
 439 |     | <span class='neutral'></span>
 440 |     | <span class='neutral'>    /// @notice The actual process of yield farming. Executes the strategy of `token`.</span>
 441 |     | <span class='neutral'>    /// Optionally does housekeeping if `balance` is true.</span>
 442 |     | <span class='neutral'>    /// `maxChangeAmount` is relevant for skimming or withdrawing if `balance` is true.</span>
 443 |     | <span class='neutral'>    /// @param token The address of the token for which a strategy is deployed.</span>
 444 |     | <span class='neutral'>    /// @param balance True if housekeeping should be done.</span>
 445 |     | <span class='neutral'>    /// @param maxChangeAmount The maximum amount for either pulling or pushing from/to the `IStrategy` contract.</span>
 446 |     | <span class='neutral'>    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)</span>
 447 |     | <span class='neutral'>    // F5: Total amount is updated AFTER interaction. But strategy is under our control.</span>
 448 |     | <span class='neutral'>    // F5: Not followed to prevent reentrancy issues with flashloans and BentoBox skims?</span>
 449 |     | <span class='unexecuted'>    function harvest(IERC20 token, bool balance, uint256 maxChangeAmount) public {</span>
 450 |     | <span class='unexecuted'>        StrategyData memory data = strategyData[token];</span>
 451 |     | <span class='unexecuted'>        IStrategy _strategy = strategy[token];</span>
 452 |     | <span class='unexecuted'>        int256 balanceChange = _strategy.harvest(data.balance, msg.sender);</span>
 453 |     | <span class='unexecuted'>        if (balanceChange == 0 &amp;&amp; !balance) {</span>
 454 |     | <span class='unexecuted'>            return;</span>
 455 |     | <span class='neutral'>        }</span>
 456 |     | <span class='neutral'></span>
 457 |     | <span class='unexecuted'>        uint256 totalElastic = totals[token].elastic;</span>
 458 |     | <span class='neutral'></span>
 459 |     | <span class='unexecuted'>        if (balanceChange &gt; 0) {</span>
 460 |     | <span class='unexecuted'>            uint256 add = uint256(balanceChange);</span>
 461 |     | <span class='unexecuted'>            totalElastic = totalElastic.add(add);</span>
 462 |     | <span class='unexecuted'>            totals[token].elastic = totalElastic.to128();</span>
 463 |     | <span class='unexecuted'>            emit LogStrategyProfit(token, add);</span>
 464 |     | <span class='unexecuted'>        } else if (balanceChange &lt; 0) {</span>
 465 |     | <span class='neutral'>            // C1 - All math done through BoringMath (SWC-101)</span>
 466 |     | <span class='neutral'>            // C1: balanceChange could overflow if it&#39;s max negative int128.</span>
 467 |     | <span class='neutral'>            // But tokens with balances that large are not supported by the BentoBox.</span>
 468 |     | <span class='unexecuted'>            uint256 sub = uint256(-balanceChange);</span>
 469 |     | <span class='unexecuted'>            totalElastic = totalElastic.sub(sub);</span>
 470 |     | <span class='unexecuted'>            totals[token].elastic = totalElastic.to128();</span>
 471 |     | <span class='unexecuted'>            data.balance = data.balance.sub(sub.to128());</span>
 472 |     | <span class='unexecuted'>            emit LogStrategyLoss(token, sub);</span>
 473 |     | <span class='neutral'>        }</span>
 474 |     | <span class='neutral'></span>
 475 |     | <span class='unexecuted'>        if (balance) {</span>
 476 |     | <span class='unexecuted'>            uint256 targetBalance = totalElastic.mul(data.targetPercentage) / 100;</span>
 477 |     | <span class='neutral'>            // if data.balance == targetBalance there is nothing to update</span>
 478 |     | <span class='unexecuted'>            if (data.balance &lt; targetBalance) {</span>
 479 |     | <span class='unexecuted'>                uint256 amountOut = targetBalance.sub(data.balance);</span>
 480 |     | <span class='unexecuted'>                if (maxChangeAmount != 0 &amp;&amp; amountOut &gt; maxChangeAmount) {</span>
 481 |     | <span class='unexecuted'>                    amountOut = maxChangeAmount;</span>
 482 |     | <span class='neutral'>                }</span>
 483 |     | <span class='unexecuted'>                token.safeTransfer(address(_strategy), amountOut);</span>
 484 |     | <span class='unexecuted'>                data.balance = data.balance.add(amountOut.to128());</span>
 485 |     | <span class='unexecuted'>                _strategy.skim(amountOut);</span>
 486 |     | <span class='unexecuted'>                emit LogStrategyInvest(token, amountOut);</span>
 487 |     | <span class='unexecuted'>            } else if (data.balance &gt; targetBalance) {</span>
 488 |     | <span class='unexecuted'>                uint256 amountIn = data.balance.sub(targetBalance.to128());</span>
 489 |     | <span class='unexecuted'>                if (maxChangeAmount != 0 &amp;&amp; amountIn &gt; maxChangeAmount) {</span>
 490 |     | <span class='unexecuted'>                    amountIn = maxChangeAmount;</span>
 491 |     | <span class='neutral'>                }</span>
 492 |     | <span class='neutral'></span>
 493 |     | <span class='unexecuted'>                uint256 actualAmountIn = _strategy.withdraw(amountIn);</span>
 494 |     | <span class='neutral'></span>
 495 |     | <span class='unexecuted'>                data.balance = data.balance.sub(actualAmountIn.to128());</span>
 496 |     | <span class='unexecuted'>                emit LogStrategyDivest(token, actualAmountIn);</span>
 497 |     | <span class='neutral'>            }</span>
 498 |     | <span class='neutral'>        }</span>
 499 |     | <span class='neutral'></span>
 500 |     | <span class='unexecuted'>        strategyData[token] = data;</span>
 501 |     | <span class='neutral'>    }</span>
 502 |     | <span class='neutral'></span>
 503 |     | <span class='neutral'>    // Contract should be able to receive ETH deposits to support deposit &amp; skim</span>
 504 |     | <span class='neutral'>    // solhint-disable-next-line no-empty-blocks</span>
 505 |     | <span class='neutral'>    receive() external payable {}</span>
 506 |     | <span class='neutral'></span>
 507 |     | <span class='neutral'>    ////////////////////////////////////////////////////////////////////////////////////////</span>
 508 |     | <span class='neutral'>    /// EVENTS</span>
 509 |     | <span class='neutral'>    ////////////////////////////////////////////////////////////////////////////////////////</span>
 510 |     | <span class='unexecuted'>    function _onBeforeDeposit(IERC20 token, address from, address to, uint256 amount, uint256 share) internal virtual {</span>
 511 |     | <span class='neutral'></span>
 512 |     | <span class='neutral'>    }</span>
 513 |     | <span class='neutral'>}</span>
 514 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastBox.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>// Copyright (c) 2021 BoringCrypto - All rights reserved</span>
   3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {DegenBox} from &quot;/DegenBox.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BlastYields} from &quot;/blast/libraries/BlastYields.sol&quot;;</span>
   7 |     | <span class='neutral'>import {BlastPoints} from &quot;/blast/libraries/BlastPoints.sol&quot;;</span>
   8 |     | <span class='neutral'>import {BlastTokenRegistry} from &quot;/blast/BlastTokenRegistry.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  10 |     | <span class='neutral'>import {OperatableV3} from &quot;mixins/OperatableV3.sol&quot;;</span>
  11 |     | <span class='neutral'>import {IWETH} from &quot;interfaces/IWETH.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>contract BlastBox is DegenBox, OperatableV3 {</span>
  14 |     | <span class='neutral'>    event LogTokenDepositEnabled(address indexed token, bool enabled);</span>
  15 |     | <span class='neutral'>    event LogFeeToChanged(address indexed feeTo);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    error ErrZeroAddress();</span>
  18 |     | <span class='neutral'>    error ErrUnsupportedToken();</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    BlastTokenRegistry public immutable registry;</span>
  21 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public enabledTokens;</span>
  22 |     | <span class='unexecuted'>    address public feeTo;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>    constructor(IERC20 weth_, BlastTokenRegistry registry_, address feeTo_) DegenBox(weth_) {</span>
  25 |     | <span class='unexecuted'>        if (feeTo_ == address(0)) {</span>
  26 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
  27 |     | <span class='neutral'>        }</span>
  28 |     | <span class='unexecuted'>        if (address(registry_) == address(0)) {</span>
  29 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
  30 |     | <span class='neutral'>        }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>        registry = registry_;</span>
  33 |     | <span class='unexecuted'>        feeTo = feeTo_;</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    function _onBeforeDeposit(</span>
  37 |     | <span class='neutral'>        IERC20 token,</span>
  38 |     | <span class='neutral'>        address /*from*/,</span>
  39 |     | <span class='neutral'>        address /*to*/,</span>
  40 |     | <span class='neutral'>        uint256 /*amount*/,</span>
  41 |     | <span class='neutral'>        uint256 /*share*/</span>
  42 |     | <span class='neutral'>    ) internal view override {</span>
  43 |     | <span class='unexecuted'>        if (!enabledTokens[address(token)]) {</span>
  44 |     | <span class='unexecuted'>            revert ErrUnsupportedToken();</span>
  45 |     | <span class='neutral'>        }</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  49 |     | <span class='neutral'>    /// OPERATORS</span>
  50 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>    function claimGasYields() external onlyOperators returns (uint256) {</span>
  53 |     | <span class='unexecuted'>        return BlastYields.claimMaxGasYields(feeTo);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>    function claimTokenYields(address token_) external onlyOperators returns (uint256 amount) {</span>
  57 |     | <span class='unexecuted'>        if (!registry.nativeYieldTokens(token_)) {</span>
  58 |     | <span class='unexecuted'>            revert ErrUnsupportedToken();</span>
  59 |     | <span class='neutral'>        }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>        amount = BlastYields.claimAllTokenYields(token_, feeTo);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  65 |     | <span class='neutral'>    /// ADMIN</span>
  66 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>    function callBlastPrecompile(bytes calldata data) external onlyOwner {</span>
  69 |     | <span class='unexecuted'>        BlastYields.callPrecompile(data);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>    function setFeeTo(address feeTo_) external onlyOwner {</span>
  73 |     | <span class='unexecuted'>        if (feeTo_ == address(0)) {</span>
  74 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>        feeTo = feeTo_;</span>
  78 |     | <span class='unexecuted'>        emit LogFeeToChanged(feeTo_);</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>    function setTokenEnabled(address token, bool enabled) external onlyOwner {</span>
  82 |     | <span class='unexecuted'>        enabledTokens[token] = enabled;</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        // enable native yields if token is recognized</span>
  85 |     | <span class='neutral'>        // no matter if it&#39;s enabled or not</span>
  86 |     | <span class='unexecuted'>        if (registry.nativeYieldTokens(token)) {</span>
  87 |     | <span class='unexecuted'>            BlastYields.enableTokenClaimable(token);</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>        emit LogTokenDepositEnabled(token, enabled);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  94 |     | <span class='neutral'>    /// INTERNALS</span>
  95 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /// @dev Called on DegenBox&#39;s constructor</span>
  98 |     | <span class='unexecuted'>    function _configure() internal override {</span>
  99 |     | <span class='unexecuted'>        BlastYields.configureDefaultClaimables(address(this));</span>
 100 |     | <span class='unexecuted'>        BlastPoints.configure();</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>    function isOwner(address _account) internal view override returns (bool) {</span>
 104 |     | <span class='unexecuted'>        return owner == _account;</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'>}</span>
 107 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastCauldronV4.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {BlastYields} from &quot;/blast/libraries/BlastYields.sol&quot;;</span>
  6 |     | <span class='neutral'>import {CauldronV4} from &quot;cauldrons/CauldronV4.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>contract BlastCauldronV4 is CauldronV4 {</span>
 10 |     | <span class='neutral'>    error ErrZeroAddress();</span>
 11 |     | <span class='neutral'>    error ErrInvalidGovernorAddress();</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    address private immutable _governor;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    constructor(address box_, address mim_, address governor_) CauldronV4(IBentoBoxV1(box_), IERC20(mim_)) {</span>
 16 |     | <span class='unexecuted'>        if (governor_ == address(0)) {</span>
 17 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 18 |     | <span class='neutral'>        }</span>
 19 |     | <span class='unexecuted'>        if (governor_ == address(this)) {</span>
 20 |     | <span class='unexecuted'>            revert ErrInvalidGovernorAddress();</span>
 21 |     | <span class='neutral'>        }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>        _governor = governor_;</span>
 24 |     | <span class='unexecuted'>        _setupBlacklist();</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function init(bytes calldata data) public payable override {</span>
 28 |     | <span class='unexecuted'>        if (_governor == address(this)) {</span>
 29 |     | <span class='unexecuted'>            revert ErrInvalidGovernorAddress();</span>
 30 |     | <span class='neutral'>        }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>        _setupBlacklist();</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>        super.init(data);</span>
 35 |     | <span class='unexecuted'>        BlastYields.configureDefaultClaimables(_governor);</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='unexecuted'>    function _setupBlacklist() private {</span>
 39 |     | <span class='unexecuted'>        blacklistedCallees[address(BlastYields.BLAST_YIELD_PRECOMPILE)] = true;</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'>}</span>
 42 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastFeeRateModel.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {BlastYields} from &quot;/blast/libraries/BlastYields.sol&quot;;</span>
  5 |     | <span class='neutral'>import {FeeRateModel} from &quot;/mimswap/auxiliary/FeeRateModel.sol&quot;;</span>
  6 |     | <span class='neutral'>import {FeeRateModelImpl} from &quot;/mimswap/auxiliary/FeeRateModelImpl.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>contract BlastFeeRateModel is FeeRateModel {</span>
  9 |     | <span class='unexecuted'>    constructor(address maintainer_, address owner_, address governor_) FeeRateModel(maintainer_, owner_) {</span>
 10 |     | <span class='unexecuted'>        if (governor_ == address(0)) {</span>
 11 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 12 |     | <span class='neutral'>        }</span>
 13 |     | <span class='unexecuted'>        BlastYields.configureDefaultClaimables(governor_);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>contract BlastFeeRateModelImpl is FeeRateModelImpl {</span>
 18 |     | <span class='neutral'>    error ErrZeroAddress();</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    constructor(address governor_) {</span>
 21 |     | <span class='unexecuted'>        if (governor_ == address(0)) {</span>
 22 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 23 |     | <span class='neutral'>        }</span>
 24 |     | <span class='unexecuted'>        BlastYields.configureDefaultClaimables(governor_);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastGovernor.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {BlastYields} from &quot;/blast/libraries/BlastYields.sol&quot;;</span>
  5 |     | <span class='neutral'>import {OperatableV2} from &quot;mixins/OperatableV2.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract BlastGovernor is OperatableV2 {</span>
  8 |     | <span class='neutral'>    event LogFeeToChanged(address indexed feeTo);</span>
  9 |     | <span class='neutral'>    error ErrZeroAddress();</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    address public feeTo;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    receive() external payable {}</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    constructor(address feeTo_, address _owner) OperatableV2(_owner) {</span>
 16 |     | <span class='unexecuted'>        if (feeTo_ == address(0)) {</span>
 17 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 18 |     | <span class='neutral'>        }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>        feeTo = feeTo_;</span>
 21 |     | <span class='unexecuted'>        BlastYields.configureDefaultClaimables(address(this));</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 25 |     | <span class='neutral'>    /// OPERATORS</span>
 26 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>    function claimNativeYields(address contractAddress) external onlyOperators returns (uint256) {</span>
 29 |     | <span class='unexecuted'>        return BlastYields.claimAllNativeYields(contractAddress, feeTo);</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    function claimMaxGasYields(address contractAddress) external onlyOperators returns (uint256) {</span>
 33 |     | <span class='unexecuted'>        return BlastYields.claimMaxGasYields(contractAddress, feeTo);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 37 |     | <span class='neutral'>    /// ADMIN</span>
 38 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>    function setFeeTo(address _feeTo) external onlyOwner {</span>
 41 |     | <span class='unexecuted'>        if(_feeTo == address(0)) {</span>
 42 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 43 |     | <span class='neutral'>        }</span>
 44 |     | <span class='neutral'>        </span>
 45 |     | <span class='unexecuted'>        feeTo = _feeTo;</span>
 46 |     | <span class='unexecuted'>        emit LogFeeToChanged(_feeTo);</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='unexecuted'>    function callBlastPrecompile(bytes calldata data) external onlyOwner {</span>
 50 |     | <span class='unexecuted'>        BlastYields.callPrecompile(data);</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='unexecuted'>    function execute(address to, uint256 value, bytes calldata data) external onlyOwner returns (bool success, bytes memory result) {</span>
 54 |     | <span class='unexecuted'>        (success, result) = to.call{value: value}(data);</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'>}</span>
 57 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastLockingMultiRewards.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {LockingMultiRewards} from &quot;staking/LockingMultiRewards.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BlastYields} from &quot;/blast/libraries/BlastYields.sol&quot;;</span>
  7 |     | <span class='neutral'>import {BlastPoints} from &quot;/blast/libraries/BlastPoints.sol&quot;;</span>
  8 |     | <span class='neutral'>import {BlastTokenRegistry} from &quot;/blast/BlastTokenRegistry.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>contract BlastLockingMultiRewards is LockingMultiRewards {</span>
 11 |     | <span class='neutral'>    event LogFeeToChanged(address indexed feeTo);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    error ErrNotNativeYieldToken();</span>
 14 |     | <span class='neutral'>    error ErrZeroAddress();</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    BlastTokenRegistry public immutable registry;</span>
 17 |     | <span class='unexecuted'>    address public feeTo;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    constructor(</span>
 20 |     | <span class='neutral'>        BlastTokenRegistry registry_,</span>
 21 |     | <span class='neutral'>        address feeTo_,</span>
 22 |     | <span class='neutral'>        address _stakingToken,</span>
 23 |     | <span class='neutral'>        uint256 _lockingBoostMultiplerInBips,</span>
 24 |     | <span class='neutral'>        uint256 _rewardsDuration,</span>
 25 |     | <span class='neutral'>        uint256 _lockDuration,</span>
 26 |     | <span class='neutral'>        address _owner</span>
 27 |     | <span class='unexecuted'>    ) LockingMultiRewards(_stakingToken, _lockingBoostMultiplerInBips, _rewardsDuration, _lockDuration, _owner) {</span>
 28 |     | <span class='unexecuted'>        if (address(registry_) == address(0)) {</span>
 29 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 30 |     | <span class='neutral'>        }</span>
 31 |     | <span class='unexecuted'>        if (feeTo_ == address(0)) {</span>
 32 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 33 |     | <span class='neutral'>        }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>        registry = registry_;</span>
 36 |     | <span class='unexecuted'>        feeTo = feeTo_;</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='unexecuted'>        BlastYields.configureDefaultClaimables(address(this));</span>
 39 |     | <span class='unexecuted'>        BlastPoints.configure();</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='unexecuted'>        if (registry.nativeYieldTokens(_stakingToken)) {</span>
 42 |     | <span class='unexecuted'>            BlastYields.enableTokenClaimable(_stakingToken);</span>
 43 |     | <span class='neutral'>        }</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 47 |     | <span class='neutral'>    /// OPERATORS</span>
 48 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='unexecuted'>    function claimGasYields() external onlyOperators returns (uint256) {</span>
 51 |     | <span class='unexecuted'>        return BlastYields.claimMaxGasYields(feeTo);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='unexecuted'>    function claimTokenYields(address token) external onlyOperators returns (uint256 amount) {</span>
 55 |     | <span class='unexecuted'>        if (token != stakingToken &amp;&amp; !_rewardData[token].exists) {</span>
 56 |     | <span class='unexecuted'>            revert ErrInvalidTokenAddress();</span>
 57 |     | <span class='neutral'>        }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>        if (!registry.nativeYieldTokens(token)) {</span>
 60 |     | <span class='unexecuted'>            revert ErrNotNativeYieldToken();</span>
 61 |     | <span class='neutral'>        }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='unexecuted'>        return BlastYields.claimAllTokenYields(token, feeTo);</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='unexecuted'>    function updateTokenClaimables(address token) external onlyOperators {</span>
 67 |     | <span class='neutral'>        if (registry.nativeYieldTokens(token)) {</span>
 68 |     | <span class='neutral'>            BlastYields.enableTokenClaimable(token);</span>
 69 |     | <span class='neutral'>        }</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 73 |     | <span class='neutral'>    /// ADMIN</span>
 74 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='unexecuted'>    function addReward(address rewardToken) public override onlyOwner {</span>
 77 |     | <span class='unexecuted'>        _addReward(rewardToken);</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='unexecuted'>        if (registry.nativeYieldTokens(rewardToken)) {</span>
 80 |     | <span class='unexecuted'>            BlastYields.enableTokenClaimable(rewardToken);</span>
 81 |     | <span class='neutral'>        }</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'></span>
 84 |     | <span class='unexecuted'>    function callBlastPrecompile(bytes calldata data) external onlyOwner {</span>
 85 |     | <span class='unexecuted'>        BlastYields.callPrecompile(data);</span>
 86 |     | <span class='neutral'>    }</span>
 87 |     | <span class='neutral'></span>
 88 |     | <span class='unexecuted'>    function setFeeTo(address feeTo_) external onlyOwner {</span>
 89 |     | <span class='unexecuted'>        if (feeTo_ == address(0)) {</span>
 90 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 91 |     | <span class='neutral'>        }</span>
 92 |     | <span class='neutral'></span>
 93 |     | <span class='unexecuted'>        feeTo = feeTo_;</span>
 94 |     | <span class='unexecuted'>        emit LogFeeToChanged(feeTo_);</span>
 95 |     | <span class='neutral'>    }</span>
 96 |     | <span class='neutral'>}</span>
 97 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastLzIndirectOFTV2.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {LzIndirectOFTV2} from &quot;tokens/LzIndirectOFTV2.sol&quot;;</span>
  5 |     | <span class='neutral'>import {BlastYields} from &quot;/blast/libraries/BlastYields.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IMintableBurnable} from &quot;interfaces/IMintableBurnable.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>contract BlastLzIndirectOFTV2 is LzIndirectOFTV2 {</span>
  9 |     | <span class='neutral'>    error ErrZeroAddress();</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    constructor(</span>
 12 |     | <span class='neutral'>        address _token,</span>
 13 |     | <span class='neutral'>        IMintableBurnable _minterBurner,</span>
 14 |     | <span class='neutral'>        uint8 _sharedDecimals,</span>
 15 |     | <span class='neutral'>        address _lzEndpoint,</span>
 16 |     | <span class='neutral'>        address _owner,</span>
 17 |     | <span class='neutral'>        address governor_</span>
 18 |     | <span class='unexecuted'>    ) LzIndirectOFTV2(_token, _minterBurner, _sharedDecimals, _lzEndpoint, _owner) {</span>
 19 |     | <span class='unexecuted'>        if (governor_ == address(0)) {</span>
 20 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 21 |     | <span class='neutral'>        }</span>
 22 |     | <span class='neutral'>        </span>
 23 |     | <span class='unexecuted'>        BlastYields.configureDefaultClaimables(governor_);</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastLzOFTV2FeeHandler.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {LzOFTV2FeeHandler} from &quot;periphery/LzOFTV2FeeHandler.sol&quot;;</span>
  5 |     | <span class='neutral'>import {BlastYields} from &quot;/blast/libraries/BlastYields.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/// @dev This contract holds ETH from fees and accumulates</span>
  8 |     | <span class='neutral'>/// ETH yields to claim.</span>
  9 |     | <span class='unexecuted'>contract BlastLzOFTV2FeeHandler is LzOFTV2FeeHandler {</span>
 10 |     | <span class='neutral'>    error ErrZeroAddress();</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    constructor(</span>
 13 |     | <span class='neutral'>        address _owner,</span>
 14 |     | <span class='neutral'>        uint256 _fixedNativeFee,</span>
 15 |     | <span class='neutral'>        address _oft,</span>
 16 |     | <span class='neutral'>        address _aggregator,</span>
 17 |     | <span class='neutral'>        address _feeTo,</span>
 18 |     | <span class='neutral'>        uint8 _quoteType,</span>
 19 |     | <span class='neutral'>        address governor_</span>
 20 |     | <span class='unexecuted'>    ) LzOFTV2FeeHandler(_owner, _fixedNativeFee, _oft, _aggregator, _feeTo, _quoteType) {</span>
 21 |     | <span class='unexecuted'>        if (governor_ == address(0)) {</span>
 22 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 23 |     | <span class='neutral'>        }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>        BlastYields.configureDefaultClaimables(governor_);</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastMIMSwapFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {BlastYields} from &quot;/blast/libraries/BlastYields.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Factory} from &quot;/mimswap/periphery/Factory.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IFeeRateModel} from &quot;/mimswap/interfaces/IFeeRateModel.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>contract BlastMIMSwapFactory is Factory {</span>
  9 |     | <span class='unexecuted'>    constructor(</span>
 10 |     | <span class='neutral'>        address implementation_,</span>
 11 |     | <span class='neutral'>        IFeeRateModel maintainerFeeRateModel_,</span>
 12 |     | <span class='neutral'>        address owner_,</span>
 13 |     | <span class='neutral'>        address governor_</span>
 14 |     | <span class='unexecuted'>    ) Factory(implementation_, maintainerFeeRateModel_, owner_) {</span>
 15 |     | <span class='unexecuted'>        if (governor_ == address(0)) {</span>
 16 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 17 |     | <span class='neutral'>        }</span>
 18 |     | <span class='unexecuted'>        BlastYields.configureDefaultClaimables(governor_);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastMIMSwapRouter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {BlastYields} from &quot;/blast/libraries/BlastYields.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Router} from &quot;/mimswap/periphery/Router.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IWETH} from &quot;interfaces/IWETH.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IFactory} from &quot;/mimswap/interfaces/IFactory.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>contract BlastMIMSwapRouter is Router {</span>
 10 |     | <span class='unexecuted'>    constructor(IWETH weth_, IFactory factory, address governor_) Router(weth_, factory) {</span>
 11 |     | <span class='unexecuted'>        if (governor_ == address(0)) {</span>
 12 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 13 |     | <span class='neutral'>        }</span>
 14 |     | <span class='unexecuted'>        BlastYields.configureDefaultClaimables(governor_);</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastMagicLP.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {MagicLP} from &quot;/mimswap/MagicLP.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BlastYields} from &quot;/blast/libraries/BlastYields.sol&quot;;</span>
   7 |     | <span class='neutral'>import {BlastPoints} from &quot;/blast/libraries/BlastPoints.sol&quot;;</span>
   8 |     | <span class='neutral'>import {BlastTokenRegistry} from &quot;/blast/BlastTokenRegistry.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>contract BlastMagicLP is MagicLP {</span>
  11 |     | <span class='neutral'>    event LogFeeToChanged(address indexed feeTo);</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>    BlastTokenRegistry public immutable registry;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    /// @dev Implementation storage</span>
  16 |     | <span class='unexecuted'>    address public feeTo;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    constructor(BlastTokenRegistry registry_, address feeTo_, address owner_) MagicLP(owner_) {</span>
  19 |     | <span class='unexecuted'>        if (feeTo_ == address(0)) {</span>
  20 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
  21 |     | <span class='neutral'>        }</span>
  22 |     | <span class='unexecuted'>        if (address(registry_) == address(0)) {</span>
  23 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
  24 |     | <span class='neutral'>        }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>        registry = registry_;</span>
  27 |     | <span class='unexecuted'>        feeTo = feeTo_;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  31 |     | <span class='neutral'>    /// VIEWS</span>
  32 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    function version() external pure override returns (string memory) {</span>
  35 |     | <span class='unexecuted'>        return &quot;BlastMagicLP 1.0.0&quot;;</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  39 |     | <span class='neutral'>    /// OPERATORS / CLONES ONLY - PROTOCOL LEVEL YIELDS ON ALL POOLS</span>
  40 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>    function claimGasYields() external onlyClones onlyImplementationOperators returns (uint256) {</span>
  43 |     | <span class='unexecuted'>        address feeTo_ = BlastMagicLP(address(implementation)).feeTo();</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>        return BlastYields.claimMaxGasYields(feeTo_);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>    function claimTokenYields() external onlyClones onlyImplementationOperators returns (uint256 token0Amount, uint256 token1Amount) {</span>
  49 |     | <span class='unexecuted'>        address feeTo_ = BlastMagicLP(address(implementation)).feeTo();</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>        if (registry.nativeYieldTokens(_BASE_TOKEN_)) {</span>
  52 |     | <span class='unexecuted'>            token0Amount = BlastYields.claimAllTokenYields(_BASE_TOKEN_, feeTo_);</span>
  53 |     | <span class='neutral'>        }</span>
  54 |     | <span class='unexecuted'>        if (registry.nativeYieldTokens(_QUOTE_TOKEN_)) {</span>
  55 |     | <span class='unexecuted'>            token1Amount = BlastYields.claimAllTokenYields(_QUOTE_TOKEN_, feeTo_);</span>
  56 |     | <span class='neutral'>        }</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>    function updateTokenClaimables() external onlyClones onlyImplementationOperators {</span>
  60 |     | <span class='unexecuted'>        _updateTokenClaimables();</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  64 |     | <span class='neutral'>    /// ADMIN / CLONES ONLY</span>
  65 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>    function callBlastPrecompile(bytes calldata data) external onlyClones onlyImplementationOwner {</span>
  68 |     | <span class='unexecuted'>        BlastYields.callPrecompile(data);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  72 |     | <span class='neutral'>    /// ADMIN / IMPLEMENTATION ONLY</span>
  73 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>    function setFeeTo(address feeTo_) external onlyImplementation onlyImplementationOwner {</span>
  76 |     | <span class='unexecuted'>        if (feeTo_ == address(0)) {</span>
  77 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>        feeTo = feeTo_;</span>
  81 |     | <span class='unexecuted'>        emit LogFeeToChanged(feeTo_);</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  85 |     | <span class='neutral'>    /// INTERNALS</span>
  86 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>    function _afterInitialized() internal override {</span>
  89 |     | <span class='unexecuted'>        BlastYields.configureDefaultClaimables(address(this));</span>
  90 |     | <span class='unexecuted'>        BlastPoints.configure();</span>
  91 |     | <span class='neutral'>        _updateTokenClaimables();</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>    function _updateTokenClaimables() internal {</span>
  95 |     | <span class='unexecuted'>        if (registry.nativeYieldTokens(_BASE_TOKEN_)) {</span>
  96 |     | <span class='unexecuted'>            BlastYields.enableTokenClaimable(_BASE_TOKEN_);</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>        if (registry.nativeYieldTokens(_QUOTE_TOKEN_)) {</span>
 100 |     | <span class='unexecuted'>            BlastYields.enableTokenClaimable(_QUOTE_TOKEN_);</span>
 101 |     | <span class='neutral'>        }</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'>}</span>
 104 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastMintableBurnableERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {MintableBurnableERC20} from &quot;tokens/MintableBurnableERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {BlastYields} from &quot;/blast/libraries/BlastYields.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract BlastMintableBurnableERC20 is MintableBurnableERC20 {</span>
  8 |     | <span class='neutral'>    error ErrZeroAddress();</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    constructor(</span>
 11 |     | <span class='neutral'>        address _owner,</span>
 12 |     | <span class='neutral'>        string memory name_,</span>
 13 |     | <span class='neutral'>        string memory symbol_,</span>
 14 |     | <span class='neutral'>        uint8 decimals_,</span>
 15 |     | <span class='neutral'>        address governor_</span>
 16 |     | <span class='unexecuted'>    ) MintableBurnableERC20(_owner, name_, symbol_, decimals_) {</span>
 17 |     | <span class='unexecuted'>        if (governor_ == address(0)) {</span>
 18 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 19 |     | <span class='neutral'>        }</span>
 20 |     | <span class='unexecuted'>        BlastYields.configureDefaultClaimables(governor_);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastOnboarding.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Owned} from &quot;solmate/auth/Owned.sol&quot;;</span>
   5 |     | <span class='neutral'>import {BlastYields} from &quot;/blast/libraries/BlastYields.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BlastTokenRegistry} from &quot;/blast/BlastTokenRegistry.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Proxy} from &quot;openzeppelin-contracts/proxy/Proxy.sol&quot;;</span>
   8 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solady/utils/SafeTransferLib.sol&quot;;</span>
   9 |     | <span class='neutral'>import {BlastPoints} from &quot;/blast/libraries/BlastPoints.sol&quot;;</span>
  10 |     | <span class='neutral'>import {Pausable} from &quot;openzeppelin-contracts/security/Pausable.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>contract BlastOnboardingData is Owned, Pausable {</span>
  13 |     | <span class='neutral'>    error ErrZeroAddress();</span>
  14 |     | <span class='neutral'>    error ErrWrongState();</span>
  15 |     | <span class='neutral'>    error ErrUnsupportedToken();</span>
  16 |     | <span class='neutral'>    error ErrNotAllowed();</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    enum State {</span>
  19 |     | <span class='neutral'>        Idle,</span>
  20 |     | <span class='neutral'>        Opened,</span>
  21 |     | <span class='neutral'>        Closed</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    struct Balances {</span>
  25 |     | <span class='neutral'>        uint256 unlocked;</span>
  26 |     | <span class='neutral'>        uint256 locked;</span>
  27 |     | <span class='neutral'>        uint256 total;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>    State public state;</span>
  31 |     | <span class='unexecuted'>    address public bootstrapper;</span>
  32 |     | <span class='unexecuted'>    address public feeTo;</span>
  33 |     | <span class='unexecuted'>    BlastTokenRegistry public registry;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    // Global</span>
  36 |     | <span class='unexecuted'>    mapping(address token =&gt; bool) public supportedTokens;</span>
  37 |     | <span class='unexecuted'>    mapping(address token =&gt; Balances) public totals;</span>
  38 |     | <span class='unexecuted'>    mapping(address token =&gt; uint256 cap) public caps;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    // Per-user</span>
  41 |     | <span class='unexecuted'>    mapping(address user =&gt; mapping(address token =&gt; Balances)) public balances;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    modifier onlyState(State _state) {</span>
  44 |     | <span class='unexecuted'>        if (state != _state) {</span>
  45 |     | <span class='unexecuted'>            revert ErrWrongState();</span>
  46 |     | <span class='neutral'>        }</span>
  47 |     | <span class='unexecuted'>        _;</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    modifier onlySupportedTokens(address token) {</span>
  51 |     | <span class='unexecuted'>        if (!supportedTokens[token]) {</span>
  52 |     | <span class='unexecuted'>            revert ErrUnsupportedToken();</span>
  53 |     | <span class='neutral'>        }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>        _;</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>    constructor() Owned(msg.sender) {</span>
  59 |     | <span class='unexecuted'>        BlastYields.configureDefaultClaimables(address(this));</span>
  60 |     | <span class='unexecuted'>        BlastPoints.configure();</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'>}</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>contract BlastOnboarding is BlastOnboardingData, Proxy {</span>
  65 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    event LogBootstrapperChanged(address indexed bootstrapper);</span>
  68 |     | <span class='neutral'>    event LogTokenSupported(address indexed token, bool supported);</span>
  69 |     | <span class='neutral'>    event LogDeposit(address indexed user, address indexed token, uint256 amount, bool lock);</span>
  70 |     | <span class='neutral'>    event LogLock(address indexed user, address indexed token, uint256 amount);</span>
  71 |     | <span class='neutral'>    event LogFeeToChanged(address indexed feeTo);</span>
  72 |     | <span class='neutral'>    event LogWithdraw(address indexed user, address indexed token, uint256 amount);</span>
  73 |     | <span class='neutral'>    event LogTokenCapChanged(address indexed token, uint256 cap);</span>
  74 |     | <span class='neutral'>    event LogStateChange(State state);</span>
  75 |     | <span class='neutral'>    event LogTokenRescue(address indexed token, address indexed to, uint256 amount);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    error ErrUnsupported();</span>
  78 |     | <span class='neutral'>    error ErrCapReached();</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    receive() external payable override {</span>
  81 |     | <span class='unexecuted'>        revert ErrUnsupported();</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>    constructor(BlastTokenRegistry registry_, address feeTo_) {</span>
  85 |     | <span class='unexecuted'>        if (address(registry_) == address(0)) {</span>
  86 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
  87 |     | <span class='neutral'>        }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>        if (feeTo_ == address(0)) {</span>
  90 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
  91 |     | <span class='neutral'>        }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>        registry = registry_;</span>
  94 |     | <span class='unexecuted'>        feeTo = feeTo_;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  98 |     | <span class='neutral'>    /// PUBLIC</span>
  99 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>    function deposit(address token, uint256 amount, bool lock_) external whenNotPaused onlyState(State.Opened) onlySupportedTokens(token) {</span>
 102 |     | <span class='unexecuted'>        token.safeTransferFrom(msg.sender, address(this), amount);</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>        if (lock_) {</span>
 105 |     | <span class='unexecuted'>            totals[token].locked += amount;</span>
 106 |     | <span class='unexecuted'>            balances[msg.sender][token].locked += amount;</span>
 107 |     | <span class='neutral'>        } else {</span>
 108 |     | <span class='unexecuted'>            totals[token].unlocked += amount;</span>
 109 |     | <span class='unexecuted'>            balances[msg.sender][token].unlocked += amount;</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>        totals[token].total += amount;</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>        if (caps[token] &gt; 0 &amp;&amp; totals[token].total &gt; caps[token]) {</span>
 115 |     | <span class='unexecuted'>            revert ErrCapReached();</span>
 116 |     | <span class='neutral'>        }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>        balances[msg.sender][token].total += amount;</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>        emit LogDeposit(msg.sender, token, amount, lock_);</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>    function lock(address token, uint256 amount) external whenNotPaused onlyState(State.Opened) onlySupportedTokens(token) {</span>
 124 |     | <span class='unexecuted'>        balances[msg.sender][token].unlocked -= amount;</span>
 125 |     | <span class='unexecuted'>        balances[msg.sender][token].locked += amount;</span>
 126 |     | <span class='unexecuted'>        totals[token].unlocked -= amount;</span>
 127 |     | <span class='unexecuted'>        totals[token].locked += amount;</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>        emit LogLock(msg.sender, token, amount);</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='unexecuted'>    function withdraw(address token, uint256 amount) external whenNotPaused onlySupportedTokens(token) {</span>
 133 |     | <span class='unexecuted'>        balances[msg.sender][token].unlocked -= amount;</span>
 134 |     | <span class='unexecuted'>        balances[msg.sender][token].total -= amount;</span>
 135 |     | <span class='unexecuted'>        totals[token].unlocked -= amount;</span>
 136 |     | <span class='unexecuted'>        totals[token].total -= amount;</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>        token.safeTransfer(msg.sender, amount);</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>        emit LogWithdraw(msg.sender, token, amount);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 144 |     | <span class='neutral'>    /// ADMIN</span>
 145 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='unexecuted'>    function setFeeTo(address feeTo_) external onlyOwner {</span>
 148 |     | <span class='unexecuted'>        if (feeTo_ == address(0)) {</span>
 149 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 150 |     | <span class='neutral'>        }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='unexecuted'>        feeTo = feeTo_;</span>
 153 |     | <span class='unexecuted'>        emit LogFeeToChanged(feeTo_);</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>    function callBlastPrecompile(bytes calldata data) external onlyOwner {</span>
 157 |     | <span class='unexecuted'>        BlastYields.callPrecompile(data);</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>    function claimGasYields() external onlyOwner returns (uint256) {</span>
 161 |     | <span class='unexecuted'>        return BlastYields.claimMaxGasYields(feeTo);</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='unexecuted'>    function claimTokenYields(address[] memory tokens) external onlyOwner {</span>
 165 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; tokens.length; i++) {</span>
 166 |     | <span class='unexecuted'>            if (!supportedTokens[tokens[i]]) {</span>
 167 |     | <span class='unexecuted'>                revert ErrUnsupportedToken();</span>
 168 |     | <span class='neutral'>            }</span>
 169 |     | <span class='unexecuted'>            if (registry.nativeYieldTokens(tokens[i])) {</span>
 170 |     | <span class='unexecuted'>                BlastYields.claimAllTokenYields(tokens[i], feeTo);</span>
 171 |     | <span class='neutral'>            }</span>
 172 |     | <span class='neutral'>        }</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='unexecuted'>    function setTokenSupported(address token, bool supported) external onlyOwner {</span>
 176 |     | <span class='unexecuted'>        supportedTokens[token] = supported;</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>        if (registry.nativeYieldTokens(token)) {</span>
 179 |     | <span class='unexecuted'>            BlastYields.enableTokenClaimable(token);</span>
 180 |     | <span class='neutral'>        }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='unexecuted'>        emit LogTokenSupported(token, supported);</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='unexecuted'>    function setCap(address token, uint256 cap) external onlyOwner onlySupportedTokens(token) {</span>
 186 |     | <span class='unexecuted'>        caps[token] = cap;</span>
 187 |     | <span class='unexecuted'>        emit LogTokenCapChanged(token, cap);</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='unexecuted'>    function setBootstrapper(address bootstrapper_) external onlyOwner {</span>
 191 |     | <span class='unexecuted'>        bootstrapper = bootstrapper_;</span>
 192 |     | <span class='unexecuted'>        emit LogBootstrapperChanged(bootstrapper_);</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>    function open() external onlyOwner onlyState(State.Idle) {</span>
 196 |     | <span class='unexecuted'>        state = State.Opened;</span>
 197 |     | <span class='unexecuted'>        emit LogStateChange(State.Opened);</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='unexecuted'>    function close() external onlyOwner onlyState(State.Opened) {</span>
 201 |     | <span class='unexecuted'>        state = State.Closed;</span>
 202 |     | <span class='unexecuted'>        emit LogStateChange(State.Closed);</span>
 203 |     | <span class='neutral'>    }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='unexecuted'>    function rescue(address token, address to, uint256 amount) external onlyOwner {</span>
 206 |     | <span class='unexecuted'>        if (supportedTokens[token]) {</span>
 207 |     | <span class='unexecuted'>            revert ErrNotAllowed();</span>
 208 |     | <span class='neutral'>        }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='unexecuted'>        token.safeTransfer(to, amount);</span>
 211 |     | <span class='unexecuted'>        emit LogTokenRescue(token, to, amount);</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='unexecuted'>    function pause() external onlyOwner {</span>
 215 |     | <span class='unexecuted'>        _pause();</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='unexecuted'>    function unpause() external onlyOwner {</span>
 219 |     | <span class='unexecuted'>        _unpause();</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 223 |     | <span class='neutral'>    /// PROXY IMPLEMENTATION</span>
 224 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='unexecuted'>    function _implementation() internal view override returns (address) {</span>
 227 |     | <span class='unexecuted'>        return address(bootstrapper);</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'>}</span>
 230 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastOnboardingBoot.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {BlastOnboarding} from &quot;/blast/BlastOnboarding.sol&quot;;</span>
   5 |     | <span class='neutral'>import {BlastOnboardingData} from &quot;/blast/BlastOnboarding.sol&quot;;</span>
   6 |     | <span class='neutral'>import {Router} from &quot;/mimswap/periphery/Router.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IFeeRateModel} from &quot;/mimswap/interfaces/IFeeRateModel.sol&quot;;</span>
   8 |     | <span class='neutral'>import {IFactory} from &quot;/mimswap/interfaces/IFactory.sol&quot;;</span>
   9 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solady/utils/SafeTransferLib.sol&quot;;</span>
  10 |     | <span class='neutral'>import {DecimalMath} from &quot;/mimswap/libraries/DecimalMath.sol&quot;;</span>
  11 |     | <span class='neutral'>import {BlastLockingMultiRewards} from &quot;/blast/BlastLockingMultiRewards.sol&quot;;</span>
  12 |     | <span class='neutral'>import {IMagicLP} from &quot;/mimswap/interfaces/IMagicLP.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>address constant USDB = 0x4300000000000000000000000000000000000003;</span>
  15 |     | <span class='unexecuted'>address constant MIM = 0x76DA31D7C9CbEAE102aff34D3398bC450c8374c1;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>// Add a new data contract each bootstrap upgrade that involves</span>
  18 |     | <span class='neutral'>// adding new storage variables.</span>
  19 |     | <span class='unexecuted'>contract BlastOnboardingBootDataV1 is BlastOnboardingData {</span>
  20 |     | <span class='unexecuted'>    address public pool;</span>
  21 |     | <span class='unexecuted'>    Router public router;</span>
  22 |     | <span class='unexecuted'>    IFactory public factory;</span>
  23 |     | <span class='unexecuted'>    uint256 public totalPoolShares;</span>
  24 |     | <span class='unexecuted'>    bool public ready;</span>
  25 |     | <span class='unexecuted'>    BlastLockingMultiRewards public staking;</span>
  26 |     | <span class='unexecuted'>    mapping(address user =&gt; bool claimed) public claimed;</span>
  27 |     | <span class='unexecuted'>    mapping(address token =&gt; uint256 amount) public ownerDeposits;</span>
  28 |     | <span class='neutral'>}</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>/// @dev Functions are postfixed with the version number to avoid collisions</span>
  31 |     | <span class='unexecuted'>contract BlastOnboardingBoot is BlastOnboardingBootDataV1 {</span>
  32 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    event LogReadyChanged(bool ready);</span>
  35 |     | <span class='neutral'>    event LogClaimed(address indexed user, uint256 shares, bool lock);</span>
  36 |     | <span class='neutral'>    event LogInitialized(Router indexed router);</span>
  37 |     | <span class='neutral'>    event LogLiquidityBootstrapped(address indexed pool, address indexed staking, uint256 amountOut);</span>
  38 |     | <span class='neutral'>    event LogStakingChanged(address indexed staking);</span>
  39 |     | <span class='neutral'>    event LogOwnerDeposit(address indexed token, uint256 amount);</span>
  40 |     | <span class='neutral'>    event LogOwnerWithdraw(address indexed token, uint256 amount);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    error ErrInsufficientAmountOut();</span>
  43 |     | <span class='neutral'>    error ErrNotReady();</span>
  44 |     | <span class='neutral'>    error ErrAlreadyClaimed();</span>
  45 |     | <span class='neutral'>    error ErrWrongFeeRateModel();</span>
  46 |     | <span class='neutral'>    error ErrAlreadyBootstrapped();</span>
  47 |     | <span class='neutral'>    error ErrNothingToClaim();</span>
  48 |     | <span class='neutral'>    error ErrCannotChangeOnceReady();</span>
  49 |     | <span class='neutral'>    error ErrNotInitialized();</span>
  50 |     | <span class='neutral'>    </span>
  51 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  52 |     | <span class='neutral'>    /// PUBLIC</span>
  53 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>    function claim(bool lock) external returns (uint256 shares) {</span>
  56 |     | <span class='unexecuted'>        if (!ready) {</span>
  57 |     | <span class='unexecuted'>            revert ErrNotReady();</span>
  58 |     | <span class='neutral'>        }</span>
  59 |     | <span class='unexecuted'>        if (claimed[msg.sender]) {</span>
  60 |     | <span class='unexecuted'>            revert ErrAlreadyClaimed();</span>
  61 |     | <span class='neutral'>        }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>        shares = _claimable(msg.sender);</span>
  64 |     | <span class='unexecuted'>        if (shares == 0) {</span>
  65 |     | <span class='unexecuted'>            revert ErrNothingToClaim();</span>
  66 |     | <span class='neutral'>        }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>        claimed[msg.sender] = true;</span>
  69 |     | <span class='unexecuted'>        staking.stakeFor(msg.sender, shares, lock);</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>        emit LogClaimed(msg.sender, shares, lock);</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  75 |     | <span class='neutral'>    /// VIEWS</span>
  76 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>    function claimable(address user) external view returns (uint256 shares) {</span>
  79 |     | <span class='unexecuted'>        if (!ready || claimed[user]) {</span>
  80 |     | <span class='unexecuted'>            return 0;</span>
  81 |     | <span class='neutral'>        }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        return _claimable(user);</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>    function previewTotalPoolShares(uint256 i) external view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {</span>
  87 |     | <span class='unexecuted'>        uint256 baseAmount = totals[MIM].locked;</span>
  88 |     | <span class='unexecuted'>        uint256 quoteAmount = totals[USDB].locked;</span>
  89 |     | <span class='unexecuted'>        return router.previewCreatePool(i, baseAmount, quoteAmount);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  93 |     | <span class='neutral'>    /// ADMIN</span>
  94 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    /// @notice Allows the owner to deposit an arbitrary amount of tokens to balance out the pool</span>
  97 |     | <span class='unexecuted'>    function ownerDeposit(address token, uint256 amount) external onlyOwner onlyState(State.Closed) onlySupportedTokens(token) {</span>
  98 |     | <span class='unexecuted'>        token.safeTransferFrom(msg.sender, address(this), amount);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>        balances[msg.sender][token].locked += amount;</span>
 101 |     | <span class='unexecuted'>        balances[msg.sender][token].total += amount;</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>        totals[token].locked += amount;</span>
 104 |     | <span class='unexecuted'>        totals[token].total += amount;</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>        emit LogOwnerDeposit(token, amount);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>    function ownerWithdraw(address token, uint256 amount) external onlyOwner onlyState(State.Closed) onlySupportedTokens(token) {</span>
 110 |     | <span class='unexecuted'>        balances[msg.sender][token].locked -= amount;</span>
 111 |     | <span class='unexecuted'>        balances[msg.sender][token].total -= amount;</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>        totals[token].locked -= amount;</span>
 114 |     | <span class='unexecuted'>        totals[token].total -= amount;</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>        token.safeTransfer(msg.sender, amount);</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>        emit LogOwnerWithdraw(token, amount);</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    /// @notice Example parameters:</span>
 122 |     | <span class='neutral'>    /// feeRate = 0.0005 ether; // 0.05%</span>
 123 |     | <span class='neutral'>    /// i = 0.998 ether; // 1 MIM = 0.998 USDB</span>
 124 |     | <span class='neutral'>    /// k = 0.00025 ether; // 0.00025, 1.25% price fluctuation, similar to A2000 in curve</span>
 125 |     | <span class='unexecuted'>    function bootstrap(uint256 minAmountOut, uint256 feeRate, uint256 i, uint256 k) external onlyOwner onlyState(State.Closed) returns (address, address, uint256) {</span>
 126 |     | <span class='unexecuted'>        if(address(router) == address(0)) {</span>
 127 |     | <span class='unexecuted'>            revert ErrNotInitialized();</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='unexecuted'>        if (pool != address(0)) {</span>
 130 |     | <span class='unexecuted'>            revert ErrAlreadyBootstrapped();</span>
 131 |     | <span class='neutral'>        }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>        uint256 baseAmount = totals[MIM].locked;</span>
 134 |     | <span class='unexecuted'>        uint256 quoteAmount = totals[USDB].locked;</span>
 135 |     | <span class='unexecuted'>        MIM.safeApprove(address(router), type(uint256).max);</span>
 136 |     | <span class='unexecuted'>        USDB.safeApprove(address(router), type(uint256).max);</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>        (pool, totalPoolShares) = router.createPool(MIM, USDB, feeRate, i, k, address(this), baseAmount, quoteAmount, true);</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>        if (totalPoolShares &lt; minAmountOut) {</span>
 141 |     | <span class='unexecuted'>            revert ErrInsufficientAmountOut();</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>        // Create staking contract</span>
 145 |     | <span class='neutral'>        // 3x boosting for locker, 7 days reward duration, 13 weeks lp locking</span>
 146 |     | <span class='neutral'>        // make this contract temporary the owner the set it as an operator</span>
 147 |     | <span class='neutral'>        // for permissionned `stakeFor` during the claiming process and then</span>
 148 |     | <span class='neutral'>        // transfer the ownership to the onboarding owner.</span>
 149 |     | <span class='unexecuted'>        staking = new BlastLockingMultiRewards(registry, feeTo, pool, 30_000, 7 days, 13 weeks, address(this));</span>
 150 |     | <span class='unexecuted'>        staking.setOperator(address(this), true);</span>
 151 |     | <span class='unexecuted'>        staking.transferOwnership(owner);</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>        // Approve staking contract</span>
 154 |     | <span class='unexecuted'>        pool.safeApprove(address(staking), totalPoolShares);</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>        emit LogLiquidityBootstrapped(pool, address(staking), totalPoolShares);</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>        // Claim owner share</span>
 159 |     | <span class='unexecuted'>        uint256 shares = _claimable(msg.sender);</span>
 160 |     | <span class='unexecuted'>        if (shares &gt; 0) {</span>
 161 |     | <span class='unexecuted'>            claimed[msg.sender] = true;</span>
 162 |     | <span class='unexecuted'>            pool.safeTransfer(msg.sender, shares);</span>
 163 |     | <span class='neutral'>        }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='unexecuted'>        IMagicLP(pool).setPaused(true);</span>
 166 |     | <span class='neutral'>        </span>
 167 |     | <span class='unexecuted'>        return (pool, address(staking), totalPoolShares);</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>    function initialize(Router _router) external onlyOwner {</span>
 171 |     | <span class='unexecuted'>        router = Router(payable(_router));</span>
 172 |     | <span class='unexecuted'>        factory = IFactory(router.factory());</span>
 173 |     | <span class='unexecuted'>        emit LogInitialized(_router);</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='unexecuted'>    function setReady(bool _ready) external onlyOwner onlyState(State.Closed) {</span>
 177 |     | <span class='unexecuted'>        ready = _ready;</span>
 178 |     | <span class='unexecuted'>        emit LogReadyChanged(ready);</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 182 |     | <span class='neutral'>    /// INTERNALS</span>
 183 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='unexecuted'>    function _claimable(address user) internal view returns (uint256 shares) {</span>
 186 |     | <span class='unexecuted'>        uint256 totalLocked = totals[MIM].locked + totals[USDB].locked;</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='unexecuted'>        if (totalLocked == 0) {</span>
 189 |     | <span class='unexecuted'>            return 0;</span>
 190 |     | <span class='neutral'>        }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='unexecuted'>        uint256 userLocked = balances[user][MIM].locked + balances[user][USDB].locked;</span>
 193 |     | <span class='unexecuted'>        return (userLocked * totalPoolShares) / totalLocked;</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'>}</span>
 196 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastTokenRegistry.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Owned} from &quot;solmate/auth/Owned.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract BlastTokenRegistry is Owned {</span>
  7 |     | <span class='neutral'>    event LogNativeYieldTokenEnabled(address indexed token, bool enabled);</span>
  8 |     | <span class='neutral'>    error ErrZeroAddress();</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public nativeYieldTokens;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    constructor(address _owner) Owned(_owner) {}</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    function setNativeYieldTokenEnabled(address token, bool enabled) external onlyOwner {</span>
 15 |     | <span class='unexecuted'>        if (token == address(0)) {</span>
 16 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 17 |     | <span class='neutral'>        }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>        nativeYieldTokens[token] = enabled;</span>
 20 |     | <span class='unexecuted'>        emit LogNativeYieldTokenEnabled(token, enabled);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/interfaces/IBlastBox.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IBlastBox {</span>
  5 |     | <span class='neutral'>    function feeTo() external view returns (address);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function registry() external view returns (address);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function setTokenEnabled(address token, bool enabled) external;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function claimGasYields() external returns (uint256);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function claimTokenYields(address token_) external returns (uint256 amount);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function setFeeTo(address feeTo_) external;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function enabledTokens(address) external view returns (bool);</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/libraries/BlastPoints.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IBlastPoints} from &quot;interfaces/IBlast.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>library BlastPoints {</span>
  7 |     | <span class='unexecuted'>    address public constant BLAST_POINTS_OPERATOR = 0xD1025F1359422Ca16D9084908d629E0dBa60ff28;</span>
  8 |     | <span class='unexecuted'>    IBlastPoints public constant BLAST_POINTS = IBlastPoints(0x2536FE9ab3F511540F2f9e2eC2A805005C3Dd800);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    function configure() internal {</span>
 11 |     | <span class='unexecuted'>        BLAST_POINTS.configurePointsOperator(BLAST_POINTS_OPERATOR);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/libraries/BlastYields.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IBlast, IERC20Rebasing, YieldMode, GasMode} from &quot;interfaces/IBlast.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Address} from &quot;openzeppelin-contracts/utils/Address.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library BlastYields {</span>
  8 |     | <span class='neutral'>    event LogBlastGasClaimed(address indexed recipient, uint256 amount);</span>
  9 |     | <span class='neutral'>    event LogBlastETHClaimed(address indexed recipient, uint256 amount);</span>
 10 |     | <span class='neutral'>    event LogBlastTokenClaimed(address indexed recipient, address indexed token, uint256 amount);</span>
 11 |     | <span class='neutral'>    event LogBlastTokenClaimableEnabled(address indexed contractAddress, address indexed token);</span>
 12 |     | <span class='neutral'>    event LogBlastNativeClaimableEnabled(address indexed contractAddress);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    IBlast constant BLAST_YIELD_PRECOMPILE = IBlast(0x4300000000000000000000000000000000000002);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 17 |     | <span class='neutral'>    // CONFIGURATION</span>
 18 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function enableTokenClaimable(address token) internal {</span>
 21 |     | <span class='unexecuted'>        if (IERC20Rebasing(token).getConfiguration(address(this)) == YieldMode.CLAIMABLE) {</span>
 22 |     | <span class='neutral'>            return;</span>
 23 |     | <span class='neutral'>        }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>        IERC20Rebasing(token).configure(YieldMode.CLAIMABLE);</span>
 26 |     | <span class='unexecuted'>        emit LogBlastTokenClaimableEnabled(address(this), token);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>    function configureDefaultClaimables(address governor_) internal {</span>
 30 |     | <span class='unexecuted'>        BLAST_YIELD_PRECOMPILE.configure(YieldMode.CLAIMABLE, GasMode.CLAIMABLE, governor_);</span>
 31 |     | <span class='unexecuted'>        emit LogBlastNativeClaimableEnabled(address(this));</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 35 |     | <span class='neutral'>    // GAS CLAIMING</span>
 36 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 37 |     | <span class='neutral'>    </span>
 38 |     | <span class='unexecuted'>    function claimMaxGasYields(address recipient) internal returns (uint256) {</span>
 39 |     | <span class='unexecuted'>        return claimMaxGasYields(address(this), recipient);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='unexecuted'>    function claimMaxGasYields(address contractAddress, address recipient) internal returns (uint256 amount) {</span>
 43 |     | <span class='unexecuted'>        amount = BLAST_YIELD_PRECOMPILE.claimMaxGas(contractAddress, recipient);</span>
 44 |     | <span class='unexecuted'>        emit LogBlastGasClaimed(recipient, amount);</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 48 |     | <span class='neutral'>    // NATIVE CLAIMING</span>
 49 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////&lt;</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    function claimAllNativeYields(address recipient) internal returns (uint256 amount) {</span>
 52 |     | <span class='neutral'>        return claimAllNativeYields(address(this), recipient);</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>    function claimAllNativeYields(address contractAddress, address recipient) internal returns (uint256 amount) {</span>
 56 |     | <span class='unexecuted'>        amount = BLAST_YIELD_PRECOMPILE.claimAllYield(contractAddress, recipient);</span>
 57 |     | <span class='unexecuted'>        emit LogBlastETHClaimed(recipient, amount);</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>    function claimNativeYields(address contractAddress, uint256 amount, address recipient) internal returns (uint256) {</span>
 61 |     | <span class='neutral'>        amount = BLAST_YIELD_PRECOMPILE.claimYield(contractAddress, recipient, amount);</span>
 62 |     | <span class='neutral'>        emit LogBlastETHClaimed(recipient, amount);</span>
 63 |     | <span class='neutral'>        return amount;</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 67 |     | <span class='neutral'>    // TOKENS CLAIMING</span>
 68 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='unexecuted'>    function claimAllTokenYields(address token, address recipient) internal returns (uint256 amount) {</span>
 71 |     | <span class='unexecuted'>        amount = IERC20Rebasing(token).claim(recipient, IERC20Rebasing(token).getClaimableAmount(address(this)));</span>
 72 |     | <span class='unexecuted'>        emit LogBlastTokenClaimed(recipient, address(token), amount);</span>
 73 |     | <span class='neutral'>    }</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='neutral'>    function claimTokenYields(address token, uint256 amount, address recipient) internal returns (uint256) {</span>
 76 |     | <span class='neutral'>        amount = IERC20Rebasing(token).claim(recipient, amount);</span>
 77 |     | <span class='neutral'>        emit LogBlastTokenClaimed(recipient, address(token), amount);</span>
 78 |     | <span class='neutral'>        return amount;</span>
 79 |     | <span class='neutral'>    }</span>
 80 |     | <span class='neutral'></span>
 81 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 82 |     | <span class='neutral'>    // ARBITRARY PRECOMPILE CALLS</span>
 83 |     | <span class='neutral'>    // Meant to be used for any other calls to the precompile not covered by the above</span>
 84 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 85 |     | <span class='neutral'></span>
 86 |     | <span class='unexecuted'>    function callPrecompile(bytes calldata data) internal {</span>
 87 |     | <span class='unexecuted'>        Address.functionCall(address(BLAST_YIELD_PRECOMPILE), data);</span>
 88 |     | <span class='neutral'>    }</span>
 89 |     | <span class='neutral'>}</span>
 90 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/cauldrons/CauldronV4.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>// Cauldron</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>//    (                (   (</span>
   6 |     | <span class='neutral'>//    )\      )    (   )\  )\ )  (</span>
   7 |     | <span class='neutral'>//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (</span>
   8 |     | <span class='neutral'>//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )</span>
   9 |     | <span class='neutral'>// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(</span>
  10 |     | <span class='neutral'>//  | (__ / _` || || || |/ _` | | &#39;_|/ _ \| &#39; \))</span>
  11 |     | <span class='neutral'>//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  14 |     | <span class='neutral'>import {Owned} from &quot;solmate/auth/Owned.sol&quot;;</span>
  15 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  16 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  17 |     | <span class='neutral'>import {ISwapperV2} from &quot;interfaces/ISwapperV2.sol&quot;;</span>
  18 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  19 |     | <span class='neutral'>import {IMasterContract} from &quot;BoringSolidity/interfaces/IMasterContract.sol&quot;;</span>
  20 |     | <span class='neutral'>import {RebaseLibrary, Rebase} from &quot;BoringSolidity/libraries/BoringRebase.sol&quot;;</span>
  21 |     | <span class='neutral'>import {BoringMath, BoringMath128} from &quot;BoringSolidity/libraries/BoringMath.sol&quot;;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  24 |     | <span class='neutral'>// solhint-disable no-inline-assembly</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>/// @title Cauldron</span>
  27 |     | <span class='neutral'>/// @dev This contract allows contract calls to any contract (except BentoBox)</span>
  28 |     | <span class='neutral'>/// from arbitrary callers thus, don&#39;t trust calls from this contract in any circumstances.</span>
  29 |     | <span class='unexecuted'>contract CauldronV4 is Owned, IMasterContract {</span>
  30 |     | <span class='neutral'>    using BoringMath for uint256;</span>
  31 |     | <span class='neutral'>    using BoringMath128 for uint128;</span>
  32 |     | <span class='neutral'>    using RebaseLibrary for Rebase;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    event LogExchangeRate(uint256 rate);</span>
  35 |     | <span class='neutral'>    event LogAccrue(uint128 accruedAmount);</span>
  36 |     | <span class='neutral'>    event LogAddCollateral(address indexed from, address indexed to, uint256 share);</span>
  37 |     | <span class='neutral'>    event LogRemoveCollateral(address indexed from, address indexed to, uint256 share);</span>
  38 |     | <span class='neutral'>    event LogBorrow(address indexed from, address indexed to, uint256 amount, uint256 part);</span>
  39 |     | <span class='neutral'>    event LogRepay(address indexed from, address indexed to, uint256 amount, uint256 part);</span>
  40 |     | <span class='neutral'>    event LogFeeTo(address indexed newFeeTo);</span>
  41 |     | <span class='neutral'>    event LogWithdrawFees(address indexed feeTo, uint256 feesEarnedFraction);</span>
  42 |     | <span class='neutral'>    event LogInterestChange(uint64 oldInterestRate, uint64 newInterestRate);</span>
  43 |     | <span class='neutral'>    event LogChangeBorrowLimit(uint128 newLimit, uint128 perAddressPart);</span>
  44 |     | <span class='neutral'>    event LogChangeBlacklistedCallee(address indexed account, bool blacklisted);</span>
  45 |     | <span class='neutral'>    event LogLiquidationMultiplierChanged(uint256 previous, uint256 current);</span>
  46 |     | <span class='neutral'>    event LogBorrowOpeningFeeChanged(uint256 previous, uint256 current);</span>
  47 |     | <span class='neutral'>    event LogCollateralizationRateChanged(uint256 previous, uint256 current);</span>
  48 |     | <span class='neutral'>    </span>
  49 |     | <span class='neutral'>    event LogLiquidation(</span>
  50 |     | <span class='neutral'>        address indexed from,</span>
  51 |     | <span class='neutral'>        address indexed user,</span>
  52 |     | <span class='neutral'>        address indexed to,</span>
  53 |     | <span class='neutral'>        uint256 collateralShare,</span>
  54 |     | <span class='neutral'>        uint256 borrowAmount,</span>
  55 |     | <span class='neutral'>        uint256 borrowPart</span>
  56 |     | <span class='neutral'>    );</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    error ErrNotClone();</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    // Immutables (for MasterContract and all clones)</span>
  61 |     | <span class='unexecuted'>    IBentoBoxV1 public immutable bentoBox;</span>
  62 |     | <span class='unexecuted'>    CauldronV4 public immutable masterContract;</span>
  63 |     | <span class='unexecuted'>    IERC20 public immutable magicInternetMoney;</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    // MasterContract variables</span>
  66 |     | <span class='unexecuted'>    address public feeTo;</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    // Per clone variables</span>
  69 |     | <span class='neutral'>    // Clone init settings</span>
  70 |     | <span class='unexecuted'>    IERC20 public collateral;</span>
  71 |     | <span class='unexecuted'>    IOracle public oracle;</span>
  72 |     | <span class='unexecuted'>    bytes public oracleData;</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    struct BorrowCap {</span>
  75 |     | <span class='neutral'>        uint128 total;</span>
  76 |     | <span class='neutral'>        uint128 borrowPartPerAddress;</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>    BorrowCap public borrowLimit;</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    // Total amounts</span>
  82 |     | <span class='unexecuted'>    uint256 public totalCollateralShare; // Total collateral supplied</span>
  83 |     | <span class='unexecuted'>    Rebase public totalBorrow; // elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    // User balances</span>
  86 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public userCollateralShare;</span>
  87 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public userBorrowPart;</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    // Callee restrictions</span>
  90 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public blacklistedCallees;</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    /// @notice Exchange and interest rate tracking.</span>
  93 |     | <span class='neutral'>    /// This is &#39;cached&#39; here because calls to Oracles can be very expensive.</span>
  94 |     | <span class='unexecuted'>    uint256 public exchangeRate;</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    struct AccrueInfo {</span>
  97 |     | <span class='neutral'>        uint64 lastAccrued;</span>
  98 |     | <span class='neutral'>        uint128 feesEarned;</span>
  99 |     | <span class='neutral'>        uint64 INTEREST_PER_SECOND;</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>    AccrueInfo public accrueInfo;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    uint64 internal constant ONE_PERCENT_RATE = 317097920;</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    // Settings</span>
 107 |     | <span class='unexecuted'>    uint256 public COLLATERIZATION_RATE;</span>
 108 |     | <span class='unexecuted'>    uint256 internal constant COLLATERIZATION_RATE_PRECISION = 1e5; // Must be less than EXCHANGE_RATE_PRECISION (due to optimization in math)</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>    uint256 internal constant EXCHANGE_RATE_PRECISION = 1e18;</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>    uint256 public LIQUIDATION_MULTIPLIER; </span>
 113 |     | <span class='unexecuted'>    uint256 internal constant LIQUIDATION_MULTIPLIER_PRECISION = 1e5;</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>    uint256 public BORROW_OPENING_FEE;</span>
 116 |     | <span class='unexecuted'>    uint256 internal constant BORROW_OPENING_FEE_PRECISION = 1e5;</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>    uint256 internal constant DISTRIBUTION_PART = 10;</span>
 119 |     | <span class='unexecuted'>    uint256 internal constant DISTRIBUTION_PRECISION = 100;</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    modifier onlyMasterContractOwner() {</span>
 122 |     | <span class='unexecuted'>        require(msg.sender == masterContract.owner(), &quot;Caller is not the owner&quot;);</span>
 123 |     | <span class='neutral'>        _;</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    modifier onlyClones() {</span>
 127 |     | <span class='unexecuted'>        if (address(this) == address(masterContract)) {</span>
 128 |     | <span class='unexecuted'>            revert ErrNotClone();</span>
 129 |     | <span class='neutral'>        }</span>
 130 |     | <span class='neutral'>        _;</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /// @notice The constructor is only used for the initial master contract. Subsequent clones are initialised via `init`.</span>
 134 |     | <span class='unexecuted'>    constructor(IBentoBoxV1 bentoBox_, IERC20 magicInternetMoney_) Owned(msg.sender) {</span>
 135 |     | <span class='unexecuted'>        bentoBox = bentoBox_;</span>
 136 |     | <span class='unexecuted'>        magicInternetMoney = magicInternetMoney_;</span>
 137 |     | <span class='unexecuted'>        masterContract = this;</span>
 138 |     | <span class='neutral'>        </span>
 139 |     | <span class='unexecuted'>        blacklistedCallees[address(bentoBox)] = true;</span>
 140 |     | <span class='unexecuted'>        blacklistedCallees[address(this)] = true;</span>
 141 |     | <span class='unexecuted'>        blacklistedCallees[Owned(address(bentoBox)).owner()] = true;</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    /// @notice Serves as the constructor for clones, as clones can&#39;t have a regular constructor</span>
 145 |     | <span class='neutral'>    /// @dev `data` is abi encoded in the format: (IERC20 collateral, IERC20 asset, IOracle oracle, bytes oracleData)</span>
 146 |     | <span class='unexecuted'>    function init(bytes calldata data) public virtual onlyClones payable override {</span>
 147 |     | <span class='unexecuted'>        require(address(collateral) == address(0), &quot;Cauldron: already initialized&quot;);</span>
 148 |     | <span class='unexecuted'>        (collateral, oracle, oracleData, accrueInfo.INTEREST_PER_SECOND, LIQUIDATION_MULTIPLIER, COLLATERIZATION_RATE, BORROW_OPENING_FEE) = abi.decode(data, (IERC20, IOracle, bytes, uint64, uint256, uint256, uint256));</span>
 149 |     | <span class='unexecuted'>        borrowLimit = BorrowCap(type(uint128).max, type(uint128).max);</span>
 150 |     | <span class='unexecuted'>        require(address(collateral) != address(0), &quot;Cauldron: bad pair&quot;);</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='unexecuted'>        magicInternetMoney.approve(address(bentoBox), type(uint256).max);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>        blacklistedCallees[address(bentoBox)] = true;</span>
 155 |     | <span class='unexecuted'>        blacklistedCallees[address(this)] = true;</span>
 156 |     | <span class='unexecuted'>        blacklistedCallees[Owned(address(bentoBox)).owner()] = true;</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='unexecuted'>        (, exchangeRate) = oracle.get(oracleData);</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>        accrue();</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.</span>
 164 |     | <span class='unexecuted'>    function accrue() public {</span>
 165 |     | <span class='unexecuted'>        AccrueInfo memory _accrueInfo = accrueInfo;</span>
 166 |     | <span class='neutral'>        // Number of seconds since accrue was called</span>
 167 |     | <span class='unexecuted'>        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;</span>
 168 |     | <span class='unexecuted'>        if (elapsedTime == 0) {</span>
 169 |     | <span class='unexecuted'>            return;</span>
 170 |     | <span class='neutral'>        }</span>
 171 |     | <span class='unexecuted'>        _accrueInfo.lastAccrued = uint64(block.timestamp);</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='unexecuted'>        Rebase memory _totalBorrow = totalBorrow;</span>
 174 |     | <span class='unexecuted'>        if (_totalBorrow.base == 0) {</span>
 175 |     | <span class='unexecuted'>            accrueInfo = _accrueInfo;</span>
 176 |     | <span class='neutral'>            return;</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>        // Accrue interest</span>
 180 |     | <span class='unexecuted'>        uint128 extraAmount = (uint256(_totalBorrow.elastic).mul(_accrueInfo.INTEREST_PER_SECOND).mul(elapsedTime) / 1e18).to128();</span>
 181 |     | <span class='unexecuted'>        _totalBorrow.elastic = _totalBorrow.elastic.add(extraAmount);</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='unexecuted'>        _accrueInfo.feesEarned = _accrueInfo.feesEarned.add(extraAmount);</span>
 184 |     | <span class='unexecuted'>        totalBorrow = _totalBorrow;</span>
 185 |     | <span class='unexecuted'>        accrueInfo = _accrueInfo;</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='unexecuted'>        emit LogAccrue(extraAmount);</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>    /// @notice Concrete implementation of `isSolvent`. Includes a third parameter to allow caching `exchangeRate`.</span>
 191 |     | <span class='neutral'>    /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.</span>
 192 |     | <span class='unexecuted'>    function _isSolvent(address user, uint256 _exchangeRate) virtual internal view returns (bool) {</span>
 193 |     | <span class='neutral'>        // accrue must have already been called!</span>
 194 |     | <span class='unexecuted'>        uint256 borrowPart = userBorrowPart[user];</span>
 195 |     | <span class='unexecuted'>        if (borrowPart == 0) return true;</span>
 196 |     | <span class='unexecuted'>        uint256 collateralShare = userCollateralShare[user];</span>
 197 |     | <span class='unexecuted'>        if (collateralShare == 0) return false;</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='unexecuted'>        Rebase memory _totalBorrow = totalBorrow;</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>        return</span>
 202 |     | <span class='unexecuted'>            bentoBox.toAmount(</span>
 203 |     | <span class='unexecuted'>                collateral,</span>
 204 |     | <span class='unexecuted'>                collateralShare.mul(EXCHANGE_RATE_PRECISION / COLLATERIZATION_RATE_PRECISION).mul(COLLATERIZATION_RATE),</span>
 205 |     | <span class='unexecuted'>                false</span>
 206 |     | <span class='neutral'>            ) &gt;=</span>
 207 |     | <span class='neutral'>            // Moved exchangeRate here instead of dividing the other side to preserve more precision</span>
 208 |     | <span class='unexecuted'>            borrowPart.mul(_totalBorrow.elastic).mul(_exchangeRate) / _totalBorrow.base;</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='unexecuted'>    function isSolvent(address user) public view returns (bool) {</span>
 212 |     | <span class='unexecuted'>        return _isSolvent(user, exchangeRate);</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'>    </span>
 215 |     | <span class='neutral'>    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.</span>
 216 |     | <span class='unexecuted'>    modifier solvent() {</span>
 217 |     | <span class='neutral'>        _;</span>
 218 |     | <span class='unexecuted'>        (, uint256 _exchangeRate) = updateExchangeRate();</span>
 219 |     | <span class='unexecuted'>        require(_isSolvent(msg.sender, _exchangeRate), &quot;Cauldron: user insolvent&quot;);</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.</span>
 223 |     | <span class='neutral'>    /// This function is supposed to be invoked if needed because Oracle queries can be expensive.</span>
 224 |     | <span class='neutral'>    /// @return updated True if `exchangeRate` was updated.</span>
 225 |     | <span class='neutral'>    /// @return rate The new exchange rate.</span>
 226 |     | <span class='unexecuted'>    function updateExchangeRate() public returns (bool updated, uint256 rate) {</span>
 227 |     | <span class='unexecuted'>        (updated, rate) = oracle.get(oracleData);</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='unexecuted'>        if (updated) {</span>
 230 |     | <span class='unexecuted'>            exchangeRate = rate;</span>
 231 |     | <span class='unexecuted'>            emit LogExchangeRate(rate);</span>
 232 |     | <span class='neutral'>        } else {</span>
 233 |     | <span class='neutral'>            // Return the old rate if fetching wasn&#39;t successful</span>
 234 |     | <span class='unexecuted'>            rate = exchangeRate;</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>    /// @dev Helper function to move tokens.</span>
 239 |     | <span class='neutral'>    /// @param token The ERC-20 token.</span>
 240 |     | <span class='neutral'>    /// @param share The amount in shares to add.</span>
 241 |     | <span class='neutral'>    /// @param total Grand total amount to deduct from this contract&#39;s balance. Only applicable if `skim` is True.</span>
 242 |     | <span class='neutral'>    /// Only used for accounting checks.</span>
 243 |     | <span class='neutral'>    /// @param skim If True, only does a balance check on this contract.</span>
 244 |     | <span class='neutral'>    /// False if tokens from msg.sender in `bentoBox` should be transferred.</span>
 245 |     | <span class='unexecuted'>    function _addTokens(</span>
 246 |     | <span class='neutral'>        IERC20 token,</span>
 247 |     | <span class='neutral'>        uint256 share,</span>
 248 |     | <span class='neutral'>        uint256 total,</span>
 249 |     | <span class='neutral'>        bool skim</span>
 250 |     | <span class='neutral'>    ) internal {</span>
 251 |     | <span class='unexecuted'>        if (skim) {</span>
 252 |     | <span class='unexecuted'>            require(share &lt;= bentoBox.balanceOf(token, address(this)).sub(total), &quot;Cauldron: Skim too much&quot;);</span>
 253 |     | <span class='neutral'>        } else {</span>
 254 |     | <span class='unexecuted'>            bentoBox.transfer(token, msg.sender, address(this), share);</span>
 255 |     | <span class='neutral'>        }</span>
 256 |     | <span class='neutral'>    }</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>    function _afterAddCollateral(address user, uint256 collateralShare) internal virtual {}</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>    /// @notice Adds `collateral` from msg.sender to the account `to`.</span>
 261 |     | <span class='neutral'>    /// @param to The receiver of the tokens.</span>
 262 |     | <span class='neutral'>    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.x</span>
 263 |     | <span class='neutral'>    /// False if tokens from msg.sender in `bentoBox` should be transferred.</span>
 264 |     | <span class='neutral'>    /// @param share The amount of shares to add for `to`.</span>
 265 |     | <span class='unexecuted'>    function addCollateral(</span>
 266 |     | <span class='neutral'>        address to,</span>
 267 |     | <span class='neutral'>        bool skim,</span>
 268 |     | <span class='neutral'>        uint256 share</span>
 269 |     | <span class='unexecuted'>    ) public virtual {</span>
 270 |     | <span class='unexecuted'>        userCollateralShare[to] = userCollateralShare[to].add(share);</span>
 271 |     | <span class='unexecuted'>        uint256 oldTotalCollateralShare = totalCollateralShare;</span>
 272 |     | <span class='unexecuted'>        totalCollateralShare = oldTotalCollateralShare.add(share);</span>
 273 |     | <span class='unexecuted'>        _addTokens(collateral, share, oldTotalCollateralShare, skim);</span>
 274 |     | <span class='neutral'>        _afterAddCollateral(to, share);</span>
 275 |     | <span class='unexecuted'>        emit LogAddCollateral(skim ? address(bentoBox) : msg.sender, to, share);</span>
 276 |     | <span class='neutral'>    }</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='neutral'>    function _afterRemoveCollateral(address from, address to, uint256 collateralShare) internal virtual {}</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    /// @dev Concrete implementation of `removeCollateral`.</span>
 281 |     | <span class='unexecuted'>    function _removeCollateral(address to, uint256 share) internal virtual {</span>
 282 |     | <span class='unexecuted'>        userCollateralShare[msg.sender] = userCollateralShare[msg.sender].sub(share);</span>
 283 |     | <span class='unexecuted'>        totalCollateralShare = totalCollateralShare.sub(share);</span>
 284 |     | <span class='neutral'>        _afterRemoveCollateral(msg.sender, to, share);</span>
 285 |     | <span class='unexecuted'>        emit LogRemoveCollateral(msg.sender, to, share);</span>
 286 |     | <span class='unexecuted'>        bentoBox.transfer(collateral, address(this), to, share);</span>
 287 |     | <span class='neutral'>    }</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='neutral'>    /// @notice Removes `share` amount of collateral and transfers it to `to`.</span>
 290 |     | <span class='neutral'>    /// @param to The receiver of the shares.</span>
 291 |     | <span class='neutral'>    /// @param share Amount of shares to remove.</span>
 292 |     | <span class='unexecuted'>    function removeCollateral(address to, uint256 share) public solvent {</span>
 293 |     | <span class='neutral'>        // accrue must be called because we check solvency</span>
 294 |     | <span class='unexecuted'>        accrue();</span>
 295 |     | <span class='unexecuted'>        _removeCollateral(to, share);</span>
 296 |     | <span class='neutral'>    }</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='neutral'>    function _preBorrowAction(address to, uint256 amount, uint256 newBorrowPart, uint256 part) internal virtual {</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    /// @dev Concrete implementation of `borrow`.</span>
 303 |     | <span class='unexecuted'>    function _borrow(address to, uint256 amount) internal returns (uint256 part, uint256 share) {</span>
 304 |     | <span class='unexecuted'>        uint256 feeAmount = amount.mul(BORROW_OPENING_FEE) / BORROW_OPENING_FEE_PRECISION; // A flat % fee is charged for any borrow</span>
 305 |     | <span class='unexecuted'>        (totalBorrow, part) = totalBorrow.add(amount.add(feeAmount), true);</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='unexecuted'>        BorrowCap memory cap =  borrowLimit;</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='unexecuted'>        require(totalBorrow.elastic &lt;= cap.total, &quot;Borrow Limit reached&quot;);</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='unexecuted'>        accrueInfo.feesEarned = accrueInfo.feesEarned.add(uint128(feeAmount));</span>
 312 |     | <span class='neutral'>        </span>
 313 |     | <span class='unexecuted'>        uint256 newBorrowPart = userBorrowPart[msg.sender].add(part);</span>
 314 |     | <span class='unexecuted'>        require(newBorrowPart &lt;= cap.borrowPartPerAddress, &quot;Borrow Limit reached&quot;);</span>
 315 |     | <span class='unexecuted'>        _preBorrowAction(to, amount, newBorrowPart, part);</span>
 316 |     | <span class='neutral'></span>
 317 |     | <span class='unexecuted'>        userBorrowPart[msg.sender] = newBorrowPart;</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>        // As long as there are tokens on this contract you can &#39;mint&#39;... this enables limiting borrows</span>
 320 |     | <span class='unexecuted'>        share = bentoBox.toShare(magicInternetMoney, amount, false);</span>
 321 |     | <span class='unexecuted'>        bentoBox.transfer(magicInternetMoney, address(this), to, share);</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='unexecuted'>        emit LogBorrow(msg.sender, to, amount.add(feeAmount), part);</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>    /// @notice Sender borrows `amount` and transfers it to `to`.</span>
 327 |     | <span class='neutral'>    /// @return part Total part of the debt held by borrowers.</span>
 328 |     | <span class='neutral'>    /// @return share Total amount in shares borrowed.</span>
 329 |     | <span class='unexecuted'>    function borrow(address to, uint256 amount) public solvent returns (uint256 part, uint256 share) {</span>
 330 |     | <span class='unexecuted'>        accrue();</span>
 331 |     | <span class='unexecuted'>        (part, share) = _borrow(to, amount);</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>    /// @dev Concrete implementation of `repay`.</span>
 335 |     | <span class='unexecuted'>    function _repay(</span>
 336 |     | <span class='neutral'>        address to,</span>
 337 |     | <span class='neutral'>        bool skim,</span>
 338 |     | <span class='neutral'>        uint256 part</span>
 339 |     | <span class='unexecuted'>    ) internal returns (uint256 amount) {</span>
 340 |     | <span class='unexecuted'>        (totalBorrow, amount) = totalBorrow.sub(part, true);</span>
 341 |     | <span class='unexecuted'>        userBorrowPart[to] = userBorrowPart[to].sub(part);</span>
 342 |     | <span class='neutral'></span>
 343 |     | <span class='unexecuted'>        uint256 share = bentoBox.toShare(magicInternetMoney, amount, true);</span>
 344 |     | <span class='unexecuted'>        bentoBox.transfer(magicInternetMoney, skim ? address(bentoBox) : msg.sender, address(this), share);</span>
 345 |     | <span class='unexecuted'>        emit LogRepay(skim ? address(bentoBox) : msg.sender, to, amount, part);</span>
 346 |     | <span class='neutral'>    }</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='neutral'>    /// @notice Repays a loan.</span>
 349 |     | <span class='neutral'>    /// @param to Address of the user this payment should go.</span>
 350 |     | <span class='neutral'>    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.</span>
 351 |     | <span class='neutral'>    /// False if tokens from msg.sender in `bentoBox` should be transferred.</span>
 352 |     | <span class='neutral'>    /// @param part The amount to repay. See `userBorrowPart`.</span>
 353 |     | <span class='neutral'>    /// @return amount The total amount repayed.</span>
 354 |     | <span class='unexecuted'>    function repay(</span>
 355 |     | <span class='neutral'>        address to,</span>
 356 |     | <span class='neutral'>        bool skim,</span>
 357 |     | <span class='neutral'>        uint256 part</span>
 358 |     | <span class='unexecuted'>    ) public returns (uint256 amount) {</span>
 359 |     | <span class='unexecuted'>        accrue();</span>
 360 |     | <span class='unexecuted'>        amount = _repay(to, skim, part);</span>
 361 |     | <span class='neutral'>    }</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='neutral'>    // Functions that need accrue to be called</span>
 364 |     | <span class='neutral'>    uint8 internal constant ACTION_REPAY = 2;</span>
 365 |     | <span class='neutral'>    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;</span>
 366 |     | <span class='neutral'>    uint8 internal constant ACTION_BORROW = 5;</span>
 367 |     | <span class='neutral'>    uint8 internal constant ACTION_GET_REPAY_SHARE = 6;</span>
 368 |     | <span class='neutral'>    uint8 internal constant ACTION_GET_REPAY_PART = 7;</span>
 369 |     | <span class='neutral'>    uint8 internal constant ACTION_ACCRUE = 8;</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>    // Functions that don&#39;t need accrue to be called</span>
 372 |     | <span class='neutral'>    uint8 internal constant ACTION_ADD_COLLATERAL = 10;</span>
 373 |     | <span class='neutral'>    uint8 internal constant ACTION_UPDATE_EXCHANGE_RATE = 11;</span>
 374 |     | <span class='neutral'></span>
 375 |     | <span class='neutral'>    // Function on BentoBox</span>
 376 |     | <span class='neutral'>    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;</span>
 377 |     | <span class='neutral'>    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;</span>
 378 |     | <span class='neutral'>    uint8 internal constant ACTION_BENTO_TRANSFER = 22;</span>
 379 |     | <span class='neutral'>    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;</span>
 380 |     | <span class='neutral'>    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='neutral'>    // Any external call (except to BentoBox)</span>
 383 |     | <span class='neutral'>    uint8 internal constant ACTION_CALL = 30;</span>
 384 |     | <span class='neutral'>    uint8 internal constant ACTION_LIQUIDATE = 31;</span>
 385 |     | <span class='neutral'></span>
 386 |     | <span class='neutral'>    // Custom cook actions</span>
 387 |     | <span class='unexecuted'>    uint8 internal constant ACTION_CUSTOM_START_INDEX = 100;</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>    int256 internal constant USE_VALUE1 = -1;</span>
 390 |     | <span class='neutral'>    int256 internal constant USE_VALUE2 = -2;</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='neutral'>    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.</span>
 393 |     | <span class='unexecuted'>    function _num(</span>
 394 |     | <span class='neutral'>        int256 inNum,</span>
 395 |     | <span class='neutral'>        uint256 value1,</span>
 396 |     | <span class='neutral'>        uint256 value2</span>
 397 |     | <span class='unexecuted'>    ) internal pure returns (uint256 outNum) {</span>
 398 |     | <span class='unexecuted'>        outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);</span>
 399 |     | <span class='neutral'>    }</span>
 400 |     | <span class='neutral'></span>
 401 |     | <span class='neutral'>    /// @dev Helper function for depositing into `bentoBox`.</span>
 402 |     | <span class='unexecuted'>    function _bentoDeposit(</span>
 403 |     | <span class='neutral'>        bytes memory data,</span>
 404 |     | <span class='neutral'>        uint256 value,</span>
 405 |     | <span class='neutral'>        uint256 value1,</span>
 406 |     | <span class='neutral'>        uint256 value2</span>
 407 |     | <span class='unexecuted'>    ) internal returns (uint256, uint256) {</span>
 408 |     | <span class='unexecuted'>        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));</span>
 409 |     | <span class='unexecuted'>        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors</span>
 410 |     | <span class='unexecuted'>        share = int256(_num(share, value1, value2));</span>
 411 |     | <span class='unexecuted'>        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));</span>
 412 |     | <span class='neutral'>    }</span>
 413 |     | <span class='neutral'></span>
 414 |     | <span class='neutral'>    /// @dev Helper function to withdraw from the `bentoBox`.</span>
 415 |     | <span class='unexecuted'>    function _bentoWithdraw(</span>
 416 |     | <span class='neutral'>        bytes memory data,</span>
 417 |     | <span class='neutral'>        uint256 value1,</span>
 418 |     | <span class='neutral'>        uint256 value2</span>
 419 |     | <span class='unexecuted'>    ) internal returns (uint256, uint256) {</span>
 420 |     | <span class='unexecuted'>        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));</span>
 421 |     | <span class='unexecuted'>        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));</span>
 422 |     | <span class='neutral'>    }</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='neutral'>    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.</span>
 425 |     | <span class='neutral'>    /// Calls to `bentoBox` are not allowed for obvious security reasons.</span>
 426 |     | <span class='neutral'>    /// This also means that calls made from this contract shall *not* be trusted.</span>
 427 |     | <span class='unexecuted'>    function _call(</span>
 428 |     | <span class='neutral'>        uint256 value,</span>
 429 |     | <span class='neutral'>        bytes memory data,</span>
 430 |     | <span class='neutral'>        uint256 value1,</span>
 431 |     | <span class='neutral'>        uint256 value2</span>
 432 |     | <span class='unexecuted'>    ) internal returns (bytes memory, uint8) {</span>
 433 |     | <span class='unexecuted'>        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) =</span>
 434 |     | <span class='unexecuted'>            abi.decode(data, (address, bytes, bool, bool, uint8));</span>
 435 |     | <span class='neutral'></span>
 436 |     | <span class='unexecuted'>        if (useValue1 &amp;&amp; !useValue2) {</span>
 437 |     | <span class='unexecuted'>            callData = abi.encodePacked(callData, value1);</span>
 438 |     | <span class='unexecuted'>        } else if (!useValue1 &amp;&amp; useValue2) {</span>
 439 |     | <span class='unexecuted'>            callData = abi.encodePacked(callData, value2);</span>
 440 |     | <span class='unexecuted'>        } else if (useValue1 &amp;&amp; useValue2) {</span>
 441 |     | <span class='unexecuted'>            callData = abi.encodePacked(callData, value1, value2);</span>
 442 |     | <span class='neutral'>        }</span>
 443 |     | <span class='neutral'></span>
 444 |     | <span class='unexecuted'>        require(!blacklistedCallees[callee], &quot;Cauldron: can&#39;t call&quot;);</span>
 445 |     | <span class='neutral'></span>
 446 |     | <span class='unexecuted'>        (bool success, bytes memory returnData) = callee.call{value: value}(callData);</span>
 447 |     | <span class='unexecuted'>        require(success, &quot;Cauldron: call failed&quot;);</span>
 448 |     | <span class='unexecuted'>        return (returnData, returnValues);</span>
 449 |     | <span class='neutral'>    }</span>
 450 |     | <span class='neutral'></span>
 451 |     | <span class='neutral'>    struct CookStatus {</span>
 452 |     | <span class='neutral'>        bool needsSolvencyCheck;</span>
 453 |     | <span class='neutral'>        bool hasAccrued;</span>
 454 |     | <span class='neutral'>    }</span>
 455 |     | <span class='neutral'></span>
 456 |     | <span class='unexecuted'>    function _additionalCookAction(uint8 action, CookStatus memory, uint256 value, bytes memory data, uint256 value1, uint256 value2) internal virtual returns (bytes memory, uint8, CookStatus memory) {}</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='neutral'>    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.</span>
 459 |     | <span class='neutral'>    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).</span>
 460 |     | <span class='neutral'>    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.</span>
 461 |     | <span class='neutral'>    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.</span>
 462 |     | <span class='neutral'>    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.</span>
 463 |     | <span class='neutral'>    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).</span>
 464 |     | <span class='neutral'>    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).</span>
 465 |     | <span class='unexecuted'>    function cook(</span>
 466 |     | <span class='neutral'>        uint8[] calldata actions,</span>
 467 |     | <span class='neutral'>        uint256[] calldata values,</span>
 468 |     | <span class='neutral'>        bytes[] calldata datas</span>
 469 |     | <span class='unexecuted'>    ) external payable returns (uint256 value1, uint256 value2) {</span>
 470 |     | <span class='neutral'>        CookStatus memory status;</span>
 471 |     | <span class='neutral'></span>
 472 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; actions.length; i++) {</span>
 473 |     | <span class='unexecuted'>            uint8 action = actions[i];</span>
 474 |     | <span class='unexecuted'>            if (!status.hasAccrued &amp;&amp; action &lt; 10) {</span>
 475 |     | <span class='unexecuted'>                accrue();</span>
 476 |     | <span class='unexecuted'>                status.hasAccrued = true;</span>
 477 |     | <span class='neutral'>            }</span>
 478 |     | <span class='unexecuted'>            if (action == ACTION_ADD_COLLATERAL) {</span>
 479 |     | <span class='unexecuted'>                (int256 share, address to, bool skim) = abi.decode(datas[i], (int256, address, bool));</span>
 480 |     | <span class='unexecuted'>                addCollateral(to, skim, _num(share, value1, value2));</span>
 481 |     | <span class='unexecuted'>            } else if (action == ACTION_REPAY) {</span>
 482 |     | <span class='unexecuted'>                (int256 part, address to, bool skim) = abi.decode(datas[i], (int256, address, bool));</span>
 483 |     | <span class='unexecuted'>                _repay(to, skim, _num(part, value1, value2));</span>
 484 |     | <span class='unexecuted'>            } else if (action == ACTION_REMOVE_COLLATERAL) {</span>
 485 |     | <span class='unexecuted'>                (int256 share, address to) = abi.decode(datas[i], (int256, address));</span>
 486 |     | <span class='unexecuted'>                _removeCollateral(to, _num(share, value1, value2));</span>
 487 |     | <span class='unexecuted'>                status.needsSolvencyCheck = true;</span>
 488 |     | <span class='unexecuted'>            } else if (action == ACTION_BORROW) {</span>
 489 |     | <span class='unexecuted'>                (int256 amount, address to) = abi.decode(datas[i], (int256, address));</span>
 490 |     | <span class='unexecuted'>                (value1, value2) = _borrow(to, _num(amount, value1, value2));</span>
 491 |     | <span class='unexecuted'>                status.needsSolvencyCheck = true;</span>
 492 |     | <span class='unexecuted'>            } else if (action == ACTION_UPDATE_EXCHANGE_RATE) {</span>
 493 |     | <span class='unexecuted'>                (bool must_update, uint256 minRate, uint256 maxRate) = abi.decode(datas[i], (bool, uint256, uint256));</span>
 494 |     | <span class='unexecuted'>                (bool updated, uint256 rate) = updateExchangeRate();</span>
 495 |     | <span class='unexecuted'>                require((!must_update || updated) &amp;&amp; rate &gt; minRate &amp;&amp; (maxRate == 0 || rate &lt; maxRate), &quot;Cauldron: rate not ok&quot;);</span>
 496 |     | <span class='unexecuted'>            } else if (action == ACTION_BENTO_SETAPPROVAL) {</span>
 497 |     | <span class='unexecuted'>                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) =</span>
 498 |     | <span class='unexecuted'>                    abi.decode(datas[i], (address, address, bool, uint8, bytes32, bytes32));</span>
 499 |     | <span class='unexecuted'>                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);</span>
 500 |     | <span class='unexecuted'>            } else if (action == ACTION_BENTO_DEPOSIT) {</span>
 501 |     | <span class='unexecuted'>                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);</span>
 502 |     | <span class='unexecuted'>            } else if (action == ACTION_BENTO_WITHDRAW) {</span>
 503 |     | <span class='unexecuted'>                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);</span>
 504 |     | <span class='unexecuted'>            } else if (action == ACTION_BENTO_TRANSFER) {</span>
 505 |     | <span class='unexecuted'>                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));</span>
 506 |     | <span class='unexecuted'>                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));</span>
 507 |     | <span class='unexecuted'>            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {</span>
 508 |     | <span class='unexecuted'>                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));</span>
 509 |     | <span class='unexecuted'>                bentoBox.transferMultiple(token, msg.sender, tos, shares);</span>
 510 |     | <span class='unexecuted'>            } else if (action == ACTION_CALL) {</span>
 511 |     | <span class='unexecuted'>                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);</span>
 512 |     | <span class='neutral'></span>
 513 |     | <span class='unexecuted'>                if (returnValues == 1) {</span>
 514 |     | <span class='unexecuted'>                    (value1) = abi.decode(returnData, (uint256));</span>
 515 |     | <span class='unexecuted'>                } else if (returnValues == 2) {</span>
 516 |     | <span class='unexecuted'>                    (value1, value2) = abi.decode(returnData, (uint256, uint256));</span>
 517 |     | <span class='neutral'>                }</span>
 518 |     | <span class='unexecuted'>            } else if (action == ACTION_GET_REPAY_SHARE) {</span>
 519 |     | <span class='unexecuted'>                int256 part = abi.decode(datas[i], (int256));</span>
 520 |     | <span class='unexecuted'>                value1 = bentoBox.toShare(magicInternetMoney, totalBorrow.toElastic(_num(part, value1, value2), true), true);</span>
 521 |     | <span class='unexecuted'>            } else if (action == ACTION_GET_REPAY_PART) {</span>
 522 |     | <span class='unexecuted'>                int256 amount = abi.decode(datas[i], (int256));</span>
 523 |     | <span class='unexecuted'>                value1 = totalBorrow.toBase(_num(amount, value1, value2), false);</span>
 524 |     | <span class='unexecuted'>            } else if (action == ACTION_LIQUIDATE) {</span>
 525 |     | <span class='unexecuted'>                _cookActionLiquidate(datas[i]);</span>
 526 |     | <span class='unexecuted'>            } else {</span>
 527 |     | <span class='unexecuted'>                (bytes memory returnData, uint8 returnValues, CookStatus memory returnStatus) = _additionalCookAction(action, status, values[i], datas[i], value1, value2);</span>
 528 |     | <span class='unexecuted'>                status = returnStatus;</span>
 529 |     | <span class='neutral'>                </span>
 530 |     | <span class='unexecuted'>                if (returnValues == 1) {</span>
 531 |     | <span class='unexecuted'>                    (value1) = abi.decode(returnData, (uint256));</span>
 532 |     | <span class='unexecuted'>                } else if (returnValues == 2) {</span>
 533 |     | <span class='unexecuted'>                    (value1, value2) = abi.decode(returnData, (uint256, uint256));</span>
 534 |     | <span class='neutral'>                }</span>
 535 |     | <span class='neutral'>            }</span>
 536 |     | <span class='neutral'>        }</span>
 537 |     | <span class='neutral'></span>
 538 |     | <span class='unexecuted'>        if (status.needsSolvencyCheck) {</span>
 539 |     | <span class='unexecuted'>            (, uint256 _exchangeRate) = updateExchangeRate();</span>
 540 |     | <span class='unexecuted'>            require(_isSolvent(msg.sender, _exchangeRate), &quot;Cauldron: user insolvent&quot;);</span>
 541 |     | <span class='neutral'>        }</span>
 542 |     | <span class='neutral'>    }</span>
 543 |     | <span class='neutral'></span>
 544 |     | <span class='unexecuted'>    function _cookActionLiquidate(bytes calldata data) internal {</span>
 545 |     | <span class='unexecuted'>         (address[] memory users, uint256[] memory maxBorrowParts, address to, ISwapperV2 swapper, bytes memory swapperData) = abi.decode(data, (address[], uint256[], address, ISwapperV2, bytes));</span>
 546 |     | <span class='unexecuted'>        liquidate(users, maxBorrowParts, to, swapper, swapperData);</span>
 547 |     | <span class='neutral'>    }</span>
 548 |     | <span class='neutral'></span>
 549 |     | <span class='neutral'>    function _beforeUsersLiquidated(address[] memory users, uint256[] memory maxBorrowPart) internal virtual {}</span>
 550 |     | <span class='neutral'></span>
 551 |     | <span class='neutral'>    function _beforeUserLiquidated(address user, uint256 borrowPart, uint256 borrowAmount, uint256 collateralShare) internal virtual {}</span>
 552 |     | <span class='neutral'></span>
 553 |     | <span class='neutral'>    function _afterUserLiquidated(address user, uint256 collateralShare) internal virtual {}</span>
 554 |     | <span class='neutral'></span>
 555 |     | <span class='neutral'>    /// @notice Handles the liquidation of users&#39; balances, once the users&#39; amount of collateral is too low.</span>
 556 |     | <span class='neutral'>    /// @param users An array of user addresses.</span>
 557 |     | <span class='neutral'>    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.</span>
 558 |     | <span class='neutral'>    /// @param to Address of the receiver in open liquidations if `swapper` is zero.</span>
 559 |     | <span class='unexecuted'>    function liquidate(</span>
 560 |     | <span class='neutral'>        address[] memory users,</span>
 561 |     | <span class='neutral'>        uint256[] memory maxBorrowParts,</span>
 562 |     | <span class='neutral'>        address to,</span>
 563 |     | <span class='neutral'>        ISwapperV2 swapper,</span>
 564 |     | <span class='neutral'>        bytes memory swapperData</span>
 565 |     | <span class='unexecuted'>    ) public virtual {</span>
 566 |     | <span class='neutral'>        // Oracle can fail but we still need to allow liquidations</span>
 567 |     | <span class='unexecuted'>        (, uint256 _exchangeRate) = updateExchangeRate();</span>
 568 |     | <span class='unexecuted'>        accrue();</span>
 569 |     | <span class='neutral'></span>
 570 |     | <span class='unexecuted'>        uint256 allCollateralShare;</span>
 571 |     | <span class='neutral'>        uint256 allBorrowAmount;</span>
 572 |     | <span class='neutral'>        uint256 allBorrowPart;</span>
 573 |     | <span class='unexecuted'>        Rebase memory bentoBoxTotals = bentoBox.totals(collateral);</span>
 574 |     | <span class='neutral'>        _beforeUsersLiquidated(users, maxBorrowParts);</span>
 575 |     | <span class='neutral'></span>
 576 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; users.length; i++) {</span>
 577 |     | <span class='unexecuted'>            address user = users[i];</span>
 578 |     | <span class='unexecuted'>            if (!_isSolvent(user, _exchangeRate)) {</span>
 579 |     | <span class='unexecuted'>                uint256 borrowPart;</span>
 580 |     | <span class='unexecuted'>                uint256 availableBorrowPart = userBorrowPart[user];</span>
 581 |     | <span class='unexecuted'>                borrowPart = maxBorrowParts[i] &gt; availableBorrowPart ? availableBorrowPart : maxBorrowParts[i];</span>
 582 |     | <span class='neutral'></span>
 583 |     | <span class='unexecuted'>                uint256 borrowAmount = totalBorrow.toElastic(borrowPart, false);</span>
 584 |     | <span class='unexecuted'>                uint256 collateralShare =</span>
 585 |     | <span class='unexecuted'>                    bentoBoxTotals.toBase(</span>
 586 |     | <span class='unexecuted'>                        borrowAmount.mul(LIQUIDATION_MULTIPLIER).mul(_exchangeRate) /</span>
 587 |     | <span class='unexecuted'>                            (LIQUIDATION_MULTIPLIER_PRECISION * EXCHANGE_RATE_PRECISION),</span>
 588 |     | <span class='unexecuted'>                        false</span>
 589 |     | <span class='neutral'>                    );</span>
 590 |     | <span class='neutral'></span>
 591 |     | <span class='neutral'>                _beforeUserLiquidated(user, borrowPart, borrowAmount, collateralShare);</span>
 592 |     | <span class='unexecuted'>                userBorrowPart[user] = availableBorrowPart.sub(borrowPart);</span>
 593 |     | <span class='unexecuted'>                userCollateralShare[user] = userCollateralShare[user].sub(collateralShare);</span>
 594 |     | <span class='neutral'>                _afterUserLiquidated(user, collateralShare);</span>
 595 |     | <span class='neutral'></span>
 596 |     | <span class='unexecuted'>                emit LogRemoveCollateral(user, to, collateralShare);</span>
 597 |     | <span class='unexecuted'>                emit LogRepay(msg.sender, user, borrowAmount, borrowPart);</span>
 598 |     | <span class='unexecuted'>                emit LogLiquidation(msg.sender, user, to, collateralShare, borrowAmount, borrowPart);</span>
 599 |     | <span class='neutral'></span>
 600 |     | <span class='neutral'>                // Keep totals</span>
 601 |     | <span class='unexecuted'>                allCollateralShare = allCollateralShare.add(collateralShare);</span>
 602 |     | <span class='unexecuted'>                allBorrowAmount = allBorrowAmount.add(borrowAmount);</span>
 603 |     | <span class='unexecuted'>                allBorrowPart = allBorrowPart.add(borrowPart);</span>
 604 |     | <span class='neutral'>            }</span>
 605 |     | <span class='neutral'>        }</span>
 606 |     | <span class='unexecuted'>        require(allBorrowAmount != 0, &quot;Cauldron: all are solvent&quot;);</span>
 607 |     | <span class='unexecuted'>        totalBorrow.elastic = totalBorrow.elastic.sub(allBorrowAmount.to128());</span>
 608 |     | <span class='unexecuted'>        totalBorrow.base = totalBorrow.base.sub(allBorrowPart.to128());</span>
 609 |     | <span class='unexecuted'>        totalCollateralShare = totalCollateralShare.sub(allCollateralShare);</span>
 610 |     | <span class='neutral'></span>
 611 |     | <span class='neutral'>        // Apply a percentual fee share to sSpell holders</span>
 612 |     | <span class='neutral'>        </span>
 613 |     | <span class='neutral'>        {</span>
 614 |     | <span class='unexecuted'>            uint256 distributionAmount = (allBorrowAmount.mul(LIQUIDATION_MULTIPLIER) / LIQUIDATION_MULTIPLIER_PRECISION).sub(allBorrowAmount).mul(DISTRIBUTION_PART) / DISTRIBUTION_PRECISION; // Distribution Amount</span>
 615 |     | <span class='unexecuted'>            allBorrowAmount = allBorrowAmount.add(distributionAmount);</span>
 616 |     | <span class='unexecuted'>            accrueInfo.feesEarned = accrueInfo.feesEarned.add(distributionAmount.to128());</span>
 617 |     | <span class='neutral'>        }</span>
 618 |     | <span class='neutral'></span>
 619 |     | <span class='unexecuted'>        uint256 allBorrowShare = bentoBox.toShare(magicInternetMoney, allBorrowAmount, true);</span>
 620 |     | <span class='neutral'></span>
 621 |     | <span class='neutral'>        // Swap using a swapper freely chosen by the caller</span>
 622 |     | <span class='neutral'>        // Open (flash) liquidation: get proceeds first and provide the borrow after</span>
 623 |     | <span class='unexecuted'>        bentoBox.transfer(collateral, address(this), to, allCollateralShare);</span>
 624 |     | <span class='unexecuted'>        if (swapper != ISwapperV2(address(0))) {</span>
 625 |     | <span class='unexecuted'>            swapper.swap(address(collateral), address(magicInternetMoney), msg.sender, allBorrowShare, allCollateralShare, swapperData);</span>
 626 |     | <span class='neutral'>        }</span>
 627 |     | <span class='neutral'></span>
 628 |     | <span class='unexecuted'>        allBorrowShare = bentoBox.toShare(magicInternetMoney, allBorrowAmount, true);</span>
 629 |     | <span class='unexecuted'>        bentoBox.transfer(magicInternetMoney, msg.sender, address(this), allBorrowShare);</span>
 630 |     | <span class='neutral'>    }</span>
 631 |     | <span class='neutral'></span>
 632 |     | <span class='neutral'>    /// @notice Withdraws the fees accumulated.</span>
 633 |     | <span class='unexecuted'>    function withdrawFees() public {</span>
 634 |     | <span class='unexecuted'>        accrue();</span>
 635 |     | <span class='unexecuted'>        address _feeTo = masterContract.feeTo();</span>
 636 |     | <span class='unexecuted'>        uint256 _feesEarned = accrueInfo.feesEarned;</span>
 637 |     | <span class='unexecuted'>        uint256 share = bentoBox.toShare(magicInternetMoney, _feesEarned, false);</span>
 638 |     | <span class='unexecuted'>        bentoBox.transfer(magicInternetMoney, address(this), _feeTo, share);</span>
 639 |     | <span class='unexecuted'>        accrueInfo.feesEarned = 0;</span>
 640 |     | <span class='neutral'></span>
 641 |     | <span class='unexecuted'>        emit LogWithdrawFees(_feeTo, _feesEarned);</span>
 642 |     | <span class='neutral'>    }</span>
 643 |     | <span class='neutral'></span>
 644 |     | <span class='neutral'>    /// @notice Sets the beneficiary of interest accrued.</span>
 645 |     | <span class='neutral'>    /// MasterContract Only Admin function.</span>
 646 |     | <span class='neutral'>    /// @param newFeeTo The address of the receiver.</span>
 647 |     | <span class='unexecuted'>    function setFeeTo(address newFeeTo) public onlyOwner {</span>
 648 |     | <span class='unexecuted'>        feeTo = newFeeTo;</span>
 649 |     | <span class='unexecuted'>        emit LogFeeTo(newFeeTo);</span>
 650 |     | <span class='neutral'>    }</span>
 651 |     | <span class='neutral'></span>
 652 |     | <span class='neutral'>    /// @notice reduces the supply of MIM</span>
 653 |     | <span class='neutral'>    /// @param amount amount to reduce supply by</span>
 654 |     | <span class='unexecuted'>    function reduceSupply(uint256 amount) public onlyMasterContractOwner {</span>
 655 |     | <span class='unexecuted'>        uint256 maxAmount = bentoBox.toAmount(magicInternetMoney, bentoBox.balanceOf(magicInternetMoney, address(this)), false);</span>
 656 |     | <span class='unexecuted'>        amount = maxAmount &gt; amount ? amount : maxAmount;</span>
 657 |     | <span class='unexecuted'>        bentoBox.withdraw(magicInternetMoney, address(this), msg.sender, amount, 0);</span>
 658 |     | <span class='neutral'>    }</span>
 659 |     | <span class='neutral'></span>
 660 |     | <span class='neutral'>    /// @notice allows to change the interest rate</span>
 661 |     | <span class='neutral'>    /// @param newInterestRate new interest rate</span>
 662 |     | <span class='unexecuted'>    function changeInterestRate(uint64 newInterestRate) public onlyMasterContractOwner {</span>
 663 |     | <span class='unexecuted'>        accrue();</span>
 664 |     | <span class='unexecuted'>        emit LogInterestChange(accrueInfo.INTEREST_PER_SECOND, newInterestRate);</span>
 665 |     | <span class='unexecuted'>        accrueInfo.INTEREST_PER_SECOND = newInterestRate;</span>
 666 |     | <span class='neutral'>    }</span>
 667 |     | <span class='neutral'></span>
 668 |     | <span class='neutral'>    /// @notice allows to change the borrow limit</span>
 669 |     | <span class='neutral'>    /// @param newBorrowLimit new borrow limit</span>
 670 |     | <span class='neutral'>    /// @param perAddressPart new borrow limit per address</span>
 671 |     | <span class='unexecuted'>    function changeBorrowLimit(uint128 newBorrowLimit, uint128 perAddressPart) public onlyMasterContractOwner {</span>
 672 |     | <span class='unexecuted'>        borrowLimit = BorrowCap(newBorrowLimit, perAddressPart);</span>
 673 |     | <span class='unexecuted'>        emit LogChangeBorrowLimit(newBorrowLimit, perAddressPart);</span>
 674 |     | <span class='neutral'>    }</span>
 675 |     | <span class='neutral'></span>
 676 |     | <span class='neutral'>    /// @notice allows to change blacklisted callees</span>
 677 |     | <span class='neutral'>    /// @param callee callee to blacklist or not</span>
 678 |     | <span class='neutral'>    /// @param blacklisted true when the callee cannot be used in call cook action</span>
 679 |     | <span class='unexecuted'>    function setBlacklistedCallee(address callee, bool blacklisted) public onlyMasterContractOwner {</span>
 680 |     | <span class='unexecuted'>        require(callee != address(bentoBox) &amp;&amp; callee != address(this), &quot;invalid callee&quot;);</span>
 681 |     | <span class='neutral'></span>
 682 |     | <span class='unexecuted'>        blacklistedCallees[callee] = blacklisted;</span>
 683 |     | <span class='unexecuted'>        emit LogChangeBlacklistedCallee(callee, blacklisted);</span>
 684 |     | <span class='neutral'>    }</span>
 685 |     | <span class='neutral'></span>
 686 |     | <span class='neutral'>    /// Allows to change the liquidation multiplier</span>
 687 |     | <span class='neutral'>    /// @param _liquidationMultiplier new liquidation multiplier.</span>
 688 |     | <span class='neutral'>    /// To convert from bips: liquidationFeeBips * 1e1 + 1e5</span>
 689 |     | <span class='unexecuted'>    function setLiquidationMultiplier(uint256 _liquidationMultiplier) public onlyMasterContractOwner {</span>
 690 |     | <span class='unexecuted'>        emit LogLiquidationMultiplierChanged(LIQUIDATION_MULTIPLIER, _liquidationMultiplier);</span>
 691 |     | <span class='unexecuted'>        LIQUIDATION_MULTIPLIER = _liquidationMultiplier;</span>
 692 |     | <span class='neutral'>    }</span>
 693 |     | <span class='neutral'></span>
 694 |     | <span class='neutral'>    /// Allows to change the borrow opening fee</span>
 695 |     | <span class='neutral'>    /// @param _borrowOpeningFee new borrow opening fee.</span>
 696 |     | <span class='neutral'>    /// To convert from bips: borrowOpeningFeeBips * 1e1</span>
 697 |     | <span class='unexecuted'>    function setBorrowOpeningFee(uint256 _borrowOpeningFee) public onlyMasterContractOwner {</span>
 698 |     | <span class='unexecuted'>        emit LogBorrowOpeningFeeChanged(BORROW_OPENING_FEE, _borrowOpeningFee);</span>
 699 |     | <span class='unexecuted'>        BORROW_OPENING_FEE = _borrowOpeningFee;</span>
 700 |     | <span class='neutral'>    }</span>
 701 |     | <span class='neutral'></span>
 702 |     | <span class='neutral'>    /// Allows to change the collateralization rate</span>
 703 |     | <span class='neutral'>    /// @param _collateralizationRate new collateralization rate.</span>
 704 |     | <span class='neutral'>    /// To convert from bips: collateralizationRateBips * 1e1</span>
 705 |     | <span class='unexecuted'>    function setCollateralizationRate(uint256 _collateralizationRate) public onlyMasterContractOwner {</span>
 706 |     | <span class='unexecuted'>        emit LogCollateralizationRateChanged(COLLATERIZATION_RATE, _collateralizationRate);</span>
 707 |     | <span class='unexecuted'>        COLLATERIZATION_RATE = _collateralizationRate;</span>
 708 |     | <span class='neutral'>    }</span>
 709 |     | <span class='neutral'>}</span>
 710 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/cauldrons/GmxV2CauldronV4.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {RebaseLibrary, Rebase} from &quot;BoringSolidity/libraries/BoringRebase.sol&quot;;</span>
   5 |     | <span class='neutral'>import {ISwapperV2} from &quot;interfaces/ISwapperV2.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
   8 |     | <span class='neutral'>import {CauldronV4} from &quot;cauldrons/CauldronV4.sol&quot;;</span>
   9 |     | <span class='neutral'>import {BoringMath, BoringMath128} from &quot;BoringSolidity/libraries/BoringMath.sol&quot;;</span>
  10 |     | <span class='neutral'>import {ICauldronV4GmxV2} from &quot;interfaces/ICauldronV4GmxV2.sol&quot;;</span>
  11 |     | <span class='neutral'>import {GmRouterOrderParams, IGmRouterOrder, IGmCauldronOrderAgent} from &quot;periphery/GmxV2CauldronOrderAgent.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>/// @notice Cauldron with both whitelisting and checkpointing token rewards on add/remove/liquidate collateral</span>
  14 |     | <span class='unexecuted'>contract GmxV2CauldronV4 is CauldronV4 {</span>
  15 |     | <span class='neutral'>    using BoringMath for uint256;</span>
  16 |     | <span class='neutral'>    using BoringMath128 for uint128;</span>
  17 |     | <span class='neutral'>    using RebaseLibrary for Rebase;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    event LogOrderAgentChanged(address indexed previous, address indexed current);</span>
  20 |     | <span class='neutral'>    event LogOrderCreated(address indexed user, address indexed order);</span>
  21 |     | <span class='neutral'>    event LogWithdrawFromOrder(address indexed user, address indexed token, address indexed to, uint256 amount, bool close);</span>
  22 |     | <span class='neutral'>    event LogOrderCanceled(address indexed user, address indexed order);</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    error ErrOrderAlreadyExists();</span>
  25 |     | <span class='neutral'>    error ErrOrderDoesNotExist();</span>
  26 |     | <span class='neutral'>    error ErrOrderNotFromUser();</span>
  27 |     | <span class='neutral'>    error ErrWhitelistedBorrowExceeded();</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    // ACTION no &lt; 10 to ensure ACCRUE is triggered</span>
  30 |     | <span class='unexecuted'>    uint8 public constant ACTION_WITHDRAW_FROM_ORDER = 9;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>    uint8 public constant ACTION_CREATE_ORDER = 3;</span>
  33 |     | <span class='unexecuted'>    uint8 public constant ACTION_CANCEL_ORDER = ACTION_CUSTOM_START_INDEX + 2;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    IGmCauldronOrderAgent public orderAgent;</span>
  36 |     | <span class='unexecuted'>    mapping(address =&gt; IGmRouterOrder) public orders;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    constructor(IBentoBoxV1 box, IERC20 mim) CauldronV4(box, mim) {}</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>    function setOrderAgent(IGmCauldronOrderAgent _orderAgent) public onlyMasterContractOwner {</span>
  41 |     | <span class='unexecuted'>        emit LogOrderAgentChanged(address(orderAgent), address(_orderAgent));</span>
  42 |     | <span class='unexecuted'>        orderAgent = _orderAgent;</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /// @notice Concrete implementation of `isSolvent`. Includes a second parameter to allow caching `exchangeRate`.</span>
  46 |     | <span class='neutral'>    /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.</span>
  47 |     | <span class='unexecuted'>    function _isSolvent(address user, uint256 _exchangeRate) internal view override returns (bool) {</span>
  48 |     | <span class='neutral'>        // accrue must have already been called!</span>
  49 |     | <span class='unexecuted'>        uint256 borrowPart = userBorrowPart[user];</span>
  50 |     | <span class='unexecuted'>        if (borrowPart == 0) return true;</span>
  51 |     | <span class='unexecuted'>        uint256 collateralShare = userCollateralShare[user];</span>
  52 |     | <span class='unexecuted'>        if (collateralShare == 0 &amp;&amp; orders[user] == IGmRouterOrder(address(0))) return false;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>        Rebase memory _totalBorrow = totalBorrow;</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>        uint256 amountToAdd;</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>        if (orders[user] != IGmRouterOrder(address(0))) {</span>
  59 |     | <span class='unexecuted'>            amountToAdd = orders[user].orderValueInCollateral();</span>
  60 |     | <span class='neutral'>        }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>        return</span>
  63 |     | <span class='unexecuted'>            bentoBox</span>
  64 |     | <span class='unexecuted'>                .toAmount(collateral, collateralShare, false)</span>
  65 |     | <span class='unexecuted'>                .add(amountToAdd)</span>
  66 |     | <span class='unexecuted'>                .mul(EXCHANGE_RATE_PRECISION / COLLATERIZATION_RATE_PRECISION)</span>
  67 |     | <span class='unexecuted'>                .mul(COLLATERIZATION_RATE) &gt;=</span>
  68 |     | <span class='neutral'>            // Moved exchangeRate here instead of dividing the other side to preserve more precision</span>
  69 |     | <span class='unexecuted'>            borrowPart.mul(_totalBorrow.elastic).mul(_exchangeRate) / _totalBorrow.base;</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>    function _additionalCookAction(</span>
  73 |     | <span class='neutral'>        uint8 action,</span>
  74 |     | <span class='neutral'>        CookStatus memory status,</span>
  75 |     | <span class='neutral'>        uint256 value,</span>
  76 |     | <span class='neutral'>        bytes memory data,</span>
  77 |     | <span class='neutral'>        uint256,</span>
  78 |     | <span class='neutral'>        uint256</span>
  79 |     | <span class='unexecuted'>    ) internal virtual override returns (bytes memory, uint8, CookStatus memory) {</span>
  80 |     | <span class='unexecuted'>        if (action == ACTION_WITHDRAW_FROM_ORDER) {</span>
  81 |     | <span class='unexecuted'>            (address token, address to, uint256 amount, bool close) = abi.decode(data, (address, address, uint256, bool));</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>            if (orders[msg.sender] == IGmRouterOrder(address(0))) {</span>
  84 |     | <span class='unexecuted'>                revert ErrOrderDoesNotExist();</span>
  85 |     | <span class='neutral'>            }</span>
  86 |     | <span class='unexecuted'>            orders[msg.sender].withdrawFromOrder(token, to, amount, close);</span>
  87 |     | <span class='unexecuted'>            status.needsSolvencyCheck = true;</span>
  88 |     | <span class='unexecuted'>            emit LogWithdrawFromOrder(msg.sender, token, to, amount, close);</span>
  89 |     | <span class='unexecuted'>        } else if (action == ACTION_CREATE_ORDER) {</span>
  90 |     | <span class='unexecuted'>            if (orders[msg.sender] != IGmRouterOrder(address(0))) {</span>
  91 |     | <span class='unexecuted'>                revert ErrOrderAlreadyExists();</span>
  92 |     | <span class='neutral'>            }</span>
  93 |     | <span class='unexecuted'>            GmRouterOrderParams memory params = abi.decode(data, (GmRouterOrderParams));</span>
  94 |     | <span class='unexecuted'>            orders[msg.sender] = IGmRouterOrder(orderAgent.createOrder{value: value}(msg.sender, params));</span>
  95 |     | <span class='unexecuted'>            blacklistedCallees[address(orders[msg.sender])] = true;</span>
  96 |     | <span class='unexecuted'>            status.needsSolvencyCheck = true;</span>
  97 |     | <span class='unexecuted'>            emit LogChangeBlacklistedCallee(address(orders[msg.sender]), true);</span>
  98 |     | <span class='unexecuted'>            emit LogOrderCreated(msg.sender, address(orders[msg.sender]));</span>
  99 |     | <span class='unexecuted'>        } else if (action == ACTION_CANCEL_ORDER) {</span>
 100 |     | <span class='unexecuted'>            if (orders[msg.sender] == IGmRouterOrder(address(0))) {</span>
 101 |     | <span class='unexecuted'>                revert ErrOrderDoesNotExist();</span>
 102 |     | <span class='neutral'>            }</span>
 103 |     | <span class='unexecuted'>            orders[msg.sender].cancelOrder();</span>
 104 |     | <span class='unexecuted'>            emit LogOrderCanceled(msg.sender, address(orders[msg.sender]));</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>        return (&quot;&quot;, 0, status);</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    /// @notice Handles the liquidation of users&#39; balances, once the users&#39; amount of collateral is too low.</span>
 111 |     | <span class='neutral'>    /// @param users An array of user addresses.</span>
 112 |     | <span class='neutral'>    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.</span>
 113 |     | <span class='neutral'>    /// @param to Address of the receiver in open liquidations if `swapper` is zero.</span>
 114 |     | <span class='unexecuted'>    function liquidate(</span>
 115 |     | <span class='neutral'>        address[] memory users,</span>
 116 |     | <span class='neutral'>        uint256[] memory maxBorrowParts,</span>
 117 |     | <span class='neutral'>        address to,</span>
 118 |     | <span class='neutral'>        ISwapperV2 swapper,</span>
 119 |     | <span class='neutral'>        bytes memory swapperData</span>
 120 |     | <span class='unexecuted'>    ) public virtual override {</span>
 121 |     | <span class='neutral'>        // Oracle can fail but we still need to allow liquidations</span>
 122 |     | <span class='unexecuted'>        (, uint256 _exchangeRate) = updateExchangeRate();</span>
 123 |     | <span class='unexecuted'>        accrue();</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>        uint256 allCollateralShare;</span>
 126 |     | <span class='neutral'>        uint256 allBorrowAmount;</span>
 127 |     | <span class='neutral'>        uint256 allBorrowPart;</span>
 128 |     | <span class='unexecuted'>        Rebase memory bentoBoxTotals = bentoBox.totals(collateral);</span>
 129 |     | <span class='neutral'>        _beforeUsersLiquidated(users, maxBorrowParts);</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; users.length; i++) {</span>
 132 |     | <span class='unexecuted'>            address user = users[i];</span>
 133 |     | <span class='unexecuted'>            if (!_isSolvent(user, _exchangeRate)) {</span>
 134 |     | <span class='neutral'>                // the user has an active order, cancel it before allowing liquidation</span>
 135 |     | <span class='unexecuted'>                if (orders[user] != IGmRouterOrder(address(0)) &amp;&amp; orders[user].isActive()) {</span>
 136 |     | <span class='unexecuted'>                    orders[user].cancelOrder();</span>
 137 |     | <span class='unexecuted'>                    emit LogOrderCanceled(user, address(orders[user]));</span>
 138 |     | <span class='neutral'>                }</span>
 139 |     | <span class='unexecuted'>                uint256 borrowPart;</span>
 140 |     | <span class='unexecuted'>                uint256 availableBorrowPart = userBorrowPart[user];</span>
 141 |     | <span class='unexecuted'>                borrowPart = maxBorrowParts[i] &gt; availableBorrowPart ? availableBorrowPart : maxBorrowParts[i];</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>                uint256 borrowAmount = totalBorrow.toElastic(borrowPart, false);</span>
 144 |     | <span class='unexecuted'>                uint256 collateralShare = bentoBoxTotals.toBase(</span>
 145 |     | <span class='unexecuted'>                    borrowAmount.mul(LIQUIDATION_MULTIPLIER).mul(_exchangeRate) /</span>
 146 |     | <span class='unexecuted'>                        (LIQUIDATION_MULTIPLIER_PRECISION * EXCHANGE_RATE_PRECISION),</span>
 147 |     | <span class='unexecuted'>                    false</span>
 148 |     | <span class='neutral'>                );</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>                _beforeUserLiquidated(user, borrowPart, borrowAmount, collateralShare);</span>
 151 |     | <span class='unexecuted'>                userBorrowPart[user] = availableBorrowPart.sub(borrowPart);</span>
 152 |     | <span class='unexecuted'>                if (collateralShare &gt; userCollateralShare[user] &amp;&amp; orders[user] != IGmRouterOrder(address(0))) {</span>
 153 |     | <span class='unexecuted'>                    orders[user].sendValueInCollateral(to, collateralShare - userCollateralShare[user]);</span>
 154 |     | <span class='unexecuted'>                    collateralShare = userCollateralShare[user];</span>
 155 |     | <span class='neutral'>                }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='unexecuted'>                userCollateralShare[user] = userCollateralShare[user].sub(collateralShare);</span>
 158 |     | <span class='neutral'>                _afterUserLiquidated(user, collateralShare);</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>                emit LogRemoveCollateral(user, to, collateralShare);</span>
 161 |     | <span class='unexecuted'>                emit LogRepay(msg.sender, user, borrowAmount, borrowPart);</span>
 162 |     | <span class='unexecuted'>                emit LogLiquidation(msg.sender, user, to, collateralShare, borrowAmount, borrowPart);</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>                // Keep totals</span>
 165 |     | <span class='unexecuted'>                allCollateralShare = allCollateralShare.add(collateralShare);</span>
 166 |     | <span class='unexecuted'>                allBorrowAmount = allBorrowAmount.add(borrowAmount);</span>
 167 |     | <span class='unexecuted'>                allBorrowPart = allBorrowPart.add(borrowPart);</span>
 168 |     | <span class='neutral'>            }</span>
 169 |     | <span class='neutral'>        }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>        require(allBorrowAmount != 0, &quot;Cauldron: all are solvent&quot;);</span>
 172 |     | <span class='unexecuted'>        totalBorrow.elastic = totalBorrow.elastic.sub(allBorrowAmount.to128());</span>
 173 |     | <span class='unexecuted'>        totalBorrow.base = totalBorrow.base.sub(allBorrowPart.to128());</span>
 174 |     | <span class='unexecuted'>        totalCollateralShare = totalCollateralShare.sub(allCollateralShare);</span>
 175 |     | <span class='neutral'>        // Apply a percentual fee share to sSpell holders</span>
 176 |     | <span class='neutral'>        {</span>
 177 |     | <span class='unexecuted'>            uint256 distributionAmount = (allBorrowAmount.mul(LIQUIDATION_MULTIPLIER) / LIQUIDATION_MULTIPLIER_PRECISION)</span>
 178 |     | <span class='unexecuted'>                .sub(allBorrowAmount)</span>
 179 |     | <span class='neutral'>                .mul(DISTRIBUTION_PART) / DISTRIBUTION_PRECISION; // Distribution Amount</span>
 180 |     | <span class='unexecuted'>            allBorrowAmount = allBorrowAmount.add(distributionAmount);</span>
 181 |     | <span class='unexecuted'>            accrueInfo.feesEarned = accrueInfo.feesEarned.add(distributionAmount.to128());</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='unexecuted'>        uint256 allBorrowShare = bentoBox.toShare(magicInternetMoney, allBorrowAmount, true);</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>        // Swap using a swapper freely chosen by the caller</span>
 187 |     | <span class='neutral'>        // Open (flash) liquidation: get proceeds first and provide the borrow after</span>
 188 |     | <span class='unexecuted'>        bentoBox.transfer(collateral, address(this), to, allCollateralShare);</span>
 189 |     | <span class='unexecuted'>        if (swapper != ISwapperV2(address(0))) {</span>
 190 |     | <span class='unexecuted'>            swapper.swap(address(collateral), address(magicInternetMoney), msg.sender, allBorrowShare, allCollateralShare, swapperData);</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='unexecuted'>        allBorrowShare = bentoBox.toShare(magicInternetMoney, allBorrowAmount, true);</span>
 194 |     | <span class='unexecuted'>        bentoBox.transfer(magicInternetMoney, msg.sender, address(this), allBorrowShare);</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='unexecuted'>    function closeOrder(address user) public {</span>
 198 |     | <span class='unexecuted'>        if (msg.sender != address(orders[user])) {</span>
 199 |     | <span class='unexecuted'>            revert ErrOrderNotFromUser();</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='unexecuted'>        blacklistedCallees[address(orders[user])] = false;</span>
 202 |     | <span class='unexecuted'>        orders[user] = IGmRouterOrder(address(0));</span>
 203 |     | <span class='neutral'>    }</span>
 204 |     | <span class='neutral'>}</span>
 205 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/cauldrons/PrivilegedCauldronV4.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  6 |     | <span class='neutral'>import {CauldronV4} from &quot;cauldrons/CauldronV4.sol&quot;;</span>
  7 |     | <span class='neutral'>import {RebaseLibrary, Rebase} from &quot;BoringSolidity/libraries/BoringRebase.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>contract PrivilegedCauldronV4 is CauldronV4 {</span>
 10 |     | <span class='neutral'>    using RebaseLibrary for Rebase;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    constructor(IBentoBoxV1 bentoBox_, IERC20 magicInternetMoney_) CauldronV4(bentoBox_, magicInternetMoney_) {}</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /// @dev masterContract Owner should call updateExchangeRate() before single or multiple call to this function</span>
 15 |     | <span class='unexecuted'>    function addBorrowPosition(address to, uint256 amount) external onlyMasterContractOwner returns (uint256 part) {</span>
 16 |     | <span class='unexecuted'>        (totalBorrow, part) = totalBorrow.add(amount, true);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>        userBorrowPart[to] = userBorrowPart[to] + part;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>        emit LogBorrow(msg.sender, to, amount, part);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>        require(_isSolvent(to, exchangeRate), &quot;Cauldron: user insolvent&quot;);</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/cauldrons/ProtocolOwnedDebtCauldron.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {RebaseLibrary, Rebase} from &quot;BoringSolidity/libraries/BoringRebase.sol&quot;;</span>
  5 |     | <span class='neutral'>import {BoringERC20, IERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BoringMath} from &quot;BoringSolidity/libraries/BoringMath.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  8 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>contract ProtocolOwnedDebtCauldron {</span>
 11 |     | <span class='neutral'>    using RebaseLibrary for Rebase;</span>
 12 |     | <span class='neutral'>    using BoringMath for uint256;</span>
 13 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    error ErrNotAllowed();</span>
 16 |     | <span class='neutral'>    event LogBorrow(address indexed from, address indexed to, uint256 amount, uint256 part);</span>
 17 |     | <span class='neutral'>    event LogRepay(address indexed from, address indexed to, uint256 amount, uint256 part);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    address public constant multisig = 0x5f0DeE98360d8200b20812e174d139A1a633EDd2;</span>
 20 |     | <span class='unexecuted'>    address public constant safe = 0xDF2C270f610Dc35d8fFDA5B453E74db5471E126B;</span>
 21 |     | <span class='unexecuted'>    IERC20 public constant magicInternetMoney = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);</span>
 22 |     | <span class='unexecuted'>    address public immutable masterContract;</span>
 23 |     | <span class='unexecuted'>    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    /// @dev compatibility with Cauldron interface</span>
 26 |     | <span class='neutral'>    IERC20 public constant collateral = magicInternetMoney;</span>
 27 |     | <span class='unexecuted'>    IOracle public constant oracle = IOracle(address(0));</span>
 28 |     | <span class='unexecuted'>    bytes public constant oracleData = &quot;&quot;;</span>
 29 |     | <span class='neutral'>    uint256 public constant totalCollateralShare = 0;</span>
 30 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public userCollateralShare;</span>
 31 |     | <span class='unexecuted'>    uint256 public constant exchangeRate = 0;</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public userBorrowPart;</span>
 34 |     | <span class='unexecuted'>    Rebase public totalBorrow;</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    modifier onlySafe() {</span>
 37 |     | <span class='unexecuted'>        if (msg.sender != safe) {</span>
 38 |     | <span class='unexecuted'>            revert ErrNotAllowed();</span>
 39 |     | <span class='neutral'>        }</span>
 40 |     | <span class='neutral'>        _;</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>    constructor() {</span>
 44 |     | <span class='unexecuted'>        masterContract = address(this);</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>    function accrueInfo() external pure returns (uint64 /*lastAccrued*/, uint128 /*feesEarned*/, uint64 /*INTEREST_PER_SECOND*/) {</span>
 48 |     | <span class='neutral'>        return (0, 0, 0);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>    function borrow(uint256 amount) external onlySafe returns (uint256 part) {</span>
 52 |     | <span class='unexecuted'>        (totalBorrow, part) = totalBorrow.add(amount, false);</span>
 53 |     | <span class='unexecuted'>        userBorrowPart[safe] = userBorrowPart[safe].add(part);</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>        magicInternetMoney.safeTransferFrom(multisig, safe, amount);</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='unexecuted'>        emit LogBorrow(safe, safe, amount, part);</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='unexecuted'>    function repay(uint256 part) external onlySafe returns (uint256 amount) {</span>
 61 |     | <span class='unexecuted'>        (totalBorrow, amount) = totalBorrow.sub(part, false);</span>
 62 |     | <span class='unexecuted'>        userBorrowPart[safe] = userBorrowPart[safe].sub(part);</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='unexecuted'>        magicInternetMoney.safeTransferFrom(safe, multisig, amount);</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='unexecuted'>        emit LogRepay(safe, safe, amount, part);</span>
 67 |     | <span class='neutral'>    }</span>
 68 |     | <span class='neutral'>}</span>
 69 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/cauldrons/WhitelistedCauldronV4.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {CauldronV4} from &quot;cauldrons/CauldronV4.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IWhitelister} from &quot;interfaces/IWhitelister.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  8 |     | <span class='neutral'>import {RebaseLibrary, Rebase} from &quot;BoringSolidity/libraries/BoringRebase.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>contract WhitelistedCauldronV4 is CauldronV4 {</span>
 11 |     | <span class='neutral'>    using RebaseLibrary for Rebase;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    error ErrWhitelistedBorrowExceeded();</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    uint8 public constant ACTION_SET_MAX_BORROW = ACTION_CUSTOM_START_INDEX + 1;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    IWhitelister public whitelister;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    constructor(IBentoBoxV1 bentoBox_, IERC20 magicInternetMoney_) CauldronV4(bentoBox_, magicInternetMoney_) {}</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    event LogChangeWhitelister(IWhitelister indexed newWhiteLister);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function _preBorrowAction(address, uint256, uint256 newBorrowPart, uint256) internal view override {</span>
 24 |     | <span class='unexecuted'>        if (whitelister != IWhitelister(address(0)) &amp;&amp; !whitelister.isBorrowingAllowed(msg.sender, newBorrowPart)) {</span>
 25 |     | <span class='unexecuted'>            revert ErrWhitelistedBorrowExceeded();</span>
 26 |     | <span class='neutral'>        }</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>    function _additionalCookAction(</span>
 30 |     | <span class='neutral'>        uint8 action,</span>
 31 |     | <span class='neutral'>        CookStatus memory status,</span>
 32 |     | <span class='neutral'>        uint256 /*value*/,</span>
 33 |     | <span class='neutral'>        bytes memory data,</span>
 34 |     | <span class='neutral'>        uint256 /*value1*/,</span>
 35 |     | <span class='neutral'>        uint256 /*value2*/</span>
 36 |     | <span class='unexecuted'>    ) internal virtual override returns (bytes memory /*returnData*/, uint8 /*returnValues*/, CookStatus memory /*updatedStatus*/) {</span>
 37 |     | <span class='unexecuted'>        if (action == ACTION_SET_MAX_BORROW) {</span>
 38 |     | <span class='unexecuted'>            (address user, uint256 maxBorrow, bytes32[] memory merkleProof) = abi.decode(data, (address, uint256, bytes32[]));</span>
 39 |     | <span class='unexecuted'>            whitelister.setMaxBorrow(user, maxBorrow, merkleProof);</span>
 40 |     | <span class='neutral'>        }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='unexecuted'>        return (&quot;&quot;, 0, status);</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    /// @notice allows to change the whitelister</span>
 46 |     | <span class='neutral'>    /// @param newWhiteLister new whitelisting address</span>
 47 |     | <span class='unexecuted'>    function changeWhitelister(IWhitelister newWhiteLister) public onlyMasterContractOwner {</span>
 48 |     | <span class='unexecuted'>        whitelister = newWhiteLister;</span>
 49 |     | <span class='unexecuted'>        emit LogChangeWhitelister(newWhiteLister);</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'>}</span>
 52 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/Fuzz.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./FuzzFactory.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./FuzzRouter.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./FuzzMagicLP.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @title Fuzz</span>
 10 |     | <span class='neutral'> * @author 0xScourgedev</span>
 11 |     | <span class='neutral'> * @notice Composite contract for all of the handlers</span>
 12 |     | <span class='neutral'> */</span>
 13 | *r  | <span class='executed'>contract Fuzz is FuzzFactory, FuzzRouter, FuzzMagicLP {</span>
 14 |     | <span class='neutral'>    constructor() payable {</span>
 15 |     | <span class='unexecuted'>        setup();</span>
 16 |     | <span class='unexecuted'>        setupActors();</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/FuzzFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./FuzzSetup.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./helper/preconditions/PreconditionsFactory.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./helper/postconditions/PostconditionsFactory.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./util/FunctionCalls.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @title FuzzFactory</span>
 11 |     | <span class='neutral'> * @author 0xScourgedev</span>
 12 |     | <span class='neutral'> * @notice Fuzz handlers for Factory</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='unexecuted'>contract FuzzFactory is PreconditionsFactory, PostconditionsFactory {</span>
 15 | *   | <span class='executed'>    function fuzz_create(uint8 baseToken_, uint8 quoteToken_, uint256 lpFeeRate_, uint256 i_, uint256 k_) public setCurrentActor {</span>
 16 | *   | <span class='executed'>        CreateParams memory params = createPreconditions(baseToken_, quoteToken_, lpFeeRate_, i_, k_);</span>
 17 |     | <span class='neutral'></span>
 18 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
 19 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
 20 |     | <span class='neutral'></span>
 21 | *   | <span class='executed'>        address[] memory poolsToUpdate = new address[](1);</span>
 22 |     | <span class='neutral'></span>
 23 | *   | <span class='executed'>        _before(actorsToUpdate, poolsToUpdate);</span>
 24 |     | <span class='neutral'></span>
 25 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _createCall(</span>
 26 | *   | <span class='executed'>            params.baseToken_,</span>
 27 | *   | <span class='executed'>            params.quoteToken_,</span>
 28 | *   | <span class='executed'>            params.lpFeeRate_,</span>
 29 | *   | <span class='executed'>            params.i_,</span>
 30 | *   | <span class='executed'>            params.k_</span>
 31 |     | <span class='neutral'>        );</span>
 32 |     | <span class='neutral'></span>
 33 | *   | <span class='executed'>        createPostconditions(success, returnData, actorsToUpdate, poolsToUpdate, params.baseToken_, params.quoteToken_);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'>}</span>
 36 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/FuzzMagicLP.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./FuzzSetup.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./helper/preconditions/PreconditionsMagicLP.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./helper/postconditions/PostconditionsMagicLP.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./util/FunctionCalls.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/**</span>
  10 |     | <span class='neutral'> * @title FuzzMagicLP</span>
  11 |     | <span class='neutral'> * @author 0xScourgedev</span>
  12 |     | <span class='neutral'> * @notice Fuzz handlers for MagicLP</span>
  13 |     | <span class='neutral'> */</span>
  14 |     | <span class='unexecuted'>contract FuzzMagicLP is PreconditionsMagicLP, PostconditionsMagicLP {</span>
  15 | *   | <span class='executed'>    function fuzz_buyShares(uint8 lp) public setCurrentActor {</span>
  16 | *   | <span class='executed'>        address lpAddr = buySharesPreconditions(lp);</span>
  17 |     | <span class='neutral'></span>
  18 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
  19 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
  20 |     | <span class='neutral'></span>
  21 | *   | <span class='executed'>        address[] memory poolsToUpdate = new address[](1);</span>
  22 | *   | <span class='executed'>        poolsToUpdate[0] = lpAddr;</span>
  23 |     | <span class='neutral'></span>
  24 | *   | <span class='executed'>        _before(actorsToUpdate, poolsToUpdate);</span>
  25 |     | <span class='neutral'></span>
  26 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _buySharesCall(lpAddr, currentActor);</span>
  27 |     | <span class='neutral'></span>
  28 | *   | <span class='executed'>        buySharesPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 | *   | <span class='executed'>    function fuzz_correctRState(uint8 lp) public setCurrentActor {</span>
  32 | *   | <span class='executed'>        address lpAddr = correctRStatePreconditions(lp);</span>
  33 |     | <span class='neutral'></span>
  34 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
  35 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
  36 |     | <span class='neutral'></span>
  37 | *   | <span class='executed'>        address[] memory poolsToUpdate = new address[](1);</span>
  38 | *   | <span class='executed'>        poolsToUpdate[0] = lpAddr;</span>
  39 |     | <span class='neutral'></span>
  40 | *   | <span class='executed'>        _before(actorsToUpdate, poolsToUpdate);</span>
  41 |     | <span class='neutral'></span>
  42 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _correctRStateCall(lpAddr);</span>
  43 |     | <span class='neutral'></span>
  44 | *   | <span class='executed'>        correctRStatePostconditions(success, returnData, actorsToUpdate, poolsToUpdate);</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 | *   | <span class='executed'>    function fuzz_sellBase(uint8 lp) public setCurrentActor {</span>
  48 | *   | <span class='executed'>        address lpAddr = sellBasePreconditions(lp);</span>
  49 |     | <span class='neutral'></span>
  50 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
  51 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
  52 |     | <span class='neutral'></span>
  53 | *   | <span class='executed'>        address[] memory poolsToUpdate = new address[](1);</span>
  54 | *   | <span class='executed'>        poolsToUpdate[0] = lpAddr;</span>
  55 |     | <span class='neutral'></span>
  56 | *   | <span class='executed'>        _before(actorsToUpdate, poolsToUpdate);</span>
  57 |     | <span class='neutral'></span>
  58 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _sellBaseCall(lpAddr, currentActor);</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>        sellBasePostconditions(success, returnData, actorsToUpdate, poolsToUpdate);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 | *   | <span class='executed'>    function fuzz_sellQuote(uint8 lp) public setCurrentActor {</span>
  64 | *   | <span class='executed'>        address lpAddr = sellQuotePreconditions(lp);</span>
  65 |     | <span class='neutral'></span>
  66 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
  67 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
  68 |     | <span class='neutral'></span>
  69 | *   | <span class='executed'>        address[] memory poolsToUpdate = new address[](1);</span>
  70 | *   | <span class='executed'>        poolsToUpdate[0] = lpAddr;</span>
  71 |     | <span class='neutral'></span>
  72 | *   | <span class='executed'>        _before(actorsToUpdate, poolsToUpdate);</span>
  73 |     | <span class='neutral'></span>
  74 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _sellQuoteCall(lpAddr, currentActor);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        sellQuotePostconditions(success, returnData, actorsToUpdate, poolsToUpdate);</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 | *   | <span class='executed'>    function fuzz_sellShares(</span>
  80 |     | <span class='neutral'>        uint256 shareAmount,</span>
  81 |     | <span class='neutral'>        uint8 lp,</span>
  82 |     | <span class='neutral'>        uint256 baseMinAmount,</span>
  83 |     | <span class='neutral'>        uint256 quoteMinAmount,</span>
  84 |     | <span class='neutral'>        uint256 deadline</span>
  85 |     | <span class='unexecuted'>    ) public setCurrentActor {</span>
  86 | *   | <span class='executed'>        SellSharesParams memory params = sellSharesPreconditions(shareAmount, lp, baseMinAmount, quoteMinAmount, deadline);</span>
  87 |     | <span class='neutral'></span>
  88 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
  89 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
  90 |     | <span class='neutral'></span>
  91 | *   | <span class='executed'>        address[] memory poolsToUpdate = new address[](1);</span>
  92 | *   | <span class='executed'>        poolsToUpdate[0] = params.lpAddr;</span>
  93 |     | <span class='neutral'></span>
  94 | *   | <span class='executed'>        _before(actorsToUpdate, poolsToUpdate);</span>
  95 |     | <span class='neutral'></span>
  96 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _sellSharesCall(</span>
  97 | *   | <span class='executed'>            params.lpAddr,</span>
  98 | *   | <span class='executed'>            params.shareAmount,</span>
  99 | *   | <span class='executed'>            currentActor,</span>
 100 | *   | <span class='executed'>            params.baseMinAmount,</span>
 101 | *   | <span class='executed'>            params.quoteMinAmount,</span>
 102 |     | <span class='neutral'>            &quot;&quot;,</span>
 103 | *   | <span class='executed'>            params.deadline</span>
 104 |     | <span class='neutral'>        );</span>
 105 |     | <span class='neutral'></span>
 106 | *   | <span class='executed'>        sellSharesPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 | *   | <span class='executed'>    function fuzz_sync(uint8 lp) public setCurrentActor {</span>
 110 | *   | <span class='executed'>        address lpAddr = syncPreconditions(lp);</span>
 111 |     | <span class='neutral'></span>
 112 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
 113 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
 114 |     | <span class='neutral'></span>
 115 | *   | <span class='executed'>        address[] memory poolsToUpdate = new address[](1);</span>
 116 | *   | <span class='executed'>        poolsToUpdate[0] = lpAddr;</span>
 117 |     | <span class='neutral'></span>
 118 | *   | <span class='executed'>        _before(actorsToUpdate, poolsToUpdate);</span>
 119 |     | <span class='neutral'></span>
 120 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _syncCall(lpAddr);</span>
 121 |     | <span class='neutral'></span>
 122 | *   | <span class='executed'>        syncPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 | *   | <span class='executed'>    function fuzz_transferSharesToLp(uint8 lp, uint256 amount) public setCurrentActor {</span>
 126 | *   | <span class='executed'>        TransferParams memory params = transferSharesToLpPreconditions(lp, amount);</span>
 127 |     | <span class='neutral'></span>
 128 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
 129 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
 130 |     | <span class='neutral'></span>
 131 | *   | <span class='executed'>        address[] memory poolsToUpdate = new address[](1);</span>
 132 | *   | <span class='executed'>        poolsToUpdate[0] = params.lpAddr;</span>
 133 |     | <span class='neutral'></span>
 134 | *   | <span class='executed'>        _before(actorsToUpdate, poolsToUpdate);</span>
 135 |     | <span class='neutral'></span>
 136 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _transferCall(params.lpAddr, params.lpAddr, params.amount);</span>
 137 |     | <span class='neutral'></span>
 138 | *   | <span class='executed'>        transferPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 | *   | <span class='executed'>    function fuzz_transferTokensToLp(uint8 lp, bool transferQuote, uint256 amount) public setCurrentActor {</span>
 142 | *   | <span class='executed'>        TransferTokensToLpParams memory params = transferTokensToLpPreconditions(lp, transferQuote, amount);</span>
 143 |     | <span class='neutral'></span>
 144 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
 145 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
 146 |     | <span class='neutral'></span>
 147 | *   | <span class='executed'>        address[] memory poolsToUpdate = new address[](1);</span>
 148 | *   | <span class='executed'>        poolsToUpdate[0] = params.lpAddr;</span>
 149 |     | <span class='neutral'></span>
 150 | *   | <span class='executed'>        _before(actorsToUpdate, poolsToUpdate);</span>
 151 |     | <span class='neutral'></span>
 152 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _transferCall(params.token, params.lpAddr, params.amount);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>        transferPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'>}</span>
 157 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/FuzzRouter.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./FuzzSetup.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./helper/preconditions/PreconditionsRouter.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./helper/postconditions/PostconditionsRouter.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./util/FunctionCalls.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/**</span>
  10 |     | <span class='neutral'> * @title FuzzRouter</span>
  11 |     | <span class='neutral'> * @author 0xScourgedev</span>
  12 |     | <span class='neutral'> * @notice Fuzz handlers for Router</span>
  13 |     | <span class='neutral'> */</span>
  14 |     | <span class='unexecuted'>contract FuzzRouter is PreconditionsRouter, PostconditionsRouter {</span>
  15 | *   | <span class='executed'>    function fuzz_addLiquidity(uint8 lp, uint256 baseInAmount, uint256 quoteInAmount, uint256 minimumShares) public setCurrentActor {</span>
  16 | *   | <span class='executed'>        AddLiquidityParams memory params = addLiquidityPreconditions(lp, baseInAmount, quoteInAmount, minimumShares);</span>
  17 |     | <span class='neutral'></span>
  18 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
  19 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
  20 |     | <span class='neutral'></span>
  21 | *   | <span class='executed'>        address[] memory poolsToUpdate = new address[](1);</span>
  22 | *   | <span class='executed'>        poolsToUpdate[0] = params.lpAddr;</span>
  23 |     | <span class='neutral'></span>
  24 | *   | <span class='executed'>        _before(actorsToUpdate, poolsToUpdate);</span>
  25 |     | <span class='neutral'></span>
  26 | *   | <span class='executed'>        (, , uint256 previewShares) = router.previewAddLiquidity(params.lpAddr, params.baseInAmount, params.quoteInAmount);</span>
  27 |     | <span class='neutral'></span>
  28 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _addLiquidityCall(</span>
  29 | *   | <span class='executed'>            params.lpAddr,</span>
  30 | *   | <span class='executed'>            currentActor,</span>
  31 | *   | <span class='executed'>            params.baseInAmount,</span>
  32 | *   | <span class='executed'>            params.quoteInAmount,</span>
  33 | *   | <span class='executed'>            params.minimumShares,</span>
  34 | *   | <span class='executed'>            type(uint32).max</span>
  35 |     | <span class='neutral'>        );</span>
  36 |     | <span class='neutral'></span>
  37 | *   | <span class='executed'>        addLiquidityPostconditions(success, returnData, actorsToUpdate, poolsToUpdate, previewShares);</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 | *   | <span class='executed'>    function fuzz_addLiquidityETH(uint8 lp, uint256 tokenInAmount, uint256 value, uint256 minimumShares) public setCurrentActor {</span>
  41 | *   | <span class='executed'>        AddLiquidityETHParams memory params = addLiquidityETHPreconditions(lp, tokenInAmount, value, minimumShares);</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>        address[] memory actorsToUpdate = new address[](1);</span>
  44 |     | <span class='unexecuted'>        actorsToUpdate[0] = currentActor;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>        address[] memory poolsToUpdate = new address[](1);</span>
  47 |     | <span class='unexecuted'>        poolsToUpdate[0] = params.lpAddr;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>        _before(actorsToUpdate, poolsToUpdate);</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>        address token = IMagicLP(params.lpAddr)._BASE_TOKEN_();</span>
  52 |     | <span class='unexecuted'>        uint256 previewShares;</span>
  53 |     | <span class='unexecuted'>        if (token == address(weth)) {</span>
  54 |     | <span class='unexecuted'>            (, , previewShares) = router.previewAddLiquidity(params.lpAddr, params.value, params.tokenInAmount);</span>
  55 |     | <span class='neutral'>        } else {</span>
  56 |     | <span class='unexecuted'>            (, , previewShares) = router.previewAddLiquidity(params.lpAddr, params.tokenInAmount, params.value);</span>
  57 |     | <span class='neutral'>        }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>        (bool success, bytes memory returnData) = _addLiquidityETHCall(</span>
  60 |     | <span class='unexecuted'>            params.lpAddr,</span>
  61 |     | <span class='unexecuted'>            currentActor,</span>
  62 |     | <span class='neutral'>            currentActor,</span>
  63 |     | <span class='unexecuted'>            params.tokenInAmount,</span>
  64 |     | <span class='unexecuted'>            params.value,</span>
  65 |     | <span class='unexecuted'>            params.minimumShares,</span>
  66 |     | <span class='unexecuted'>            type(uint32).max</span>
  67 |     | <span class='neutral'>        );</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>        addLiquidityETHPostconditions(success, returnData, actorsToUpdate, poolsToUpdate, previewShares);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 | *   | <span class='executed'>    function fuzz_addLiquidityETHUnsafe(uint8 lp, uint256 tokenInAmount, uint256 value, uint256 minimumShares) public setCurrentActor {</span>
  73 | *   | <span class='executed'>        AddLiquidityETHUnsafeParams memory params = addLiquidityETHUnsafePreconditions(lp, tokenInAmount, value, minimumShares);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>        address[] memory actorsToUpdate = new address[](1);</span>
  76 |     | <span class='unexecuted'>        actorsToUpdate[0] = currentActor;</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>        address[] memory poolsToUpdate = new address[](1);</span>
  79 |     | <span class='unexecuted'>        poolsToUpdate[0] = params.lpAddr;</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>        _before(actorsToUpdate, poolsToUpdate);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        address token = IMagicLP(params.lpAddr)._BASE_TOKEN_();</span>
  84 |     | <span class='unexecuted'>        uint256 previewShares;</span>
  85 |     | <span class='unexecuted'>        if (token == address(weth)) {</span>
  86 |     | <span class='unexecuted'>            (, , previewShares) = router.previewAddLiquidity(params.lpAddr, params.value, params.tokenInAmount);</span>
  87 |     | <span class='neutral'>        } else {</span>
  88 |     | <span class='unexecuted'>            (, , previewShares) = router.previewAddLiquidity(params.lpAddr, params.tokenInAmount, params.value);</span>
  89 |     | <span class='neutral'>        }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>        (bool success, bytes memory returnData) = _addLiquidityETHUnsafeCall(</span>
  92 |     | <span class='unexecuted'>            params.lpAddr,</span>
  93 |     | <span class='unexecuted'>            currentActor,</span>
  94 |     | <span class='unexecuted'>            params.tokenInAmount,</span>
  95 |     | <span class='unexecuted'>            params.value,</span>
  96 |     | <span class='unexecuted'>            params.minimumShares,</span>
  97 |     | <span class='unexecuted'>            type(uint32).max</span>
  98 |     | <span class='neutral'>        );</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>        addLiquidityETHUnsafePostconditions(success, returnData, actorsToUpdate, poolsToUpdate, previewShares);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 | *   | <span class='executed'>    function fuzz_addLiquidityUnsafe(uint8 lp, uint256 baseInAmount, uint256 quoteInAmount, uint256 minimumShares) public setCurrentActor {</span>
 104 | *   | <span class='executed'>        AddLiquidityUnsafeParams memory params = addLiquidityUnsafePreconditions(lp, baseInAmount, quoteInAmount, minimumShares);</span>
 105 |     | <span class='neutral'></span>
 106 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
 107 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
 108 |     | <span class='neutral'></span>
 109 | *   | <span class='executed'>        address[] memory poolsToUpdate = new address[](1);</span>
 110 | *   | <span class='executed'>        poolsToUpdate[0] = params.lpAddr;</span>
 111 |     | <span class='neutral'></span>
 112 | *   | <span class='executed'>        _before(actorsToUpdate, poolsToUpdate);</span>
 113 |     | <span class='neutral'></span>
 114 | *   | <span class='executed'>        (, , uint256 previewShares) = router.previewAddLiquidity(params.lpAddr, params.baseInAmount, params.quoteInAmount);</span>
 115 |     | <span class='neutral'></span>
 116 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _addLiquidityUnsafeCall(</span>
 117 | *   | <span class='executed'>            params.lpAddr,</span>
 118 | *   | <span class='executed'>            currentActor,</span>
 119 | *   | <span class='executed'>            params.baseInAmount,</span>
 120 | *   | <span class='executed'>            params.quoteInAmount,</span>
 121 | *   | <span class='executed'>            params.minimumShares,</span>
 122 | *   | <span class='executed'>            type(uint32).max</span>
 123 |     | <span class='neutral'>        );</span>
 124 |     | <span class='neutral'></span>
 125 | *   | <span class='executed'>        addLiquidityUnsafePostconditions(success, returnData, actorsToUpdate, poolsToUpdate, previewShares);</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'></span>
 128 | *   | <span class='executed'>    function fuzz_createPool(</span>
 129 |     | <span class='neutral'>        uint8 baseToken,</span>
 130 |     | <span class='neutral'>        uint8 quoteToken,</span>
 131 |     | <span class='neutral'>        uint256 lpFeeRate,</span>
 132 |     | <span class='neutral'>        uint256 i,</span>
 133 |     | <span class='neutral'>        uint256 k,</span>
 134 |     | <span class='neutral'>        uint256 baseInAmount,</span>
 135 |     | <span class='neutral'>        uint256 quoteInAmount</span>
 136 |     | <span class='neutral'>    ) public setCurrentActor {</span>
 137 | *   | <span class='executed'>        CreatePoolParams memory params = createPoolPreconditions(baseToken, quoteToken, lpFeeRate, i, k, baseInAmount, quoteInAmount);</span>
 138 |     | <span class='neutral'></span>
 139 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
 140 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
 141 |     | <span class='neutral'></span>
 142 | *   | <span class='executed'>        address[] memory poolsToUpdate = new address[](1);</span>
 143 |     | <span class='neutral'></span>
 144 | *   | <span class='executed'>        _before(actorsToUpdate, poolsToUpdate);</span>
 145 |     | <span class='neutral'></span>
 146 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _createPoolCall(</span>
 147 | *   | <span class='executed'>            params.baseToken,</span>
 148 | *   | <span class='executed'>            params.quoteToken,</span>
 149 | *   | <span class='executed'>            params.lpFeeRate,</span>
 150 | *   | <span class='executed'>            params.i,</span>
 151 | *   | <span class='executed'>            params.k,</span>
 152 | *   | <span class='executed'>            currentActor,</span>
 153 | *   | <span class='executed'>            params.baseInAmount,</span>
 154 | *   | <span class='executed'>            params.quoteInAmount</span>
 155 |     | <span class='neutral'>        );</span>
 156 |     | <span class='neutral'></span>
 157 | *   | <span class='executed'>        createPoolPostconditions(success, returnData, actorsToUpdate, poolsToUpdate, params.baseToken, params.quoteToken);</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 | *   | <span class='executed'>    function fuzz_createPoolETH(</span>
 161 |     | <span class='neutral'>        uint8 token,</span>
 162 |     | <span class='neutral'>        bool useTokenAsQuote,</span>
 163 |     | <span class='neutral'>        uint256 lpFeeRate,</span>
 164 |     | <span class='neutral'>        uint256 i,</span>
 165 |     | <span class='neutral'>        uint256 k,</span>
 166 |     | <span class='neutral'>        uint256 tokenInAmount,</span>
 167 |     | <span class='neutral'>        uint256 value</span>
 168 | *   | <span class='executed'>    ) public setCurrentActor {</span>
 169 | *   | <span class='executed'>        CreatePoolETHParams memory params = createPoolETHPreconditions(token, useTokenAsQuote, lpFeeRate, i, k, tokenInAmount, value);</span>
 170 |     | <span class='neutral'></span>
 171 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
 172 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
 173 |     | <span class='neutral'></span>
 174 | *   | <span class='executed'>        address[] memory poolsToUpdate = new address[](1);</span>
 175 |     | <span class='neutral'></span>
 176 | *   | <span class='executed'>        _before(actorsToUpdate, poolsToUpdate);</span>
 177 |     | <span class='neutral'></span>
 178 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _createPoolETHCall(</span>
 179 | *   | <span class='executed'>            params.token,</span>
 180 | *   | <span class='executed'>            params.useTokenAsQuote,</span>
 181 | *   | <span class='executed'>            params.lpFeeRate,</span>
 182 | *   | <span class='executed'>            params.i,</span>
 183 | *   | <span class='executed'>            params.k,</span>
 184 | *   | <span class='executed'>            currentActor,</span>
 185 | *   | <span class='executed'>            params.tokenInAmount,</span>
 186 | *   | <span class='executed'>            params.value</span>
 187 |     | <span class='neutral'>        );</span>
 188 |     | <span class='neutral'></span>
 189 | *   | <span class='executed'>        createPoolETHPostconditions(success, returnData, actorsToUpdate, poolsToUpdate, params.token);</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 | *   | <span class='executed'>    function fuzz_removeLiquidity(</span>
 193 |     | <span class='neutral'>        uint8 lp,</span>
 194 |     | <span class='neutral'>        uint256 sharesIn,</span>
 195 |     | <span class='neutral'>        uint256 minimumBaseAmount,</span>
 196 |     | <span class='neutral'>        uint256 minimumQuoteAmount</span>
 197 | *   | <span class='executed'>    ) public setCurrentActor {</span>
 198 | *   | <span class='executed'>        RemoveLiquidityParams memory params = removeLiquidityPreconditions(lp, sharesIn, minimumBaseAmount, minimumQuoteAmount);</span>
 199 |     | <span class='neutral'></span>
 200 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
 201 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
 202 |     | <span class='neutral'></span>
 203 | *   | <span class='executed'>        address[] memory poolsToUpdate = new address[](1);</span>
 204 | *   | <span class='executed'>        poolsToUpdate[0] = params.lpAddr;</span>
 205 |     | <span class='neutral'></span>
 206 | *   | <span class='executed'>        _before(actorsToUpdate, poolsToUpdate);</span>
 207 |     | <span class='neutral'></span>
 208 | *r  | <span class='executed'>        (uint256 previewBase, uint256 previewQuote) = router.previewRemoveLiquidity(params.lpAddr, params.sharesIn);</span>
 209 |     | <span class='neutral'></span>
 210 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _removeLiquidityCall(</span>
 211 | *   | <span class='executed'>            params.lpAddr,</span>
 212 | *   | <span class='executed'>            currentActor,</span>
 213 | *   | <span class='executed'>            params.sharesIn,</span>
 214 | *   | <span class='executed'>            params.minimumBaseAmount,</span>
 215 | *   | <span class='executed'>            params.minimumQuoteAmount,</span>
 216 | *   | <span class='executed'>            type(uint32).max</span>
 217 |     | <span class='neutral'>        );</span>
 218 |     | <span class='neutral'></span>
 219 | *   | <span class='executed'>        removeLiquidityPostconditions(success, returnData, actorsToUpdate, poolsToUpdate, params.sharesIn, previewBase, previewQuote);</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 | *   | <span class='executed'>    function fuzz_removeLiquidityETH(</span>
 223 |     | <span class='neutral'>        uint8 lp,</span>
 224 |     | <span class='neutral'>        uint256 sharesIn,</span>
 225 |     | <span class='neutral'>        uint256 minimumETHAmount,</span>
 226 |     | <span class='neutral'>        uint256 minimumTokenAmount</span>
 227 |     | <span class='neutral'>    ) public setCurrentActor {</span>
 228 | *   | <span class='executed'>        RemoveLiquidityETHParams memory params = removeLiquidityETHPreconditions(lp, sharesIn, minimumETHAmount, minimumTokenAmount);</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='unexecuted'>        address[] memory actorsToUpdate = new address[](1);</span>
 231 |     | <span class='unexecuted'>        actorsToUpdate[0] = currentActor;</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='unexecuted'>        address[] memory poolsToUpdate = new address[](1);</span>
 234 |     | <span class='unexecuted'>        poolsToUpdate[0] = params.lpAddr;</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='unexecuted'>        _before(actorsToUpdate, poolsToUpdate);</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='unexecuted'>        (bool success, bytes memory returnData) = _removeLiquidityETHCall(</span>
 239 |     | <span class='unexecuted'>            params.lpAddr,</span>
 240 |     | <span class='unexecuted'>            currentActor,</span>
 241 |     | <span class='unexecuted'>            params.sharesIn,</span>
 242 |     | <span class='unexecuted'>            params.minimumETHAmount,</span>
 243 |     | <span class='unexecuted'>            params.minimumTokenAmount,</span>
 244 |     | <span class='unexecuted'>            type(uint32).max</span>
 245 |     | <span class='neutral'>        );</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='unexecuted'>        removeLiquidityETHPostconditions(success, returnData, actorsToUpdate, poolsToUpdate, params.sharesIn);</span>
 248 |     | <span class='neutral'>    }</span>
 249 |     | <span class='neutral'></span>
 250 | *   | <span class='executed'>    function fuzz_previewAddLiquidity(uint8 lp, uint256 baseInAmount, uint256 quoteInAmount) public setCurrentActor {</span>
 251 | *   | <span class='executed'>        PreviewAddLiquidityParams memory params = previewAddLiquidityPreconditions(lp, baseInAmount, quoteInAmount);</span>
 252 |     | <span class='neutral'></span>
 253 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _previewAddLiquidityCall(params.lpAddr, params.baseInAmount, params.quoteInAmount);</span>
 254 |     | <span class='neutral'></span>
 255 | *   | <span class='executed'>        previewAddLiquidityPostconditions(success, returnData);</span>
 256 |     | <span class='neutral'>    }</span>
 257 |     | <span class='neutral'></span>
 258 | *   | <span class='executed'>    function fuzz_previewRemoveLiquidity(uint8 lp, uint256 sharesIn) public setCurrentActor {</span>
 259 | *   | <span class='executed'>        PreviewRemoveLiquidityParams memory params = previewRemoveLiquidityPreconditions(lp, sharesIn);</span>
 260 |     | <span class='neutral'></span>
 261 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _previewRemoveLiquidityCall(params.lpAddr, params.sharesIn);</span>
 262 |     | <span class='neutral'></span>
 263 | *   | <span class='executed'>        previewRemoveLiquidityPostconditions(success, returnData, params.lpAddr);</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 | *   | <span class='executed'>    function fuzz_sellBaseETHForTokens(uint8 lp, uint256 minimumOut, uint256 value) public setCurrentActor {</span>
 267 | *   | <span class='executed'>        SellBaseETHForTokensParams memory params = sellBaseETHForTokensPreconditions(lp, minimumOut, value);</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='unexecuted'>        address[] memory actorsToUpdate = new address[](1);</span>
 270 |     | <span class='unexecuted'>        actorsToUpdate[0] = currentActor;</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='unexecuted'>        address[] memory poolsToUpdate = new address[](1);</span>
 273 |     | <span class='unexecuted'>        poolsToUpdate[0] = params.lpAddr;</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='unexecuted'>        _before(actorsToUpdate, poolsToUpdate);</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>        (bool success, bytes memory returnData) = _sellBaseETHForTokensCall(</span>
 278 |     | <span class='unexecuted'>            params.lpAddr,</span>
 279 |     | <span class='unexecuted'>            currentActor,</span>
 280 |     | <span class='unexecuted'>            params.minimumOut,</span>
 281 |     | <span class='unexecuted'>            type(uint32).max,</span>
 282 |     | <span class='unexecuted'>            params.value</span>
 283 |     | <span class='neutral'>        );</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>        sellBaseETHForTokensPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);</span>
 286 |     | <span class='neutral'>    }</span>
 287 |     | <span class='neutral'></span>
 288 | *   | <span class='executed'>    function fuzz_sellBaseTokensForETH(uint8 lp, uint256 amountIn, uint256 minimumOut) public setCurrentActor {</span>
 289 | *   | <span class='executed'>        SellBaseTokensForETHParams memory params = sellBaseTokensForETHPreconditions(lp, amountIn, minimumOut);</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='unexecuted'>        address[] memory actorsToUpdate = new address[](1);</span>
 292 |     | <span class='unexecuted'>        actorsToUpdate[0] = currentActor;</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='unexecuted'>        address[] memory poolsToUpdate = new address[](1);</span>
 295 |     | <span class='unexecuted'>        poolsToUpdate[0] = params.lpAddr;</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='unexecuted'>        _before(actorsToUpdate, poolsToUpdate);</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='unexecuted'>        (bool success, bytes memory returnData) = _sellBaseTokensForETHCall(</span>
 300 |     | <span class='unexecuted'>            params.lpAddr,</span>
 301 |     | <span class='unexecuted'>            currentActor,</span>
 302 |     | <span class='unexecuted'>            params.amountIn,</span>
 303 |     | <span class='unexecuted'>            params.minimumOut,</span>
 304 |     | <span class='unexecuted'>            type(uint32).max</span>
 305 |     | <span class='neutral'>        );</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='neutral'>        sellBaseTokensForETHPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);</span>
 308 |     | <span class='neutral'>    }</span>
 309 |     | <span class='neutral'></span>
 310 | *   | <span class='executed'>    function fuzz_sellBaseTokensForTokens(uint8 lp, uint256 amountIn, uint256 minimumOut) public setCurrentActor {</span>
 311 | *   | <span class='executed'>        SellBaseTokensForTokensParams memory params = sellBaseTokensForTokensPreconditions(lp, amountIn, minimumOut);</span>
 312 |     | <span class='neutral'></span>
 313 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
 314 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
 315 |     | <span class='neutral'></span>
 316 | *   | <span class='executed'>        address[] memory poolsToUpdate = new address[](1);</span>
 317 | *   | <span class='executed'>        poolsToUpdate[0] = params.lpAddr;</span>
 318 |     | <span class='neutral'></span>
 319 | *   | <span class='executed'>        _before(actorsToUpdate, poolsToUpdate);</span>
 320 |     | <span class='neutral'></span>
 321 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _sellBaseTokensForTokensCall(</span>
 322 | *   | <span class='executed'>            params.lpAddr,</span>
 323 | *   | <span class='executed'>            currentActor,</span>
 324 | *   | <span class='executed'>            params.amountIn,</span>
 325 | *   | <span class='executed'>            params.minimumOut,</span>
 326 | *   | <span class='executed'>            type(uint32).max</span>
 327 |     | <span class='neutral'>        );</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='neutral'>        sellBaseTokensForTokensPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);</span>
 330 |     | <span class='neutral'>    }</span>
 331 |     | <span class='neutral'></span>
 332 | *   | <span class='executed'>    function fuzz_sellQuoteETHForTokens(uint8 lp, uint256 minimumOut, uint256 value) public setCurrentActor {</span>
 333 | *   | <span class='executed'>        SellQuoteETHForTokensParams memory params = sellQuoteETHForTokensPreconditions(lp, minimumOut, value);</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='unexecuted'>        address[] memory actorsToUpdate = new address[](1);</span>
 336 |     | <span class='unexecuted'>        actorsToUpdate[0] = currentActor;</span>
 337 |     | <span class='neutral'></span>
 338 |     | <span class='unexecuted'>        address[] memory poolsToUpdate = new address[](1);</span>
 339 |     | <span class='unexecuted'>        poolsToUpdate[0] = params.lpAddr;</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='unexecuted'>        _before(actorsToUpdate, poolsToUpdate);</span>
 342 |     | <span class='neutral'></span>
 343 |     | <span class='unexecuted'>        (bool success, bytes memory returnData) = _sellQuoteETHForTokensCall(</span>
 344 |     | <span class='unexecuted'>            params.lpAddr,</span>
 345 |     | <span class='unexecuted'>            currentActor,</span>
 346 |     | <span class='unexecuted'>            params.minimumOut,</span>
 347 |     | <span class='unexecuted'>            type(uint32).max,</span>
 348 |     | <span class='unexecuted'>            params.value</span>
 349 |     | <span class='neutral'>        );</span>
 350 |     | <span class='neutral'></span>
 351 |     | <span class='neutral'>        sellQuoteETHForTokensPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);</span>
 352 |     | <span class='neutral'>    }</span>
 353 |     | <span class='neutral'></span>
 354 | *   | <span class='executed'>    function fuzz_sellQuoteTokensForETH(uint8 lp, uint256 amountIn, uint256 minimumOut) public setCurrentActor {</span>
 355 | *   | <span class='executed'>        SellQuoteTokensForETHParams memory params = sellQuoteTokensForETHPreconditions(lp, amountIn, minimumOut);</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='unexecuted'>        address[] memory actorsToUpdate = new address[](1);</span>
 358 |     | <span class='unexecuted'>        actorsToUpdate[0] = currentActor;</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='unexecuted'>        address[] memory poolsToUpdate = new address[](1);</span>
 361 |     | <span class='unexecuted'>        poolsToUpdate[0] = params.lpAddr;</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='unexecuted'>        _before(actorsToUpdate, poolsToUpdate);</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='unexecuted'>        (bool success, bytes memory returnData) = _sellQuoteTokensForETHCall(</span>
 366 |     | <span class='unexecuted'>            params.lpAddr,</span>
 367 |     | <span class='unexecuted'>            currentActor,</span>
 368 |     | <span class='unexecuted'>            params.amountIn,</span>
 369 |     | <span class='unexecuted'>            params.minimumOut,</span>
 370 |     | <span class='unexecuted'>            type(uint32).max</span>
 371 |     | <span class='neutral'>        );</span>
 372 |     | <span class='neutral'></span>
 373 |     | <span class='neutral'>        sellQuoteTokensForETHPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);</span>
 374 |     | <span class='neutral'>    }</span>
 375 |     | <span class='neutral'></span>
 376 | *   | <span class='executed'>    function fuzz_sellQuoteTokensForTokens(uint8 lp, uint256 amountIn, uint256 minimumOut) public setCurrentActor {</span>
 377 | *   | <span class='executed'>        SellQuoteTokensForTokensParams memory params = sellQuoteTokensForTokensPreconditions(lp, amountIn, minimumOut);</span>
 378 |     | <span class='neutral'></span>
 379 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
 380 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
 381 |     | <span class='neutral'></span>
 382 | *   | <span class='executed'>        address[] memory poolsToUpdate = new address[](1);</span>
 383 | *   | <span class='executed'>        poolsToUpdate[0] = params.lpAddr;</span>
 384 |     | <span class='neutral'></span>
 385 | *   | <span class='executed'>        _before(actorsToUpdate, poolsToUpdate);</span>
 386 |     | <span class='neutral'></span>
 387 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _sellQuoteTokensForTokensCall(</span>
 388 | *   | <span class='executed'>            params.lpAddr,</span>
 389 | *   | <span class='executed'>            currentActor,</span>
 390 | *   | <span class='executed'>            params.amountIn,</span>
 391 | *   | <span class='executed'>            params.minimumOut,</span>
 392 | *   | <span class='executed'>            type(uint32).max</span>
 393 |     | <span class='neutral'>        );</span>
 394 |     | <span class='neutral'></span>
 395 | *   | <span class='executed'>        sellQuoteTokensForTokensPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);</span>
 396 |     | <span class='neutral'>    }</span>
 397 |     | <span class='neutral'></span>
 398 | *   | <span class='executed'>    function fuzz_swapETHForTokens(</span>
 399 |     | <span class='neutral'>        uint8 entropy,</span>
 400 |     | <span class='neutral'>        uint8 pathLength,</span>
 401 |     | <span class='neutral'>        uint256 directions,</span>
 402 |     | <span class='neutral'>        uint256 minimumOut,</span>
 403 |     | <span class='neutral'>        uint256 value</span>
 404 |     | <span class='neutral'>    ) public setCurrentActor {</span>
 405 | *   | <span class='executed'>        SwapETHForTokensParams memory params = swapETHForTokensPreconditions(entropy, pathLength, directions, minimumOut, value);</span>
 406 |     | <span class='neutral'></span>
 407 |     | <span class='unexecuted'>        address[] memory actorsToUpdate = new address[](1);</span>
 408 |     | <span class='unexecuted'>        actorsToUpdate[0] = currentActor;</span>
 409 |     | <span class='neutral'></span>
 410 |     | <span class='unexecuted'>        _before(actorsToUpdate, params.path);</span>
 411 |     | <span class='neutral'></span>
 412 |     | <span class='unexecuted'>        (bool success, bytes memory returnData) = _swapETHForTokensCall(</span>
 413 |     | <span class='unexecuted'>            currentActor,</span>
 414 |     | <span class='unexecuted'>            params.path,</span>
 415 |     | <span class='unexecuted'>            params.directions,</span>
 416 |     | <span class='unexecuted'>            params.minimumOut,</span>
 417 |     | <span class='unexecuted'>            type(uint32).max,</span>
 418 |     | <span class='unexecuted'>            params.value</span>
 419 |     | <span class='neutral'>        );</span>
 420 |     | <span class='neutral'></span>
 421 |     | <span class='unexecuted'>        swapETHForTokensPostconditions(success, returnData, actorsToUpdate, params.path, params.directions, params.minimumOut);</span>
 422 |     | <span class='neutral'>    }</span>
 423 |     | <span class='neutral'></span>
 424 | *   | <span class='executed'>    function fuzz_swapTokensForETH(</span>
 425 |     | <span class='neutral'>        uint256 amountIn,</span>
 426 |     | <span class='neutral'>        uint8 entropy,</span>
 427 |     | <span class='neutral'>        uint8 pathLength,</span>
 428 |     | <span class='neutral'>        uint256 directions,</span>
 429 |     | <span class='neutral'>        uint256 minimumOut</span>
 430 |     | <span class='unexecuted'>    ) public setCurrentActor {</span>
 431 | *   | <span class='executed'>        SwapTokensForETHParams memory params = swapTokensForETHPreconditions(amountIn, entropy, pathLength, directions, minimumOut);</span>
 432 |     | <span class='neutral'></span>
 433 |     | <span class='unexecuted'>        address[] memory actorsToUpdate = new address[](1);</span>
 434 |     | <span class='unexecuted'>        actorsToUpdate[0] = currentActor;</span>
 435 |     | <span class='neutral'></span>
 436 |     | <span class='unexecuted'>        _before(actorsToUpdate, params.path);</span>
 437 |     | <span class='neutral'></span>
 438 |     | <span class='unexecuted'>        (bool success, bytes memory returnData) = _swapTokensForETHCall(</span>
 439 |     | <span class='unexecuted'>            currentActor,</span>
 440 |     | <span class='unexecuted'>            params.amountIn,</span>
 441 |     | <span class='unexecuted'>            params.path,</span>
 442 |     | <span class='unexecuted'>            params.directions,</span>
 443 |     | <span class='unexecuted'>            params.minimumOut,</span>
 444 |     | <span class='unexecuted'>            type(uint32).max</span>
 445 |     | <span class='neutral'>        );</span>
 446 |     | <span class='neutral'></span>
 447 |     | <span class='unexecuted'>        swapTokensForETHPostconditions(success, returnData, actorsToUpdate, params.path, params.directions, params.minimumOut);</span>
 448 |     | <span class='neutral'>    }</span>
 449 |     | <span class='neutral'></span>
 450 | *   | <span class='executed'>    function fuzz_swapTokensForTokens(</span>
 451 |     | <span class='neutral'>        uint8 startingToken,</span>
 452 |     | <span class='neutral'>        uint256 amountIn,</span>
 453 |     | <span class='neutral'>        uint8 entropy,</span>
 454 |     | <span class='neutral'>        uint8 pathLength,</span>
 455 |     | <span class='neutral'>        uint256 directions,</span>
 456 |     | <span class='neutral'>        uint256 minimumOut</span>
 457 |     | <span class='neutral'>    ) public setCurrentActor {</span>
 458 | *   | <span class='executed'>        SwapTokensForTokensParams memory params = swapTokensForTokensPreconditions(</span>
 459 | *   | <span class='executed'>            startingToken,</span>
 460 | *   | <span class='executed'>            amountIn,</span>
 461 | *   | <span class='executed'>            entropy,</span>
 462 | *   | <span class='executed'>            pathLength,</span>
 463 | *   | <span class='executed'>            directions,</span>
 464 | *   | <span class='executed'>            minimumOut</span>
 465 |     | <span class='neutral'>        );</span>
 466 |     | <span class='neutral'></span>
 467 |     | <span class='unexecuted'>        address[] memory actorsToUpdate = new address[](1);</span>
 468 |     | <span class='unexecuted'>        actorsToUpdate[0] = currentActor;</span>
 469 |     | <span class='neutral'></span>
 470 |     | <span class='unexecuted'>        _before(actorsToUpdate, params.path);</span>
 471 |     | <span class='neutral'></span>
 472 |     | <span class='unexecuted'>        (bool success, bytes memory returnData) = _swapTokensForTokensCall(</span>
 473 |     | <span class='unexecuted'>            currentActor,</span>
 474 |     | <span class='unexecuted'>            params.amountIn,</span>
 475 |     | <span class='unexecuted'>            params.path,</span>
 476 |     | <span class='unexecuted'>            params.directions,</span>
 477 |     | <span class='unexecuted'>            params.minimumOut,</span>
 478 |     | <span class='unexecuted'>            type(uint32).max</span>
 479 |     | <span class='neutral'>        );</span>
 480 |     | <span class='neutral'></span>
 481 |     | <span class='unexecuted'>        swapTokensForTokensPostconditions(success, returnData, actorsToUpdate, params.path, params.directions, params.minimumOut);</span>
 482 |     | <span class='neutral'>    }</span>
 483 |     | <span class='neutral'>}</span>
 484 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/FuzzSetup.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;fuzzlib/FuzzBase.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./helper/FuzzStorageVariables.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @title FuzzSetup</span>
 10 |     | <span class='neutral'> * @author 0xScourgedev</span>
 11 |     | <span class='neutral'> * @notice Setup for the fuzzing suite</span>
 12 |     | <span class='neutral'> */</span>
 13 |     | <span class='unexecuted'>contract FuzzSetup is FuzzBase, FuzzStorageVariables {</span>
 14 |     | <span class='unexecuted'>    function setup() internal {</span>
 15 |     | <span class='unexecuted'>        weth = new MockWETH(&quot;Wrapped ETH&quot;, &quot;WETH&quot;);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>        feeRateModelImpl = new FeeRateModelImpl();</span>
 18 |     | <span class='unexecuted'>        feeRateModel = new FeeRateModel(address(this), address(this));</span>
 19 |     | <span class='unexecuted'>        marketImpl = new MagicLP(address(this));</span>
 20 |     | <span class='unexecuted'>        factory = new Factory(address(marketImpl), IFeeRateModel(address(feeRateModel)), address(this));</span>
 21 |     | <span class='unexecuted'>        router = new Router(IWETH(address(weth)), IFactory(address(factory)));</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>        tokenA18 = new MockERC20(&quot;TokenA18&quot;, &quot;TKA18&quot;, 18);</span>
 24 |     | <span class='unexecuted'>        tokenB18 = new MockERC20(&quot;TokenB18&quot;, &quot;TKB18&quot;, 18);</span>
 25 |     | <span class='unexecuted'>        tokenA6 = new MockERC20(&quot;TokenA6&quot;, &quot;TKA6&quot;, 6);</span>
 26 |     | <span class='unexecuted'>        tokenB6 = new MockERC20(&quot;TokenB6&quot;, &quot;TKB6&quot;, 6);</span>
 27 |     | <span class='unexecuted'>        tokenA8 = new MockERC20(&quot;TokenA8&quot;, &quot;TKA8&quot;, 8);</span>
 28 |     | <span class='unexecuted'>        tokenB8 = new MockERC20(&quot;TokenB8&quot;, &quot;TKB8&quot;, 8);</span>
 29 |     | <span class='unexecuted'>        tokenA24 = new MockERC20(&quot;tokenA24&quot;, &quot;TKA24&quot;, 24);</span>
 30 |     | <span class='unexecuted'>        tokenB24 = new MockERC20(&quot;tokenB24&quot;, &quot;TKB24&quot;, 24);</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='unexecuted'>    function setupActors() internal {</span>
 34 |     | <span class='unexecuted'>        bool success;</span>
 35 |     | <span class='unexecuted'>        address[] memory targets = new address[](2);</span>
 36 |     | <span class='unexecuted'>        targets[0] = address(factory);</span>
 37 |     | <span class='unexecuted'>        targets[1] = address(router);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>        tokens.push(tokenA18);</span>
 40 |     | <span class='unexecuted'>        tokens.push(tokenB18);</span>
 41 |     | <span class='unexecuted'>        tokens.push(tokenA6);</span>
 42 |     | <span class='unexecuted'>        tokens.push(tokenB6);</span>
 43 |     | <span class='unexecuted'>        tokens.push(tokenA8);</span>
 44 |     | <span class='unexecuted'>        tokens.push(tokenB8);</span>
 45 |     | <span class='unexecuted'>        tokens.push(tokenA24);</span>
 46 |     | <span class='unexecuted'>        tokens.push(tokenB24);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>        (success, ) = address(weth).call{value: INITIAL_WETH_BALANCE * USERS.length}(&quot;&quot;);</span>
 49 |     | <span class='unexecuted'>        assert(success);</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>        for (uint8 i = 0; i &lt; USERS.length; i++) {</span>
 52 |     | <span class='unexecuted'>            address user = USERS[i];</span>
 53 |     | <span class='unexecuted'>            (success, ) = address(user).call{value: INITIAL_BALANCE}(&quot;&quot;);</span>
 54 |     | <span class='unexecuted'>            assert(success);</span>
 55 |     | <span class='unexecuted'>            weth.transfer(user, INITIAL_WETH_BALANCE);</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='unexecuted'>            for (uint8 j = 0; j &lt; tokens.length; j++) {</span>
 58 |     | <span class='unexecuted'>                tokens[j].mint(user, INITIAL_TOKEN_BALANCE * (10 ** tokens[j].decimals()));</span>
 59 |     | <span class='unexecuted'>                for (uint8 k = 0; k &lt; targets.length; k++) {</span>
 60 |     | <span class='unexecuted'>                    vm.prank(user);</span>
 61 |     | <span class='unexecuted'>                    tokens[j].approve(targets[k], type(uint128).max);</span>
 62 |     | <span class='unexecuted'>                    vm.prank(user);</span>
 63 |     | <span class='unexecuted'>                    weth.approve(targets[k], INITIAL_WETH_BALANCE);</span>
 64 |     | <span class='neutral'>                }</span>
 65 |     | <span class='neutral'>            }</span>
 66 |     | <span class='neutral'>        }</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='unexecuted'>        tokens.push(weth);</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'>}</span>
 71 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/BeforeAfter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../FuzzSetup.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title BeforeAfter</span>
  8 |     | <span class='neutral'> * @author 0xScourgedev</span>
  9 |     | <span class='neutral'> * @notice Contains the states of the system before and after calls</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>abstract contract BeforeAfter is FuzzSetup {</span>
 12 |     | <span class='neutral'>    mapping(uint8 =&gt; State) states;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    struct State {</span>
 15 |     | <span class='neutral'>        // actor =&gt; actorStates</span>
 16 |     | <span class='neutral'>        mapping(address =&gt; ActorStates) actorStates;</span>
 17 |     | <span class='neutral'>        mapping(address =&gt; PoolStates) poolStates;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    struct ActorStates {</span>
 21 |     | <span class='neutral'>        mapping(address =&gt; uint256) tokenBalances;</span>
 22 |     | <span class='neutral'>        uint256 ethBalance;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    struct PoolStates {</span>
 26 |     | <span class='neutral'>        uint256 baseBalance;</span>
 27 |     | <span class='neutral'>        uint256 quoteBalance;</span>
 28 |     | <span class='neutral'>        uint256 baseReserve;</span>
 29 |     | <span class='neutral'>        uint256 quoteReserve;</span>
 30 |     | <span class='neutral'>        uint256 baseTarget;</span>
 31 |     | <span class='neutral'>        uint256 quoteTarget;</span>
 32 |     | <span class='neutral'>        uint256 RState;</span>
 33 |     | <span class='neutral'>        uint256 lpTotalSupply;</span>
 34 |     | <span class='neutral'>        uint256 addressZeroBal;</span>
 35 |     | <span class='neutral'>        uint256 poolLpTokenBal;</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 | *   | <span class='executed'>    function _before(address[] memory actors, address[] memory poolsToUpdate) internal {</span>
 39 | *   | <span class='executed'>        _setStates(0, actors, poolsToUpdate);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 | *   | <span class='executed'>    function _after(address[] memory actors, address[] memory poolsToUpdate) internal {</span>
 43 | *   | <span class='executed'>        _setStates(1, actors, poolsToUpdate);</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 | *   | <span class='executed'>    function _setStates(uint8 callNum, address[] memory actors, address[] memory poolsToUpdate) internal {</span>
 47 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; actors.length; i++) {</span>
 48 | *   | <span class='executed'>            _setActorState(callNum, actors[i]);</span>
 49 |     | <span class='neutral'>        }</span>
 50 |     | <span class='neutral'></span>
 51 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; poolsToUpdate.length; i++) {</span>
 52 | *   | <span class='executed'>            if (poolsToUpdate[i] == address(0)) {</span>
 53 | *   | <span class='executed'>                break;</span>
 54 |     | <span class='neutral'>            }</span>
 55 | *   | <span class='executed'>            _setPoolState(callNum, poolsToUpdate[i]);</span>
 56 |     | <span class='neutral'>        }</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 | *   | <span class='executed'>    function _setPoolState(uint8 callNum, address pool) internal {</span>
 60 | *   | <span class='executed'>        states[callNum].poolStates[pool].baseBalance = IERC20(MagicLP(pool)._BASE_TOKEN_()).balanceOf(pool);</span>
 61 | *   | <span class='executed'>        states[callNum].poolStates[pool].quoteBalance = IERC20(MagicLP(pool)._QUOTE_TOKEN_()).balanceOf(pool);</span>
 62 | *   | <span class='executed'>        states[callNum].poolStates[pool].baseReserve = MagicLP(pool)._BASE_RESERVE_();</span>
 63 | *   | <span class='executed'>        states[callNum].poolStates[pool].quoteReserve = MagicLP(pool)._QUOTE_RESERVE_();</span>
 64 | *   | <span class='executed'>        states[callNum].poolStates[pool].baseTarget = MagicLP(pool)._BASE_TARGET_();</span>
 65 | *   | <span class='executed'>        states[callNum].poolStates[pool].quoteTarget = MagicLP(pool)._QUOTE_TARGET_();</span>
 66 | *   | <span class='executed'>        states[callNum].poolStates[pool].RState = MagicLP(pool)._RState_();</span>
 67 | *   | <span class='executed'>        states[callNum].poolStates[pool].lpTotalSupply = IERC20(pool).totalSupply();</span>
 68 | *   | <span class='executed'>        states[callNum].poolStates[pool].addressZeroBal = IERC20(pool).balanceOf(address(0));</span>
 69 | *   | <span class='executed'>        states[callNum].poolStates[pool].poolLpTokenBal = IERC20(pool).balanceOf(pool);</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'></span>
 72 | *   | <span class='executed'>    function _setActorState(uint8 callNum, address actor) internal {</span>
 73 | *   | <span class='executed'>        states[callNum].actorStates[actor].ethBalance = actor.balance;</span>
 74 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; tokens.length; i++) {</span>
 75 | *   | <span class='executed'>            states[callNum].actorStates[actor].tokenBalances[address(tokens[i])] = IERC20(address(tokens[i])).balanceOf(actor);</span>
 76 |     | <span class='neutral'>        }</span>
 77 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; allPools.length; i++) {</span>
 78 | *   | <span class='executed'>            states[callNum].actorStates[actor].tokenBalances[allPools[i]] = IERC20(allPools[i]).balanceOf(actor);</span>
 79 |     | <span class='neutral'>        }</span>
 80 |     | <span class='neutral'>    }</span>
 81 |     | <span class='neutral'>}</span>
 82 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/FuzzStorageVariables.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../util/FuzzConstants.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../mocks/MockWETH.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../../mimswap/periphery/Factory.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../../mimswap/periphery/Router.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../../mimswap/MagicLP.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;../../mimswap/auxiliary/FeeRateModelImpl.sol&quot;;</span>
 10 |     | <span class='neutral'>import &quot;../../mimswap/auxiliary/FeeRateModel.sol&quot;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>/**</span>
 13 |     | <span class='neutral'> * @title FuzzStorageVariables</span>
 14 |     | <span class='neutral'> * @author 0xScourgedev</span>
 15 |     | <span class='neutral'> * @notice Contains all of the storage variables for the fuzzing suite</span>
 16 |     | <span class='neutral'> */</span>
 17 |     | <span class='neutral'>abstract contract FuzzStorageVariables is FuzzConstants {</span>
 18 |     | <span class='neutral'>    // Echidna settings</span>
 19 |     | <span class='unexecuted'>    bool internal _setActor = true;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    // All of the deployed contracts</span>
 22 |     | <span class='neutral'>    Factory internal factory;</span>
 23 |     | <span class='neutral'>    Router internal router;</span>
 24 |     | <span class='neutral'>    MagicLP[] internal markets;</span>
 25 |     | <span class='neutral'>    MagicLP internal marketImpl;</span>
 26 |     | <span class='neutral'>    FeeRateModelImpl internal feeRateModelImpl;</span>
 27 |     | <span class='neutral'>    FeeRateModel internal feeRateModel;</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    MockWETH internal weth;</span>
 30 |     | <span class='neutral'>    MockERC20 internal tokenA18;</span>
 31 |     | <span class='neutral'>    MockERC20 internal tokenB18;</span>
 32 |     | <span class='neutral'>    MockERC20 internal tokenA6;</span>
 33 |     | <span class='neutral'>    MockERC20 internal tokenB6;</span>
 34 |     | <span class='neutral'>    MockERC20 internal tokenA8;</span>
 35 |     | <span class='neutral'>    MockERC20 internal tokenB8;</span>
 36 |     | <span class='neutral'>    MockERC20 internal tokenA24;</span>
 37 |     | <span class='neutral'>    MockERC20 internal tokenB24;</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    MockERC20[] internal tokens;</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    // baseToken =&gt; quoteToken =&gt; pool</span>
 42 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; address)) internal pools;</span>
 43 |     | <span class='neutral'>    // baseToken =&gt; array of possible quoteTokens</span>
 44 |     | <span class='neutral'>    mapping(address =&gt; address[]) internal availablePools;</span>
 45 |     | <span class='neutral'>    address[] internal allPools;</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    address internal currentActor;</span>
 48 |     | <span class='neutral'>}</span>
 49 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/postconditions/PostconditionsBase.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../../properties/Properties.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title PostconditionsBase</span>
  8 |     | <span class='neutral'> * @author 0xScourgedev</span>
  9 |     | <span class='neutral'> * @notice Contains general postconditions used across all postcondition contracts</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>abstract contract PostconditionsBase is Properties {</span>
 12 | *   | <span class='executed'>    function onSuccessInvariantsGeneral(address[] memory poolsToUpdate) internal {</span>
 13 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; poolsToUpdate.length; i++) {</span>
 14 | *   | <span class='executed'>            invariant_RES_01(poolsToUpdate[i]);</span>
 15 | *   | <span class='executed'>            invariant_RES_02(poolsToUpdate[i]);</span>
 16 | *   | <span class='executed'>            invariant_RES_03(poolsToUpdate[i]);</span>
 17 | *   | <span class='executed'>            invariant_POOL_01(poolsToUpdate[i]);</span>
 18 | *   | <span class='executed'>            invariant_POOL_04(poolsToUpdate[i]);</span>
 19 |     | <span class='neutral'>        }</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 | *   | <span class='executed'>    function onFailInvariantsGeneral(bytes memory returnData) internal {</span>
 23 | *   | <span class='executed'>        invariant_GENERAL_01(returnData);</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/postconditions/PostconditionsFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../../properties/Properties.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./PostconditionsBase.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/**</span>
  8 |     | <span class='neutral'> * @title PostconditionsFactory</span>
  9 |     | <span class='neutral'> * @author 0xScourgedev</span>
 10 |     | <span class='neutral'> * @notice Contains all postconditions for Factory</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='neutral'>abstract contract PostconditionsFactory is PostconditionsBase {</span>
 13 | *   | <span class='executed'>    function createPostconditions(</span>
 14 |     | <span class='neutral'>        bool success,</span>
 15 |     | <span class='neutral'>        bytes memory returnData,</span>
 16 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 17 |     | <span class='neutral'>        address[] memory poolsToUpdate,</span>
 18 |     | <span class='neutral'>        address baseToken,</span>
 19 |     | <span class='neutral'>        address quoteToken</span>
 20 |     | <span class='neutral'>    ) internal {</span>
 21 | *   | <span class='executed'>        if (success) {</span>
 22 | *   | <span class='executed'>            address pool = abi.decode(returnData, (address));</span>
 23 | *   | <span class='executed'>            allPools.push(pool);</span>
 24 | *   | <span class='executed'>            pools[baseToken][quoteToken] = pool;</span>
 25 | *   | <span class='executed'>            pools[quoteToken][baseToken] = pool;</span>
 26 | *   | <span class='executed'>            availablePools[quoteToken].push(pool);</span>
 27 | *   | <span class='executed'>            availablePools[baseToken].push(pool);</span>
 28 | *   | <span class='executed'>            poolsToUpdate[0] = pool;</span>
 29 |     | <span class='neutral'></span>
 30 | *   | <span class='executed'>            _after(actorsToUpdate, poolsToUpdate);</span>
 31 | *   | <span class='executed'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
 32 |     | <span class='neutral'>        } else {</span>
 33 |     | <span class='unexecuted'>            onFailInvariantsGeneral(returnData);</span>
 34 |     | <span class='neutral'>        }</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/postconditions/PostconditionsMagicLP.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;../../properties/Properties.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./PostconditionsBase.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @title PostconditionsMagicLP</span>
   9 |     | <span class='neutral'> * @author 0xScourgedev</span>
  10 |     | <span class='neutral'> * @notice Contains all postconditions for MagicLP</span>
  11 |     | <span class='neutral'> */</span>
  12 |     | <span class='neutral'>abstract contract PostconditionsMagicLP is PostconditionsBase {</span>
  13 |     | <span class='unexecuted'>    function buySharesPostconditions(</span>
  14 |     | <span class='neutral'>        bool success,</span>
  15 |     | <span class='neutral'>        bytes memory returnData,</span>
  16 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
  17 |     | <span class='neutral'>        address[] memory poolsToUpdate</span>
  18 |     | <span class='neutral'>    ) internal {</span>
  19 |     | <span class='unexecuted'>        if (success) {</span>
  20 |     | <span class='unexecuted'>            _after(actorsToUpdate, poolsToUpdate);</span>
  21 |     | <span class='unexecuted'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
  22 |     | <span class='neutral'>        } else {</span>
  23 |     | <span class='unexecuted'>            onFailInvariantsGeneral(returnData);</span>
  24 |     | <span class='neutral'>        }</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 | *   | <span class='executed'>    function correctRStatePostconditions(</span>
  28 |     | <span class='neutral'>        bool success,</span>
  29 |     | <span class='neutral'>        bytes memory returnData,</span>
  30 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
  31 |     | <span class='neutral'>        address[] memory poolsToUpdate</span>
  32 |     | <span class='neutral'>    ) internal {</span>
  33 | *   | <span class='executed'>        if (success) {</span>
  34 | *   | <span class='executed'>            _after(actorsToUpdate, poolsToUpdate);</span>
  35 |     | <span class='neutral'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
  36 |     | <span class='neutral'>        } else {</span>
  37 |     | <span class='unexecuted'>            invariant_POOL_03();</span>
  38 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
  39 |     | <span class='neutral'>        }</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    function sellBasePostconditions(</span>
  43 |     | <span class='neutral'>        bool success,</span>
  44 |     | <span class='neutral'>        bytes memory returnData,</span>
  45 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
  46 |     | <span class='neutral'>        address[] memory poolsToUpdate</span>
  47 |     | <span class='neutral'>    ) internal {</span>
  48 |     | <span class='neutral'>        if (success) {</span>
  49 |     | <span class='neutral'>            _after(actorsToUpdate, poolsToUpdate);</span>
  50 |     | <span class='neutral'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
  51 |     | <span class='neutral'>        } else {</span>
  52 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
  53 |     | <span class='neutral'>        }</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function sellQuotePostconditions(</span>
  57 |     | <span class='neutral'>        bool success,</span>
  58 |     | <span class='neutral'>        bytes memory returnData,</span>
  59 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
  60 |     | <span class='neutral'>        address[] memory poolsToUpdate</span>
  61 |     | <span class='neutral'>    ) internal {</span>
  62 |     | <span class='neutral'>        if (success) {</span>
  63 |     | <span class='neutral'>            _after(actorsToUpdate, poolsToUpdate);</span>
  64 |     | <span class='neutral'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
  65 |     | <span class='neutral'>        } else {</span>
  66 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
  67 |     | <span class='neutral'>        }</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    function sellSharesPostconditions(</span>
  71 |     | <span class='neutral'>        bool success,</span>
  72 |     | <span class='neutral'>        bytes memory returnData,</span>
  73 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
  74 |     | <span class='neutral'>        address[] memory poolsToUpdate</span>
  75 |     | <span class='neutral'>    ) internal {</span>
  76 |     | <span class='neutral'>        if (success) {</span>
  77 |     | <span class='neutral'>            _after(actorsToUpdate, poolsToUpdate);</span>
  78 |     | <span class='neutral'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
  79 |     | <span class='neutral'>        } else {</span>
  80 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
  81 |     | <span class='neutral'>        }</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 | *   | <span class='executed'>    function syncPostconditions(</span>
  85 |     | <span class='neutral'>        bool success,</span>
  86 |     | <span class='neutral'>        bytes memory returnData,</span>
  87 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
  88 |     | <span class='neutral'>        address[] memory poolsToUpdate</span>
  89 |     | <span class='neutral'>    ) internal {</span>
  90 | *   | <span class='executed'>        if (success) {</span>
  91 | *   | <span class='executed'>            _after(actorsToUpdate, poolsToUpdate);</span>
  92 |     | <span class='neutral'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
  93 |     | <span class='neutral'>        } else {</span>
  94 | *   | <span class='executed'>            invariant_POOL_02();</span>
  95 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    function transferPostconditions(</span>
 100 |     | <span class='neutral'>        bool success,</span>
 101 |     | <span class='neutral'>        bytes memory returnData,</span>
 102 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 103 |     | <span class='neutral'>        address[] memory poolsToUpdate</span>
 104 |     | <span class='neutral'>    ) internal {</span>
 105 |     | <span class='neutral'>        if (success) {</span>
 106 |     | <span class='neutral'>            _after(actorsToUpdate, poolsToUpdate);</span>
 107 |     | <span class='neutral'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
 108 |     | <span class='neutral'>        } else {</span>
 109 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'>}</span>
 113 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/postconditions/PostconditionsRouter.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;../../properties/Properties.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./PostconditionsBase.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @title PostconditionsRouter</span>
   9 |     | <span class='neutral'> * @author 0xScourgedev</span>
  10 |     | <span class='neutral'> * @notice Contains all postconditions for Router</span>
  11 |     | <span class='neutral'> */</span>
  12 |     | <span class='neutral'>abstract contract PostconditionsRouter is PostconditionsBase {</span>
  13 | *   | <span class='executed'>    function addLiquidityPostconditions(</span>
  14 |     | <span class='neutral'>        bool success,</span>
  15 |     | <span class='neutral'>        bytes memory returnData,</span>
  16 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
  17 |     | <span class='neutral'>        address[] memory poolsToUpdate,</span>
  18 |     | <span class='neutral'>        uint256 previewShares</span>
  19 |     | <span class='neutral'>    ) internal {</span>
  20 | *   | <span class='executed'>        if (success) {</span>
  21 | *   | <span class='executed'>            (, , uint256 actualShares) = abi.decode(returnData, (uint256, uint256, uint256));</span>
  22 | *   | <span class='executed'>            _after(actorsToUpdate, poolsToUpdate);</span>
  23 | *   | <span class='executed'>            invariant_LIQ_01(poolsToUpdate[0]);</span>
  24 | *   | <span class='executed'>            invariant_LIQ_02(poolsToUpdate[0], false);</span>
  25 | *   | <span class='executed'>            invariant_LIQ_03(poolsToUpdate[0]);</span>
  26 | *   | <span class='executed'>            invariant_LIQ_04(poolsToUpdate[0]);</span>
  27 | *   | <span class='executed'>            invariant_LIQ_12(previewShares, actualShares);</span>
  28 |     | <span class='neutral'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
  29 |     | <span class='neutral'>        } else {</span>
  30 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
  31 |     | <span class='neutral'>        }</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    function addLiquidityETHPostconditions(</span>
  35 |     | <span class='neutral'>        bool success,</span>
  36 |     | <span class='neutral'>        bytes memory returnData,</span>
  37 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
  38 |     | <span class='neutral'>        address[] memory poolsToUpdate,</span>
  39 |     | <span class='neutral'>        uint256 previewShares</span>
  40 |     | <span class='neutral'>    ) internal {</span>
  41 |     | <span class='unexecuted'>        if (success) {</span>
  42 |     | <span class='unexecuted'>            (, , uint256 actualShares) = abi.decode(returnData, (uint256, uint256, uint256));</span>
  43 |     | <span class='unexecuted'>            _after(actorsToUpdate, poolsToUpdate);</span>
  44 |     | <span class='unexecuted'>            invariant_LIQ_01(poolsToUpdate[0]);</span>
  45 |     | <span class='unexecuted'>            invariant_LIQ_02(poolsToUpdate[0], true);</span>
  46 |     | <span class='neutral'>            invariant_LIQ_03(poolsToUpdate[0]);</span>
  47 |     | <span class='neutral'>            invariant_LIQ_04(poolsToUpdate[0]);</span>
  48 |     | <span class='neutral'>            invariant_LIQ_12(previewShares, actualShares);</span>
  49 |     | <span class='neutral'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
  50 |     | <span class='neutral'>        } else {</span>
  51 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
  52 |     | <span class='neutral'>        }</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>    function addLiquidityETHUnsafePostconditions(</span>
  56 |     | <span class='neutral'>        bool success,</span>
  57 |     | <span class='neutral'>        bytes memory returnData,</span>
  58 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
  59 |     | <span class='neutral'>        address[] memory poolsToUpdate,</span>
  60 |     | <span class='neutral'>        uint256 previewShares</span>
  61 |     | <span class='neutral'>    ) internal {</span>
  62 |     | <span class='unexecuted'>        if (success) {</span>
  63 |     | <span class='unexecuted'>            uint256 actualShares = abi.decode(returnData, (uint256));</span>
  64 |     | <span class='unexecuted'>            _after(actorsToUpdate, poolsToUpdate);</span>
  65 |     | <span class='unexecuted'>            invariant_LIQ_01(poolsToUpdate[0]);</span>
  66 |     | <span class='unexecuted'>            invariant_LIQ_02(poolsToUpdate[0], true);</span>
  67 |     | <span class='neutral'>            invariant_LIQ_03(poolsToUpdate[0]);</span>
  68 |     | <span class='neutral'>            invariant_LIQ_04(poolsToUpdate[0]);</span>
  69 |     | <span class='neutral'>            invariant_LIQ_13(previewShares, actualShares);</span>
  70 |     | <span class='neutral'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
  71 |     | <span class='neutral'>        } else {</span>
  72 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
  73 |     | <span class='neutral'>        }</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 | *   | <span class='executed'>    function addLiquidityUnsafePostconditions(</span>
  77 |     | <span class='neutral'>        bool success,</span>
  78 |     | <span class='neutral'>        bytes memory returnData,</span>
  79 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
  80 |     | <span class='neutral'>        address[] memory poolsToUpdate,</span>
  81 |     | <span class='neutral'>        uint256 previewShares</span>
  82 |     | <span class='neutral'>    ) internal {</span>
  83 | *   | <span class='executed'>        if (success) {</span>
  84 | *   | <span class='executed'>            uint256 actualShares = abi.decode(returnData, (uint256));</span>
  85 | *   | <span class='executed'>            _after(actorsToUpdate, poolsToUpdate);</span>
  86 | *   | <span class='executed'>            invariant_LIQ_01(poolsToUpdate[0]);</span>
  87 | *   | <span class='executed'>            invariant_LIQ_02(poolsToUpdate[0], false);</span>
  88 | *   | <span class='executed'>            invariant_LIQ_03(poolsToUpdate[0]);</span>
  89 | *   | <span class='executed'>            invariant_LIQ_04(poolsToUpdate[0]);</span>
  90 | *   | <span class='executed'>            invariant_LIQ_13(previewShares, actualShares);</span>
  91 |     | <span class='neutral'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
  92 |     | <span class='neutral'>        } else {</span>
  93 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
  94 |     | <span class='neutral'>        }</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 | *   | <span class='executed'>    function createPoolPostconditions(</span>
  98 |     | <span class='neutral'>        bool success,</span>
  99 |     | <span class='neutral'>        bytes memory returnData,</span>
 100 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 101 |     | <span class='neutral'>        address[] memory poolsToUpdate,</span>
 102 |     | <span class='neutral'>        address baseToken,</span>
 103 |     | <span class='neutral'>        address quoteToken</span>
 104 |     | <span class='neutral'>    ) internal {</span>
 105 | *   | <span class='executed'>        if (success) {</span>
 106 | *   | <span class='executed'>            (address pool, ) = abi.decode(returnData, (address, uint256));</span>
 107 | *   | <span class='executed'>            allPools.push(pool);</span>
 108 | *   | <span class='executed'>            pools[baseToken][quoteToken] = pool;</span>
 109 | *   | <span class='executed'>            pools[quoteToken][baseToken] = pool;</span>
 110 | *   | <span class='executed'>            availablePools[quoteToken].push(pool);</span>
 111 | *   | <span class='executed'>            availablePools[baseToken].push(pool);</span>
 112 | *   | <span class='executed'>            poolsToUpdate[0] = pool;</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>            _after(actorsToUpdate, poolsToUpdate);</span>
 115 |     | <span class='unexecuted'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
 116 |     | <span class='neutral'>        } else {</span>
 117 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
 118 |     | <span class='neutral'>        }</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 | *   | <span class='executed'>    function createPoolETHPostconditions(</span>
 122 |     | <span class='neutral'>        bool success,</span>
 123 |     | <span class='neutral'>        bytes memory returnData,</span>
 124 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 125 |     | <span class='neutral'>        address[] memory poolsToUpdate,</span>
 126 |     | <span class='neutral'>        address baseToken</span>
 127 |     | <span class='neutral'>    ) internal {</span>
 128 | *   | <span class='executed'>        if (success) {</span>
 129 |     | <span class='unexecuted'>            (address pool, ) = abi.decode(returnData, (address, uint256));</span>
 130 |     | <span class='unexecuted'>            allPools.push(pool);</span>
 131 |     | <span class='unexecuted'>            pools[baseToken][address(weth)] = pool;</span>
 132 |     | <span class='unexecuted'>            pools[address(weth)][baseToken] = pool;</span>
 133 |     | <span class='unexecuted'>            availablePools[address(weth)].push(baseToken);</span>
 134 |     | <span class='unexecuted'>            availablePools[baseToken].push(address(weth));</span>
 135 |     | <span class='unexecuted'>            poolsToUpdate[0] = pool;</span>
 136 |     | <span class='neutral'></span>
 137 | *   | <span class='executed'>            _after(actorsToUpdate, poolsToUpdate);</span>
 138 | *   | <span class='executed'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
 139 |     | <span class='neutral'>        } else {</span>
 140 | *   | <span class='executed'>            onFailInvariantsGeneral(returnData);</span>
 141 |     | <span class='neutral'>        }</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 | *   | <span class='executed'>    function removeLiquidityPostconditions(</span>
 145 |     | <span class='neutral'>        bool success,</span>
 146 |     | <span class='neutral'>        bytes memory returnData,</span>
 147 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 148 |     | <span class='neutral'>        address[] memory poolsToUpdate,</span>
 149 |     | <span class='neutral'>        uint256 sharesIn,</span>
 150 |     | <span class='neutral'>        uint256 previewBase,</span>
 151 |     | <span class='neutral'>        uint256 previewQuote</span>
 152 |     | <span class='neutral'>    ) internal {</span>
 153 | *   | <span class='executed'>        if (success) {</span>
 154 | *   | <span class='executed'>            (uint256 actualBase, uint256 actualQuote) = abi.decode(returnData, (uint256, uint256));</span>
 155 | *   | <span class='executed'>            _after(actorsToUpdate, poolsToUpdate);</span>
 156 | *   | <span class='executed'>            invariant_LIQ_05(poolsToUpdate[0]);</span>
 157 | *   | <span class='executed'>            invariant_LIQ_06(poolsToUpdate[0], false);</span>
 158 | *   | <span class='executed'>            invariant_LIQ_07(poolsToUpdate[0], sharesIn);</span>
 159 | *   | <span class='executed'>            invariant_LIQ_08(poolsToUpdate[0], sharesIn);</span>
 160 | *   | <span class='executed'>            invariant_LIQ_09(poolsToUpdate[0], sharesIn);</span>
 161 | *   | <span class='executed'>            invariant_LIQ_14(previewBase, previewQuote, actualBase, actualQuote);</span>
 162 | *   | <span class='executed'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
 163 |     | <span class='neutral'>        } else {</span>
 164 | *   | <span class='executed'>            onFailInvariantsGeneral(returnData);</span>
 165 |     | <span class='neutral'>        }</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>    function removeLiquidityETHPostconditions(</span>
 169 |     | <span class='neutral'>        bool success,</span>
 170 |     | <span class='neutral'>        bytes memory returnData,</span>
 171 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 172 |     | <span class='neutral'>        address[] memory poolsToUpdate,</span>
 173 |     | <span class='neutral'>        uint256 sharesIn</span>
 174 |     | <span class='neutral'>    ) internal {</span>
 175 |     | <span class='unexecuted'>        if (success) {</span>
 176 |     | <span class='unexecuted'>            _after(actorsToUpdate, poolsToUpdate);</span>
 177 |     | <span class='unexecuted'>            invariant_LIQ_05(poolsToUpdate[0]);</span>
 178 |     | <span class='unexecuted'>            invariant_LIQ_06(poolsToUpdate[0], true);</span>
 179 |     | <span class='unexecuted'>            invariant_LIQ_07(poolsToUpdate[0], sharesIn);</span>
 180 |     | <span class='unexecuted'>            invariant_LIQ_08(poolsToUpdate[0], sharesIn);</span>
 181 |     | <span class='unexecuted'>            invariant_LIQ_09(poolsToUpdate[0], sharesIn);</span>
 182 |     | <span class='unexecuted'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
 183 |     | <span class='neutral'>        } else {</span>
 184 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
 185 |     | <span class='neutral'>        }</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 | *   | <span class='executed'>    function previewAddLiquidityPostconditions(bool success, bytes memory returnData) internal {</span>
 189 | *   | <span class='executed'>        if (success) {</span>
 190 | *   | <span class='executed'>            onSuccessInvariantsGeneral(new address[](0));</span>
 191 |     | <span class='neutral'>        } else {</span>
 192 |     | <span class='unexecuted'>            invariant_LIQ_10();</span>
 193 |     | <span class='unexecuted'>            onFailInvariantsGeneral(returnData);</span>
 194 |     | <span class='neutral'>        }</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'></span>
 197 | *   | <span class='executed'>    function previewRemoveLiquidityPostconditions(bool success, bytes memory returnData, address pool) internal {</span>
 198 | *   | <span class='executed'>        if (success) {</span>
 199 | *   | <span class='executed'>            onSuccessInvariantsGeneral(new address[](0));</span>
 200 |     | <span class='neutral'>        } else {</span>
 201 | *   | <span class='executed'>            invariant_LIQ_11(pool);</span>
 202 | *   | <span class='executed'>            onFailInvariantsGeneral(returnData);</span>
 203 |     | <span class='neutral'>        }</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    function sellBaseETHForTokensPostconditions(</span>
 207 |     | <span class='neutral'>        bool success,</span>
 208 |     | <span class='neutral'>        bytes memory returnData,</span>
 209 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 210 |     | <span class='neutral'>        address[] memory poolsToUpdate</span>
 211 |     | <span class='neutral'>    ) internal {</span>
 212 |     | <span class='neutral'>        if (success) {</span>
 213 |     | <span class='neutral'>            _after(actorsToUpdate, poolsToUpdate);</span>
 214 |     | <span class='neutral'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
 215 |     | <span class='neutral'>        } else {</span>
 216 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
 217 |     | <span class='neutral'>        }</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>    function sellBaseTokensForETHPostconditions(</span>
 221 |     | <span class='neutral'>        bool success,</span>
 222 |     | <span class='neutral'>        bytes memory returnData,</span>
 223 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 224 |     | <span class='neutral'>        address[] memory poolsToUpdate</span>
 225 |     | <span class='neutral'>    ) internal {</span>
 226 |     | <span class='neutral'>        if (success) {</span>
 227 |     | <span class='neutral'>            _after(actorsToUpdate, poolsToUpdate);</span>
 228 |     | <span class='neutral'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
 229 |     | <span class='neutral'>        } else {</span>
 230 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
 231 |     | <span class='neutral'>        }</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    function sellBaseTokensForTokensPostconditions(</span>
 235 |     | <span class='neutral'>        bool success,</span>
 236 |     | <span class='neutral'>        bytes memory returnData,</span>
 237 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 238 |     | <span class='neutral'>        address[] memory poolsToUpdate</span>
 239 |     | <span class='neutral'>    ) internal {</span>
 240 |     | <span class='neutral'>        if (success) {</span>
 241 |     | <span class='neutral'>            _after(actorsToUpdate, poolsToUpdate);</span>
 242 |     | <span class='neutral'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
 243 |     | <span class='neutral'>        } else {</span>
 244 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
 245 |     | <span class='neutral'>        }</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    function sellQuoteETHForTokensPostconditions(</span>
 249 |     | <span class='neutral'>        bool success,</span>
 250 |     | <span class='neutral'>        bytes memory returnData,</span>
 251 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 252 |     | <span class='neutral'>        address[] memory poolsToUpdate</span>
 253 |     | <span class='neutral'>    ) internal {</span>
 254 |     | <span class='neutral'>        if (success) {</span>
 255 |     | <span class='neutral'>            _after(actorsToUpdate, poolsToUpdate);</span>
 256 |     | <span class='neutral'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
 257 |     | <span class='neutral'>        } else {</span>
 258 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
 259 |     | <span class='neutral'>        }</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    function sellQuoteTokensForETHPostconditions(</span>
 263 |     | <span class='neutral'>        bool success,</span>
 264 |     | <span class='neutral'>        bytes memory returnData,</span>
 265 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 266 |     | <span class='neutral'>        address[] memory poolsToUpdate</span>
 267 |     | <span class='neutral'>    ) internal {</span>
 268 |     | <span class='neutral'>        if (success) {</span>
 269 |     | <span class='neutral'>            _after(actorsToUpdate, poolsToUpdate);</span>
 270 |     | <span class='neutral'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
 271 |     | <span class='neutral'>        } else {</span>
 272 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
 273 |     | <span class='neutral'>        }</span>
 274 |     | <span class='neutral'>    }</span>
 275 |     | <span class='neutral'></span>
 276 | *   | <span class='executed'>    function sellQuoteTokensForTokensPostconditions(</span>
 277 |     | <span class='neutral'>        bool success,</span>
 278 |     | <span class='neutral'>        bytes memory returnData,</span>
 279 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 280 |     | <span class='neutral'>        address[] memory poolsToUpdate</span>
 281 |     | <span class='neutral'>    ) internal {</span>
 282 | *   | <span class='executed'>        if (success) {</span>
 283 | *   | <span class='executed'>            _after(actorsToUpdate, poolsToUpdate);</span>
 284 | *   | <span class='executed'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
 285 |     | <span class='neutral'>        } else {</span>
 286 | *   | <span class='executed'>            onFailInvariantsGeneral(returnData);</span>
 287 |     | <span class='neutral'>        }</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='unexecuted'>    function swapETHForTokensPostconditions(</span>
 291 |     | <span class='neutral'>        bool success,</span>
 292 |     | <span class='neutral'>        bytes memory returnData,</span>
 293 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 294 |     | <span class='neutral'>        address[] memory poolsToUpdate,</span>
 295 |     | <span class='neutral'>        uint256 directions,</span>
 296 |     | <span class='neutral'>        uint256 minimumOut</span>
 297 |     | <span class='neutral'>    ) internal {</span>
 298 |     | <span class='unexecuted'>        if (success) {</span>
 299 |     | <span class='unexecuted'>            uint256 actualOut = abi.decode(returnData, (uint256));</span>
 300 |     | <span class='unexecuted'>            _after(actorsToUpdate, poolsToUpdate);</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>            // Get the final token out address</span>
 303 |     | <span class='unexecuted'>            directions &gt;&gt;= poolsToUpdate.length - 1;</span>
 304 |     | <span class='unexecuted'>            address tokenAddr;</span>
 305 |     | <span class='unexecuted'>            if (directions &amp; 1 == 0) {</span>
 306 |     | <span class='unexecuted'>                tokenAddr = IMagicLP(poolsToUpdate[poolsToUpdate.length - 1])._BASE_TOKEN_();</span>
 307 |     | <span class='neutral'>            } else {</span>
 308 |     | <span class='unexecuted'>                tokenAddr = IMagicLP(poolsToUpdate[poolsToUpdate.length - 1])._QUOTE_TOKEN_();</span>
 309 |     | <span class='neutral'>            }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='unexecuted'>            invariant_SWAP_01(address(0), address(weth), true);</span>
 312 |     | <span class='unexecuted'>            invariant_SWAP_02(address(0), tokenAddr, false);</span>
 313 |     | <span class='neutral'>            invariant_SWAP_03(actualOut, minimumOut);</span>
 314 |     | <span class='neutral'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
 315 |     | <span class='neutral'>        } else {</span>
 316 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
 317 |     | <span class='neutral'>        }</span>
 318 |     | <span class='neutral'>    }</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='unexecuted'>    function swapTokensForETHPostconditions(</span>
 321 |     | <span class='neutral'>        bool success,</span>
 322 |     | <span class='neutral'>        bytes memory returnData,</span>
 323 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 324 |     | <span class='neutral'>        address[] memory poolsToUpdate,</span>
 325 |     | <span class='neutral'>        uint256 directions,</span>
 326 |     | <span class='neutral'>        uint256 minimumOut</span>
 327 |     | <span class='neutral'>    ) internal {</span>
 328 | *   | <span class='executed'>        if (success) {</span>
 329 |     | <span class='unexecuted'>            uint256 actualOut = abi.decode(returnData, (uint256));</span>
 330 |     | <span class='unexecuted'>            _after(actorsToUpdate, poolsToUpdate);</span>
 331 |     | <span class='neutral'></span>
 332 |     | <span class='neutral'>            // Get the token in address</span>
 333 |     | <span class='unexecuted'>            address tokenAddr;</span>
 334 |     | <span class='unexecuted'>            if (directions &amp; 1 == 0) {</span>
 335 |     | <span class='unexecuted'>                tokenAddr = IMagicLP(poolsToUpdate[0])._BASE_TOKEN_();</span>
 336 |     | <span class='neutral'>            } else {</span>
 337 |     | <span class='unexecuted'>                tokenAddr = IMagicLP(poolsToUpdate[0])._QUOTE_TOKEN_();</span>
 338 |     | <span class='neutral'>            }</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='unexecuted'>            invariant_SWAP_01(tokenAddr, address(0), false);</span>
 341 |     | <span class='unexecuted'>            invariant_SWAP_02(address(weth), address(weth), true);</span>
 342 |     | <span class='unexecuted'>            invariant_SWAP_03(actualOut, minimumOut);</span>
 343 |     | <span class='unexecuted'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
 344 |     | <span class='neutral'>        } else {</span>
 345 | *   | <span class='executed'>            onFailInvariantsGeneral(returnData);</span>
 346 |     | <span class='neutral'>        }</span>
 347 |     | <span class='neutral'>    }</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='unexecuted'>    function swapTokensForTokensPostconditions(</span>
 350 |     | <span class='neutral'>        bool success,</span>
 351 |     | <span class='neutral'>        bytes memory returnData,</span>
 352 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 353 |     | <span class='neutral'>        address[] memory poolsToUpdate,</span>
 354 |     | <span class='neutral'>        uint256 directions,</span>
 355 |     | <span class='neutral'>        uint256 minimumOut</span>
 356 |     | <span class='neutral'>    ) internal {</span>
 357 |     | <span class='unexecuted'>        if (success) {</span>
 358 |     | <span class='unexecuted'>            uint256 actualOut = abi.decode(returnData, (uint256));</span>
 359 |     | <span class='unexecuted'>            _after(actorsToUpdate, poolsToUpdate);</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='neutral'>            // Get the token in address</span>
 362 |     | <span class='unexecuted'>            address tokenInAddr;</span>
 363 |     | <span class='unexecuted'>            if (directions &amp; 1 == 0) {</span>
 364 |     | <span class='unexecuted'>                tokenInAddr = IMagicLP(poolsToUpdate[0])._BASE_TOKEN_();</span>
 365 |     | <span class='unexecuted'>                log(&quot;post token for token swap base&quot;, tokenInAddr);</span>
 366 |     | <span class='neutral'>            } else {</span>
 367 |     | <span class='unexecuted'>                tokenInAddr = IMagicLP(poolsToUpdate[0])._QUOTE_TOKEN_();</span>
 368 |     | <span class='unexecuted'>                log(&quot;post token for token swap quote&quot;, tokenInAddr);</span>
 369 |     | <span class='neutral'>            }</span>
 370 |     | <span class='unexecuted'>            directions &gt;&gt;= poolsToUpdate.length - 1;</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='unexecuted'>            address tokenOutAddr;</span>
 373 |     | <span class='neutral'>            // Get the token out address</span>
 374 |     | <span class='unexecuted'>            if (directions &amp; 1 == 0) {</span>
 375 |     | <span class='unexecuted'>                tokenOutAddr = IMagicLP(poolsToUpdate[poolsToUpdate.length - 1])._QUOTE_TOKEN_();</span>
 376 |     | <span class='unexecuted'>                log(&quot;post token for token swap quote out&quot;, tokenOutAddr);</span>
 377 |     | <span class='neutral'>            } else {</span>
 378 |     | <span class='unexecuted'>                tokenOutAddr = IMagicLP(poolsToUpdate[poolsToUpdate.length - 1])._BASE_TOKEN_();</span>
 379 |     | <span class='unexecuted'>                log(&quot;post token for token swap base out&quot;, tokenOutAddr);</span>
 380 |     | <span class='neutral'>            }</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='unexecuted'>            invariant_SWAP_01(tokenInAddr, tokenOutAddr, false);</span>
 383 |     | <span class='unexecuted'>            invariant_SWAP_02(tokenInAddr, tokenOutAddr, false);</span>
 384 |     | <span class='unexecuted'>            invariant_SWAP_03(actualOut, minimumOut);</span>
 385 |     | <span class='neutral'></span>
 386 |     | <span class='unexecuted'>            onSuccessInvariantsGeneral(poolsToUpdate);</span>
 387 |     | <span class='neutral'>        } else {</span>
 388 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
 389 |     | <span class='neutral'>        }</span>
 390 |     | <span class='neutral'>    }</span>
 391 |     | <span class='neutral'>}</span>
 392 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/preconditions/PreconditionsBase.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../../util/FunctionCalls.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../BeforeAfter.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/**</span>
  8 |     | <span class='neutral'> * @title PreconditionsBase</span>
  9 |     | <span class='neutral'> * @author 0xScourgedev</span>
 10 |     | <span class='neutral'> * @notice Contains the base for all preconditions</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='neutral'>abstract contract PreconditionsBase is FunctionCalls, BeforeAfter {</span>
 13 |     | <span class='neutral'>    modifier setCurrentActor() {</span>
 14 | *   | <span class='executed'>        if (_setActor) {</span>
 15 | *   | <span class='executed'>            currentActor = msg.sender;</span>
 16 |     | <span class='neutral'>        }</span>
 17 |     | <span class='neutral'>        _;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/preconditions/PreconditionsFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./PreconditionsBase.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title PreconditionsFactory</span>
  8 |     | <span class='neutral'> * @author 0xScourgedev</span>
  9 |     | <span class='neutral'> * @notice Contains all preconditions for Factory</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>abstract contract PreconditionsFactory is PreconditionsBase {</span>
 12 |     | <span class='neutral'>    struct CreateParams {</span>
 13 |     | <span class='neutral'>        address baseToken_;</span>
 14 |     | <span class='neutral'>        address quoteToken_;</span>
 15 |     | <span class='neutral'>        uint256 lpFeeRate_;</span>
 16 |     | <span class='neutral'>        uint256 i_;</span>
 17 |     | <span class='neutral'>        uint256 k_;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 | *   | <span class='executed'>    function createPreconditions(</span>
 21 |     | <span class='neutral'>        uint8 baseToken_,</span>
 22 |     | <span class='neutral'>        uint8 quoteToken_,</span>
 23 |     | <span class='neutral'>        uint256 lpFeeRate_,</span>
 24 |     | <span class='neutral'>        uint256 i_,</span>
 25 |     | <span class='neutral'>        uint256 k_</span>
 26 | *   | <span class='executed'>    ) internal returns (CreateParams memory) {</span>
 27 | *   | <span class='executed'>        require(allPools.length &lt; MAX_POOLS, &quot;Maximum number of pools reached&quot;);</span>
 28 |     | <span class='neutral'></span>
 29 | *   | <span class='executed'>        address baseToken = address(tokens[baseToken_ % tokens.length]);</span>
 30 | *   | <span class='executed'>        address quoteToken = address(tokens[quoteToken_ % tokens.length]);</span>
 31 | *   | <span class='executed'>        if(baseToken == quoteToken) {</span>
 32 | *   | <span class='executed'>            quoteToken = address(tokens[(quoteToken_ + 1) % tokens.length]);</span>
 33 |     | <span class='neutral'>        }</span>
 34 |     | <span class='neutral'>        </span>
 35 | *   | <span class='executed'>        lpFeeRate_ = clampBetween(lpFeeRate_, MIN_LP_FEE_RATE, MAX_LP_FEE_RATE);</span>
 36 | *   | <span class='executed'>        i_ = clampBetween(i_, 1, MAX_I);</span>
 37 | *   | <span class='executed'>        k_ = clampBetween(k_, 0, MAX_K);</span>
 38 |     | <span class='neutral'></span>
 39 | *   | <span class='executed'>        return CreateParams(baseToken, quoteToken, lpFeeRate_, i_, k_);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'>}</span>
 42 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/preconditions/PreconditionsMagicLP.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./PreconditionsBase.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @title PreconditionsMagicLP</span>
   8 |     | <span class='neutral'> * @author 0xScourgedev</span>
   9 |     | <span class='neutral'> * @notice Contains all preconditions for MagicLP</span>
  10 |     | <span class='neutral'> */</span>
  11 |     | <span class='neutral'>abstract contract PreconditionsMagicLP is PreconditionsBase {</span>
  12 |     | <span class='neutral'>    struct SellSharesParams {</span>
  13 |     | <span class='neutral'>        uint256 shareAmount;</span>
  14 |     | <span class='neutral'>        address lpAddr;</span>
  15 |     | <span class='neutral'>        uint256 baseMinAmount;</span>
  16 |     | <span class='neutral'>        uint256 quoteMinAmount;</span>
  17 |     | <span class='neutral'>        uint256 deadline;</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    struct TransferParams {</span>
  21 |     | <span class='neutral'>        address lpAddr;</span>
  22 |     | <span class='neutral'>        uint256 amount;</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    struct TransferTokensToLpParams {</span>
  26 |     | <span class='neutral'>        address token;</span>
  27 |     | <span class='neutral'>        address lpAddr;</span>
  28 |     | <span class='neutral'>        uint256 amount;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 | *   | <span class='executed'>    function buySharesPreconditions(uint8 lp) internal view returns (address) {</span>
  32 | *   | <span class='executed'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
  33 | *   | <span class='executed'>        return allPools[lp % allPools.length];</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    function correctRStatePreconditions(uint8 lp) internal view returns (address) {</span>
  37 |     | <span class='neutral'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
  38 |     | <span class='neutral'>        return allPools[lp % allPools.length];</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    function sellBasePreconditions(uint8 lp) internal view returns (address) {</span>
  42 |     | <span class='neutral'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
  43 |     | <span class='neutral'>        return allPools[lp % allPools.length];</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    function sellQuotePreconditions(uint8 lp) internal view returns (address) {</span>
  47 |     | <span class='neutral'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
  48 |     | <span class='neutral'>        return allPools[lp % allPools.length];</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 | *   | <span class='executed'>    function sellSharesPreconditions(</span>
  52 |     | <span class='neutral'>        uint256 shareAmount,</span>
  53 |     | <span class='neutral'>        uint8 lp,</span>
  54 |     | <span class='neutral'>        uint256 baseMinAmount,</span>
  55 |     | <span class='neutral'>        uint256 quoteMinAmount,</span>
  56 |     | <span class='neutral'>        uint256 deadline</span>
  57 | *   | <span class='executed'>    ) internal view returns (SellSharesParams memory) {</span>
  58 | *   | <span class='executed'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
  59 |     | <span class='neutral'></span>
  60 | *   | <span class='executed'>        address lpAddr = allPools[lp % allPools.length];</span>
  61 | *   | <span class='executed'>        return SellSharesParams(shareAmount, lpAddr, baseMinAmount, quoteMinAmount, deadline);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function syncPreconditions(uint8 lp) internal view returns (address) {</span>
  65 |     | <span class='neutral'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>        return allPools[lp % allPools.length];</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 | *   | <span class='executed'>    function transferSharesToLpPreconditions(uint8 lp, uint256 amount) internal returns (TransferParams memory) {</span>
  71 | *   | <span class='executed'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
  72 |     | <span class='neutral'></span>
  73 | *   | <span class='executed'>        address lpAddr = allPools[lp % allPools.length];</span>
  74 |     | <span class='neutral'></span>
  75 | *   | <span class='executed'>        amount = clampBetween(amount, 0, IERC20(lpAddr).balanceOf(address(currentActor)));</span>
  76 |     | <span class='neutral'></span>
  77 | *   | <span class='executed'>        vm.prank(currentActor);</span>
  78 | *   | <span class='executed'>        IERC20(lpAddr).approve(lpAddr, amount);</span>
  79 |     | <span class='neutral'></span>
  80 | *   | <span class='executed'>        return TransferParams(lpAddr, amount);</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 | *   | <span class='executed'>    function transferTokensToLpPreconditions(</span>
  84 |     | <span class='neutral'>        uint8 lp,</span>
  85 |     | <span class='neutral'>        bool transferQuote,</span>
  86 |     | <span class='neutral'>        uint256 amount</span>
  87 |     | <span class='neutral'>    ) internal returns (TransferTokensToLpParams memory) {</span>
  88 | *   | <span class='executed'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
  89 |     | <span class='neutral'></span>
  90 | *   | <span class='executed'>        address lpAddr = allPools[lp % allPools.length];</span>
  91 |     | <span class='neutral'>        address token;</span>
  92 | *   | <span class='executed'>        if (transferQuote) {</span>
  93 | *   | <span class='executed'>            token = MagicLP(lpAddr)._QUOTE_TOKEN_();</span>
  94 |     | <span class='neutral'>        } else {</span>
  95 | *   | <span class='executed'>            token = MagicLP(lpAddr)._BASE_TOKEN_();</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'></span>
  98 | *   | <span class='executed'>        amount = clampBetween(amount, 0, IERC20(token).balanceOf(address(currentActor)));</span>
  99 |     | <span class='neutral'></span>
 100 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 101 | *   | <span class='executed'>        IERC20(token).approve(lpAddr, amount);</span>
 102 |     | <span class='neutral'></span>
 103 | *   | <span class='executed'>        return TransferTokensToLpParams(token, lpAddr, amount);</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'>}</span>
 106 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/preconditions/PreconditionsRouter.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./PreconditionsBase.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @title PreconditionsRouter</span>
   8 |     | <span class='neutral'> * @author 0xScourgedev</span>
   9 |     | <span class='neutral'> * @notice Contains all preconditions for Router</span>
  10 |     | <span class='neutral'> */</span>
  11 |     | <span class='neutral'>abstract contract PreconditionsRouter is PreconditionsBase {</span>
  12 |     | <span class='neutral'>    struct AddLiquidityParams {</span>
  13 |     | <span class='neutral'>        address lpAddr;</span>
  14 |     | <span class='neutral'>        uint256 baseInAmount;</span>
  15 |     | <span class='neutral'>        uint256 quoteInAmount;</span>
  16 |     | <span class='neutral'>        uint256 minimumShares;</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    struct AddLiquidityETHParams {</span>
  20 |     | <span class='neutral'>        address lpAddr;</span>
  21 |     | <span class='neutral'>        uint256 tokenInAmount;</span>
  22 |     | <span class='neutral'>        uint256 value;</span>
  23 |     | <span class='neutral'>        uint256 minimumShares;</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    struct AddLiquidityETHUnsafeParams {</span>
  27 |     | <span class='neutral'>        address lpAddr;</span>
  28 |     | <span class='neutral'>        uint256 tokenInAmount;</span>
  29 |     | <span class='neutral'>        uint256 value;</span>
  30 |     | <span class='neutral'>        uint256 minimumShares;</span>
  31 |     | <span class='neutral'>    }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    struct AddLiquidityUnsafeParams {</span>
  34 |     | <span class='neutral'>        address lpAddr;</span>
  35 |     | <span class='neutral'>        uint256 baseInAmount;</span>
  36 |     | <span class='neutral'>        uint256 quoteInAmount;</span>
  37 |     | <span class='neutral'>        uint256 minimumShares;</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    struct CreatePoolParams {</span>
  41 |     | <span class='neutral'>        address baseToken;</span>
  42 |     | <span class='neutral'>        address quoteToken;</span>
  43 |     | <span class='neutral'>        uint256 lpFeeRate;</span>
  44 |     | <span class='neutral'>        uint256 i;</span>
  45 |     | <span class='neutral'>        uint256 k;</span>
  46 |     | <span class='neutral'>        address to;</span>
  47 |     | <span class='neutral'>        uint256 baseInAmount;</span>
  48 |     | <span class='neutral'>        uint256 quoteInAmount;</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    struct CreatePoolETHParams {</span>
  52 |     | <span class='neutral'>        address token;</span>
  53 |     | <span class='neutral'>        bool useTokenAsQuote;</span>
  54 |     | <span class='neutral'>        uint256 lpFeeRate;</span>
  55 |     | <span class='neutral'>        uint256 i;</span>
  56 |     | <span class='neutral'>        uint256 k;</span>
  57 |     | <span class='neutral'>        address to;</span>
  58 |     | <span class='neutral'>        uint256 tokenInAmount;</span>
  59 |     | <span class='neutral'>        uint256 value;</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    struct RemoveLiquidityParams {</span>
  63 |     | <span class='neutral'>        address lpAddr;</span>
  64 |     | <span class='neutral'>        uint256 sharesIn;</span>
  65 |     | <span class='neutral'>        uint256 minimumBaseAmount;</span>
  66 |     | <span class='neutral'>        uint256 minimumQuoteAmount;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    struct RemoveLiquidityETHParams {</span>
  70 |     | <span class='neutral'>        address lpAddr;</span>
  71 |     | <span class='neutral'>        uint256 sharesIn;</span>
  72 |     | <span class='neutral'>        uint256 minimumETHAmount;</span>
  73 |     | <span class='neutral'>        uint256 minimumTokenAmount;</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    struct PreviewAddLiquidityParams {</span>
  77 |     | <span class='neutral'>        address lpAddr;</span>
  78 |     | <span class='neutral'>        uint256 baseInAmount;</span>
  79 |     | <span class='neutral'>        uint256 quoteInAmount;</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    struct PreviewRemoveLiquidityParams {</span>
  83 |     | <span class='neutral'>        address lpAddr;</span>
  84 |     | <span class='neutral'>        uint256 sharesIn;</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    struct SellBaseETHForTokensParams {</span>
  88 |     | <span class='neutral'>        address lpAddr;</span>
  89 |     | <span class='neutral'>        uint256 minimumOut;</span>
  90 |     | <span class='neutral'>        uint256 value;</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    struct SellBaseTokensForETHParams {</span>
  94 |     | <span class='neutral'>        address lpAddr;</span>
  95 |     | <span class='neutral'>        uint256 amountIn;</span>
  96 |     | <span class='neutral'>        uint256 minimumOut;</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    struct SellBaseTokensForTokensParams {</span>
 100 |     | <span class='neutral'>        address lpAddr;</span>
 101 |     | <span class='neutral'>        uint256 amountIn;</span>
 102 |     | <span class='neutral'>        uint256 minimumOut;</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    struct SellQuoteETHForTokensParams {</span>
 106 |     | <span class='neutral'>        address lpAddr;</span>
 107 |     | <span class='neutral'>        uint256 minimumOut;</span>
 108 |     | <span class='neutral'>        uint256 value;</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    struct SellQuoteTokensForETHParams {</span>
 112 |     | <span class='neutral'>        address lpAddr;</span>
 113 |     | <span class='neutral'>        uint256 amountIn;</span>
 114 |     | <span class='neutral'>        uint256 minimumOut;</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    struct SellQuoteTokensForTokensParams {</span>
 118 |     | <span class='neutral'>        address lpAddr;</span>
 119 |     | <span class='neutral'>        uint256 amountIn;</span>
 120 |     | <span class='neutral'>        uint256 minimumOut;</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    struct SwapETHForTokensParams {</span>
 124 |     | <span class='neutral'>        address[] path;</span>
 125 |     | <span class='neutral'>        uint256 directions;</span>
 126 |     | <span class='neutral'>        uint256 minimumOut;</span>
 127 |     | <span class='neutral'>        uint256 value;</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    struct SwapTokensForETHParams {</span>
 131 |     | <span class='neutral'>        uint256 amountIn;</span>
 132 |     | <span class='neutral'>        address[] path;</span>
 133 |     | <span class='neutral'>        uint256 directions;</span>
 134 |     | <span class='neutral'>        uint256 minimumOut;</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    struct SwapTokensForTokensParams {</span>
 138 |     | <span class='neutral'>        uint256 amountIn;</span>
 139 |     | <span class='neutral'>        address[] path;</span>
 140 |     | <span class='neutral'>        uint256 directions;</span>
 141 |     | <span class='neutral'>        uint256 minimumOut;</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    function addLiquidityPreconditions(</span>
 145 |     | <span class='neutral'>        uint8 lp,</span>
 146 |     | <span class='neutral'>        uint256 baseInAmount,</span>
 147 |     | <span class='neutral'>        uint256 quoteInAmount,</span>
 148 |     | <span class='neutral'>        uint256 minimumShares</span>
 149 |     | <span class='neutral'>    ) internal returns (AddLiquidityParams memory) {</span>
 150 |     | <span class='neutral'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>        address lpAddr = address(allPools[lp % allPools.length]);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>        baseInAmount = clampBetween(baseInAmount, 0, IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).balanceOf(address(currentActor)));</span>
 155 |     | <span class='neutral'>        quoteInAmount = clampBetween(quoteInAmount, 0, IERC20(MagicLP(lpAddr)._QUOTE_TOKEN_()).balanceOf(address(currentActor)));</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>        return AddLiquidityParams(lpAddr, baseInAmount, quoteInAmount, minimumShares);</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    function addLiquidityETHPreconditions(</span>
 161 |     | <span class='neutral'>        uint8 lp,</span>
 162 |     | <span class='neutral'>        uint256 tokenInAmount,</span>
 163 |     | <span class='neutral'>        uint256 value,</span>
 164 |     | <span class='neutral'>        uint256 minimumShares</span>
 165 |     | <span class='neutral'>    ) internal returns (AddLiquidityETHParams memory) {</span>
 166 |     | <span class='neutral'>        require(availablePools[address(weth)].length &gt; 0, &quot;There are no available pools with WETH&quot;);</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>        address quoteToken = availablePools[address(weth)][lp % availablePools[address(weth)].length];</span>
 169 |     | <span class='neutral'>        address lpAddr = pools[address(weth)][quoteToken];</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>        value = clampBetween(value, 0, currentActor.balance);</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>        if (MagicLP(lpAddr)._BASE_TOKEN_() == address(weth)) {</span>
 174 |     | <span class='neutral'>            tokenInAmount = clampBetween(tokenInAmount, 0, IERC20(MagicLP(lpAddr)._QUOTE_TOKEN_()).balanceOf(address(currentActor)));</span>
 175 |     | <span class='neutral'>        } else {</span>
 176 |     | <span class='neutral'>            tokenInAmount = clampBetween(tokenInAmount, 0, IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).balanceOf(address(currentActor)));</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>        return AddLiquidityETHParams(lpAddr, tokenInAmount, value, minimumShares);</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 | *   | <span class='executed'>    function addLiquidityETHUnsafePreconditions(</span>
 183 |     | <span class='neutral'>        uint8 lp,</span>
 184 |     | <span class='neutral'>        uint256 tokenInAmount,</span>
 185 |     | <span class='neutral'>        uint256 value,</span>
 186 |     | <span class='neutral'>        uint256 minimumShares</span>
 187 | *   | <span class='executed'>    ) internal returns (AddLiquidityETHUnsafeParams memory) {</span>
 188 | *   | <span class='executed'>        require(availablePools[address(weth)].length &gt; 0, &quot;There are no available pools with WETH&quot;);</span>
 189 |     | <span class='neutral'></span>
 190 | *   | <span class='executed'>        address quoteToken = availablePools[address(weth)][lp % availablePools[address(weth)].length];</span>
 191 | *   | <span class='executed'>        address lpAddr = pools[address(weth)][quoteToken];</span>
 192 |     | <span class='neutral'></span>
 193 | *   | <span class='executed'>        value = clampBetween(value, 0, currentActor.balance);</span>
 194 |     | <span class='neutral'></span>
 195 | *   | <span class='executed'>        if (MagicLP(lpAddr)._BASE_TOKEN_() == address(weth)) {</span>
 196 |     | <span class='unexecuted'>            tokenInAmount = clampBetween(tokenInAmount, 0, IERC20(MagicLP(lpAddr)._QUOTE_TOKEN_()).balanceOf(address(currentActor)));</span>
 197 |     | <span class='neutral'>        } else {</span>
 198 |     | <span class='unexecuted'>            tokenInAmount = clampBetween(tokenInAmount, 0, IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).balanceOf(address(currentActor)));</span>
 199 |     | <span class='neutral'>        }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='unexecuted'>        return AddLiquidityETHUnsafeParams(lpAddr, tokenInAmount, value, minimumShares);</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 | *   | <span class='executed'>    function addLiquidityUnsafePreconditions(</span>
 205 |     | <span class='neutral'>        uint8 lp,</span>
 206 |     | <span class='neutral'>        uint256 baseInAmount,</span>
 207 |     | <span class='neutral'>        uint256 quoteInAmount,</span>
 208 |     | <span class='neutral'>        uint256 minimumShares</span>
 209 | *   | <span class='executed'>    ) internal returns (AddLiquidityUnsafeParams memory) {</span>
 210 | *   | <span class='executed'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
 211 |     | <span class='neutral'></span>
 212 | *   | <span class='executed'>        address lpAddr = address(allPools[lp % allPools.length]);</span>
 213 |     | <span class='neutral'></span>
 214 | *   | <span class='executed'>        baseInAmount = clampBetween(baseInAmount, 0, IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).balanceOf(address(currentActor)));</span>
 215 | *   | <span class='executed'>        quoteInAmount = clampBetween(quoteInAmount, 0, IERC20(MagicLP(lpAddr)._QUOTE_TOKEN_()).balanceOf(address(currentActor)));</span>
 216 |     | <span class='neutral'></span>
 217 | *   | <span class='executed'>        return AddLiquidityUnsafeParams(lpAddr, baseInAmount, quoteInAmount, minimumShares);</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'></span>
 220 | *   | <span class='executed'>    function createPoolPreconditions(</span>
 221 |     | <span class='neutral'>        uint8 baseToken,</span>
 222 |     | <span class='neutral'>        uint8 quoteToken,</span>
 223 |     | <span class='neutral'>        uint256 lpFeeRate,</span>
 224 |     | <span class='neutral'>        uint256 i,</span>
 225 |     | <span class='neutral'>        uint256 k,</span>
 226 |     | <span class='neutral'>        uint256 baseInAmount,</span>
 227 |     | <span class='neutral'>        uint256 quoteInAmount</span>
 228 | *   | <span class='executed'>    ) internal returns (CreatePoolParams memory) {</span>
 229 | *   | <span class='executed'>        require(allPools.length &lt; MAX_POOLS, &quot;Maximum number of pools reached&quot;);</span>
 230 |     | <span class='neutral'></span>
 231 | *   | <span class='executed'>        address baseTokenAddr = address(tokens[baseToken % tokens.length]);</span>
 232 | *   | <span class='executed'>        address quoteTokenAddr = address(tokens[quoteToken % tokens.length]);</span>
 233 | *   | <span class='executed'>        if (baseTokenAddr == quoteTokenAddr) {</span>
 234 | *   | <span class='executed'>            quoteTokenAddr = address(tokens[(quoteToken + 1) % tokens.length]);</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'></span>
 237 | *   | <span class='executed'>        lpFeeRate = clampBetween(lpFeeRate, MIN_LP_FEE_RATE, MAX_LP_FEE_RATE);</span>
 238 | *   | <span class='executed'>        i = clampBetween(i, 1, MAX_I);</span>
 239 | *   | <span class='executed'>        k = clampBetween(k, 0, MAX_K);</span>
 240 |     | <span class='neutral'></span>
 241 | *   | <span class='executed'>        return CreatePoolParams(baseTokenAddr, quoteTokenAddr, lpFeeRate, i, k, currentActor, baseInAmount, quoteInAmount);</span>
 242 |     | <span class='neutral'>    }</span>
 243 |     | <span class='neutral'></span>
 244 | *   | <span class='executed'>    function createPoolETHPreconditions(</span>
 245 |     | <span class='neutral'>        uint8 token,</span>
 246 |     | <span class='neutral'>        bool useTokenAsQuote,</span>
 247 |     | <span class='neutral'>        uint256 lpFeeRate,</span>
 248 |     | <span class='neutral'>        uint256 i,</span>
 249 |     | <span class='neutral'>        uint256 k,</span>
 250 |     | <span class='neutral'>        uint256 tokenInAmount,</span>
 251 |     | <span class='neutral'>        uint256 value</span>
 252 | *   | <span class='executed'>    ) internal returns (CreatePoolETHParams memory) {</span>
 253 | *   | <span class='executed'>        require(allPools.length &lt; MAX_POOLS, &quot;Maximum number of pools reached&quot;);</span>
 254 |     | <span class='neutral'></span>
 255 | *   | <span class='executed'>        address tokenAddr = address(tokens[token % tokens.length]);</span>
 256 | *   | <span class='executed'>        if (tokenAddr == address(weth)) {</span>
 257 | *   | <span class='executed'>            tokenAddr = address(tokens[(token + 1) % tokens.length]);</span>
 258 |     | <span class='neutral'>        }</span>
 259 | *   | <span class='executed'>        lpFeeRate = clampBetween(lpFeeRate, MIN_LP_FEE_RATE, MAX_LP_FEE_RATE);</span>
 260 | *   | <span class='executed'>        i = clampBetween(i, 1, MAX_I);</span>
 261 | *   | <span class='executed'>        k = clampBetween(k, 0, MAX_K);</span>
 262 | *   | <span class='executed'>        tokenInAmount = clampBetween(tokenInAmount, 0, IERC20(tokenAddr).balanceOf(address(currentActor)));</span>
 263 | *   | <span class='executed'>        value = clampBetween(value, 0, currentActor.balance);</span>
 264 | *   | <span class='executed'>        return CreatePoolETHParams(tokenAddr, useTokenAsQuote, lpFeeRate, i, k, currentActor, tokenInAmount, value);</span>
 265 |     | <span class='neutral'>    }</span>
 266 |     | <span class='neutral'></span>
 267 | *   | <span class='executed'>    function removeLiquidityPreconditions(</span>
 268 |     | <span class='neutral'>        uint8 lp,</span>
 269 |     | <span class='neutral'>        uint256 sharesIn,</span>
 270 |     | <span class='neutral'>        uint256 minimumBaseAmount,</span>
 271 |     | <span class='neutral'>        uint256 minimumQuoteAmount</span>
 272 | *   | <span class='executed'>    ) internal returns (RemoveLiquidityParams memory) {</span>
 273 | *r  | <span class='executed'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
 274 |     | <span class='neutral'></span>
 275 | *   | <span class='executed'>        address lpAddr = address(allPools[lp % allPools.length]);</span>
 276 |     | <span class='neutral'></span>
 277 | *   | <span class='executed'>        sharesIn = clampBetween(sharesIn, 0, MagicLP(lpAddr).balanceOf(address(currentActor)));</span>
 278 |     | <span class='neutral'></span>
 279 | *   | <span class='executed'>        return RemoveLiquidityParams(lpAddr, sharesIn, minimumBaseAmount, minimumQuoteAmount);</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'></span>
 282 | *   | <span class='executed'>    function removeLiquidityETHPreconditions(</span>
 283 |     | <span class='neutral'>        uint8 lp,</span>
 284 |     | <span class='neutral'>        uint256 sharesIn,</span>
 285 |     | <span class='neutral'>        uint256 minimumETHAmount,</span>
 286 |     | <span class='neutral'>        uint256 minimumTokenAmount</span>
 287 | *   | <span class='executed'>    ) internal returns (RemoveLiquidityETHParams memory) {</span>
 288 | *   | <span class='executed'>        require(availablePools[address(weth)].length &gt; 0, &quot;There are no available pools with WETH&quot;);</span>
 289 |     | <span class='neutral'></span>
 290 | *   | <span class='executed'>        address quoteToken = availablePools[address(weth)][lp % availablePools[address(weth)].length];</span>
 291 | *   | <span class='executed'>        address lpAddr = pools[address(weth)][quoteToken];</span>
 292 |     | <span class='neutral'></span>
 293 | *   | <span class='executed'>        sharesIn = clampBetween(sharesIn, 0, MagicLP(lpAddr).balanceOf(address(currentActor)));</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='unexecuted'>        return RemoveLiquidityETHParams(lpAddr, sharesIn, minimumETHAmount, minimumTokenAmount);</span>
 296 |     | <span class='neutral'>    }</span>
 297 |     | <span class='neutral'></span>
 298 | *   | <span class='executed'>    function previewAddLiquidityPreconditions(</span>
 299 |     | <span class='neutral'>        uint8 lp,</span>
 300 |     | <span class='neutral'>        uint256 baseInAmount,</span>
 301 |     | <span class='neutral'>        uint256 quoteInAmount</span>
 302 | *   | <span class='executed'>    ) internal returns (PreviewAddLiquidityParams memory) {</span>
 303 | *   | <span class='executed'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
 304 |     | <span class='neutral'></span>
 305 | *   | <span class='executed'>        address lpAddr = address(allPools[lp % allPools.length]);</span>
 306 |     | <span class='neutral'></span>
 307 | *   | <span class='executed'>        baseInAmount = clampBetween(baseInAmount, 0, REASONABLE_PREVIEW_AMOUNT);</span>
 308 | *   | <span class='executed'>        quoteInAmount = clampBetween(quoteInAmount, 0, REASONABLE_PREVIEW_AMOUNT);</span>
 309 |     | <span class='neutral'></span>
 310 | *   | <span class='executed'>        return PreviewAddLiquidityParams(lpAddr, baseInAmount, quoteInAmount);</span>
 311 |     | <span class='neutral'>    }</span>
 312 |     | <span class='neutral'></span>
 313 | *   | <span class='executed'>    function previewRemoveLiquidityPreconditions(uint8 lp, uint256 sharesIn) internal returns (PreviewRemoveLiquidityParams memory) {</span>
 314 | *   | <span class='executed'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
 315 |     | <span class='neutral'></span>
 316 | *   | <span class='executed'>        address lpAddr = address(allPools[lp % allPools.length]);</span>
 317 |     | <span class='neutral'></span>
 318 | *   | <span class='executed'>        sharesIn = clampBetween(sharesIn, 0, REASONABLE_PREVIEW_AMOUNT);</span>
 319 |     | <span class='neutral'></span>
 320 | *   | <span class='executed'>        return PreviewRemoveLiquidityParams(lpAddr, sharesIn);</span>
 321 |     | <span class='neutral'>    }</span>
 322 |     | <span class='neutral'></span>
 323 | *   | <span class='executed'>    function sellBaseETHForTokensPreconditions(</span>
 324 |     | <span class='neutral'>        uint8 lp,</span>
 325 |     | <span class='neutral'>        uint256 minimumOut,</span>
 326 |     | <span class='neutral'>        uint256 value</span>
 327 | *   | <span class='executed'>    ) internal returns (SellBaseETHForTokensParams memory) {</span>
 328 | *   | <span class='executed'>        require(availablePools[address(weth)].length &gt; 0, &quot;There are no available pools with WETH&quot;);</span>
 329 |     | <span class='neutral'></span>
 330 | *   | <span class='executed'>        address quoteToken = availablePools[address(weth)][lp % availablePools[address(weth)].length];</span>
 331 | *   | <span class='executed'>        address lpAddr = pools[address(weth)][quoteToken];</span>
 332 |     | <span class='neutral'></span>
 333 | *   | <span class='executed'>        require(MagicLP(lpAddr)._BASE_TOKEN_() == address(weth), &quot;The base token of the pool is not WETH&quot;);</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='unexecuted'>        value = clampBetween(value, 0, currentActor.balance);</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='unexecuted'>        return SellBaseETHForTokensParams(lpAddr, minimumOut, value);</span>
 338 |     | <span class='neutral'>    }</span>
 339 |     | <span class='neutral'></span>
 340 | *   | <span class='executed'>    function sellBaseTokensForETHPreconditions(</span>
 341 |     | <span class='neutral'>        uint8 lp,</span>
 342 |     | <span class='neutral'>        uint256 amountIn,</span>
 343 |     | <span class='neutral'>        uint256 minimumOut</span>
 344 | *   | <span class='executed'>    ) internal returns (SellBaseTokensForETHParams memory) {</span>
 345 | *   | <span class='executed'>        require(availablePools[address(weth)].length &gt; 0, &quot;There are no available pools with WETH&quot;);</span>
 346 |     | <span class='neutral'></span>
 347 | *   | <span class='executed'>        address quoteToken = availablePools[address(weth)][lp % availablePools[address(weth)].length];</span>
 348 | *   | <span class='executed'>        address lpAddr = pools[address(weth)][quoteToken];</span>
 349 |     | <span class='neutral'></span>
 350 | *   | <span class='executed'>        require(MagicLP(lpAddr)._QUOTE_TOKEN_() == address(weth), &quot;The quote token of the pool is not WETH&quot;);</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='unexecuted'>        amountIn = clampBetween(amountIn, 0, IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).balanceOf(address(currentActor)));</span>
 353 |     | <span class='neutral'></span>
 354 |     | <span class='unexecuted'>        vm.prank(currentActor);</span>
 355 |     | <span class='unexecuted'>        IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).approve(address(router), amountIn);</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='unexecuted'>        return SellBaseTokensForETHParams(lpAddr, amountIn, minimumOut);</span>
 358 |     | <span class='neutral'>    }</span>
 359 |     | <span class='neutral'></span>
 360 | *   | <span class='executed'>    function sellBaseTokensForTokensPreconditions(</span>
 361 |     | <span class='neutral'>        uint8 lp,</span>
 362 |     | <span class='neutral'>        uint256 amountIn,</span>
 363 |     | <span class='neutral'>        uint256 minimumOut</span>
 364 | *   | <span class='executed'>    ) internal returns (SellBaseTokensForTokensParams memory) {</span>
 365 | *   | <span class='executed'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
 366 |     | <span class='neutral'></span>
 367 | *   | <span class='executed'>        address lpAddr = address(allPools[lp % allPools.length]);</span>
 368 |     | <span class='neutral'></span>
 369 | *   | <span class='executed'>        amountIn = clampBetween(amountIn, 0, IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).balanceOf(address(currentActor)));</span>
 370 |     | <span class='neutral'></span>
 371 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 372 | *   | <span class='executed'>        IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).approve(address(router), amountIn);</span>
 373 |     | <span class='neutral'></span>
 374 |     | <span class='neutral'>        return SellBaseTokensForTokensParams(lpAddr, amountIn, minimumOut);</span>
 375 |     | <span class='neutral'>    }</span>
 376 |     | <span class='neutral'></span>
 377 | *   | <span class='executed'>    function sellQuoteETHForTokensPreconditions(</span>
 378 |     | <span class='neutral'>        uint8 lp,</span>
 379 |     | <span class='neutral'>        uint256 minimumOut,</span>
 380 |     | <span class='neutral'>        uint256 value</span>
 381 | *   | <span class='executed'>    ) internal returns (SellQuoteETHForTokensParams memory) {</span>
 382 | *   | <span class='executed'>        require(availablePools[address(weth)].length &gt; 0, &quot;There are no available pools with WETH&quot;);</span>
 383 |     | <span class='neutral'></span>
 384 | *   | <span class='executed'>        address quoteToken = availablePools[address(weth)][lp % availablePools[address(weth)].length];</span>
 385 | *   | <span class='executed'>        address lpAddr = pools[address(weth)][quoteToken];</span>
 386 |     | <span class='neutral'></span>
 387 | *   | <span class='executed'>        require(MagicLP(lpAddr)._QUOTE_TOKEN_() == address(weth), &quot;The base token of the pool is not WETH&quot;);</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>        value = clampBetween(value, 0, currentActor.balance);</span>
 390 |     | <span class='neutral'></span>
 391 |     | <span class='neutral'>        return SellQuoteETHForTokensParams(lpAddr, minimumOut, value);</span>
 392 |     | <span class='neutral'>    }</span>
 393 |     | <span class='neutral'></span>
 394 | *   | <span class='executed'>    function sellQuoteTokensForETHPreconditions(</span>
 395 |     | <span class='neutral'>        uint8 lp,</span>
 396 |     | <span class='neutral'>        uint256 amountIn,</span>
 397 |     | <span class='neutral'>        uint256 minimumOut</span>
 398 | *   | <span class='executed'>    ) internal returns (SellQuoteTokensForETHParams memory) {</span>
 399 | *   | <span class='executed'>        require(availablePools[address(weth)].length &gt; 0, &quot;There are no available pools with WETH&quot;);</span>
 400 |     | <span class='neutral'></span>
 401 | *   | <span class='executed'>        address quoteToken = availablePools[address(weth)][lp % availablePools[address(weth)].length];</span>
 402 | *   | <span class='executed'>        address lpAddr = pools[address(weth)][quoteToken];</span>
 403 |     | <span class='neutral'></span>
 404 | *   | <span class='executed'>        require(MagicLP(lpAddr)._BASE_TOKEN_() == address(weth), &quot;The quote token of the pool is not WETH&quot;);</span>
 405 |     | <span class='neutral'></span>
 406 |     | <span class='neutral'>        amountIn = clampBetween(amountIn, 0, IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).balanceOf(address(currentActor)));</span>
 407 |     | <span class='neutral'></span>
 408 |     | <span class='neutral'>        vm.prank(currentActor);</span>
 409 |     | <span class='neutral'>        IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).approve(address(router), amountIn);</span>
 410 |     | <span class='neutral'></span>
 411 |     | <span class='neutral'>        return SellQuoteTokensForETHParams(lpAddr, amountIn, minimumOut);</span>
 412 |     | <span class='neutral'>    }</span>
 413 |     | <span class='neutral'></span>
 414 | *   | <span class='executed'>    function sellQuoteTokensForTokensPreconditions(</span>
 415 |     | <span class='neutral'>        uint8 lp,</span>
 416 |     | <span class='neutral'>        uint256 amountIn,</span>
 417 |     | <span class='neutral'>        uint256 minimumOut</span>
 418 | *   | <span class='executed'>    ) internal returns (SellQuoteTokensForTokensParams memory) {</span>
 419 | *   | <span class='executed'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
 420 |     | <span class='neutral'></span>
 421 | *   | <span class='executed'>        address lpAddr = address(allPools[lp % allPools.length]);</span>
 422 |     | <span class='neutral'></span>
 423 | *   | <span class='executed'>        amountIn = clampBetween(amountIn, 0, IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).balanceOf(address(currentActor)));</span>
 424 |     | <span class='neutral'></span>
 425 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 426 | *   | <span class='executed'>        IERC20(MagicLP(lpAddr)._QUOTE_TOKEN_()).approve(address(router), amountIn);</span>
 427 |     | <span class='neutral'></span>
 428 | *   | <span class='executed'>        return SellQuoteTokensForTokensParams(lpAddr, amountIn, minimumOut);</span>
 429 |     | <span class='neutral'>    }</span>
 430 |     | <span class='neutral'></span>
 431 | *   | <span class='executed'>    function swapETHForTokensPreconditions(</span>
 432 |     | <span class='neutral'>        uint8 entropy,</span>
 433 |     | <span class='neutral'>        uint8 pathLength,</span>
 434 |     | <span class='neutral'>        uint256 directions,</span>
 435 |     | <span class='neutral'>        uint256 minimumOut,</span>
 436 |     | <span class='neutral'>        uint256 value</span>
 437 | *   | <span class='executed'>    ) internal returns (SwapETHForTokensParams memory) {</span>
 438 | *   | <span class='executed'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
 439 |     | <span class='neutral'></span>
 440 | *   | <span class='executed'>        address currentToken = address(weth);</span>
 441 | *   | <span class='executed'>        pathLength = uint8(clampBetween(pathLength, 1, MAX_PATH_LENGTH));</span>
 442 | *   | <span class='executed'>        address[] memory tempPath = new address[](pathLength);</span>
 443 | *   | <span class='executed'>        uint8 constructedPathLength = 0;</span>
 444 |     | <span class='neutral'></span>
 445 | *   | <span class='executed'>        for (uint8 i = 0; i &lt; pathLength; i++) {</span>
 446 | *   | <span class='executed'>            address nextPool = fetchPoolForToken(entropy, currentToken);</span>
 447 | *   | <span class='executed'>            if (nextPool == address(0)) {</span>
 448 | *   | <span class='executed'>                break;</span>
 449 |     | <span class='neutral'>            }</span>
 450 |     | <span class='unexecuted'>            tempPath[i] = nextPool;</span>
 451 |     | <span class='unexecuted'>            if (currentToken == MagicLP(nextPool)._QUOTE_TOKEN_()) {</span>
 452 |     | <span class='unexecuted'>                currentToken = MagicLP(nextPool)._BASE_TOKEN_();</span>
 453 |     | <span class='neutral'>            } else {</span>
 454 |     | <span class='unexecuted'>                currentToken = MagicLP(nextPool)._QUOTE_TOKEN_();</span>
 455 |     | <span class='neutral'>            }</span>
 456 |     | <span class='unexecuted'>            constructedPathLength++;</span>
 457 |     | <span class='neutral'>        }</span>
 458 | *   | <span class='executed'>        require(constructedPathLength &gt; 0, &quot;No valid path constructed&quot;);</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='unexecuted'>        address[] memory path = new address[](constructedPathLength);</span>
 461 |     | <span class='unexecuted'>        for (uint8 i = 0; i &lt; constructedPathLength; i++) {</span>
 462 |     | <span class='unexecuted'>            path[i] = tempPath[i];</span>
 463 |     | <span class='neutral'>        }</span>
 464 |     | <span class='neutral'></span>
 465 |     | <span class='unexecuted'>        value = clampBetween(value, 0, currentActor.balance);</span>
 466 |     | <span class='neutral'></span>
 467 |     | <span class='unexecuted'>        return SwapETHForTokensParams(path, directions, minimumOut, value);</span>
 468 |     | <span class='neutral'>    }</span>
 469 |     | <span class='neutral'></span>
 470 |     | <span class='neutral'>    event Path(address[] path);</span>
 471 |     | <span class='neutral'></span>
 472 | *   | <span class='executed'>    function swapTokensForETHPreconditions(</span>
 473 |     | <span class='neutral'>        uint256 amountIn,</span>
 474 |     | <span class='neutral'>        uint8 entropy,</span>
 475 |     | <span class='neutral'>        uint8 pathLength,</span>
 476 |     | <span class='neutral'>        uint256 directions,</span>
 477 |     | <span class='neutral'>        uint256 minimumOut</span>
 478 | *   | <span class='executed'>    ) internal returns (SwapTokensForETHParams memory) {</span>
 479 | *   | <span class='executed'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
 480 |     | <span class='neutral'></span>
 481 | *   | <span class='executed'>        address currentToken = address(weth);</span>
 482 | *   | <span class='executed'>        pathLength = uint8(clampBetween(pathLength, 1, MAX_PATH_LENGTH));</span>
 483 | *   | <span class='executed'>        address[] memory tempPath = new address[](pathLength);</span>
 484 | *   | <span class='executed'>        uint8 constructedPathLength = 0;</span>
 485 |     | <span class='neutral'></span>
 486 | *   | <span class='executed'>        for (uint8 i = pathLength - 1; i &gt;= 0; i--) {</span>
 487 | *   | <span class='executed'>            address nextPool = fetchPoolForToken(entropy, currentToken);</span>
 488 | *   | <span class='executed'>            if (nextPool == address(0)) {</span>
 489 | *   | <span class='executed'>                break;</span>
 490 |     | <span class='neutral'>            }</span>
 491 |     | <span class='unexecuted'>            tempPath[i] = nextPool;</span>
 492 |     | <span class='unexecuted'>            if (currentToken == MagicLP(nextPool)._QUOTE_TOKEN_()) {</span>
 493 |     | <span class='unexecuted'>                currentToken = MagicLP(nextPool)._BASE_TOKEN_();</span>
 494 |     | <span class='neutral'>            } else {</span>
 495 |     | <span class='unexecuted'>                currentToken = MagicLP(nextPool)._QUOTE_TOKEN_();</span>
 496 |     | <span class='neutral'>            }</span>
 497 |     | <span class='unexecuted'>            constructedPathLength++;</span>
 498 |     | <span class='neutral'>        }</span>
 499 | *   | <span class='executed'>        require(constructedPathLength &gt; 0, &quot;No valid path constructed&quot;);</span>
 500 |     | <span class='neutral'></span>
 501 |     | <span class='unexecuted'>        address[] memory path = new address[](constructedPathLength);</span>
 502 |     | <span class='unexecuted'>        for (uint8 i = 0; i &lt; constructedPathLength; i++) {</span>
 503 |     | <span class='unexecuted'>            path[i] = tempPath[i + (pathLength - constructedPathLength)];</span>
 504 |     | <span class='neutral'>        }</span>
 505 |     | <span class='neutral'></span>
 506 |     | <span class='unexecuted'>        if (directions &amp; 1 == 0) {</span>
 507 |     | <span class='unexecuted'>            amountIn = clampBetween(amountIn, 0, IERC20(IMagicLP(path[0])._BASE_TOKEN_()).balanceOf(address(currentActor)));</span>
 508 |     | <span class='unexecuted'>            IERC20(IMagicLP(path[0])._BASE_TOKEN_()).approve(path[0], amountIn);</span>
 509 |     | <span class='neutral'>        } else {</span>
 510 |     | <span class='unexecuted'>            amountIn = clampBetween(amountIn, 0, IERC20(IMagicLP(path[0])._QUOTE_TOKEN_()).balanceOf(address(currentActor)));</span>
 511 |     | <span class='unexecuted'>            IERC20(IMagicLP(path[0])._QUOTE_TOKEN_()).approve(path[0], amountIn);</span>
 512 |     | <span class='neutral'>        }</span>
 513 |     | <span class='neutral'></span>
 514 |     | <span class='unexecuted'>        return SwapTokensForETHParams(amountIn, path, directions, minimumOut);</span>
 515 |     | <span class='neutral'>    }</span>
 516 |     | <span class='neutral'></span>
 517 | *   | <span class='executed'>    function swapTokensForTokensPreconditions(</span>
 518 |     | <span class='neutral'>        uint8 startingToken,</span>
 519 |     | <span class='neutral'>        uint256 amountIn,</span>
 520 |     | <span class='neutral'>        uint8 entropy,</span>
 521 |     | <span class='neutral'>        uint8 pathLength,</span>
 522 |     | <span class='neutral'>        uint256 directions,</span>
 523 |     | <span class='neutral'>        uint256 minimumOut</span>
 524 | *   | <span class='executed'>    ) internal returns (SwapTokensForTokensParams memory) {</span>
 525 | *   | <span class='executed'>        require(allPools.length &gt; 0, &quot;There are no available pools&quot;);</span>
 526 |     | <span class='neutral'></span>
 527 | *   | <span class='executed'>        address currentToken = address(tokens[startingToken % tokens.length]);</span>
 528 | *   | <span class='executed'>        pathLength = uint8(clampBetween(pathLength, 1, MAX_PATH_LENGTH));</span>
 529 | *   | <span class='executed'>        address[] memory tempPath = new address[](pathLength);</span>
 530 | *   | <span class='executed'>        uint8 constructedPathLength = 0;</span>
 531 |     | <span class='neutral'></span>
 532 | *   | <span class='executed'>        for (uint8 i = 0; i &lt; pathLength; i++) {</span>
 533 | *   | <span class='executed'>            address nextPool = fetchPoolForToken(entropy, currentToken);</span>
 534 | *   | <span class='executed'>            if (nextPool == address(0)) {</span>
 535 | *   | <span class='executed'>                break;</span>
 536 |     | <span class='neutral'>            }</span>
 537 |     | <span class='unexecuted'>            tempPath[i] = nextPool;</span>
 538 |     | <span class='unexecuted'>            if (currentToken == MagicLP(nextPool)._QUOTE_TOKEN_()) {</span>
 539 |     | <span class='unexecuted'>                currentToken = MagicLP(nextPool)._BASE_TOKEN_();</span>
 540 |     | <span class='neutral'>            } else {</span>
 541 |     | <span class='unexecuted'>                currentToken = MagicLP(nextPool)._QUOTE_TOKEN_();</span>
 542 |     | <span class='neutral'>            }</span>
 543 |     | <span class='unexecuted'>            constructedPathLength++;</span>
 544 |     | <span class='neutral'>        }</span>
 545 | *   | <span class='executed'>        require(constructedPathLength &gt; 0, &quot;No valid path constructed&quot;);</span>
 546 |     | <span class='neutral'></span>
 547 |     | <span class='unexecuted'>        address[] memory path = new address[](constructedPathLength);</span>
 548 |     | <span class='unexecuted'>        for (uint8 i = 0; i &lt; constructedPathLength; i++) {</span>
 549 |     | <span class='unexecuted'>            path[i] = tempPath[i];</span>
 550 |     | <span class='neutral'>        }</span>
 551 |     | <span class='neutral'></span>
 552 |     | <span class='unexecuted'>        if (directions &amp; 1 == 0) {</span>
 553 |     | <span class='unexecuted'>            amountIn = clampBetween(amountIn, 0, IERC20(IMagicLP(path[0])._BASE_TOKEN_()).balanceOf(address(currentActor)));</span>
 554 |     | <span class='unexecuted'>            IERC20(IMagicLP(path[0])._BASE_TOKEN_()).approve(path[0], amountIn);</span>
 555 |     | <span class='neutral'>        } else {</span>
 556 |     | <span class='unexecuted'>            amountIn = clampBetween(amountIn, 0, IERC20(IMagicLP(path[0])._QUOTE_TOKEN_()).balanceOf(address(currentActor)));</span>
 557 |     | <span class='unexecuted'>            IERC20(IMagicLP(path[0])._QUOTE_TOKEN_()).approve(path[0], amountIn);</span>
 558 |     | <span class='neutral'>        }</span>
 559 |     | <span class='neutral'></span>
 560 |     | <span class='unexecuted'>        return SwapTokensForTokensParams(amountIn, path, directions, minimumOut);</span>
 561 |     | <span class='neutral'>    }</span>
 562 |     | <span class='neutral'></span>
 563 | *   | <span class='executed'>    function fetchPoolForToken(uint8 entropy, address token) internal returns (address) {</span>
 564 | *   | <span class='executed'>        uint8 index = uint8(uint256(keccak256(abi.encode(entropy))));</span>
 565 | *   | <span class='executed'>        index = uint8(clampBetween(index, 0, availablePools[token].length - 1));</span>
 566 | *   | <span class='executed'>        address quoteToken = availablePools[token][index];</span>
 567 | *   | <span class='executed'>        return pools[token][quoteToken];</span>
 568 |     | <span class='neutral'>    }</span>
 569 |     | <span class='neutral'>}</span>
 570 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/mocks/MockERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ERC20} from &quot;openzeppelin-contracts/token/ERC20/ERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 | *   | <span class='executed'>contract MockERC20 is ERC20 {</span>
  7 |     | <span class='neutral'>    uint8 private _decimals;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    constructor(string memory name, string memory symbol, uint8 dec) ERC20(name, symbol) {</span>
 10 |     | <span class='unexecuted'>        _decimals = dec;</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 | *   | <span class='executed'>    function decimals() public view virtual override(ERC20) returns (uint8) {</span>
 14 | *   | <span class='executed'>        return _decimals;</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 | *   | <span class='executed'>    function mint(address account, uint256 amount) external {</span>
 18 |     | <span class='unexecuted'>        _mint(account, amount);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    function burn(address account, uint256 amount) external {</span>
 22 |     | <span class='unexecuted'>        _burn(account, amount);</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/mocks/MockWETH.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {MockERC20} from &quot;./MockERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 | *   | <span class='executed'>contract MockWETH is MockERC20 {</span>
  7 |     | <span class='neutral'>    event Deposit(address indexed dst, uint wad);</span>
  8 |     | <span class='neutral'>    event Withdrawal(address indexed src, uint wad);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    constructor(string memory name, string memory symbol) MockERC20(name, symbol, 18) {}</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    receive() external payable {</span>
 13 | *   | <span class='executed'>        deposit();</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 | *   | <span class='executed'>    function deposit() public payable {</span>
 17 | *   | <span class='executed'>        _mint(msg.sender, msg.value);</span>
 18 |     | <span class='neutral'></span>
 19 | *   | <span class='executed'>        emit Deposit(msg.sender, msg.value);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function withdraw(uint256 wad) public {</span>
 23 |     | <span class='unexecuted'>        _burn(msg.sender, wad);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>        payable(msg.sender).transfer(wad);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>        emit Withdrawal(msg.sender, wad);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/properties/Properties.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./Properties_LIQ.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./Properties_RES.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./Properties_POOL.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./Properties_SWAP.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @title Properties</span>
 11 |     | <span class='neutral'> * @author 0xScourgedev</span>
 12 |     | <span class='neutral'> * @notice Composite contract for all of the properties, and contains general invariants</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='neutral'>abstract contract Properties is Properties_LIQ, Properties_RES, Properties_POOL, Properties_SWAP {</span>
 15 | *   | <span class='executed'>    function invariant_GENERAL_01(bytes memory returnData) internal {</span>
 16 | *   | <span class='executed'>        gte(returnData.length, 4, GENERAL_01);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/properties/PropertiesBase.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;fuzzlib/FuzzBase.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;fuzzlib/AssertWrapper.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./PropertiesDescriptions.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../helper/BeforeAfter.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @title PropertiesBase</span>
 11 |     | <span class='neutral'> * @author 0xScourgedev</span>
 12 |     | <span class='neutral'> * @notice Composite contract for all of the dependencies of the properties</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='neutral'>abstract contract PropertiesBase is FuzzBase, BeforeAfter, PropertiesDescriptions {</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/properties/PropertiesDescriptions.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title PropertiesDescriptions</span>
  6 |     | <span class='neutral'> * @author 0xScourgedev</span>
  7 |     | <span class='neutral'> * @notice Descriptions strings for the invariants</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>abstract contract PropertiesDescriptions {</span>
 10 |     | <span class='neutral'>    string constant GENERAL_01 = &quot;GENERAL-01: Does not silent revert&quot;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    string constant LIQ_01 =</span>
 13 |     | <span class='neutral'>        &quot;LIQ-01: If the base and quote token balance is 0, the amount of base tokens and quote tokens in the pool is always strictly increasing after adding liquidity&quot;;</span>
 14 |     | <span class='neutral'>    string constant LIQ_02 =</span>
 15 |     | <span class='neutral'>        &quot;LIQ-02: If the base and quote token balance is 0, the amount of base and quote tokens of the user is always strictly decreasing after adding liquidity&quot;;</span>
 16 |     | <span class='neutral'>    string constant LIQ_03 = &quot;LIQ-03: The total supply of lp tokens is always strictly increasing after adding liquidity&quot;;</span>
 17 |     | <span class='neutral'>    string constant LIQ_04 = &quot;LIQ-04: The lp token balance of the user is always strictly increasing after adding liquidity&quot;;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    string constant LIQ_05 = &quot;LIQ-05: The amount of base tokens and quote tokens in the pool is always decreasing after removing liquidity&quot;;</span>
 20 |     | <span class='neutral'>    string constant LIQ_06 = &quot;LIQ-06: The amount of base and quote tokens of the user is always increasing after removing liquidity&quot;;</span>
 21 |     | <span class='neutral'>    string constant LIQ_07 = &quot;LIQ-07: The total supply of lp tokens is always strictly decreasing after removing liquidity&quot;;</span>
 22 |     | <span class='neutral'>    string constant LIQ_08 = &quot;LIQ-08: The lp token balance of the user is always strictly decreasing after removing liquidity&quot;;</span>
 23 |     | <span class='neutral'>    string constant LIQ_09 = &quot;LIQ-09: Base and quote tokens are never transfered to the user for free when removing liquidity&quot;;</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    string constant LIQ_10 = &quot;LIQ-10: previewAddLiquidity() never reverts for reasonable values&quot;;</span>
 26 |     | <span class='neutral'>    string constant LIQ_11 =</span>
 27 |     | <span class='neutral'>        &quot;LIQ-11: previewRemoveLiquidity() never reverts for reasonable values if the total supply of lp tokens is greater than 0&quot;;</span>
 28 |     | <span class='neutral'>    string constant LIQ_12 = &quot;LIQ-12: Adding liquidity must provide less or equal shares to the user predicted by previewAddLiquidity()&quot;;</span>
 29 |     | <span class='neutral'>    string constant LIQ_13 = &quot;LIQ-13: Adding liquidity unsafe must provide exact shares to the user predicted by previewAddLiquidity()&quot;;</span>
 30 |     | <span class='neutral'>    string constant LIQ_14 =</span>
 31 |     | <span class='neutral'>        &quot;LIQ-14: Removing liquidity must provide the same amount of base and quote tokens to the user predicted by previewRemoveLiquidity()&quot;;</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    string constant RES_01 = &quot;RES-01: If the quote reserve and base reserve of a pool is 0, then the lp total supply must be 0&quot;;</span>
 34 |     | <span class='neutral'>    string constant RES_02 = &quot;RES-02: The base reserve of a pool is always less than or equal to the pool base balance&quot;;</span>
 35 |     | <span class='neutral'>    string constant RES_03 = &quot;RES-03: The quote reserve of a pool is always less than or equal to the pool quote balance&quot;;</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    string constant POOL_01 =</span>
 38 |     | <span class='neutral'>        &quot;POOL-01: The sum of the LP token balances held by each user is always equal to the total supply of LP tokens&quot;;</span>
 39 |     | <span class='neutral'>    string constant POOL_02 = &quot;POOL-02: sync() must never revert&quot;;</span>
 40 |     | <span class='neutral'>    string constant POOL_03 = &quot;POOL-03: correctRState() must never revert&quot;;</span>
 41 |     | <span class='neutral'>    string constant POOL_04 = &quot;POOL-04: The total supply of LP tokens is either 0 or always greater or equal to 1001&quot;;</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    string constant SWAP_01 = &quot;SWAP-01: Swap must decrease the input token balance of the user if the input and output token are different&quot;;</span>
 44 |     | <span class='neutral'>    string constant SWAP_02 =</span>
 45 |     | <span class='neutral'>        &quot;SWAP-02: Swap must increase the output token balance of the user if the input and output token are different&quot;;</span>
 46 |     | <span class='neutral'>    string constant SWAP_03 =</span>
 47 |     | <span class='neutral'>        &quot;SWAP-03: The swap must credit the user with an amount of the output token that is equal to or greater than the specified minimumOut&quot;;</span>
 48 |     | <span class='neutral'>}</span>
 49 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/properties/Properties_LIQ.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./PropertiesBase.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @title Properties_LIQ</span>
   8 |     | <span class='neutral'> * @author 0xScourgedev</span>
   9 |     | <span class='neutral'> * @notice Contains all LIQ invariants</span>
  10 |     | <span class='neutral'> */</span>
  11 |     | <span class='neutral'>abstract contract Properties_LIQ is PropertiesBase {</span>
  12 | *   | <span class='executed'>    function invariant_LIQ_01(address pool) internal {</span>
  13 | *   | <span class='executed'>        if (states[0].poolStates[pool].baseBalance &gt; 0 || states[0].poolStates[pool].quoteBalance &gt; 0) {</span>
  14 |     | <span class='neutral'>            return;</span>
  15 |     | <span class='neutral'>        }</span>
  16 | *   | <span class='executed'>        gt(states[1].poolStates[pool].baseBalance, states[0].poolStates[pool].baseBalance, LIQ_01);</span>
  17 | *   | <span class='executed'>        gt(states[1].poolStates[pool].quoteBalance, states[0].poolStates[pool].quoteBalance, LIQ_01);</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 | *   | <span class='executed'>    function invariant_LIQ_02(address pool, bool supplyETH) internal {</span>
  21 | *   | <span class='executed'>        if (states[0].poolStates[pool].baseBalance &gt; 0 || states[0].poolStates[pool].quoteBalance &gt; 0) {</span>
  22 |     | <span class='neutral'>            return;</span>
  23 |     | <span class='neutral'>        }</span>
  24 |     | <span class='neutral'></span>
  25 | *   | <span class='executed'>        if (supplyETH) {</span>
  26 |     | <span class='unexecuted'>            address tokenToCheck;</span>
  27 |     | <span class='unexecuted'>            if (MagicLP(pool)._BASE_TOKEN_() == address(weth)) {</span>
  28 |     | <span class='unexecuted'>                tokenToCheck = MagicLP(pool)._QUOTE_TOKEN_();</span>
  29 |     | <span class='neutral'>            } else {</span>
  30 |     | <span class='unexecuted'>                tokenToCheck = MagicLP(pool)._BASE_TOKEN_();</span>
  31 |     | <span class='neutral'>            }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>            lt(</span>
  34 |     | <span class='unexecuted'>                states[1].actorStates[currentActor].tokenBalances[tokenToCheck],</span>
  35 |     | <span class='unexecuted'>                states[0].actorStates[currentActor].tokenBalances[tokenToCheck],</span>
  36 |     | <span class='unexecuted'>                LIQ_02</span>
  37 |     | <span class='neutral'>            );</span>
  38 |     | <span class='unexecuted'>            lt(states[1].actorStates[currentActor].ethBalance, states[0].actorStates[currentActor].ethBalance, LIQ_02);</span>
  39 |     | <span class='neutral'>        } else {</span>
  40 | *   | <span class='executed'>            lt(</span>
  41 | *   | <span class='executed'>                states[1].actorStates[currentActor].tokenBalances[MagicLP(pool)._BASE_TOKEN_()],</span>
  42 | *   | <span class='executed'>                states[0].actorStates[currentActor].tokenBalances[MagicLP(pool)._BASE_TOKEN_()],</span>
  43 | *   | <span class='executed'>                LIQ_02</span>
  44 |     | <span class='neutral'>            );</span>
  45 | *   | <span class='executed'>            lt(</span>
  46 | *   | <span class='executed'>                states[1].actorStates[currentActor].tokenBalances[MagicLP(pool)._QUOTE_TOKEN_()],</span>
  47 | *   | <span class='executed'>                states[0].actorStates[currentActor].tokenBalances[MagicLP(pool)._QUOTE_TOKEN_()],</span>
  48 |     | <span class='neutral'>                LIQ_02</span>
  49 |     | <span class='neutral'>            );</span>
  50 |     | <span class='neutral'>        }</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 | *   | <span class='executed'>    function invariant_LIQ_03(address pool) internal {</span>
  54 | *   | <span class='executed'>        gt(states[1].poolStates[pool].lpTotalSupply, states[0].poolStates[pool].lpTotalSupply, LIQ_03);</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 | *   | <span class='executed'>    function invariant_LIQ_04(address pool) internal {</span>
  58 | *   | <span class='executed'>        gt(states[1].actorStates[currentActor].tokenBalances[pool], states[0].actorStates[currentActor].tokenBalances[pool], LIQ_04);</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 | *   | <span class='executed'>    function invariant_LIQ_05(address pool) internal {</span>
  62 | *   | <span class='executed'>        lte(states[1].poolStates[pool].baseBalance, states[0].poolStates[pool].baseBalance, LIQ_05);</span>
  63 | *   | <span class='executed'>        lte(states[1].poolStates[pool].quoteBalance, states[0].poolStates[pool].quoteBalance, LIQ_05);</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 | *   | <span class='executed'>    function invariant_LIQ_06(address pool, bool supplyETH) internal {</span>
  67 | *   | <span class='executed'>        if (supplyETH) {</span>
  68 |     | <span class='unexecuted'>            address tokenToCheck;</span>
  69 |     | <span class='unexecuted'>            if (MagicLP(pool)._BASE_TOKEN_() == address(weth)) {</span>
  70 |     | <span class='unexecuted'>                tokenToCheck = MagicLP(pool)._QUOTE_TOKEN_();</span>
  71 |     | <span class='neutral'>            } else {</span>
  72 |     | <span class='unexecuted'>                tokenToCheck = MagicLP(pool)._BASE_TOKEN_();</span>
  73 |     | <span class='neutral'>            }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>            gte(</span>
  76 |     | <span class='unexecuted'>                states[1].actorStates[currentActor].tokenBalances[tokenToCheck],</span>
  77 |     | <span class='unexecuted'>                states[0].actorStates[currentActor].tokenBalances[tokenToCheck],</span>
  78 |     | <span class='unexecuted'>                LIQ_06</span>
  79 |     | <span class='neutral'>            );</span>
  80 |     | <span class='unexecuted'>            gte(states[1].actorStates[currentActor].ethBalance, states[0].actorStates[currentActor].ethBalance, LIQ_06);</span>
  81 |     | <span class='neutral'>        } else {</span>
  82 | *   | <span class='executed'>            gte(</span>
  83 | *   | <span class='executed'>                states[1].actorStates[currentActor].tokenBalances[MagicLP(pool)._BASE_TOKEN_()],</span>
  84 | *   | <span class='executed'>                states[0].actorStates[currentActor].tokenBalances[MagicLP(pool)._BASE_TOKEN_()],</span>
  85 | *   | <span class='executed'>                LIQ_06</span>
  86 |     | <span class='neutral'>            );</span>
  87 | *   | <span class='executed'>            gte(</span>
  88 | *   | <span class='executed'>                states[1].actorStates[currentActor].tokenBalances[MagicLP(pool)._QUOTE_TOKEN_()],</span>
  89 | *   | <span class='executed'>                states[0].actorStates[currentActor].tokenBalances[MagicLP(pool)._QUOTE_TOKEN_()],</span>
  90 |     | <span class='neutral'>                LIQ_06</span>
  91 |     | <span class='neutral'>            );</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 | *   | <span class='executed'>    function invariant_LIQ_07(address pool, uint256 sharesIn) internal {</span>
  96 | *   | <span class='executed'>        if (sharesIn &gt; 0) {</span>
  97 | *   | <span class='executed'>            lt(states[1].poolStates[pool].lpTotalSupply, states[0].poolStates[pool].lpTotalSupply, LIQ_07);</span>
  98 |     | <span class='neutral'>        }</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 | *   | <span class='executed'>    function invariant_LIQ_08(address pool, uint256 sharesIn) internal {</span>
 102 | *   | <span class='executed'>        if (sharesIn &gt; 0) {</span>
 103 | *   | <span class='executed'>            lt(states[1].actorStates[currentActor].tokenBalances[pool], states[0].actorStates[currentActor].tokenBalances[pool], LIQ_08);</span>
 104 |     | <span class='neutral'>        }</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 | *   | <span class='executed'>    function invariant_LIQ_09(address pool, uint256 sharesIn) internal {</span>
 108 | *   | <span class='executed'>        if (sharesIn == 0) {</span>
 109 |     | <span class='unexecuted'>            eq(</span>
 110 |     | <span class='unexecuted'>                states[1].actorStates[currentActor].tokenBalances[MagicLP(pool)._BASE_TOKEN_()],</span>
 111 |     | <span class='unexecuted'>                states[0].actorStates[currentActor].tokenBalances[MagicLP(pool)._BASE_TOKEN_()],</span>
 112 |     | <span class='unexecuted'>                LIQ_09</span>
 113 |     | <span class='neutral'>            );</span>
 114 |     | <span class='unexecuted'>            eq(</span>
 115 |     | <span class='unexecuted'>                states[1].actorStates[currentActor].tokenBalances[MagicLP(pool)._QUOTE_TOKEN_()],</span>
 116 |     | <span class='unexecuted'>                states[0].actorStates[currentActor].tokenBalances[MagicLP(pool)._QUOTE_TOKEN_()],</span>
 117 |     | <span class='neutral'>                LIQ_09</span>
 118 |     | <span class='neutral'>            );</span>
 119 |     | <span class='unexecuted'>            eq(states[1].actorStates[currentActor].ethBalance, states[0].actorStates[currentActor].ethBalance, LIQ_09);</span>
 120 |     | <span class='neutral'>        }</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>    function invariant_LIQ_10() internal {</span>
 124 |     | <span class='unexecuted'>        t(false, LIQ_10);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 | *   | <span class='executed'>    function invariant_LIQ_11(address pool) internal {</span>
 128 | *   | <span class='executed'>        if (MagicLP(pool).totalSupply() &gt; 0) {</span>
 129 |     | <span class='unexecuted'>            t(false, LIQ_11);</span>
 130 |     | <span class='neutral'>        }</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 | *   | <span class='executed'>    function invariant_LIQ_12(uint256 preview, uint256 actual) internal {</span>
 134 | *   | <span class='executed'>        gte(preview, actual, LIQ_12);</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 | *   | <span class='executed'>    function invariant_LIQ_13(uint256 preview, uint256 actual) internal {</span>
 138 | *   | <span class='executed'>        eq(preview, actual, LIQ_13);</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 | *   | <span class='executed'>    function invariant_LIQ_14(uint256 previewBase, uint256 previewQuote, uint256 actualBase, uint256 actualQuote) internal {</span>
 142 | *   | <span class='executed'>        eq(previewBase, actualBase, LIQ_14);</span>
 143 | *   | <span class='executed'>        eq(previewQuote, actualQuote, LIQ_14);</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'>}</span>
 146 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/properties/Properties_POOL.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./PropertiesBase.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title Properties_POOL</span>
  8 |     | <span class='neutral'> * @author 0xScourgedev</span>
  9 |     | <span class='neutral'> * @notice Contains all POOL invariants</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>abstract contract Properties_POOL is PropertiesBase {</span>
 12 | *   | <span class='executed'>    function invariant_POOL_01(address pool) internal {</span>
 13 | *   | <span class='executed'>        uint256 sum = 0;</span>
 14 | *   | <span class='executed'>        for (uint8 i = 0; i &lt; USERS.length; i++) {</span>
 15 | *   | <span class='executed'>            sum += states[1].actorStates[USERS[i]].tokenBalances[pool];</span>
 16 |     | <span class='neutral'>        }</span>
 17 | *   | <span class='executed'>        sum += states[1].poolStates[pool].addressZeroBal;</span>
 18 | *   | <span class='executed'>        sum += states[1].poolStates[pool].poolLpTokenBal;</span>
 19 | *   | <span class='executed'>        eq(sum, states[1].poolStates[pool].lpTotalSupply, POOL_01);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 | *   | <span class='executed'>    function invariant_POOL_02() internal {</span>
 23 | *   | <span class='executed'>        t(false, POOL_02);</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    function invariant_POOL_03() internal {</span>
 27 |     | <span class='unexecuted'>        t(false, POOL_03);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 | *   | <span class='executed'>    function invariant_POOL_04(address pool) internal {</span>
 31 | *   | <span class='executed'>        bool isZero = states[1].poolStates[pool].lpTotalSupply == 0;</span>
 32 | *   | <span class='executed'>        bool gte1001 = states[1].poolStates[pool].lpTotalSupply &gt;= 1001;</span>
 33 | *   | <span class='executed'>        t(isZero || gte1001, POOL_04);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'>}</span>
 36 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/properties/Properties_RES.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./PropertiesBase.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title Properties_RES</span>
  8 |     | <span class='neutral'> * @author 0xScourgedev</span>
  9 |     | <span class='neutral'> * @notice Contains all RES invariants</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>abstract contract Properties_RES is PropertiesBase {</span>
 12 | *   | <span class='executed'>    function invariant_RES_01(address pool) internal {</span>
 13 | *   | <span class='executed'>        if (states[1].poolStates[pool].baseReserve == 0 &amp;&amp; states[1].poolStates[pool].quoteReserve == 0) {</span>
 14 | *   | <span class='executed'>            eq(states[1].poolStates[pool].lpTotalSupply, 0, RES_01);</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 | *   | <span class='executed'>    function invariant_RES_02(address pool) internal {</span>
 19 | *   | <span class='executed'>        lte(states[1].poolStates[pool].baseReserve, states[1].poolStates[pool].baseBalance, RES_02);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 | *   | <span class='executed'>    function invariant_RES_03(address pool) internal {</span>
 23 | *   | <span class='executed'>        lte(states[1].poolStates[pool].quoteReserve, states[1].poolStates[pool].quoteBalance, RES_03);</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/properties/Properties_SWAP.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./PropertiesBase.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title Properties_SWAP</span>
  8 |     | <span class='neutral'> * @author 0xScourgedev</span>
  9 |     | <span class='neutral'> * @notice Contains all SWAP invariants</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>abstract contract Properties_SWAP is PropertiesBase {</span>
 12 |     | <span class='unexecuted'>    function invariant_SWAP_01(address inputToken, address outputToken, bool isEth) internal {</span>
 13 |     | <span class='unexecuted'>        if (isEth) {</span>
 14 |     | <span class='unexecuted'>            lte(states[1].actorStates[currentActor].ethBalance, states[0].actorStates[currentActor].ethBalance, SWAP_01);</span>
 15 |     | <span class='neutral'>        } else {</span>
 16 |     | <span class='unexecuted'>            if (inputToken == outputToken) {</span>
 17 |     | <span class='neutral'>                return;</span>
 18 |     | <span class='neutral'>            }</span>
 19 |     | <span class='unexecuted'>            lte(</span>
 20 |     | <span class='unexecuted'>                states[1].actorStates[currentActor].tokenBalances[inputToken],</span>
 21 |     | <span class='unexecuted'>                states[0].actorStates[currentActor].tokenBalances[inputToken],</span>
 22 |     | <span class='unexecuted'>                SWAP_01</span>
 23 |     | <span class='neutral'>            );</span>
 24 |     | <span class='neutral'>        }</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function invariant_SWAP_02(address inputToken, address outputToken, bool isEth) internal {</span>
 28 |     | <span class='unexecuted'>        if (isEth) {</span>
 29 |     | <span class='unexecuted'>            gte(states[1].actorStates[currentActor].ethBalance, states[0].actorStates[currentActor].ethBalance, SWAP_02);</span>
 30 |     | <span class='neutral'>        } else {</span>
 31 |     | <span class='unexecuted'>            if (inputToken == outputToken) {</span>
 32 |     | <span class='neutral'>                return;</span>
 33 |     | <span class='neutral'>            }</span>
 34 |     | <span class='unexecuted'>            gte(</span>
 35 |     | <span class='unexecuted'>                states[1].actorStates[currentActor].tokenBalances[outputToken],</span>
 36 |     | <span class='unexecuted'>                states[0].actorStates[currentActor].tokenBalances[outputToken],</span>
 37 |     | <span class='unexecuted'>                SWAP_02</span>
 38 |     | <span class='neutral'>            );</span>
 39 |     | <span class='neutral'>        }</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='unexecuted'>    function invariant_SWAP_03(uint256 actualOut, uint256 minimumOut) internal {</span>
 43 |     | <span class='unexecuted'>        gte(actualOut, minimumOut, SWAP_03);</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'>}</span>
 46 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/util/FunctionCalls.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;fuzzlib/FuzzBase.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../helper/FuzzStorageVariables.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @title FunctionCalls</span>
  10 |     | <span class='neutral'> * @author 0xScourgedev</span>
  11 |     | <span class='neutral'> * @notice Contains the function calls for all of the handlers</span>
  12 |     | <span class='neutral'> */</span>
  13 |     | <span class='neutral'>abstract contract FunctionCalls is FuzzBase, FuzzStorageVariables {</span>
  14 |     | <span class='neutral'>    event CreateCall(address baseToken_, address quoteToken_, uint256 lpFeeRate_, uint256 i_, uint256 k_);</span>
  15 |     | <span class='neutral'>    event BuySharesCall(address to);</span>
  16 |     | <span class='neutral'>    event CorrectRStateCall();</span>
  17 |     | <span class='neutral'>    event SellBaseCall(address to);</span>
  18 |     | <span class='neutral'>    event SellQuoteCall(address to);</span>
  19 |     | <span class='neutral'>    event SellSharesCall(uint256 shareAmount, address to, uint256 baseMinAmount, uint256 quoteMinAmount, bytes data, uint256 deadline);</span>
  20 |     | <span class='neutral'>    event SyncCall();</span>
  21 |     | <span class='neutral'>    event TransferCall(address to, uint256 amount);</span>
  22 |     | <span class='neutral'>    event AddLiquidityCall(address lp, address to, uint256 baseInAmount, uint256 quoteInAmount, uint256 minimumShares, uint256 deadline);</span>
  23 |     | <span class='neutral'>    event AddLiquidityETHCall(</span>
  24 |     | <span class='neutral'>        address lp,</span>
  25 |     | <span class='neutral'>        address to,</span>
  26 |     | <span class='neutral'>        address refundTo,</span>
  27 |     | <span class='neutral'>        uint256 tokenInAmount,</span>
  28 |     | <span class='neutral'>        uint256 value,</span>
  29 |     | <span class='neutral'>        uint256 minimumShares,</span>
  30 |     | <span class='neutral'>        uint256 deadline</span>
  31 |     | <span class='neutral'>    );</span>
  32 |     | <span class='neutral'>    event AddLiquidityETHUnsafeCall(address lp, address to, uint256 tokenInAmount, uint256 value, uint256 minimumShares, uint256 deadline);</span>
  33 |     | <span class='neutral'>    event AddLiquidityUnsafeCall(</span>
  34 |     | <span class='neutral'>        address lp,</span>
  35 |     | <span class='neutral'>        address to,</span>
  36 |     | <span class='neutral'>        uint256 baseInAmount,</span>
  37 |     | <span class='neutral'>        uint256 quoteInAmount,</span>
  38 |     | <span class='neutral'>        uint256 minimumShares,</span>
  39 |     | <span class='neutral'>        uint256 deadline</span>
  40 |     | <span class='neutral'>    );</span>
  41 |     | <span class='neutral'>    event CreatePoolCall(</span>
  42 |     | <span class='neutral'>        address baseToken,</span>
  43 |     | <span class='neutral'>        address quoteToken,</span>
  44 |     | <span class='neutral'>        uint256 lpFeeRate,</span>
  45 |     | <span class='neutral'>        uint256 i,</span>
  46 |     | <span class='neutral'>        uint256 k,</span>
  47 |     | <span class='neutral'>        address to,</span>
  48 |     | <span class='neutral'>        uint256 baseInAmount,</span>
  49 |     | <span class='neutral'>        uint256 quoteInAmount</span>
  50 |     | <span class='neutral'>    );</span>
  51 |     | <span class='neutral'>    event CreatePoolETHCall(</span>
  52 |     | <span class='neutral'>        address token,</span>
  53 |     | <span class='neutral'>        bool useTokenAsQuote,</span>
  54 |     | <span class='neutral'>        uint256 lpFeeRate,</span>
  55 |     | <span class='neutral'>        uint256 i,</span>
  56 |     | <span class='neutral'>        uint256 k,</span>
  57 |     | <span class='neutral'>        address to,</span>
  58 |     | <span class='neutral'>        uint256 tokenInAmount</span>
  59 |     | <span class='neutral'>    );</span>
  60 |     | <span class='neutral'>    event RemoveLiquidityCall(</span>
  61 |     | <span class='neutral'>        address lp,</span>
  62 |     | <span class='neutral'>        address to,</span>
  63 |     | <span class='neutral'>        uint256 sharesIn,</span>
  64 |     | <span class='neutral'>        uint256 minimumBaseAmount,</span>
  65 |     | <span class='neutral'>        uint256 minimumQuoteAmount,</span>
  66 |     | <span class='neutral'>        uint256 deadline</span>
  67 |     | <span class='neutral'>    );</span>
  68 |     | <span class='neutral'>    event RemoveLiquidityETHCall(</span>
  69 |     | <span class='neutral'>        address lp,</span>
  70 |     | <span class='neutral'>        address to,</span>
  71 |     | <span class='neutral'>        uint256 sharesIn,</span>
  72 |     | <span class='neutral'>        uint256 minimumETHAmount,</span>
  73 |     | <span class='neutral'>        uint256 minimumTokenAmount,</span>
  74 |     | <span class='neutral'>        uint256 deadline</span>
  75 |     | <span class='neutral'>    );</span>
  76 |     | <span class='neutral'>    event PreviewAddLiquidityCall(address lp, uint256 baseInAmount, uint256 quoteInAmount);</span>
  77 |     | <span class='neutral'>    event PreviewRemoveLiquidityCall(address lp, uint256 sharesIn);</span>
  78 |     | <span class='neutral'>    event SellBaseETHForTokensCall(address lp, address to, uint256 minimumOut, uint256 deadline);</span>
  79 |     | <span class='neutral'>    event SellBaseTokensForETHCall(address lp, address to, uint256 amountIn, uint256 minimumOut, uint256 deadline);</span>
  80 |     | <span class='neutral'>    event SellBaseTokensForTokensCall(address lp, address to, uint256 amountIn, uint256 minimumOut, uint256 deadline);</span>
  81 |     | <span class='neutral'>    event SellQuoteETHForTokensCall(address lp, address to, uint256 minimumOut, uint256 deadline);</span>
  82 |     | <span class='neutral'>    event SellQuoteTokensForETHCall(address lp, address to, uint256 amountIn, uint256 minimumOut, uint256 deadline);</span>
  83 |     | <span class='neutral'>    event SellQuoteTokensForTokensCall(address lp, address to, uint256 amountIn, uint256 minimumOut, uint256 deadline);</span>
  84 |     | <span class='neutral'>    event SwapETHForTokensCall(address to, address[] path, uint256 directions, uint256 minimumOut, uint256 deadline);</span>
  85 |     | <span class='neutral'>    event SwapTokensForETHCall(address to, uint256 amountIn, address[] path, uint256 directions, uint256 minimumOut, uint256 deadline);</span>
  86 |     | <span class='neutral'>    event SwapTokensForTokensCall(address to, uint256 amountIn, address[] path, uint256 directions, uint256 minimumOut, uint256 deadline);</span>
  87 |     | <span class='neutral'></span>
  88 | *   | <span class='executed'>    function _createCall(</span>
  89 |     | <span class='neutral'>        address baseToken_,</span>
  90 |     | <span class='neutral'>        address quoteToken_,</span>
  91 |     | <span class='neutral'>        uint256 lpFeeRate_,</span>
  92 |     | <span class='neutral'>        uint256 i_,</span>
  93 |     | <span class='neutral'>        uint256 k_</span>
  94 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
  95 | *   | <span class='executed'>        emit CreateCall(baseToken_, quoteToken_, lpFeeRate_, i_, k_);</span>
  96 |     | <span class='neutral'></span>
  97 | *   | <span class='executed'>        vm.prank(currentActor);</span>
  98 | *   | <span class='executed'>        (success, returnData) = address(factory).call{gas: 1000000}(</span>
  99 | *   | <span class='executed'>            abi.encodeWithSelector(factory.create.selector, baseToken_, quoteToken_, lpFeeRate_, i_, k_, false)</span>
 100 |     | <span class='neutral'>        );</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 | *   | <span class='executed'>    function _buySharesCall(address pool, address to) internal returns (bool success, bytes memory returnData) {</span>
 104 | *   | <span class='executed'>        emit BuySharesCall(to);</span>
 105 |     | <span class='neutral'></span>
 106 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 107 | *   | <span class='executed'>        (success, returnData) = address(pool).call{gas: 1000000}(abi.encodeWithSelector(marketImpl.buyShares.selector, to));</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 | *   | <span class='executed'>    function _correctRStateCall(address pool) internal returns (bool success, bytes memory returnData) {</span>
 111 | *   | <span class='executed'>        emit CorrectRStateCall();</span>
 112 |     | <span class='neutral'></span>
 113 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 114 | *   | <span class='executed'>        (success, returnData) = address(pool).call{gas: 1000000}(abi.encodeWithSelector(marketImpl.correctRState.selector));</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 | *   | <span class='executed'>    function _sellBaseCall(address pool, address to) internal returns (bool success, bytes memory returnData) {</span>
 118 | *   | <span class='executed'>        emit SellBaseCall(to);</span>
 119 |     | <span class='neutral'></span>
 120 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 121 | *   | <span class='executed'>        (success, returnData) = address(pool).call{gas: 1000000}(abi.encodeWithSelector(marketImpl.sellBase.selector, to));</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 | *   | <span class='executed'>    function _sellQuoteCall(address pool, address to) internal returns (bool success, bytes memory returnData) {</span>
 125 | *   | <span class='executed'>        emit SellQuoteCall(to);</span>
 126 |     | <span class='neutral'></span>
 127 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 128 | *   | <span class='executed'>        (success, returnData) = address(pool).call{gas: 1000000}(abi.encodeWithSelector(marketImpl.sellQuote.selector, to));</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 | *   | <span class='executed'>    function _sellSharesCall(</span>
 132 |     | <span class='neutral'>        address pool,</span>
 133 |     | <span class='neutral'>        uint256 shareAmount,</span>
 134 |     | <span class='neutral'>        address to,</span>
 135 |     | <span class='neutral'>        uint256 baseMinAmount,</span>
 136 |     | <span class='neutral'>        uint256 quoteMinAmount,</span>
 137 |     | <span class='neutral'>        bytes memory data,</span>
 138 |     | <span class='neutral'>        uint256 deadline</span>
 139 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
 140 | *   | <span class='executed'>        emit SellSharesCall(shareAmount, to, baseMinAmount, quoteMinAmount, data, deadline);</span>
 141 |     | <span class='neutral'></span>
 142 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 143 | *   | <span class='executed'>        (success, returnData) = address(pool).call{gas: 1000000}(</span>
 144 | *   | <span class='executed'>            abi.encodeWithSelector(marketImpl.sellShares.selector, shareAmount, to, baseMinAmount, quoteMinAmount, data, deadline)</span>
 145 |     | <span class='neutral'>        );</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 | *   | <span class='executed'>    function _syncCall(address pool) internal returns (bool success, bytes memory returnData) {</span>
 149 | *   | <span class='executed'>        emit SyncCall();</span>
 150 |     | <span class='neutral'></span>
 151 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 152 | *   | <span class='executed'>        (success, returnData) = address(pool).call{gas: 1000000}(abi.encodeWithSelector(marketImpl.sync.selector));</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 | *   | <span class='executed'>    function _transferCall(address token, address to, uint256 amount) internal returns (bool success, bytes memory returnData) {</span>
 156 | *   | <span class='executed'>        emit TransferCall(to, amount);</span>
 157 |     | <span class='neutral'></span>
 158 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 159 | *   | <span class='executed'>        (success, returnData) = address(token).call{gas: 1000000}(abi.encodeWithSelector(marketImpl.transfer.selector, to, amount));</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 | *   | <span class='executed'>    function _addLiquidityCall(</span>
 163 |     | <span class='neutral'>        address lp,</span>
 164 |     | <span class='neutral'>        address to,</span>
 165 |     | <span class='neutral'>        uint256 baseInAmount,</span>
 166 |     | <span class='neutral'>        uint256 quoteInAmount,</span>
 167 |     | <span class='neutral'>        uint256 minimumShares,</span>
 168 |     | <span class='neutral'>        uint256 deadline</span>
 169 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
 170 | *   | <span class='executed'>        emit AddLiquidityCall(lp, to, baseInAmount, quoteInAmount, minimumShares, deadline);</span>
 171 |     | <span class='neutral'></span>
 172 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 173 | *   | <span class='executed'>        (success, returnData) = address(router).call{gas: 1000000}(</span>
 174 | *   | <span class='executed'>            abi.encodeWithSelector(router.addLiquidity.selector, lp, to, baseInAmount, quoteInAmount, minimumShares, deadline)</span>
 175 |     | <span class='neutral'>        );</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>    function _addLiquidityETHCall(</span>
 179 |     | <span class='neutral'>        address lp,</span>
 180 |     | <span class='neutral'>        address to,</span>
 181 |     | <span class='neutral'>        address refundTo,</span>
 182 |     | <span class='neutral'>        uint256 tokenInAmount,</span>
 183 |     | <span class='neutral'>        uint256 value,</span>
 184 |     | <span class='neutral'>        uint256 minimumShares,</span>
 185 |     | <span class='neutral'>        uint256 deadline</span>
 186 |     | <span class='unexecuted'>    ) internal returns (bool success, bytes memory returnData) {</span>
 187 |     | <span class='unexecuted'>        emit AddLiquidityETHCall(lp, to, refundTo, tokenInAmount, value, minimumShares, deadline);</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='unexecuted'>        vm.prank(currentActor);</span>
 190 |     | <span class='unexecuted'>        (success, returnData) = address(router).call{value: value, gas: 1000000}(</span>
 191 |     | <span class='unexecuted'>            abi.encodeWithSelector(router.addLiquidityETH.selector, lp, to, refundTo, tokenInAmount, minimumShares, deadline)</span>
 192 |     | <span class='neutral'>        );</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>    function _addLiquidityETHUnsafeCall(</span>
 196 |     | <span class='neutral'>        address lp,</span>
 197 |     | <span class='neutral'>        address to,</span>
 198 |     | <span class='neutral'>        uint256 tokenInAmount,</span>
 199 |     | <span class='neutral'>        uint256 value,</span>
 200 |     | <span class='neutral'>        uint256 minimumShares,</span>
 201 |     | <span class='neutral'>        uint256 deadline</span>
 202 |     | <span class='unexecuted'>    ) internal returns (bool success, bytes memory returnData) {</span>
 203 |     | <span class='unexecuted'>        emit AddLiquidityETHUnsafeCall(lp, to, tokenInAmount, value, minimumShares, deadline);</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='unexecuted'>        vm.prank(currentActor);</span>
 206 |     | <span class='unexecuted'>        (success, returnData) = address(router).call{value: value, gas: 1000000}(</span>
 207 |     | <span class='unexecuted'>            abi.encodeWithSelector(router.addLiquidityETHUnsafe.selector, lp, to, tokenInAmount, minimumShares, deadline)</span>
 208 |     | <span class='neutral'>        );</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 | *   | <span class='executed'>    function _addLiquidityUnsafeCall(</span>
 212 |     | <span class='neutral'>        address lp,</span>
 213 |     | <span class='neutral'>        address to,</span>
 214 |     | <span class='neutral'>        uint256 baseInAmount,</span>
 215 |     | <span class='neutral'>        uint256 quoteInAmount,</span>
 216 |     | <span class='neutral'>        uint256 minimumShares,</span>
 217 |     | <span class='neutral'>        uint256 deadline</span>
 218 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
 219 | *   | <span class='executed'>        emit AddLiquidityUnsafeCall(lp, to, baseInAmount, quoteInAmount, minimumShares, deadline);</span>
 220 |     | <span class='neutral'></span>
 221 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 222 | *   | <span class='executed'>        (success, returnData) = address(router).call{gas: 1000000}(</span>
 223 | *   | <span class='executed'>            abi.encodeWithSelector(router.addLiquidityUnsafe.selector, lp, to, baseInAmount, quoteInAmount, minimumShares, deadline)</span>
 224 |     | <span class='neutral'>        );</span>
 225 |     | <span class='neutral'>    }</span>
 226 |     | <span class='neutral'></span>
 227 | *   | <span class='executed'>    function _createPoolCall(</span>
 228 |     | <span class='neutral'>        address baseToken,</span>
 229 |     | <span class='neutral'>        address quoteToken,</span>
 230 |     | <span class='neutral'>        uint256 lpFeeRate,</span>
 231 |     | <span class='neutral'>        uint256 i,</span>
 232 |     | <span class='neutral'>        uint256 k,</span>
 233 |     | <span class='neutral'>        address to,</span>
 234 |     | <span class='neutral'>        uint256 baseInAmount,</span>
 235 |     | <span class='neutral'>        uint256 quoteInAmount</span>
 236 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
 237 | *   | <span class='executed'>        emit CreatePoolCall(baseToken, quoteToken, lpFeeRate, i, k, to, baseInAmount, quoteInAmount);</span>
 238 |     | <span class='neutral'></span>
 239 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 240 | *   | <span class='executed'>        (success, returnData) = address(router).call{gas: 1000000}(</span>
 241 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
 242 |     | <span class='neutral'>                router.createPool.selector,</span>
 243 |     | <span class='neutral'>                baseToken,</span>
 244 |     | <span class='neutral'>                quoteToken,</span>
 245 |     | <span class='neutral'>                lpFeeRate,</span>
 246 |     | <span class='neutral'>                i,</span>
 247 |     | <span class='neutral'>                k,</span>
 248 |     | <span class='neutral'>                to,</span>
 249 |     | <span class='neutral'>                baseInAmount,</span>
 250 |     | <span class='neutral'>                quoteInAmount,</span>
 251 |     | <span class='neutral'>                false</span>
 252 |     | <span class='neutral'>            )</span>
 253 |     | <span class='neutral'>        );</span>
 254 |     | <span class='neutral'>    }</span>
 255 |     | <span class='neutral'></span>
 256 | *   | <span class='executed'>    function _createPoolETHCall(</span>
 257 |     | <span class='neutral'>        address token,</span>
 258 |     | <span class='neutral'>        bool useTokenAsQuote,</span>
 259 |     | <span class='neutral'>        uint256 lpFeeRate,</span>
 260 |     | <span class='neutral'>        uint256 i,</span>
 261 |     | <span class='neutral'>        uint256 k,</span>
 262 |     | <span class='neutral'>        address to,</span>
 263 |     | <span class='neutral'>        uint256 tokenInAmount,</span>
 264 |     | <span class='neutral'>        uint256 value</span>
 265 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
 266 | *   | <span class='executed'>        emit CreatePoolETHCall(token, useTokenAsQuote, lpFeeRate, i, k, to, tokenInAmount);</span>
 267 |     | <span class='neutral'></span>
 268 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 269 | *   | <span class='executed'>        (success, returnData) = address(router).call{value: value, gas: 1000000}(</span>
 270 | *   | <span class='executed'>            abi.encodeWithSelector(router.createPoolETH.selector, token, useTokenAsQuote, lpFeeRate, i, k, to, tokenInAmount, false)</span>
 271 |     | <span class='neutral'>        );</span>
 272 |     | <span class='neutral'>    }</span>
 273 |     | <span class='neutral'></span>
 274 | *   | <span class='executed'>    function _removeLiquidityCall(</span>
 275 |     | <span class='neutral'>        address lp,</span>
 276 |     | <span class='neutral'>        address to,</span>
 277 |     | <span class='neutral'>        uint256 sharesIn,</span>
 278 |     | <span class='neutral'>        uint256 minimumBaseAmount,</span>
 279 |     | <span class='neutral'>        uint256 minimumQuoteAmount,</span>
 280 |     | <span class='neutral'>        uint256 deadline</span>
 281 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
 282 | *   | <span class='executed'>        emit RemoveLiquidityCall(lp, to, sharesIn, minimumBaseAmount, minimumQuoteAmount, deadline);</span>
 283 |     | <span class='neutral'></span>
 284 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 285 | *   | <span class='executed'>        (success, returnData) = address(lp).call{gas: 1000000}(</span>
 286 | *   | <span class='executed'>            abi.encodeWithSelector(marketImpl.approve.selector, address(router), sharesIn)</span>
 287 |     | <span class='neutral'>        );</span>
 288 |     | <span class='neutral'></span>
 289 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 290 | *   | <span class='executed'>        (success, returnData) = address(router).call{gas: 1000000}(</span>
 291 | *   | <span class='executed'>            abi.encodeWithSelector(router.removeLiquidity.selector, lp, to, sharesIn, minimumBaseAmount, minimumQuoteAmount, deadline)</span>
 292 |     | <span class='neutral'>        );</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='unexecuted'>    function _removeLiquidityETHCall(</span>
 296 |     | <span class='neutral'>        address lp,</span>
 297 |     | <span class='neutral'>        address to,</span>
 298 |     | <span class='neutral'>        uint256 sharesIn,</span>
 299 |     | <span class='neutral'>        uint256 minimumETHAmount,</span>
 300 |     | <span class='neutral'>        uint256 minimumTokenAmount,</span>
 301 |     | <span class='neutral'>        uint256 deadline</span>
 302 |     | <span class='unexecuted'>    ) internal returns (bool success, bytes memory returnData) {</span>
 303 |     | <span class='unexecuted'>        emit RemoveLiquidityETHCall(lp, to, sharesIn, minimumETHAmount, minimumTokenAmount, deadline);</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='unexecuted'>        vm.prank(currentActor);</span>
 306 |     | <span class='unexecuted'>        (success, returnData) = address(lp).call{gas: 1000000}(</span>
 307 |     | <span class='unexecuted'>            abi.encodeWithSelector(marketImpl.approve.selector, address(router), sharesIn)</span>
 308 |     | <span class='neutral'>        );</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='unexecuted'>        vm.prank(currentActor);</span>
 311 |     | <span class='unexecuted'>        (success, returnData) = address(router).call{gas: 1000000}(</span>
 312 |     | <span class='unexecuted'>            abi.encodeWithSelector(router.removeLiquidityETH.selector, lp, to, sharesIn, minimumETHAmount, minimumTokenAmount, deadline)</span>
 313 |     | <span class='neutral'>        );</span>
 314 |     | <span class='neutral'>    }</span>
 315 |     | <span class='neutral'></span>
 316 | *   | <span class='executed'>    function _previewAddLiquidityCall(</span>
 317 |     | <span class='neutral'>        address lp,</span>
 318 |     | <span class='neutral'>        uint256 baseInAmount,</span>
 319 |     | <span class='neutral'>        uint256 quoteInAmount</span>
 320 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
 321 | *   | <span class='executed'>        emit PreviewAddLiquidityCall(lp, baseInAmount, quoteInAmount);</span>
 322 |     | <span class='neutral'></span>
 323 | *   | <span class='executed'>        (success, returnData) = address(router).staticcall(</span>
 324 | *   | <span class='executed'>            abi.encodeWithSelector(router.previewAddLiquidity.selector, lp, baseInAmount, quoteInAmount)</span>
 325 |     | <span class='neutral'>        );</span>
 326 |     | <span class='neutral'>    }</span>
 327 |     | <span class='neutral'></span>
 328 | *   | <span class='executed'>    function _previewRemoveLiquidityCall(address lp, uint256 sharesIn) internal returns (bool success, bytes memory returnData) {</span>
 329 | *   | <span class='executed'>        emit PreviewRemoveLiquidityCall(lp, sharesIn);</span>
 330 |     | <span class='neutral'></span>
 331 | *   | <span class='executed'>        (success, returnData) = address(router).staticcall(abi.encodeWithSelector(router.previewRemoveLiquidity.selector, lp, sharesIn));</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='unexecuted'>    function _sellBaseETHForTokensCall(</span>
 335 |     | <span class='neutral'>        address lp,</span>
 336 |     | <span class='neutral'>        address to,</span>
 337 |     | <span class='neutral'>        uint256 minimumOut,</span>
 338 |     | <span class='neutral'>        uint256 deadline,</span>
 339 |     | <span class='neutral'>        uint256 value</span>
 340 |     | <span class='unexecuted'>    ) internal returns (bool success, bytes memory returnData) {</span>
 341 |     | <span class='unexecuted'>        emit SellBaseETHForTokensCall(lp, to, minimumOut, deadline);</span>
 342 |     | <span class='neutral'></span>
 343 |     | <span class='unexecuted'>        vm.prank(currentActor);</span>
 344 |     | <span class='unexecuted'>        (success, returnData) = address(router).call{value: value, gas: 1000000}(</span>
 345 |     | <span class='unexecuted'>            abi.encodeWithSelector(router.sellBaseETHForTokens.selector, lp, to, minimumOut, deadline)</span>
 346 |     | <span class='neutral'>        );</span>
 347 |     | <span class='neutral'>    }</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='unexecuted'>    function _sellBaseTokensForETHCall(</span>
 350 |     | <span class='neutral'>        address lp,</span>
 351 |     | <span class='neutral'>        address to,</span>
 352 |     | <span class='neutral'>        uint256 amountIn,</span>
 353 |     | <span class='neutral'>        uint256 minimumOut,</span>
 354 |     | <span class='neutral'>        uint256 deadline</span>
 355 |     | <span class='unexecuted'>    ) internal returns (bool success, bytes memory returnData) {</span>
 356 |     | <span class='unexecuted'>        emit SellBaseTokensForETHCall(lp, to, amountIn, minimumOut, deadline);</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='unexecuted'>        vm.prank(currentActor);</span>
 359 |     | <span class='unexecuted'>        (success, returnData) = address(router).call{gas: 1000000}(</span>
 360 |     | <span class='unexecuted'>            abi.encodeWithSelector(router.sellBaseTokensForETH.selector, lp, to, amountIn, minimumOut, deadline)</span>
 361 |     | <span class='neutral'>        );</span>
 362 |     | <span class='neutral'>    }</span>
 363 |     | <span class='neutral'></span>
 364 | *   | <span class='executed'>    function _sellBaseTokensForTokensCall(</span>
 365 |     | <span class='neutral'>        address lp,</span>
 366 |     | <span class='neutral'>        address to,</span>
 367 |     | <span class='neutral'>        uint256 amountIn,</span>
 368 |     | <span class='neutral'>        uint256 minimumOut,</span>
 369 |     | <span class='neutral'>        uint256 deadline</span>
 370 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
 371 | *   | <span class='executed'>        emit SellBaseTokensForTokensCall(lp, to, amountIn, minimumOut, deadline);</span>
 372 |     | <span class='neutral'></span>
 373 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 374 | *   | <span class='executed'>        (success, returnData) = address(router).call{gas: 1000000}(</span>
 375 | *   | <span class='executed'>            abi.encodeWithSelector(router.sellBaseTokensForTokens.selector, lp, to, amountIn, minimumOut, deadline)</span>
 376 |     | <span class='neutral'>        );</span>
 377 |     | <span class='neutral'>    }</span>
 378 |     | <span class='neutral'></span>
 379 |     | <span class='unexecuted'>    function _sellQuoteETHForTokensCall(</span>
 380 |     | <span class='neutral'>        address lp,</span>
 381 |     | <span class='neutral'>        address to,</span>
 382 |     | <span class='neutral'>        uint256 minimumOut,</span>
 383 |     | <span class='neutral'>        uint256 deadline,</span>
 384 |     | <span class='neutral'>        uint256 value</span>
 385 |     | <span class='unexecuted'>    ) internal returns (bool success, bytes memory returnData) {</span>
 386 |     | <span class='unexecuted'>        emit SellQuoteETHForTokensCall(lp, to, minimumOut, deadline);</span>
 387 |     | <span class='neutral'></span>
 388 |     | <span class='unexecuted'>        vm.prank(currentActor);</span>
 389 |     | <span class='unexecuted'>        (success, returnData) = address(router).call{value: value, gas: 1000000}(</span>
 390 |     | <span class='unexecuted'>            abi.encodeWithSelector(router.sellQuoteETHForTokens.selector, lp, to, minimumOut, deadline)</span>
 391 |     | <span class='neutral'>        );</span>
 392 |     | <span class='neutral'>    }</span>
 393 |     | <span class='neutral'></span>
 394 |     | <span class='unexecuted'>    function _sellQuoteTokensForETHCall(</span>
 395 |     | <span class='neutral'>        address lp,</span>
 396 |     | <span class='neutral'>        address to,</span>
 397 |     | <span class='neutral'>        uint256 amountIn,</span>
 398 |     | <span class='neutral'>        uint256 minimumOut,</span>
 399 |     | <span class='neutral'>        uint256 deadline</span>
 400 |     | <span class='unexecuted'>    ) internal returns (bool success, bytes memory returnData) {</span>
 401 |     | <span class='unexecuted'>        emit SellQuoteTokensForETHCall(lp, to, amountIn, minimumOut, deadline);</span>
 402 |     | <span class='neutral'></span>
 403 |     | <span class='unexecuted'>        vm.prank(currentActor);</span>
 404 |     | <span class='unexecuted'>        (success, returnData) = address(router).call{gas: 1000000}(</span>
 405 |     | <span class='unexecuted'>            abi.encodeWithSelector(router.sellQuoteTokensForETH.selector, lp, to, amountIn, minimumOut, deadline)</span>
 406 |     | <span class='neutral'>        );</span>
 407 |     | <span class='neutral'>    }</span>
 408 |     | <span class='neutral'></span>
 409 | *   | <span class='executed'>    function _sellQuoteTokensForTokensCall(</span>
 410 |     | <span class='neutral'>        address lp,</span>
 411 |     | <span class='neutral'>        address to,</span>
 412 |     | <span class='neutral'>        uint256 amountIn,</span>
 413 |     | <span class='neutral'>        uint256 minimumOut,</span>
 414 |     | <span class='neutral'>        uint256 deadline</span>
 415 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
 416 | *   | <span class='executed'>        emit SellQuoteTokensForTokensCall(lp, to, amountIn, minimumOut, deadline);</span>
 417 |     | <span class='neutral'></span>
 418 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 419 | *   | <span class='executed'>        (success, returnData) = address(router).call{gas: 1000000}(</span>
 420 | *   | <span class='executed'>            abi.encodeWithSelector(router.sellQuoteTokensForTokens.selector, lp, to, amountIn, minimumOut, deadline)</span>
 421 |     | <span class='neutral'>        );</span>
 422 |     | <span class='neutral'>    }</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='unexecuted'>    function _swapETHForTokensCall(</span>
 425 |     | <span class='neutral'>        address to,</span>
 426 |     | <span class='neutral'>        address[] memory path,</span>
 427 |     | <span class='neutral'>        uint256 directions,</span>
 428 |     | <span class='neutral'>        uint256 minimumOut,</span>
 429 |     | <span class='neutral'>        uint256 deadline,</span>
 430 |     | <span class='neutral'>        uint256 value</span>
 431 |     | <span class='unexecuted'>    ) internal returns (bool success, bytes memory returnData) {</span>
 432 |     | <span class='unexecuted'>        emit SwapETHForTokensCall(to, path, directions, minimumOut, deadline);</span>
 433 |     | <span class='neutral'></span>
 434 |     | <span class='unexecuted'>        vm.prank(currentActor);</span>
 435 |     | <span class='unexecuted'>        (success, returnData) = address(router).call{value: value, gas: 1000000}(</span>
 436 |     | <span class='unexecuted'>            abi.encodeWithSelector(router.swapETHForTokens.selector, to, path, directions, minimumOut, deadline)</span>
 437 |     | <span class='neutral'>        );</span>
 438 |     | <span class='neutral'>    }</span>
 439 |     | <span class='neutral'></span>
 440 |     | <span class='unexecuted'>    function _swapTokensForETHCall(</span>
 441 |     | <span class='neutral'>        address to,</span>
 442 |     | <span class='neutral'>        uint256 amountIn,</span>
 443 |     | <span class='neutral'>        address[] memory path,</span>
 444 |     | <span class='neutral'>        uint256 directions,</span>
 445 |     | <span class='neutral'>        uint256 minimumOut,</span>
 446 |     | <span class='neutral'>        uint256 deadline</span>
 447 |     | <span class='unexecuted'>    ) internal returns (bool success, bytes memory returnData) {</span>
 448 |     | <span class='unexecuted'>        emit SwapTokensForETHCall(to, amountIn, path, directions, minimumOut, deadline);</span>
 449 |     | <span class='neutral'></span>
 450 |     | <span class='unexecuted'>        vm.prank(currentActor);</span>
 451 |     | <span class='unexecuted'>        (success, returnData) = address(router).call{gas: 1000000}(</span>
 452 |     | <span class='unexecuted'>            abi.encodeWithSelector(router.swapTokensForETH.selector, to, amountIn, path, directions, minimumOut, deadline)</span>
 453 |     | <span class='neutral'>        );</span>
 454 |     | <span class='neutral'>    }</span>
 455 |     | <span class='neutral'></span>
 456 |     | <span class='unexecuted'>    function _swapTokensForTokensCall(</span>
 457 |     | <span class='neutral'>        address to,</span>
 458 |     | <span class='neutral'>        uint256 amountIn,</span>
 459 |     | <span class='neutral'>        address[] memory path,</span>
 460 |     | <span class='neutral'>        uint256 directions,</span>
 461 |     | <span class='neutral'>        uint256 minimumOut,</span>
 462 |     | <span class='neutral'>        uint256 deadline</span>
 463 |     | <span class='unexecuted'>    ) internal returns (bool success, bytes memory returnData) {</span>
 464 |     | <span class='unexecuted'>        emit SwapTokensForTokensCall(to, amountIn, path, directions, minimumOut, deadline);</span>
 465 |     | <span class='neutral'></span>
 466 |     | <span class='unexecuted'>        vm.prank(currentActor);</span>
 467 |     | <span class='unexecuted'>        (success, returnData) = address(router).call{gas: 1000000}(</span>
 468 |     | <span class='unexecuted'>            abi.encodeWithSelector(router.swapTokensForTokens.selector, to, amountIn, path, directions, minimumOut, deadline)</span>
 469 |     | <span class='neutral'>        );</span>
 470 |     | <span class='neutral'>    }</span>
 471 |     | <span class='neutral'>}</span>
 472 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/util/FuzzConstants.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;fuzzlib/IHevm.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title FuzzConstants</span>
  8 |     | <span class='neutral'> * @author 0xScourgedev</span>
  9 |     | <span class='neutral'> * @notice Constants and assumptions for the fuzzing suite</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>abstract contract FuzzConstants {</span>
 12 |     | <span class='neutral'>    bool internal constant DEBUG = false;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    address internal constant USER1 = address(0x10000);</span>
 15 |     | <span class='unexecuted'>    address internal constant USER2 = address(0x20000);</span>
 16 |     | <span class='unexecuted'>    address internal constant USER3 = address(0x30000);</span>
 17 |     | <span class='unexecuted'>    address[] internal USERS = [USER1, USER2, USER3];</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    uint256 internal constant INITIAL_BALANCE = 500_000 ether; // 1 Billion USD worth of ETH at $2000/ETH</span>
 20 |     | <span class='unexecuted'>    uint256 internal constant INITIAL_WETH_BALANCE = 500_000 ether; // 1 Billion USD worth of WETH at $2000/ETH</span>
 21 |     | <span class='unexecuted'>    uint256 internal constant INITIAL_TOKEN_BALANCE = 5_000_000_000_000; // 5 trillion tokens, to be multiplied by decimals in setup</span>
 22 | *   | <span class='executed'>    uint256 internal constant REASONABLE_PREVIEW_AMOUNT = type(uint96).max; // 1 Billion USD as the upper bound of reasonable amount</span>
 23 |     | <span class='neutral'></span>
 24 | *   | <span class='executed'>    uint256 internal constant MAX_POOLS = 16;</span>
 25 | *   | <span class='executed'>    uint8 internal constant MAX_PATH_LENGTH = 5;</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    // MagicLP constants</span>
 28 | *   | <span class='executed'>    uint256 internal constant MAX_I = 10 ** 36;</span>
 29 | *   | <span class='executed'>    uint256 internal constant MAX_K = 10 ** 18;</span>
 30 | *   | <span class='executed'>    uint256 internal constant MIN_LP_FEE_RATE = 1e14; // 0.01%</span>
 31 | *   | <span class='executed'>    uint256 internal constant MAX_LP_FEE_RATE = 1e16; // 1%</span>
 32 |     | <span class='neutral'>}</span>
 33 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IAggregator.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IAggregator {</span>
  5 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function latestAnswer() external view returns (int256 answer);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function latestRoundData()</span>
 10 |     | <span class='neutral'>        external</span>
 11 |     | <span class='neutral'>        view</span>
 12 |     | <span class='neutral'>        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IAnyswapERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>interface IAnyswapERC20 {</span>
   5 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>    function PERMIT_TYPEHASH() external view returns (bytes32);</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    function Swapin(bytes32 txhash, address account, uint256 amount) external returns (bool);</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    function Swapout(uint256 amount, address bindaddr) external returns (bool);</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    function TRANSFER_TYPEHASH() external view returns (bytes32);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    function allowance(address, address) external view returns (uint256);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    function applyMinter() external;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    function applyVault() external;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    function approve(address spender, uint256 value) external returns (bool);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    function approveAndCall(address spender, uint256 value, bytes memory data) external returns (bool);</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    function balanceOf(address) external view returns (uint256);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    function burn(address from, uint256 amount) external returns (bool);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    function changeMPCOwner(address newVault) external returns (bool);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    function changeVault(address newVault) external returns (bool);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    function delay() external view returns (uint256);</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    function delayDelay() external view returns (uint256);</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    function delayMinter() external view returns (uint256);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    function delayVault() external view returns (uint256);</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    function deposit(uint256 amount, address to) external returns (uint256);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    function deposit(uint256 amount) external returns (uint256);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    function deposit() external returns (uint256);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    function depositVault(uint256 amount, address to) external returns (uint256);</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    function depositWithPermit(</span>
  52 |     | <span class='neutral'>        address target,</span>
  53 |     | <span class='neutral'>        uint256 value,</span>
  54 |     | <span class='neutral'>        uint256 deadline,</span>
  55 |     | <span class='neutral'>        uint8 v,</span>
  56 |     | <span class='neutral'>        bytes32 r,</span>
  57 |     | <span class='neutral'>        bytes32 s,</span>
  58 |     | <span class='neutral'>        address to</span>
  59 |     | <span class='neutral'>    ) external returns (uint256);</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    function depositWithTransferPermit(</span>
  62 |     | <span class='neutral'>        address target,</span>
  63 |     | <span class='neutral'>        uint256 value,</span>
  64 |     | <span class='neutral'>        uint256 deadline,</span>
  65 |     | <span class='neutral'>        uint8 v,</span>
  66 |     | <span class='neutral'>        bytes32 r,</span>
  67 |     | <span class='neutral'>        bytes32 s,</span>
  68 |     | <span class='neutral'>        address to</span>
  69 |     | <span class='neutral'>    ) external returns (uint256);</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    function getAllMinters() external view returns (address[] memory);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    function initVault(address _vault) external;</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    function isMinter(address) external view returns (bool);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    function mint(address to, uint256 amount) external returns (bool);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    function minters(uint256) external view returns (address);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    function mpc() external view returns (address);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    function nonces(address) external view returns (uint256);</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    function owner() external view returns (address);</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    function pendingDelay() external view returns (uint256);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    function pendingMinter() external view returns (address);</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    function pendingVault() external view returns (address);</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    function revokeMinter(address _auth) external;</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    function setMinter(address _auth) external;</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    function setVault(address _vault) external;</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function setVaultOnly(bool enabled) external;</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    function transfer(address to, uint256 value) external returns (bool);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    function transferAndCall(address to, uint256 value, bytes memory data) external returns (bool);</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 value) external returns (bool);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    function transferWithPermit(</span>
 116 |     | <span class='neutral'>        address target,</span>
 117 |     | <span class='neutral'>        address to,</span>
 118 |     | <span class='neutral'>        uint256 value,</span>
 119 |     | <span class='neutral'>        uint256 deadline,</span>
 120 |     | <span class='neutral'>        uint8 v,</span>
 121 |     | <span class='neutral'>        bytes32 r,</span>
 122 |     | <span class='neutral'>        bytes32 s</span>
 123 |     | <span class='neutral'>    ) external returns (bool);</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    function underlying() external view returns (address);</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function vault() external view returns (address);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    function withdraw(uint256 amount, address to) external returns (uint256);</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    function withdraw(uint256 amount) external returns (uint256);</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    function withdraw() external returns (uint256);</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    function withdrawVault(address from, uint256 amount, address to) external returns (uint256);</span>
 136 |     | <span class='neutral'>}</span>
 137 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IApeCoinStaking.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>interface IApeCoinStaking {</span>
   5 |     | <span class='neutral'>    struct PairNft {</span>
   6 |     | <span class='neutral'>        uint128 mainTokenId;</span>
   7 |     | <span class='neutral'>        uint128 bakcTokenId;</span>
   8 |     | <span class='neutral'>    }</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>    struct PairNftDepositWithAmount {</span>
  11 |     | <span class='neutral'>        uint32 mainTokenId;</span>
  12 |     | <span class='neutral'>        uint32 bakcTokenId;</span>
  13 |     | <span class='neutral'>        uint184 amount;</span>
  14 |     | <span class='neutral'>    }</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    struct SingleNft {</span>
  17 |     | <span class='neutral'>        uint32 tokenId;</span>
  18 |     | <span class='neutral'>        uint224 amount;</span>
  19 |     | <span class='neutral'>    }</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    struct DashboardStake {</span>
  22 |     | <span class='neutral'>        uint256 poolId;</span>
  23 |     | <span class='neutral'>        uint256 tokenId;</span>
  24 |     | <span class='neutral'>        uint256 deposited;</span>
  25 |     | <span class='neutral'>        uint256 unclaimed;</span>
  26 |     | <span class='neutral'>        uint256 rewards24hr;</span>
  27 |     | <span class='neutral'>        DashboardPair pair;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    struct DashboardPair {</span>
  31 |     | <span class='neutral'>        uint256 mainTokenId;</span>
  32 |     | <span class='neutral'>        uint256 mainTypePoolId;</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    struct PoolUI {</span>
  36 |     | <span class='neutral'>        uint256 poolId;</span>
  37 |     | <span class='neutral'>        uint256 stakedAmount;</span>
  38 |     | <span class='neutral'>        TimeRange currentTimeRange;</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    struct TimeRange {</span>
  42 |     | <span class='neutral'>        uint48 startTimestampHour;</span>
  43 |     | <span class='neutral'>        uint48 endTimestampHour;</span>
  44 |     | <span class='neutral'>        uint96 rewardsPerHour;</span>
  45 |     | <span class='neutral'>        uint96 capPerPosition;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    struct PairNftWithdrawWithAmount {</span>
  49 |     | <span class='neutral'>        uint32 mainTokenId;</span>
  50 |     | <span class='neutral'>        uint32 bakcTokenId;</span>
  51 |     | <span class='neutral'>        uint184 amount;</span>
  52 |     | <span class='neutral'>        bool isUncommit;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    event ClaimRewards(address indexed user, uint256 amount, address recipient);</span>
  56 |     | <span class='neutral'>    event ClaimRewardsNft(address indexed user, uint256 indexed poolId, uint256 amount, uint256 tokenId);</span>
  57 |     | <span class='neutral'>    event ClaimRewardsPairNft(address indexed user, uint256 amount, uint256 mainTypePoolId, uint256 mainTokenId, uint256 bakcTokenId);</span>
  58 |     | <span class='neutral'>    event Deposit(address indexed user, uint256 amount, address recipient);</span>
  59 |     | <span class='neutral'>    event DepositNft(address indexed user, uint256 indexed poolId, uint256 amount, uint256 tokenId);</span>
  60 |     | <span class='neutral'>    event DepositPairNft(address indexed user, uint256 amount, uint256 mainTypePoolId, uint256 mainTokenId, uint256 bakcTokenId);</span>
  61 |     | <span class='neutral'>    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span>
  62 |     | <span class='neutral'>    event UpdatePool(uint256 indexed poolId, uint256 lastRewardedBlock, uint256 stakedAmount, uint256 accumulatedRewardsPerShare);</span>
  63 |     | <span class='neutral'>    event Withdraw(address indexed user, uint256 amount, address recipient);</span>
  64 |     | <span class='neutral'>    event WithdrawNft(address indexed user, uint256 indexed poolId, uint256 amount, address recipient, uint256 tokenId);</span>
  65 |     | <span class='neutral'>    event WithdrawPairNft(address indexed user, uint256 amount, uint256 mainTypePoolId, uint256 mainTokenId, uint256 bakcTokenId);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    function addTimeRange(</span>
  68 |     | <span class='neutral'>        uint256 _poolId,</span>
  69 |     | <span class='neutral'>        uint256 _amount,</span>
  70 |     | <span class='neutral'>        uint256 _startTimestamp,</span>
  71 |     | <span class='neutral'>        uint256 _endTimeStamp,</span>
  72 |     | <span class='neutral'>        uint256 _capPerPosition</span>
  73 |     | <span class='neutral'>    ) external;</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    function addressPosition(address) external view returns (uint256 stakedAmount, int256 rewardsDebt);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    function apeCoin() external view returns (address);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    function bakcToMain(uint256, uint256) external view returns (uint248 tokenId, bool isPaired);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    function claimApeCoin(address _recipient) external;</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    function claimBAKC(PairNft[] memory _baycPairs, PairNft[] memory _maycPairs, address _recipient) external;</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    function claimBAYC(uint256[] memory _nfts, address _recipient) external;</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    function claimMAYC(uint256[] memory _nfts, address _recipient) external;</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    function claimSelfApeCoin() external;</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    function claimSelfBAKC(PairNft[] memory _baycPairs, PairNft[] memory _maycPairs) external;</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    function claimSelfBAYC(uint256[] memory _nfts) external;</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    function claimSelfMAYC(uint256[] memory _nfts) external;</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    function depositApeCoin(uint256 _amount, address _recipient) external;</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    function depositBAKC(PairNftDepositWithAmount[] memory _baycPairs, PairNftDepositWithAmount[] memory _maycPairs) external;</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    function depositBAYC(SingleNft[] memory _nfts) external;</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function depositMAYC(SingleNft[] memory _nfts) external;</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    function depositSelfApeCoin(uint256 _amount) external;</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function getAllStakes(address _address) external view returns (DashboardStake[] memory);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    function getApeCoinStake(address _address) external view returns (DashboardStake memory);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    function getBakcStakes(address _address) external view returns (DashboardStake[] memory);</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    function getBaycStakes(address _address) external view returns (DashboardStake[] memory);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    function getMaycStakes(address _address) external view returns (DashboardStake[] memory);</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    function getPoolsUI() external view returns (PoolUI memory, PoolUI memory, PoolUI memory, PoolUI memory);</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    function getSplitStakes(address _address) external view returns (DashboardStake[] memory);</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    function getTimeRangeBy(uint256 _poolId, uint256 _index) external view returns (TimeRange memory);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    function mainToBakc(uint256, uint256) external view returns (uint248 tokenId, bool isPaired);</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    function nftContracts(uint256) external view returns (address);</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function nftPosition(uint256, uint256) external view returns (uint256 stakedAmount, int256 rewardsDebt);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    function owner() external view returns (address);</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    function pendingRewards(uint256 _poolId, address _address, uint256 _tokenId) external view returns (uint256);</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    function pools(</span>
 134 |     | <span class='neutral'>        uint256</span>
 135 |     | <span class='neutral'>    )</span>
 136 |     | <span class='neutral'>        external</span>
 137 |     | <span class='neutral'>        view</span>
 138 |     | <span class='neutral'>        returns (uint48 lastRewardedTimestampHour, uint16 lastRewardsRangeIndex, uint96 stakedAmount, uint96 accumulatedRewardsPerShare);</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function removeLastTimeRange(uint256 _poolId) external;</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    function renounceOwnership() external;</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    function rewardsBy(uint256 _poolId, uint256 _from, uint256 _to) external view returns (uint256, uint256);</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    function stakedTotal(address _address) external view returns (uint256);</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    function transferOwnership(address newOwner) external;</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    function updatePool(uint256 _poolId) external;</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    function withdrawApeCoin(uint256 _amount, address _recipient) external;</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    function withdrawBAKC(PairNftWithdrawWithAmount[] memory _baycPairs, PairNftWithdrawWithAmount[] memory _maycPairs) external;</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    function withdrawBAYC(SingleNft[] memory _nfts, address _recipient) external;</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function withdrawMAYC(SingleNft[] memory _nfts, address _recipient) external;</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    function withdrawSelfApeCoin(uint256 _amount) external;</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    function withdrawSelfBAYC(SingleNft[] memory _nfts) external;</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    function withdrawSelfMAYC(SingleNft[] memory _nfts) external;</span>
 165 |     | <span class='neutral'>}</span>
 166 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IBentoBoxV1.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import {Rebase} from &quot;BoringSolidity/libraries/BoringRebase.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IStrategy} from &quot;interfaces/IStrategy.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>interface IFlashBorrower {</span>
   9 |     | <span class='neutral'>    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.</span>
  10 |     | <span class='neutral'>    /// @param sender The address of the invoker of this flashloan.</span>
  11 |     | <span class='neutral'>    /// @param token The address of the token that is loaned.</span>
  12 |     | <span class='neutral'>    /// @param amount of the `token` that is loaned.</span>
  13 |     | <span class='neutral'>    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.</span>
  14 |     | <span class='neutral'>    /// @param data Additional data that was passed to the flashloan function.</span>
  15 |     | <span class='neutral'>    function onFlashLoan(</span>
  16 |     | <span class='neutral'>        address sender,</span>
  17 |     | <span class='neutral'>        IERC20 token,</span>
  18 |     | <span class='neutral'>        uint256 amount,</span>
  19 |     | <span class='neutral'>        uint256 fee,</span>
  20 |     | <span class='neutral'>        bytes calldata data</span>
  21 |     | <span class='neutral'>    ) external;</span>
  22 |     | <span class='neutral'>}</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>interface IBatchFlashBorrower {</span>
  25 |     | <span class='neutral'>    /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.</span>
  26 |     | <span class='neutral'>    /// @param sender The address of the invoker of this flashloan.</span>
  27 |     | <span class='neutral'>    /// @param tokens Array of addresses for ERC-20 tokens that is loaned.</span>
  28 |     | <span class='neutral'>    /// @param amounts A one-to-one map to `tokens` that is loaned.</span>
  29 |     | <span class='neutral'>    /// @param fees A one-to-one map to `tokens` that needs to be paid on top for each loan. Needs to be the same token.</span>
  30 |     | <span class='neutral'>    /// @param data Additional data that was passed to the flashloan function.</span>
  31 |     | <span class='neutral'>    function onBatchFlashLoan(</span>
  32 |     | <span class='neutral'>        address sender,</span>
  33 |     | <span class='neutral'>        IERC20[] calldata tokens,</span>
  34 |     | <span class='neutral'>        uint256[] calldata amounts,</span>
  35 |     | <span class='neutral'>        uint256[] calldata fees,</span>
  36 |     | <span class='neutral'>        bytes calldata data</span>
  37 |     | <span class='neutral'>    ) external;</span>
  38 |     | <span class='neutral'>}</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>interface IBentoBoxV1 {</span>
  41 |     | <span class='neutral'>    function balanceOf(IERC20, address) external view returns (uint256);</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    function batchFlashLoan(</span>
  46 |     | <span class='neutral'>        IBatchFlashBorrower borrower,</span>
  47 |     | <span class='neutral'>        address[] calldata receivers,</span>
  48 |     | <span class='neutral'>        IERC20[] calldata tokens,</span>
  49 |     | <span class='neutral'>        uint256[] calldata amounts,</span>
  50 |     | <span class='neutral'>        bytes calldata data</span>
  51 |     | <span class='neutral'>    ) external;</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    function claimOwnership() external;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    function flashLoan(</span>
  56 |     | <span class='neutral'>        IFlashBorrower borrower,</span>
  57 |     | <span class='neutral'>        address receiver,</span>
  58 |     | <span class='neutral'>        IERC20 token,</span>
  59 |     | <span class='neutral'>        uint256 amount,</span>
  60 |     | <span class='neutral'>        bytes calldata data</span>
  61 |     | <span class='neutral'>    ) external;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    function deploy(</span>
  64 |     | <span class='neutral'>        address masterContract,</span>
  65 |     | <span class='neutral'>        bytes calldata data,</span>
  66 |     | <span class='neutral'>        bool useCreate2</span>
  67 |     | <span class='neutral'>    ) external payable returns (address);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    function deposit(</span>
  70 |     | <span class='neutral'>        IERC20 token_,</span>
  71 |     | <span class='neutral'>        address from,</span>
  72 |     | <span class='neutral'>        address to,</span>
  73 |     | <span class='neutral'>        uint256 amount,</span>
  74 |     | <span class='neutral'>        uint256 share</span>
  75 |     | <span class='neutral'>    ) external payable returns (uint256 amountOut, uint256 shareOut);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    function harvest(</span>
  78 |     | <span class='neutral'>        IERC20 token,</span>
  79 |     | <span class='neutral'>        bool balance,</span>
  80 |     | <span class='neutral'>        uint256 maxChangeAmount</span>
  81 |     | <span class='neutral'>    ) external;</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    function masterContractApproved(address, address) external view returns (bool);</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    function masterContractOf(address) external view returns (address);</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    function nonces(address) external view returns (uint256);</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    function owner() external view returns (address);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    function pendingOwner() external view returns (address);</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    function pendingStrategy(IERC20) external view returns (IStrategy);</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    function permitToken(</span>
  96 |     | <span class='neutral'>        IERC20 token,</span>
  97 |     | <span class='neutral'>        address from,</span>
  98 |     | <span class='neutral'>        address to,</span>
  99 |     | <span class='neutral'>        uint256 amount,</span>
 100 |     | <span class='neutral'>        uint256 deadline,</span>
 101 |     | <span class='neutral'>        uint8 v,</span>
 102 |     | <span class='neutral'>        bytes32 r,</span>
 103 |     | <span class='neutral'>        bytes32 s</span>
 104 |     | <span class='neutral'>    ) external;</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    function registerProtocol() external;</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    function setMasterContractApproval(</span>
 109 |     | <span class='neutral'>        address user,</span>
 110 |     | <span class='neutral'>        address masterContract,</span>
 111 |     | <span class='neutral'>        bool approved,</span>
 112 |     | <span class='neutral'>        uint8 v,</span>
 113 |     | <span class='neutral'>        bytes32 r,</span>
 114 |     | <span class='neutral'>        bytes32 s</span>
 115 |     | <span class='neutral'>    ) external;</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    function setStrategy(IERC20 token, IStrategy newStrategy) external;</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    function strategy(IERC20) external view returns (IStrategy);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    function strategyData(IERC20)</span>
 124 |     | <span class='neutral'>        external</span>
 125 |     | <span class='neutral'>        view</span>
 126 |     | <span class='neutral'>        returns (</span>
 127 |     | <span class='neutral'>            uint64 strategyStartDate,</span>
 128 |     | <span class='neutral'>            uint64 targetPercentage,</span>
 129 |     | <span class='neutral'>            uint128 balance</span>
 130 |     | <span class='neutral'>        );</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    function toAmount(</span>
 133 |     | <span class='neutral'>        IERC20 token,</span>
 134 |     | <span class='neutral'>        uint256 share,</span>
 135 |     | <span class='neutral'>        bool roundUp</span>
 136 |     | <span class='neutral'>    ) external view returns (uint256 amount);</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    function toShare(</span>
 139 |     | <span class='neutral'>        IERC20 token,</span>
 140 |     | <span class='neutral'>        uint256 amount,</span>
 141 |     | <span class='neutral'>        bool roundUp</span>
 142 |     | <span class='neutral'>    ) external view returns (uint256 share);</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    function totals(IERC20) external view returns (Rebase memory totals_);</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    function transfer(</span>
 147 |     | <span class='neutral'>        IERC20 token,</span>
 148 |     | <span class='neutral'>        address from,</span>
 149 |     | <span class='neutral'>        address to,</span>
 150 |     | <span class='neutral'>        uint256 share</span>
 151 |     | <span class='neutral'>    ) external;</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    function transferMultiple(</span>
 154 |     | <span class='neutral'>        IERC20 token,</span>
 155 |     | <span class='neutral'>        address from,</span>
 156 |     | <span class='neutral'>        address[] calldata tos,</span>
 157 |     | <span class='neutral'>        uint256[] calldata shares</span>
 158 |     | <span class='neutral'>    ) external;</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    function transferOwnership(</span>
 161 |     | <span class='neutral'>        address newOwner,</span>
 162 |     | <span class='neutral'>        bool direct,</span>
 163 |     | <span class='neutral'>        bool renounce</span>
 164 |     | <span class='neutral'>    ) external;</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    function whitelistMasterContract(address masterContract, bool approved) external;</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    function whitelistedMasterContracts(address) external view returns (bool);</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    function withdraw(</span>
 171 |     | <span class='neutral'>        IERC20 token_,</span>
 172 |     | <span class='neutral'>        address from,</span>
 173 |     | <span class='neutral'>        address to,</span>
 174 |     | <span class='neutral'>        uint256 amount,</span>
 175 |     | <span class='neutral'>        uint256 share</span>
 176 |     | <span class='neutral'>    ) external returns (uint256 amountOut, uint256 shareOut);</span>
 177 |     | <span class='neutral'>}</span>
 178 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IBlast.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>enum YieldMode {</span>
  5 |     | <span class='neutral'>    AUTOMATIC,</span>
  6 |     | <span class='neutral'>    DISABLED,</span>
  7 |     | <span class='neutral'>    CLAIMABLE</span>
  8 |     | <span class='neutral'>}</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>enum GasMode {</span>
 11 |     | <span class='neutral'>    VOID,</span>
 12 |     | <span class='neutral'>    CLAIMABLE</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>interface IBlast {</span>
 16 |     | <span class='neutral'>    function governorMap(address) external view returns (address);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    // configure</span>
 19 |     | <span class='neutral'>    function configureContract(address contractAddress, YieldMode _yield, GasMode gasMode, address governor) external;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function configure(YieldMode _yield, GasMode gasMode, address governor) external;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    // base configuration options</span>
 24 |     | <span class='neutral'>    function configureClaimableYield() external;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    function configureClaimableYieldOnBehalf(address contractAddress) external;</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    function configureAutomaticYield() external;</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    function configureAutomaticYieldOnBehalf(address contractAddress) external;</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    function configureVoidYield() external;</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    function configureVoidYieldOnBehalf(address contractAddress) external;</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    function configureClaimableGas() external;</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    function configureClaimableGasOnBehalf(address contractAddress) external;</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    function configureVoidGas() external;</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    function configureVoidGasOnBehalf(address contractAddress) external;</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function configureGovernor(address _governor) external;</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function configureGovernorOnBehalf(address _newGovernor, address contractAddress) external;</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    // claim yield</span>
 49 |     | <span class='neutral'>    function claimYield(address contractAddress, address recipientOfYield, uint256 amount) external returns (uint256);</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    function claimAllYield(address contractAddress, address recipientOfYield) external returns (uint256);</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    // claim gas</span>
 54 |     | <span class='neutral'>    function claimAllGas(address contractAddress, address recipientOfGas) external returns (uint256);</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    function claimGasAtMinClaimRate(address contractAddress, address recipientOfGas, uint256 minClaimRateBips) external returns (uint256);</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    function claimMaxGas(address contractAddress, address recipientOfGas) external returns (uint256);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>    function claimGas(</span>
 61 |     | <span class='neutral'>        address contractAddress,</span>
 62 |     | <span class='neutral'>        address recipientOfGas,</span>
 63 |     | <span class='neutral'>        uint256 gasToClaim,</span>
 64 |     | <span class='neutral'>        uint256 gasSecondsToConsume</span>
 65 |     | <span class='neutral'>    ) external returns (uint256);</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='neutral'>    // read functions</span>
 68 |     | <span class='neutral'>    function readClaimableYield(address contractAddress) external view returns (uint256);</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>    function readYieldConfiguration(address contractAddress) external view returns (uint8);</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>    function readGasParams(</span>
 73 |     | <span class='neutral'>        address contractAddress</span>
 74 |     | <span class='neutral'>    ) external view returns (uint256 etherSeconds, uint256 etherBalance, uint256 lastUpdated, GasMode);</span>
 75 |     | <span class='neutral'>}</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='neutral'>interface IERC20Rebasing {</span>
 78 |     | <span class='neutral'>    function getConfiguration(address account) external view returns (YieldMode);</span>
 79 |     | <span class='neutral'></span>
 80 |     | <span class='neutral'>    // changes the yield mode of the caller and update the balance</span>
 81 |     | <span class='neutral'>    // to reflect the configuration</span>
 82 |     | <span class='neutral'>    function configure(YieldMode) external returns (uint256);</span>
 83 |     | <span class='neutral'></span>
 84 |     | <span class='neutral'>    // &quot;claimable&quot; yield mode accounts can call this this claim their yield</span>
 85 |     | <span class='neutral'>    // to another address</span>
 86 |     | <span class='neutral'>    function claim(address recipient, uint256 amount) external returns (uint256);</span>
 87 |     | <span class='neutral'></span>
 88 |     | <span class='neutral'>    // read the claimable amount for an account</span>
 89 |     | <span class='neutral'>    function getClaimableAmount(address account) external view returns (uint256);</span>
 90 |     | <span class='neutral'>}</span>
 91 |     | <span class='neutral'></span>
 92 |     | <span class='neutral'>interface IBlastPoints {</span>
 93 |     | <span class='neutral'>    function configurePointsOperator(address operator) external;</span>
 94 |     | <span class='neutral'>}</span>
 95 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ICauldronV1.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface ICauldronV1 {</span>
  7 |     | <span class='neutral'>    function accrue() external;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function withdrawFees() external;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function accrueInfo() external view returns (uint64, uint128);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function setFeeTo(address newFeeTo) external;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function feeTo() external view returns (address);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function masterContract() external view returns (ICauldronV1);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function bentoBox() external view returns (address);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function exchangeRate() external view returns (uint256 rate);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function updateExchangeRate() external returns (bool updated, uint256 rate);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function oracle() external view returns (IOracle);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function oracleData() external view returns (bytes memory);</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ICauldronV2.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  6 |     | <span class='neutral'>import {Rebase} from &quot;BoringSolidity/libraries/BoringRebase.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>interface ICauldronV2 {</span>
  9 |     | <span class='neutral'>    function oracle() external view returns (IOracle);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function oracleData() external view returns (bytes memory);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function accrueInfo() external view returns (uint64, uint128, uint64);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function BORROW_OPENING_FEE() external view returns (uint256);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function COLLATERIZATION_RATE() external view returns (uint256);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function LIQUIDATION_MULTIPLIER() external view returns (uint256);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function totalCollateralShare() external view returns (uint256);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function bentoBox() external view returns (address);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function feeTo() external view returns (address);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function masterContract() external view returns (ICauldronV2);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function collateral() external view returns (IERC20);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function setFeeTo(address newFeeTo) external;</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    function accrue() external;</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function totalBorrow() external view returns (Rebase memory);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function userBorrowPart(address account) external view returns (uint256);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    function userCollateralShare(address account) external view returns (uint256);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    function withdrawFees() external;</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    function cook(</span>
 44 |     | <span class='neutral'>        uint8[] calldata actions,</span>
 45 |     | <span class='neutral'>        uint256[] calldata values,</span>
 46 |     | <span class='neutral'>        bytes[] calldata datas</span>
 47 |     | <span class='neutral'>    ) external payable returns (uint256 value1, uint256 value2);</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    function addCollateral(address to, bool skim, uint256 share) external;</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    function removeCollateral(address to, uint256 share) external;</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    function borrow(address to, uint256 amount) external returns (uint256 part, uint256 share);</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    function repay(address to, bool skim, uint256 part) external returns (uint256 amount);</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    function reduceSupply(uint256 amount) external;</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    function magicInternetMoney() external view returns (IERC20);</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='neutral'>    function liquidate(address[] calldata users, uint256[] calldata maxBorrowParts, address to, address swapper) external;</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='neutral'>    function updateExchangeRate() external returns (bool updated, uint256 rate);</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='neutral'>    function exchangeRate() external view returns (uint256 rate);</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='neutral'>    function init(bytes calldata data) external payable;</span>
 68 |     | <span class='neutral'>}</span>
 69 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ICauldronV3.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ICauldronV2} from &quot;interfaces/ICauldronV2.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface ICauldronV3 is ICauldronV2 {</span>
  7 |     | <span class='neutral'>    function borrowLimit() external view returns (uint128 total, uint128 borrowPartPerAddres);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function changeInterestRate(uint64 newInterestRate) external;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function changeBorrowLimit(uint128 newBorrowLimit, uint128 perAddressPart) external;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function liquidate(</span>
 14 |     | <span class='neutral'>        address[] calldata users,</span>
 15 |     | <span class='neutral'>        uint256[] calldata maxBorrowParts,</span>
 16 |     | <span class='neutral'>        address to,</span>
 17 |     | <span class='neutral'>        address swapper,</span>
 18 |     | <span class='neutral'>        bytes calldata swapperData</span>
 19 |     | <span class='neutral'>    ) external;</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ICauldronV4.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ICauldronV3} from &quot;interfaces/ICauldronV3.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface ICauldronV4 is ICauldronV3 {</span>
  7 |     | <span class='neutral'>    function setBlacklistedCallee(address callee, bool blacklisted) external;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function blacklistedCallees(address callee) external view returns (bool);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function isSolvent(address user) external view returns (bool);</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ICauldronV4GmxV2.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ICauldronV4} from &quot;interfaces/ICauldronV4.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IGmCauldronOrderAgent, IGmRouterOrder} from &quot;periphery/GmxV2CauldronOrderAgent.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface ICauldronV4GmxV2 is ICauldronV4 {</span>
  8 |     | <span class='neutral'>    function closeOrder(address user) external;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function orders(address user) external view returns (IGmRouterOrder);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function orderAgent() external view returns (IGmCauldronOrderAgent);</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IConvexWrapper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>interface IConvexWrapper {</span>
   5 |     | <span class='neutral'>    struct EarnedData {</span>
   6 |     | <span class='neutral'>        address token;</span>
   7 |     | <span class='neutral'>        uint256 amount;</span>
   8 |     | <span class='neutral'>    }</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>    function addRewards() external;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    function addTokenReward(address _token) external;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    function cauldrons(uint256) external view returns (address);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    function cauldronsLength() external view returns (uint256);</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    function collateralVault() external view returns (address);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    function convexBooster() external view returns (address);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function convexPool() external view returns (address);</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    function convexPoolId() external view returns (uint256);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    function convexToken() external view returns (address);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    function crv() external view returns (address);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    function curveToken() external view returns (address);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    function cvx() external view returns (address);</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function deposit(uint256 _amount, address _to) external;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    function earmarkRewards() external returns (bool);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function earned(address _account) external returns (EarnedData[] memory claimable);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    function factory() external view returns (address);</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function getReward(address _account, address _forwardTo) external;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    function getReward(address _account) external;</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    function initialize(uint256 _poolId) external;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function invalidateReward(address _token) external;</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    function isInit() external view returns (bool);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function isShutdown() external view returns (bool);</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function owner() external view returns (address);</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    function registeredRewards(address) external view returns (uint256);</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function renounceOwnership() external;</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    function rewardHook() external view returns (address);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function rewardLength() external view returns (uint256);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function rewardRedirect(address) external view returns (address);</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    function rewards(</span>
  81 |     | <span class='neutral'>        uint256</span>
  82 |     | <span class='neutral'>    ) external view returns (address reward_token, address reward_pool, uint256 reward_integral, uint256 reward_remaining);</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    function setApprovals() external;</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function setCauldron(address _cauldron) external;</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function setHook(address _hook) external;</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    function setRewardRedirect(address _to) external;</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function shutdown() external;</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    function stake(uint256 _amount, address _to) external;</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    function totalBalanceOf(address _account) external view returns (uint256);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    function transfer(address recipient, uint256 amount) external returns (bool);</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    function transferOwnership(address newOwner) external;</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    function user_checkpoint(address _account) external returns (bool);</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    function withdraw(uint256 _amount) external;</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    function withdrawAndUnwrap(uint256 _amount) external;</span>
 113 |     | <span class='neutral'>}</span>
 114 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IConvexWrapperFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IConvexWrapperFactory {</span>
  5 |     | <span class='neutral'>    function CreateWrapper(uint256 _pid) external returns (address);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function acceptPendingOwner() external;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function owner() external view returns (address);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function pendingOwner() external view returns (address);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function proxyFactory() external view returns (address);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function setImplementation(address _imp) external;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function setPendingOwner(address _po) external;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function wrapperImplementation() external view returns (address);</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ICurvePool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// solhint-disable func-name-mixedcase, var-name-mixedcase</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>enum CurvePoolInterfaceType {</span>
  6 |     | <span class='neutral'>    ICURVE_POOL,</span>
  7 |     | <span class='neutral'>    ICURVE_3POOL_ZAPPER,</span>
  8 |     | <span class='neutral'>    IFACTORY_POOL,</span>
  9 |     | <span class='neutral'>    ITRICRYPTO_POOL</span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>interface ICurvePool {</span>
 13 |     | <span class='neutral'>    function decimals() external view returns (uint256);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function coins(uint256 i) external view returns (address);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external returns (uint256);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function approve(address _spender, uint256 _value) external returns (bool);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function add_liquidity(uint256[2] memory amounts, uint256 _min_mint_amount) external;</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function add_liquidity(uint256[3] memory amounts, uint256 _min_mint_amount) external;</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    function add_liquidity(uint256[4] memory amounts, uint256 _min_mint_amount) external;</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function remove_liquidity_one_coin(uint256 tokenAmount, int128 i, uint256 min_amount) external returns (uint256);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function get_virtual_price() external view returns (uint256 price);</span>
 38 |     | <span class='neutral'>}</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>interface ICurve3PoolZapper {</span>
 41 |     | <span class='neutral'>    function add_liquidity(address _pool, uint256[4] memory _deposit_amounts, uint256 _min_mint_amount) external returns (uint256);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    function add_liquidity(</span>
 44 |     | <span class='neutral'>        address _pool,</span>
 45 |     | <span class='neutral'>        uint256[4] memory _deposit_amounts,</span>
 46 |     | <span class='neutral'>        uint256 _min_mint_amount,</span>
 47 |     | <span class='neutral'>        address _receiver</span>
 48 |     | <span class='neutral'>    ) external returns (uint256);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function remove_liquidity(address _pool, uint256 _burn_amount, uint256[4] memory _min_amounts) external returns (uint256[4] memory);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    function remove_liquidity(</span>
 53 |     | <span class='neutral'>        address _pool,</span>
 54 |     | <span class='neutral'>        uint256 _burn_amount,</span>
 55 |     | <span class='neutral'>        uint256[4] memory _min_amounts,</span>
 56 |     | <span class='neutral'>        address _receiver</span>
 57 |     | <span class='neutral'>    ) external returns (uint256[4] memory);</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    function remove_liquidity_one_coin(address _pool, uint256 _burn_amount, int128 i, uint256 _min_amount) external returns (uint256);</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='neutral'>    function remove_liquidity_one_coin(</span>
 62 |     | <span class='neutral'>        address _pool,</span>
 63 |     | <span class='neutral'>        uint256 _burn_amount,</span>
 64 |     | <span class='neutral'>        int128 i,</span>
 65 |     | <span class='neutral'>        uint256 _min_amount,</span>
 66 |     | <span class='neutral'>        address _receiver</span>
 67 |     | <span class='neutral'>    ) external returns (uint256);</span>
 68 |     | <span class='neutral'>}</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>interface IFactoryPool is ICurvePool {</span>
 71 |     | <span class='neutral'>    function remove_liquidity_one_coin(uint256 tokenAmount, uint256 i, uint256 min_amount) external returns (uint256);</span>
 72 |     | <span class='neutral'>}</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>interface ITriCrypto is ICurvePool {</span>
 75 |     | <span class='neutral'>    function remove_liquidity_one_coin(uint256 tokenAmount, uint256 i, uint256 min_amount) external;</span>
 76 |     | <span class='neutral'>}</span>
 77 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ICurveRewardGauge.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface ICurveRewardGauge {</span>
  5 |     | <span class='neutral'>    function claim_rewards(address account, address to) external;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function deposit(uint256 amount, address account, bool claimRewards) external;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function withdraw(uint256 amount) external;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function reward_count() external view returns (uint256);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function reward_tokens() external view returns (address[] memory);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function claimable_reward(address account, address rewardToken) external view returns (uint256);</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ICurveStablePoolAggregator.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface ICurveStablePoolAggregator is IAggregator {</span>
  7 |     | <span class='neutral'>    function curvePool() external view returns (address);</span>
  8 |     | <span class='neutral'>}</span>
  9 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IERC20Vault.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IERC20Vault is IERC20 {</span>
  7 |     | <span class='neutral'>    function toAmount(uint256 shares) external view returns (uint256);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function toShares(uint256 amount) external view returns (uint256);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function underlying() external view returns (IERC20);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function enter(uint256 amount) external returns (uint256 shares);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function enterFor(uint256 amount, address recipient) external returns (uint256 shares);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function leave(uint256 shares) external returns (uint256 amount);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function leaveTo(uint256 shares, address receipient) external returns (uint256 amount);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function leaveAll() external returns (uint256 amount);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function leaveAllTo(address receipient) external returns (uint256 amount);</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IERC4626.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @notice Tokenized Vaults with a single underlying EIP-20 token.</span>
  7 |     | <span class='neutral'>interface IERC4626 {</span>
  8 |     | <span class='neutral'>    function decimals() external view returns (uint8 decimals);</span>
  9 |     | <span class='neutral'>    </span>
 10 |     | <span class='neutral'>    /// @notice The address of the underlying token used for the Vault for accounting, depositing, and withdrawing.</span>
 11 |     | <span class='neutral'>    function asset() external view returns (IERC20 assetTokenAddress);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    /// @notice Total amount of the underlying asset that is managed by Vault.</span>
 14 |     | <span class='neutral'>    function totalAssets() external view returns (uint256 totalManagedAssets);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /// @notice The amount of shares that the Vault would exchange for the amount of assets provided, in an ideal scenario where all the conditions are met.</span>
 17 |     | <span class='neutral'>    function convertToShares(uint256 assets) external view returns (uint256 shares);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /// @notice The amount of assets that the Vault would exchange for the amount of shares provided, in an ideal scenario where all the conditions are met.</span>
 20 |     | <span class='neutral'>    function convertToAssets(uint256 shares) external view returns (uint256 assets);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    /// @notice Maximum amount of the underlying asset that can be deposited into the Vault for the receiver, through a deposit call.</span>
 23 |     | <span class='neutral'>    function maxDeposit(address receiver) external view returns (uint256 maxAssets);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    /// @notice Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given current on-chain conditions.</span>
 26 |     | <span class='neutral'>    function previewDeposit(uint256 assets) external view returns (uint256 shares);</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    /// @notice Mints shares Vault shares to receiver by depositing exactly assets of underlying tokens.</span>
 29 |     | <span class='neutral'>    function deposit(uint256 assets, address receiver) external returns (uint256 shares);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @notice Maximum amount of shares that can be minted from the Vault for the receiver, through a mint call.</span>
 32 |     | <span class='neutral'>    function maxMint(address receiver) external view returns (uint256 maxShares);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /// @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given current on-chain conditions.</span>
 35 |     | <span class='neutral'>    function previewMint(uint256 shares) external view returns (uint256 assets);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    /// @notice Mints exactly shares Vault shares to receiver by depositing assets of underlying tokens.</span>
 38 |     | <span class='neutral'>    function mint(uint256 shares, address receiver) external returns (uint256 assets);</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /// @notice Maximum amount of the underlying asset that can be withdrawn from the owner balance in the Vault, through a withdraw call.</span>
 41 |     | <span class='neutral'>    function maxWithdraw(address owner) external view returns (uint256 maxAssets);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /// @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block, given current on-chain conditions.</span>
 44 |     | <span class='neutral'>    function previewWithdraw(uint256 assets) external view returns (uint256 shares);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    /// @notice Burns shares from owner and sends exactly assets of underlying tokens to receiver.</span>
 47 |     | <span class='neutral'>    function withdraw(</span>
 48 |     | <span class='neutral'>        uint256 assets,</span>
 49 |     | <span class='neutral'>        address receiver,</span>
 50 |     | <span class='neutral'>        address owner</span>
 51 |     | <span class='neutral'>    ) external returns (uint256 shares);</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    /// @notice Maximum amount of Vault shares that can be redeemed from the owner balance in the Vault, through a redeem call.</span>
 54 |     | <span class='neutral'>    function maxRedeem(address owner) external view returns (uint256 maxShares);</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    /// @notice Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block, given current on-chain conditions.</span>
 57 |     | <span class='neutral'>    function previewRedeem(uint256 shares) external view returns (uint256 assets);</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    /// @notice Burns exactly shares from owner and sends assets of underlying tokens to receiver.</span>
 60 |     | <span class='neutral'>    function redeem(</span>
 61 |     | <span class='neutral'>        uint256 shares,</span>
 62 |     | <span class='neutral'>        address receiver,</span>
 63 |     | <span class='neutral'>        address owner</span>
 64 |     | <span class='neutral'>    ) external returns (uint256 assets);</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);</span>
 67 |     | <span class='neutral'>    event Withdraw(address indexed caller, address indexed receiver, address indexed owner, uint256 assets, uint256 shares);</span>
 68 |     | <span class='neutral'>}</span>
 69 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IGmxV1.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>interface IGmxVault {</span>
   7 |     | <span class='neutral'>    event BuyUSDG(address account, address token, uint256 tokenAmount, uint256 usdgAmount, uint256 feeBasisPoints);</span>
   8 |     | <span class='neutral'>    event ClosePosition(</span>
   9 |     | <span class='neutral'>        bytes32 key,</span>
  10 |     | <span class='neutral'>        uint256 size,</span>
  11 |     | <span class='neutral'>        uint256 collateral,</span>
  12 |     | <span class='neutral'>        uint256 averagePrice,</span>
  13 |     | <span class='neutral'>        uint256 entryFundingRate,</span>
  14 |     | <span class='neutral'>        uint256 reserveAmount,</span>
  15 |     | <span class='neutral'>        int256 realisedPnl</span>
  16 |     | <span class='neutral'>    );</span>
  17 |     | <span class='neutral'>    event CollectMarginFees(address token, uint256 feeUsd, uint256 feeTokens);</span>
  18 |     | <span class='neutral'>    event CollectSwapFees(address token, uint256 feeUsd, uint256 feeTokens);</span>
  19 |     | <span class='neutral'>    event DecreaseGuaranteedUsd(address token, uint256 amount);</span>
  20 |     | <span class='neutral'>    event DecreasePoolAmount(address token, uint256 amount);</span>
  21 |     | <span class='neutral'>    event DecreasePosition(</span>
  22 |     | <span class='neutral'>        bytes32 key,</span>
  23 |     | <span class='neutral'>        address account,</span>
  24 |     | <span class='neutral'>        address collateralToken,</span>
  25 |     | <span class='neutral'>        address indexToken,</span>
  26 |     | <span class='neutral'>        uint256 collateralDelta,</span>
  27 |     | <span class='neutral'>        uint256 sizeDelta,</span>
  28 |     | <span class='neutral'>        bool isLong,</span>
  29 |     | <span class='neutral'>        uint256 price,</span>
  30 |     | <span class='neutral'>        uint256 fee</span>
  31 |     | <span class='neutral'>    );</span>
  32 |     | <span class='neutral'>    event DecreaseReservedAmount(address token, uint256 amount);</span>
  33 |     | <span class='neutral'>    event DecreaseUsdgAmount(address token, uint256 amount);</span>
  34 |     | <span class='neutral'>    event DirectPoolDeposit(address token, uint256 amount);</span>
  35 |     | <span class='neutral'>    event IncreaseGuaranteedUsd(address token, uint256 amount);</span>
  36 |     | <span class='neutral'>    event IncreasePoolAmount(address token, uint256 amount);</span>
  37 |     | <span class='neutral'>    event IncreasePosition(</span>
  38 |     | <span class='neutral'>        bytes32 key,</span>
  39 |     | <span class='neutral'>        address account,</span>
  40 |     | <span class='neutral'>        address collateralToken,</span>
  41 |     | <span class='neutral'>        address indexToken,</span>
  42 |     | <span class='neutral'>        uint256 collateralDelta,</span>
  43 |     | <span class='neutral'>        uint256 sizeDelta,</span>
  44 |     | <span class='neutral'>        bool isLong,</span>
  45 |     | <span class='neutral'>        uint256 price,</span>
  46 |     | <span class='neutral'>        uint256 fee</span>
  47 |     | <span class='neutral'>    );</span>
  48 |     | <span class='neutral'>    event IncreaseReservedAmount(address token, uint256 amount);</span>
  49 |     | <span class='neutral'>    event IncreaseUsdgAmount(address token, uint256 amount);</span>
  50 |     | <span class='neutral'>    event LiquidatePosition(</span>
  51 |     | <span class='neutral'>        bytes32 key,</span>
  52 |     | <span class='neutral'>        address account,</span>
  53 |     | <span class='neutral'>        address collateralToken,</span>
  54 |     | <span class='neutral'>        address indexToken,</span>
  55 |     | <span class='neutral'>        bool isLong,</span>
  56 |     | <span class='neutral'>        uint256 size,</span>
  57 |     | <span class='neutral'>        uint256 collateral,</span>
  58 |     | <span class='neutral'>        uint256 reserveAmount,</span>
  59 |     | <span class='neutral'>        int256 realisedPnl,</span>
  60 |     | <span class='neutral'>        uint256 markPrice</span>
  61 |     | <span class='neutral'>    );</span>
  62 |     | <span class='neutral'>    event SellUSDG(address account, address token, uint256 usdgAmount, uint256 tokenAmount, uint256 feeBasisPoints);</span>
  63 |     | <span class='neutral'>    event Swap(</span>
  64 |     | <span class='neutral'>        address account,</span>
  65 |     | <span class='neutral'>        address tokenIn,</span>
  66 |     | <span class='neutral'>        address tokenOut,</span>
  67 |     | <span class='neutral'>        uint256 amountIn,</span>
  68 |     | <span class='neutral'>        uint256 amountOut,</span>
  69 |     | <span class='neutral'>        uint256 amountOutAfterFees,</span>
  70 |     | <span class='neutral'>        uint256 feeBasisPoints</span>
  71 |     | <span class='neutral'>    );</span>
  72 |     | <span class='neutral'>    event UpdateFundingRate(address token, uint256 fundingRate);</span>
  73 |     | <span class='neutral'>    event UpdatePnl(bytes32 key, bool hasProfit, uint256 delta);</span>
  74 |     | <span class='neutral'>    event UpdatePosition(</span>
  75 |     | <span class='neutral'>        bytes32 key,</span>
  76 |     | <span class='neutral'>        uint256 size,</span>
  77 |     | <span class='neutral'>        uint256 collateral,</span>
  78 |     | <span class='neutral'>        uint256 averagePrice,</span>
  79 |     | <span class='neutral'>        uint256 entryFundingRate,</span>
  80 |     | <span class='neutral'>        uint256 reserveAmount,</span>
  81 |     | <span class='neutral'>        int256 realisedPnl</span>
  82 |     | <span class='neutral'>    );</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    function BASIS_POINTS_DIVISOR() external view returns (uint256);</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function FUNDING_RATE_PRECISION() external view returns (uint256);</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function MAX_FEE_BASIS_POINTS() external view returns (uint256);</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    function MAX_FUNDING_RATE_FACTOR() external view returns (uint256);</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function MAX_LIQUIDATION_FEE_USD() external view returns (uint256);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    function MIN_FUNDING_RATE_INTERVAL() external view returns (uint256);</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function MIN_LEVERAGE() external view returns (uint256);</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    function PRICE_PRECISION() external view returns (uint256);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    function USDG_DECIMALS() external view returns (uint256);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    function addRouter(address _router) external;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    function adjustForDecimals(uint256 _amount, address _tokenDiv, address _tokenMul) external view returns (uint256);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    function allWhitelistedTokens(uint256) external view returns (address);</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    function allWhitelistedTokensLength() external view returns (uint256);</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    function approvedRouters(address, address) external view returns (bool);</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    function bufferAmounts(address) external view returns (uint256);</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function buyUSDG(address _token, address _receiver) external returns (uint256);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    function clearTokenConfig(address _token) external;</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function cumulativeFundingRates(address) external view returns (uint256);</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    function decreasePosition(</span>
 121 |     | <span class='neutral'>        address _account,</span>
 122 |     | <span class='neutral'>        address _collateralToken,</span>
 123 |     | <span class='neutral'>        address _indexToken,</span>
 124 |     | <span class='neutral'>        uint256 _collateralDelta,</span>
 125 |     | <span class='neutral'>        uint256 _sizeDelta,</span>
 126 |     | <span class='neutral'>        bool _isLong,</span>
 127 |     | <span class='neutral'>        address _receiver</span>
 128 |     | <span class='neutral'>    ) external returns (uint256);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    function directPoolDeposit(address _token) external;</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    function errorController() external view returns (address);</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    function errors(uint256) external view returns (string memory);</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    function feeReserves(address) external view returns (uint256);</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    function fundingInterval() external view returns (uint256);</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function fundingRateFactor() external view returns (uint256);</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    function getDelta(</span>
 143 |     | <span class='neutral'>        address _indexToken,</span>
 144 |     | <span class='neutral'>        uint256 _size,</span>
 145 |     | <span class='neutral'>        uint256 _averagePrice,</span>
 146 |     | <span class='neutral'>        bool _isLong,</span>
 147 |     | <span class='neutral'>        uint256 _lastIncreasedTime</span>
 148 |     | <span class='neutral'>    ) external view returns (bool, uint256);</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    function getFeeBasisPoints(</span>
 151 |     | <span class='neutral'>        address _token,</span>
 152 |     | <span class='neutral'>        uint256 _usdgDelta,</span>
 153 |     | <span class='neutral'>        uint256 _feeBasisPoints,</span>
 154 |     | <span class='neutral'>        uint256 _taxBasisPoints,</span>
 155 |     | <span class='neutral'>        bool _increment</span>
 156 |     | <span class='neutral'>    ) external view returns (uint256);</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function getFundingFee(address _token, uint256 _size, uint256 _entryFundingRate) external view returns (uint256);</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    function getGlobalShortDelta(address _token) external view returns (bool, uint256);</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    function getMaxPrice(address _token) external view returns (uint256);</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    function getMinPrice(address _token) external view returns (uint256);</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    function getNextAveragePrice(</span>
 167 |     | <span class='neutral'>        address _indexToken,</span>
 168 |     | <span class='neutral'>        uint256 _size,</span>
 169 |     | <span class='neutral'>        uint256 _averagePrice,</span>
 170 |     | <span class='neutral'>        bool _isLong,</span>
 171 |     | <span class='neutral'>        uint256 _nextPrice,</span>
 172 |     | <span class='neutral'>        uint256 _sizeDelta,</span>
 173 |     | <span class='neutral'>        uint256 _lastIncreasedTime</span>
 174 |     | <span class='neutral'>    ) external view returns (uint256);</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function getNextFundingRate(address _token) external view returns (uint256);</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>    function getNextGlobalShortAveragePrice(address _indexToken, uint256 _nextPrice, uint256 _sizeDelta) external view returns (uint256);</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    function getPosition(</span>
 181 |     | <span class='neutral'>        address _account,</span>
 182 |     | <span class='neutral'>        address _collateralToken,</span>
 183 |     | <span class='neutral'>        address _indexToken,</span>
 184 |     | <span class='neutral'>        bool _isLong</span>
 185 |     | <span class='neutral'>    ) external view returns (uint256, uint256, uint256, uint256, uint256, uint256, bool, uint256);</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    function getPositionDelta(</span>
 188 |     | <span class='neutral'>        address _account,</span>
 189 |     | <span class='neutral'>        address _collateralToken,</span>
 190 |     | <span class='neutral'>        address _indexToken,</span>
 191 |     | <span class='neutral'>        bool _isLong</span>
 192 |     | <span class='neutral'>    ) external view returns (bool, uint256);</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    function getPositionFee(uint256 _sizeDelta) external view returns (uint256);</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    function getPositionKey(address _account, address _collateralToken, address _indexToken, bool _isLong) external pure returns (bytes32);</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    function getPositionLeverage(</span>
 199 |     | <span class='neutral'>        address _account,</span>
 200 |     | <span class='neutral'>        address _collateralToken,</span>
 201 |     | <span class='neutral'>        address _indexToken,</span>
 202 |     | <span class='neutral'>        bool _isLong</span>
 203 |     | <span class='neutral'>    ) external view returns (uint256);</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>    function getRedemptionAmount(address _token, uint256 _usdgAmount) external view returns (uint256);</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>    function getRedemptionCollateral(address _token) external view returns (uint256);</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>    function getRedemptionCollateralUsd(address _token) external view returns (uint256);</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    function getTargetUsdgAmount(address _token) external view returns (uint256);</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    function getUtilisation(address _token) external view returns (uint256);</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>    function globalShortAveragePrices(address) external view returns (uint256);</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>    function globalShortSizes(address) external view returns (uint256);</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>    function gov() external view returns (address);</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    function guaranteedUsd(address) external view returns (uint256);</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    function hasDynamicFees() external view returns (bool);</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>    function inManagerMode() external view returns (bool);</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>    function inPrivateLiquidationMode() external view returns (bool);</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    function includeAmmPrice() external view returns (bool);</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    function increasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong) external;</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>    function initialize(</span>
 234 |     | <span class='neutral'>        address _router,</span>
 235 |     | <span class='neutral'>        address _usdg,</span>
 236 |     | <span class='neutral'>        address _priceFeed,</span>
 237 |     | <span class='neutral'>        uint256 _liquidationFeeUsd,</span>
 238 |     | <span class='neutral'>        uint256 _fundingRateFactor,</span>
 239 |     | <span class='neutral'>        uint256 _stableFundingRateFactor</span>
 240 |     | <span class='neutral'>    ) external;</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    function isInitialized() external view returns (bool);</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    function isLeverageEnabled() external view returns (bool);</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>    function isLiquidator(address) external view returns (bool);</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    function isManager(address) external view returns (bool);</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>    function isSwapEnabled() external view returns (bool);</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>    function lastFundingTimes(address) external view returns (uint256);</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>    function liquidatePosition(</span>
 255 |     | <span class='neutral'>        address _account,</span>
 256 |     | <span class='neutral'>        address _collateralToken,</span>
 257 |     | <span class='neutral'>        address _indexToken,</span>
 258 |     | <span class='neutral'>        bool _isLong,</span>
 259 |     | <span class='neutral'>        address _feeReceiver</span>
 260 |     | <span class='neutral'>    ) external;</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    function liquidationFeeUsd() external view returns (uint256);</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>    function marginFeeBasisPoints() external view returns (uint256);</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    function maxGasPrice() external view returns (uint256);</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>    function maxLeverage() external view returns (uint256);</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>    function maxUsdgAmounts(address) external view returns (uint256);</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>    function minProfitBasisPoints(address) external view returns (uint256);</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>    function minProfitTime() external view returns (uint256);</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>    function mintBurnFeeBasisPoints() external view returns (uint256);</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='neutral'>    function poolAmounts(address) external view returns (uint256);</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    function positions(</span>
 281 |     | <span class='neutral'>        bytes32</span>
 282 |     | <span class='neutral'>    )</span>
 283 |     | <span class='neutral'>        external</span>
 284 |     | <span class='neutral'>        view</span>
 285 |     | <span class='neutral'>        returns (</span>
 286 |     | <span class='neutral'>            uint256 size,</span>
 287 |     | <span class='neutral'>            uint256 collateral,</span>
 288 |     | <span class='neutral'>            uint256 averagePrice,</span>
 289 |     | <span class='neutral'>            uint256 entryFundingRate,</span>
 290 |     | <span class='neutral'>            uint256 reserveAmount,</span>
 291 |     | <span class='neutral'>            int256 realisedPnl,</span>
 292 |     | <span class='neutral'>            uint256 lastIncreasedTime</span>
 293 |     | <span class='neutral'>        );</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    function priceFeed() external view returns (address);</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    function removeRouter(address _router) external;</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>    function reservedAmounts(address) external view returns (uint256);</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='neutral'>    function router() external view returns (address);</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>    function sellUSDG(address _token, address _receiver) external returns (uint256);</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>    function setBufferAmount(address _token, uint256 _amount) external;</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='neutral'>    function setError(uint256 _errorCode, string memory _error) external;</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='neutral'>    function setErrorController(address _errorController) external;</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    function setFees(</span>
 312 |     | <span class='neutral'>        uint256 _taxBasisPoints,</span>
 313 |     | <span class='neutral'>        uint256 _stableTaxBasisPoints,</span>
 314 |     | <span class='neutral'>        uint256 _mintBurnFeeBasisPoints,</span>
 315 |     | <span class='neutral'>        uint256 _swapFeeBasisPoints,</span>
 316 |     | <span class='neutral'>        uint256 _stableSwapFeeBasisPoints,</span>
 317 |     | <span class='neutral'>        uint256 _marginFeeBasisPoints,</span>
 318 |     | <span class='neutral'>        uint256 _liquidationFeeUsd,</span>
 319 |     | <span class='neutral'>        uint256 _minProfitTime,</span>
 320 |     | <span class='neutral'>        bool _hasDynamicFees</span>
 321 |     | <span class='neutral'>    ) external;</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='neutral'>    function setFundingRate(uint256 _fundingInterval, uint256 _fundingRateFactor, uint256 _stableFundingRateFactor) external;</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='neutral'>    function setGov(address _gov) external;</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>    function setInManagerMode(bool _inManagerMode) external;</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='neutral'>    function setInPrivateLiquidationMode(bool _inPrivateLiquidationMode) external;</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='neutral'>    function setIsLeverageEnabled(bool _isLeverageEnabled) external;</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='neutral'>    function setIsSwapEnabled(bool _isSwapEnabled) external;</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='neutral'>    function setLiquidator(address _liquidator, bool _isActive) external;</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='neutral'>    function setManager(address _manager, bool _isManager) external;</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='neutral'>    function setMaxGasPrice(uint256 _maxGasPrice) external;</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='neutral'>    function setMaxLeverage(uint256 _maxLeverage) external;</span>
 342 |     | <span class='neutral'></span>
 343 |     | <span class='neutral'>    function setPriceFeed(address _priceFeed) external;</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>    function setTokenConfig(</span>
 346 |     | <span class='neutral'>        address _token,</span>
 347 |     | <span class='neutral'>        uint256 _tokenDecimals,</span>
 348 |     | <span class='neutral'>        uint256 _tokenWeight,</span>
 349 |     | <span class='neutral'>        uint256 _minProfitBps,</span>
 350 |     | <span class='neutral'>        uint256 _maxUsdgAmount,</span>
 351 |     | <span class='neutral'>        bool _isStable,</span>
 352 |     | <span class='neutral'>        bool _isShortable</span>
 353 |     | <span class='neutral'>    ) external;</span>
 354 |     | <span class='neutral'></span>
 355 |     | <span class='neutral'>    function setUsdgAmount(address _token, uint256 _amount) external;</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>    function shortableTokens(address) external view returns (bool);</span>
 358 |     | <span class='neutral'></span>
 359 |     | <span class='neutral'>    function stableFundingRateFactor() external view returns (uint256);</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='neutral'>    function stableSwapFeeBasisPoints() external view returns (uint256);</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='neutral'>    function stableTaxBasisPoints() external view returns (uint256);</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>    function stableTokens(address) external view returns (bool);</span>
 366 |     | <span class='neutral'></span>
 367 |     | <span class='neutral'>    function swap(address _tokenIn, address _tokenOut, address _receiver) external returns (uint256);</span>
 368 |     | <span class='neutral'></span>
 369 |     | <span class='neutral'>    function swapFeeBasisPoints() external view returns (uint256);</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>    function taxBasisPoints() external view returns (uint256);</span>
 372 |     | <span class='neutral'></span>
 373 |     | <span class='neutral'>    function tokenBalances(address) external view returns (uint256);</span>
 374 |     | <span class='neutral'></span>
 375 |     | <span class='neutral'>    function tokenDecimals(address) external view returns (uint256);</span>
 376 |     | <span class='neutral'></span>
 377 |     | <span class='neutral'>    function tokenToUsdMin(address _token, uint256 _tokenAmount) external view returns (uint256);</span>
 378 |     | <span class='neutral'></span>
 379 |     | <span class='neutral'>    function tokenWeights(address) external view returns (uint256);</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>    function totalTokenWeights() external view returns (uint256);</span>
 382 |     | <span class='neutral'></span>
 383 |     | <span class='neutral'>    function updateCumulativeFundingRate(address _token) external;</span>
 384 |     | <span class='neutral'></span>
 385 |     | <span class='neutral'>    function upgradeVault(address _newVault, address _token, uint256 _amount) external;</span>
 386 |     | <span class='neutral'></span>
 387 |     | <span class='neutral'>    function usdToToken(address _token, uint256 _usdAmount, uint256 _price) external view returns (uint256);</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>    function usdToTokenMax(address _token, uint256 _usdAmount) external view returns (uint256);</span>
 390 |     | <span class='neutral'></span>
 391 |     | <span class='neutral'>    function usdToTokenMin(address _token, uint256 _usdAmount) external view returns (uint256);</span>
 392 |     | <span class='neutral'></span>
 393 |     | <span class='neutral'>    function usdg() external view returns (address);</span>
 394 |     | <span class='neutral'></span>
 395 |     | <span class='neutral'>    function usdgAmounts(address) external view returns (uint256);</span>
 396 |     | <span class='neutral'></span>
 397 |     | <span class='neutral'>    function useSwapPricing() external view returns (bool);</span>
 398 |     | <span class='neutral'></span>
 399 |     | <span class='neutral'>    function validateLiquidation(</span>
 400 |     | <span class='neutral'>        address _account,</span>
 401 |     | <span class='neutral'>        address _collateralToken,</span>
 402 |     | <span class='neutral'>        address _indexToken,</span>
 403 |     | <span class='neutral'>        bool _isLong,</span>
 404 |     | <span class='neutral'>        bool _raise</span>
 405 |     | <span class='neutral'>    ) external view returns (uint256, uint256);</span>
 406 |     | <span class='neutral'></span>
 407 |     | <span class='neutral'>    function whitelistedTokenCount() external view returns (uint256);</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='neutral'>    function whitelistedTokens(address) external view returns (bool);</span>
 410 |     | <span class='neutral'></span>
 411 |     | <span class='neutral'>    function withdrawFees(address _token, address _receiver) external returns (uint256);</span>
 412 |     | <span class='neutral'>}</span>
 413 |     | <span class='neutral'></span>
 414 |     | <span class='neutral'>interface IGmxVester {</span>
 415 |     | <span class='neutral'>    function rewardTracker() external view returns (address);</span>
 416 |     | <span class='neutral'></span>
 417 |     | <span class='neutral'>    function claimForAccount(address _account, address _receiver) external returns (uint256);</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='neutral'>    function claimable(address _account) external view returns (uint256);</span>
 420 |     | <span class='neutral'></span>
 421 |     | <span class='neutral'>    function setHasMaxVestableAmount(bool _hasMaxVestableAmount) external;</span>
 422 |     | <span class='neutral'></span>
 423 |     | <span class='neutral'>    function cumulativeClaimAmounts(address _account) external view returns (uint256);</span>
 424 |     | <span class='neutral'></span>
 425 |     | <span class='neutral'>    function claimedAmounts(address _account) external view returns (uint256);</span>
 426 |     | <span class='neutral'></span>
 427 |     | <span class='neutral'>    function pairAmounts(address _account) external view returns (uint256);</span>
 428 |     | <span class='neutral'></span>
 429 |     | <span class='neutral'>    function getVestedAmount(address _account) external view returns (uint256);</span>
 430 |     | <span class='neutral'></span>
 431 |     | <span class='neutral'>    function transferredAverageStakedAmounts(address _account) external view returns (uint256);</span>
 432 |     | <span class='neutral'></span>
 433 |     | <span class='neutral'>    function transferredCumulativeRewards(address _account) external view returns (uint256);</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='neutral'>    function cumulativeRewardDeductions(address _account) external view returns (uint256);</span>
 436 |     | <span class='neutral'></span>
 437 |     | <span class='neutral'>    function bonusRewards(address _account) external view returns (uint256);</span>
 438 |     | <span class='neutral'></span>
 439 |     | <span class='neutral'>    function transferStakeValues(address _sender, address _receiver) external;</span>
 440 |     | <span class='neutral'></span>
 441 |     | <span class='neutral'>    function setTransferredAverageStakedAmounts(address _account, uint256 _amount) external;</span>
 442 |     | <span class='neutral'></span>
 443 |     | <span class='neutral'>    function setTransferredCumulativeRewards(address _account, uint256 _amount) external;</span>
 444 |     | <span class='neutral'></span>
 445 |     | <span class='neutral'>    function setCumulativeRewardDeductions(address _account, uint256 _amount) external;</span>
 446 |     | <span class='neutral'></span>
 447 |     | <span class='neutral'>    function setBonusRewards(address _account, uint256 _amount) external;</span>
 448 |     | <span class='neutral'></span>
 449 |     | <span class='neutral'>    function getMaxVestableAmount(address _account) external view returns (uint256);</span>
 450 |     | <span class='neutral'></span>
 451 |     | <span class='neutral'>    function getCombinedAverageStakedAmount(address _account) external view returns (uint256);</span>
 452 |     | <span class='neutral'></span>
 453 |     | <span class='neutral'>    function deposit(uint256 _amount) external;</span>
 454 |     | <span class='neutral'></span>
 455 |     | <span class='neutral'>    function withdraw() external;</span>
 456 |     | <span class='neutral'></span>
 457 |     | <span class='neutral'>    function claim() external returns (uint256);</span>
 458 |     | <span class='neutral'></span>
 459 |     | <span class='neutral'>    function getTotalVested(address _account) external view returns (uint256);</span>
 460 |     | <span class='neutral'></span>
 461 |     | <span class='neutral'>    function balances(address account) external view returns (uint256);</span>
 462 |     | <span class='neutral'>}</span>
 463 |     | <span class='neutral'></span>
 464 |     | <span class='neutral'>interface IVaultPriceFeed {</span>
 465 |     | <span class='neutral'>    function adjustmentBasisPoints(address _token) external view returns (uint256);</span>
 466 |     | <span class='neutral'></span>
 467 |     | <span class='neutral'>    function isAdjustmentAdditive(address _token) external view returns (bool);</span>
 468 |     | <span class='neutral'></span>
 469 |     | <span class='neutral'>    function setAdjustment(address _token, bool _isAdditive, uint256 _adjustmentBps) external;</span>
 470 |     | <span class='neutral'></span>
 471 |     | <span class='neutral'>    function setUseV2Pricing(bool _useV2Pricing) external;</span>
 472 |     | <span class='neutral'></span>
 473 |     | <span class='neutral'>    function setIsAmmEnabled(bool _isEnabled) external;</span>
 474 |     | <span class='neutral'></span>
 475 |     | <span class='neutral'>    function setIsSecondaryPriceEnabled(bool _isEnabled) external;</span>
 476 |     | <span class='neutral'></span>
 477 |     | <span class='neutral'>    function setSpreadBasisPoints(address _token, uint256 _spreadBasisPoints) external;</span>
 478 |     | <span class='neutral'></span>
 479 |     | <span class='neutral'>    function setSpreadThresholdBasisPoints(uint256 _spreadThresholdBasisPoints) external;</span>
 480 |     | <span class='neutral'></span>
 481 |     | <span class='neutral'>    function setFavorPrimaryPrice(bool _favorPrimaryPrice) external;</span>
 482 |     | <span class='neutral'></span>
 483 |     | <span class='neutral'>    function setPriceSampleSpace(uint256 _priceSampleSpace) external;</span>
 484 |     | <span class='neutral'></span>
 485 |     | <span class='neutral'>    function setMaxStrictPriceDeviation(uint256 _maxStrictPriceDeviation) external;</span>
 486 |     | <span class='neutral'></span>
 487 |     | <span class='neutral'>    function getPrice(address _token, bool _maximise, bool _includeAmmPrice, bool _useSwapPricing) external view returns (uint256);</span>
 488 |     | <span class='neutral'></span>
 489 |     | <span class='neutral'>    function getAmmPrice(address _token) external view returns (uint256);</span>
 490 |     | <span class='neutral'></span>
 491 |     | <span class='neutral'>    function getPrimaryPrice(address _token, bool _maximise) external view returns (uint256);</span>
 492 |     | <span class='neutral'>}</span>
 493 |     | <span class='neutral'></span>
 494 |     | <span class='neutral'>interface IGmxRewardDistributor {</span>
 495 |     | <span class='neutral'>    function pendingRewards() external view returns (uint256);</span>
 496 |     | <span class='neutral'></span>
 497 |     | <span class='neutral'>    function distribute() external returns (uint256);</span>
 498 |     | <span class='neutral'>}</span>
 499 |     | <span class='neutral'></span>
 500 |     | <span class='neutral'>interface IGmxRewardRouterV2 {</span>
 501 |     | <span class='neutral'>    type VotingPowerType is uint8;</span>
 502 |     | <span class='neutral'></span>
 503 |     | <span class='neutral'>    event StakeGlp(address account, uint256 amount);</span>
 504 |     | <span class='neutral'>    event StakeGmx(address account, address token, uint256 amount);</span>
 505 |     | <span class='neutral'>    event UnstakeGlp(address account, uint256 amount);</span>
 506 |     | <span class='neutral'>    event UnstakeGmx(address account, address token, uint256 amount);</span>
 507 |     | <span class='neutral'></span>
 508 |     | <span class='neutral'>    function BASIS_POINTS_DIVISOR() external view returns (uint256);</span>
 509 |     | <span class='neutral'></span>
 510 |     | <span class='neutral'>    function acceptTransfer(address _sender) external;</span>
 511 |     | <span class='neutral'></span>
 512 |     | <span class='neutral'>    function batchCompoundForAccounts(address[] memory _accounts) external;</span>
 513 |     | <span class='neutral'></span>
 514 |     | <span class='neutral'>    function batchStakeGmxForAccount(address[] memory _accounts, uint256[] memory _amounts) external;</span>
 515 |     | <span class='neutral'></span>
 516 |     | <span class='neutral'>    function bnGmx() external view returns (address);</span>
 517 |     | <span class='neutral'></span>
 518 |     | <span class='neutral'>    function bonusGmxTracker() external view returns (address);</span>
 519 |     | <span class='neutral'></span>
 520 |     | <span class='neutral'>    function claim() external;</span>
 521 |     | <span class='neutral'></span>
 522 |     | <span class='neutral'>    function claimEsGmx() external;</span>
 523 |     | <span class='neutral'></span>
 524 |     | <span class='neutral'>    function claimFees() external;</span>
 525 |     | <span class='neutral'></span>
 526 |     | <span class='neutral'>    function compound() external;</span>
 527 |     | <span class='neutral'></span>
 528 |     | <span class='neutral'>    function compoundForAccount(address _account) external;</span>
 529 |     | <span class='neutral'></span>
 530 |     | <span class='neutral'>    function esGmx() external view returns (address);</span>
 531 |     | <span class='neutral'></span>
 532 |     | <span class='neutral'>    function feeGlpTracker() external view returns (address);</span>
 533 |     | <span class='neutral'></span>
 534 |     | <span class='neutral'>    function feeGmxTracker() external view returns (address);</span>
 535 |     | <span class='neutral'></span>
 536 |     | <span class='neutral'>    function glp() external view returns (address);</span>
 537 |     | <span class='neutral'></span>
 538 |     | <span class='neutral'>    function glpManager() external view returns (address);</span>
 539 |     | <span class='neutral'></span>
 540 |     | <span class='neutral'>    function glpVester() external view returns (address);</span>
 541 |     | <span class='neutral'></span>
 542 |     | <span class='neutral'>    function gmx() external view returns (address);</span>
 543 |     | <span class='neutral'></span>
 544 |     | <span class='neutral'>    function gmxVester() external view returns (address);</span>
 545 |     | <span class='neutral'></span>
 546 |     | <span class='neutral'>    function gov() external view returns (address);</span>
 547 |     | <span class='neutral'></span>
 548 |     | <span class='neutral'>    function govToken() external view returns (address);</span>
 549 |     | <span class='neutral'></span>
 550 |     | <span class='neutral'>    function handleRewards(</span>
 551 |     | <span class='neutral'>        bool shouldClaimGmx,</span>
 552 |     | <span class='neutral'>        bool shouldStakeGmx,</span>
 553 |     | <span class='neutral'>        bool shouldClaimEsGmx,</span>
 554 |     | <span class='neutral'>        bool shouldStakeEsGmx,</span>
 555 |     | <span class='neutral'>        bool shouldStakeMultiplierPoints,</span>
 556 |     | <span class='neutral'>        bool shouldClaimWeth,</span>
 557 |     | <span class='neutral'>        bool shouldConvertWethToEth</span>
 558 |     | <span class='neutral'>    ) external;</span>
 559 |     | <span class='neutral'></span>
 560 |     | <span class='neutral'>    function inStrictTransferMode() external view returns (bool);</span>
 561 |     | <span class='neutral'></span>
 562 |     | <span class='neutral'>    function initialize(</span>
 563 |     | <span class='neutral'>        address _weth,</span>
 564 |     | <span class='neutral'>        address _gmx,</span>
 565 |     | <span class='neutral'>        address _esGmx,</span>
 566 |     | <span class='neutral'>        address _bnGmx,</span>
 567 |     | <span class='neutral'>        address _glp,</span>
 568 |     | <span class='neutral'>        address _stakedGmxTracker,</span>
 569 |     | <span class='neutral'>        address _bonusGmxTracker,</span>
 570 |     | <span class='neutral'>        address _feeGmxTracker,</span>
 571 |     | <span class='neutral'>        address _feeGlpTracker,</span>
 572 |     | <span class='neutral'>        address _stakedGlpTracker,</span>
 573 |     | <span class='neutral'>        address _glpManager,</span>
 574 |     | <span class='neutral'>        address _gmxVester,</span>
 575 |     | <span class='neutral'>        address _glpVester,</span>
 576 |     | <span class='neutral'>        address _govToken</span>
 577 |     | <span class='neutral'>    ) external;</span>
 578 |     | <span class='neutral'></span>
 579 |     | <span class='neutral'>    function isInitialized() external view returns (bool);</span>
 580 |     | <span class='neutral'></span>
 581 |     | <span class='neutral'>    function maxBoostBasisPoints() external view returns (uint256);</span>
 582 |     | <span class='neutral'></span>
 583 |     | <span class='neutral'>    function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns (uint256);</span>
 584 |     | <span class='neutral'></span>
 585 |     | <span class='neutral'>    function mintAndStakeGlpETH(uint256 _minUsdg, uint256 _minGlp) external payable returns (uint256);</span>
 586 |     | <span class='neutral'></span>
 587 |     | <span class='neutral'>    function pendingReceivers(address) external view returns (address);</span>
 588 |     | <span class='neutral'></span>
 589 |     | <span class='neutral'>    function setGov(address _gov) external;</span>
 590 |     | <span class='neutral'></span>
 591 |     | <span class='neutral'>    function setInStrictTransferMode(bool _inStrictTransferMode) external;</span>
 592 |     | <span class='neutral'></span>
 593 |     | <span class='neutral'>    function setMaxBoostBasisPoints(uint256 _maxBoostBasisPoints) external;</span>
 594 |     | <span class='neutral'></span>
 595 |     | <span class='neutral'>    function setVotingPowerType(VotingPowerType _votingPowerType) external;</span>
 596 |     | <span class='neutral'></span>
 597 |     | <span class='neutral'>    function signalTransfer(address _receiver) external;</span>
 598 |     | <span class='neutral'></span>
 599 |     | <span class='neutral'>    function stakeEsGmx(uint256 _amount) external;</span>
 600 |     | <span class='neutral'></span>
 601 |     | <span class='neutral'>    function stakeGmx(uint256 _amount) external;</span>
 602 |     | <span class='neutral'></span>
 603 |     | <span class='neutral'>    function stakeGmxForAccount(address _account, uint256 _amount) external;</span>
 604 |     | <span class='neutral'></span>
 605 |     | <span class='neutral'>    function stakedGlpTracker() external view returns (address);</span>
 606 |     | <span class='neutral'></span>
 607 |     | <span class='neutral'>    function stakedGmxTracker() external view returns (address);</span>
 608 |     | <span class='neutral'></span>
 609 |     | <span class='neutral'>    function unstakeAndRedeemGlp(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);</span>
 610 |     | <span class='neutral'></span>
 611 |     | <span class='neutral'>    function unstakeAndRedeemGlpETH(uint256 _glpAmount, uint256 _minOut, address payable _receiver) external returns (uint256);</span>
 612 |     | <span class='neutral'></span>
 613 |     | <span class='neutral'>    function unstakeEsGmx(uint256 _amount) external;</span>
 614 |     | <span class='neutral'></span>
 615 |     | <span class='neutral'>    function unstakeGmx(uint256 _amount) external;</span>
 616 |     | <span class='neutral'></span>
 617 |     | <span class='neutral'>    function votingPowerType() external view returns (VotingPowerType);</span>
 618 |     | <span class='neutral'></span>
 619 |     | <span class='neutral'>    function weth() external view returns (address);</span>
 620 |     | <span class='neutral'></span>
 621 |     | <span class='neutral'>    function withdrawToken(address _token, address _account, uint256 _amount) external;</span>
 622 |     | <span class='neutral'>}</span>
 623 |     | <span class='neutral'></span>
 624 |     | <span class='neutral'>interface IGmxRewardTracker {</span>
 625 |     | <span class='neutral'>    function rewardToken() external view returns (address);</span>
 626 |     | <span class='neutral'></span>
 627 |     | <span class='neutral'>    function depositBalances(address _account, address _depositToken) external view returns (uint256);</span>
 628 |     | <span class='neutral'></span>
 629 |     | <span class='neutral'>    function stakedAmounts(address _account) external view returns (uint256);</span>
 630 |     | <span class='neutral'></span>
 631 |     | <span class='neutral'>    function updateRewards() external;</span>
 632 |     | <span class='neutral'></span>
 633 |     | <span class='neutral'>    function stake(address _depositToken, uint256 _amount) external;</span>
 634 |     | <span class='neutral'></span>
 635 |     | <span class='neutral'>    function stakeForAccount(address _fundingAccount, address _account, address _depositToken, uint256 _amount) external;</span>
 636 |     | <span class='neutral'></span>
 637 |     | <span class='neutral'>    function unstake(address _depositToken, uint256 _amount) external;</span>
 638 |     | <span class='neutral'></span>
 639 |     | <span class='neutral'>    function unstakeForAccount(address _account, address _depositToken, uint256 _amount, address _receiver) external;</span>
 640 |     | <span class='neutral'></span>
 641 |     | <span class='neutral'>    function tokensPerInterval() external view returns (uint256);</span>
 642 |     | <span class='neutral'></span>
 643 |     | <span class='neutral'>    function claim(address _receiver) external returns (uint256);</span>
 644 |     | <span class='neutral'></span>
 645 |     | <span class='neutral'>    function claimForAccount(address _account, address _receiver) external returns (uint256);</span>
 646 |     | <span class='neutral'></span>
 647 |     | <span class='neutral'>    function claimable(address _account) external view returns (uint256);</span>
 648 |     | <span class='neutral'></span>
 649 |     | <span class='neutral'>    function averageStakedAmounts(address _account) external view returns (uint256);</span>
 650 |     | <span class='neutral'></span>
 651 |     | <span class='neutral'>    function cumulativeRewards(address _account) external view returns (uint256);</span>
 652 |     | <span class='neutral'>}</span>
 653 |     | <span class='neutral'></span>
 654 |     | <span class='neutral'>interface IGmxStakedGlp {</span>
 655 |     | <span class='neutral'>    function allowance(address _owner, address _spender) external view returns (uint256);</span>
 656 |     | <span class='neutral'></span>
 657 |     | <span class='neutral'>    function allowances(address, address) external view returns (uint256);</span>
 658 |     | <span class='neutral'></span>
 659 |     | <span class='neutral'>    function approve(address _spender, uint256 _amount) external returns (bool);</span>
 660 |     | <span class='neutral'></span>
 661 |     | <span class='neutral'>    function balanceOf(address _account) external view returns (uint256);</span>
 662 |     | <span class='neutral'></span>
 663 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 664 |     | <span class='neutral'></span>
 665 |     | <span class='neutral'>    function feeGlpTracker() external view returns (address);</span>
 666 |     | <span class='neutral'></span>
 667 |     | <span class='neutral'>    function glp() external view returns (address);</span>
 668 |     | <span class='neutral'></span>
 669 |     | <span class='neutral'>    function glpManager() external view returns (address);</span>
 670 |     | <span class='neutral'></span>
 671 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 672 |     | <span class='neutral'></span>
 673 |     | <span class='neutral'>    function stakedGlpTracker() external view returns (address);</span>
 674 |     | <span class='neutral'></span>
 675 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 676 |     | <span class='neutral'></span>
 677 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 678 |     | <span class='neutral'></span>
 679 |     | <span class='neutral'>    function transfer(address _recipient, uint256 _amount) external returns (bool);</span>
 680 |     | <span class='neutral'></span>
 681 |     | <span class='neutral'>    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool);</span>
 682 |     | <span class='neutral'>}</span>
 683 |     | <span class='neutral'></span>
 684 |     | <span class='neutral'>interface IGmxGlpRewardRouter {</span>
 685 |     | <span class='neutral'>    event StakeGlp(address account, uint256 amount);</span>
 686 |     | <span class='neutral'>    event StakeGmx(address account, address token, uint256 amount);</span>
 687 |     | <span class='neutral'>    event UnstakeGlp(address account, uint256 amount);</span>
 688 |     | <span class='neutral'>    event UnstakeGmx(address account, address token, uint256 amount);</span>
 689 |     | <span class='neutral'></span>
 690 |     | <span class='neutral'>    function acceptTransfer(address _sender) external;</span>
 691 |     | <span class='neutral'></span>
 692 |     | <span class='neutral'>    function batchCompoundForAccounts(address[] memory _accounts) external;</span>
 693 |     | <span class='neutral'></span>
 694 |     | <span class='neutral'>    function batchStakeGmxForAccount(address[] memory _accounts, uint256[] memory _amounts) external;</span>
 695 |     | <span class='neutral'></span>
 696 |     | <span class='neutral'>    function claim() external;</span>
 697 |     | <span class='neutral'></span>
 698 |     | <span class='neutral'>    function claimEsGmx() external;</span>
 699 |     | <span class='neutral'></span>
 700 |     | <span class='neutral'>    function claimFees() external;</span>
 701 |     | <span class='neutral'></span>
 702 |     | <span class='neutral'>    function compound() external;</span>
 703 |     | <span class='neutral'></span>
 704 |     | <span class='neutral'>    function compoundForAccount(address _account) external;</span>
 705 |     | <span class='neutral'></span>
 706 |     | <span class='neutral'>    function feeGlpTracker() external view returns (address);</span>
 707 |     | <span class='neutral'></span>
 708 |     | <span class='neutral'>    function glp() external view returns (address);</span>
 709 |     | <span class='neutral'></span>
 710 |     | <span class='neutral'>    function glpManager() external view returns (address);</span>
 711 |     | <span class='neutral'></span>
 712 |     | <span class='neutral'>    function gov() external view returns (address);</span>
 713 |     | <span class='neutral'></span>
 714 |     | <span class='neutral'>    function handleRewards(</span>
 715 |     | <span class='neutral'>        bool shouldClaimGmx,</span>
 716 |     | <span class='neutral'>        bool shouldStakeGmx,</span>
 717 |     | <span class='neutral'>        bool shouldClaimEsGmx,</span>
 718 |     | <span class='neutral'>        bool shouldStakeEsGmx,</span>
 719 |     | <span class='neutral'>        bool shouldStakeMultiplierPoints,</span>
 720 |     | <span class='neutral'>        bool shouldClaimWeth,</span>
 721 |     | <span class='neutral'>        bool shouldConvertWethToEth</span>
 722 |     | <span class='neutral'>    ) external;</span>
 723 |     | <span class='neutral'></span>
 724 |     | <span class='neutral'>    function initialize(</span>
 725 |     | <span class='neutral'>        address _weth,</span>
 726 |     | <span class='neutral'>        address _gmx,</span>
 727 |     | <span class='neutral'>        address _esGmx,</span>
 728 |     | <span class='neutral'>        address _bnGmx,</span>
 729 |     | <span class='neutral'>        address _glp,</span>
 730 |     | <span class='neutral'>        address _stakedGmxTracker,</span>
 731 |     | <span class='neutral'>        address _bonusGmxTracker,</span>
 732 |     | <span class='neutral'>        address _feeGmxTracker,</span>
 733 |     | <span class='neutral'>        address _feeGlpTracker,</span>
 734 |     | <span class='neutral'>        address _stakedGlpTracker,</span>
 735 |     | <span class='neutral'>        address _glpManager,</span>
 736 |     | <span class='neutral'>        address _gmxVester,</span>
 737 |     | <span class='neutral'>        address _glpVester</span>
 738 |     | <span class='neutral'>    ) external;</span>
 739 |     | <span class='neutral'></span>
 740 |     | <span class='neutral'>    function isInitialized() external view returns (bool);</span>
 741 |     | <span class='neutral'></span>
 742 |     | <span class='neutral'>    function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns (uint256);</span>
 743 |     | <span class='neutral'></span>
 744 |     | <span class='neutral'>    function mintAndStakeGlpETH(uint256 _minUsdg, uint256 _minGlp) external payable returns (uint256);</span>
 745 |     | <span class='neutral'></span>
 746 |     | <span class='neutral'>    function pendingReceivers(address) external view returns (address);</span>
 747 |     | <span class='neutral'></span>
 748 |     | <span class='neutral'>    function setGov(address _gov) external;</span>
 749 |     | <span class='neutral'></span>
 750 |     | <span class='neutral'>    function signalTransfer(address _receiver) external;</span>
 751 |     | <span class='neutral'></span>
 752 |     | <span class='neutral'>    function stakeEsGmx(uint256 _amount) external;</span>
 753 |     | <span class='neutral'></span>
 754 |     | <span class='neutral'>    function stakeGmx(uint256 _amount) external;</span>
 755 |     | <span class='neutral'></span>
 756 |     | <span class='neutral'>    function stakeGmxForAccount(address _account, uint256 _amount) external;</span>
 757 |     | <span class='neutral'></span>
 758 |     | <span class='neutral'>    function stakedGlpTracker() external view returns (address);</span>
 759 |     | <span class='neutral'></span>
 760 |     | <span class='neutral'>    function stakedGmxTracker() external view returns (address);</span>
 761 |     | <span class='neutral'></span>
 762 |     | <span class='neutral'>    function unstakeAndRedeemGlp(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);</span>
 763 |     | <span class='neutral'></span>
 764 |     | <span class='neutral'>    function unstakeAndRedeemGlpETH(uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);</span>
 765 |     | <span class='neutral'></span>
 766 |     | <span class='neutral'>    function unstakeEsGmx(uint256 _amount) external;</span>
 767 |     | <span class='neutral'></span>
 768 |     | <span class='neutral'>    function unstakeGmx(uint256 _amount) external;</span>
 769 |     | <span class='neutral'></span>
 770 |     | <span class='neutral'>    function withdrawToken(address _token, address _account, uint256 _amount) external;</span>
 771 |     | <span class='neutral'>}</span>
 772 |     | <span class='neutral'></span>
 773 |     | <span class='neutral'>interface IGmxGlpManager {</span>
 774 |     | <span class='neutral'>    event AddLiquidity(</span>
 775 |     | <span class='neutral'>        address account,</span>
 776 |     | <span class='neutral'>        address token,</span>
 777 |     | <span class='neutral'>        uint256 amount,</span>
 778 |     | <span class='neutral'>        uint256 aumInUsdg,</span>
 779 |     | <span class='neutral'>        uint256 glpSupply,</span>
 780 |     | <span class='neutral'>        uint256 usdgAmount,</span>
 781 |     | <span class='neutral'>        uint256 mintAmount</span>
 782 |     | <span class='neutral'>    );</span>
 783 |     | <span class='neutral'>    event RemoveLiquidity(</span>
 784 |     | <span class='neutral'>        address account,</span>
 785 |     | <span class='neutral'>        address token,</span>
 786 |     | <span class='neutral'>        uint256 glpAmount,</span>
 787 |     | <span class='neutral'>        uint256 aumInUsdg,</span>
 788 |     | <span class='neutral'>        uint256 glpSupply,</span>
 789 |     | <span class='neutral'>        uint256 usdgAmount,</span>
 790 |     | <span class='neutral'>        uint256 amountOut</span>
 791 |     | <span class='neutral'>    );</span>
 792 |     | <span class='neutral'></span>
 793 |     | <span class='neutral'>    function BASIS_POINTS_DIVISOR() external view returns (uint256);</span>
 794 |     | <span class='neutral'></span>
 795 |     | <span class='neutral'>    function GLP_PRECISION() external view returns (uint256);</span>
 796 |     | <span class='neutral'></span>
 797 |     | <span class='neutral'>    function MAX_COOLDOWN_DURATION() external view returns (uint256);</span>
 798 |     | <span class='neutral'></span>
 799 |     | <span class='neutral'>    function PRICE_PRECISION() external view returns (uint256);</span>
 800 |     | <span class='neutral'></span>
 801 |     | <span class='neutral'>    function USDG_DECIMALS() external view returns (uint256);</span>
 802 |     | <span class='neutral'></span>
 803 |     | <span class='neutral'>    function addLiquidity(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns (uint256);</span>
 804 |     | <span class='neutral'></span>
 805 |     | <span class='neutral'>    function addLiquidityForAccount(</span>
 806 |     | <span class='neutral'>        address _fundingAccount,</span>
 807 |     | <span class='neutral'>        address _account,</span>
 808 |     | <span class='neutral'>        address _token,</span>
 809 |     | <span class='neutral'>        uint256 _amount,</span>
 810 |     | <span class='neutral'>        uint256 _minUsdg,</span>
 811 |     | <span class='neutral'>        uint256 _minGlp</span>
 812 |     | <span class='neutral'>    ) external returns (uint256);</span>
 813 |     | <span class='neutral'></span>
 814 |     | <span class='neutral'>    function aumAddition() external view returns (uint256);</span>
 815 |     | <span class='neutral'></span>
 816 |     | <span class='neutral'>    function aumDeduction() external view returns (uint256);</span>
 817 |     | <span class='neutral'></span>
 818 |     | <span class='neutral'>    function cooldownDuration() external view returns (uint256);</span>
 819 |     | <span class='neutral'></span>
 820 |     | <span class='neutral'>    function getAum(bool maximise) external view returns (uint256);</span>
 821 |     | <span class='neutral'></span>
 822 |     | <span class='neutral'>    function getAumInUsdg(bool maximise) external view returns (uint256);</span>
 823 |     | <span class='neutral'></span>
 824 |     | <span class='neutral'>    function getAums() external view returns (uint256[] memory);</span>
 825 |     | <span class='neutral'></span>
 826 |     | <span class='neutral'>    function getGlobalShortAveragePrice(address _token) external view returns (uint256);</span>
 827 |     | <span class='neutral'></span>
 828 |     | <span class='neutral'>    function getGlobalShortDelta(address _token, uint256 _price, uint256 _size) external view returns (uint256, bool);</span>
 829 |     | <span class='neutral'></span>
 830 |     | <span class='neutral'>    function getPrice(bool _maximise) external view returns (uint256);</span>
 831 |     | <span class='neutral'></span>
 832 |     | <span class='neutral'>    function glp() external view returns (address);</span>
 833 |     | <span class='neutral'></span>
 834 |     | <span class='neutral'>    function gov() external view returns (address);</span>
 835 |     | <span class='neutral'></span>
 836 |     | <span class='neutral'>    function inPrivateMode() external view returns (bool);</span>
 837 |     | <span class='neutral'></span>
 838 |     | <span class='neutral'>    function isHandler(address) external view returns (bool);</span>
 839 |     | <span class='neutral'></span>
 840 |     | <span class='neutral'>    function lastAddedAt(address) external view returns (uint256);</span>
 841 |     | <span class='neutral'></span>
 842 |     | <span class='neutral'>    function removeLiquidity(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);</span>
 843 |     | <span class='neutral'></span>
 844 |     | <span class='neutral'>    function removeLiquidityForAccount(</span>
 845 |     | <span class='neutral'>        address _account,</span>
 846 |     | <span class='neutral'>        address _tokenOut,</span>
 847 |     | <span class='neutral'>        uint256 _glpAmount,</span>
 848 |     | <span class='neutral'>        uint256 _minOut,</span>
 849 |     | <span class='neutral'>        address _receiver</span>
 850 |     | <span class='neutral'>    ) external returns (uint256);</span>
 851 |     | <span class='neutral'></span>
 852 |     | <span class='neutral'>    function setAumAdjustment(uint256 _aumAddition, uint256 _aumDeduction) external;</span>
 853 |     | <span class='neutral'></span>
 854 |     | <span class='neutral'>    function setCooldownDuration(uint256 _cooldownDuration) external;</span>
 855 |     | <span class='neutral'></span>
 856 |     | <span class='neutral'>    function setGov(address _gov) external;</span>
 857 |     | <span class='neutral'></span>
 858 |     | <span class='neutral'>    function setHandler(address _handler, bool _isActive) external;</span>
 859 |     | <span class='neutral'></span>
 860 |     | <span class='neutral'>    function setInPrivateMode(bool _inPrivateMode) external;</span>
 861 |     | <span class='neutral'></span>
 862 |     | <span class='neutral'>    function setShortsTracker(address _shortsTracker) external;</span>
 863 |     | <span class='neutral'></span>
 864 |     | <span class='neutral'>    function setShortsTrackerAveragePriceWeight(uint256 _shortsTrackerAveragePriceWeight) external;</span>
 865 |     | <span class='neutral'></span>
 866 |     | <span class='neutral'>    function shortsTracker() external view returns (address);</span>
 867 |     | <span class='neutral'></span>
 868 |     | <span class='neutral'>    function shortsTrackerAveragePriceWeight() external view returns (uint256);</span>
 869 |     | <span class='neutral'></span>
 870 |     | <span class='neutral'>    function usdg() external view returns (address);</span>
 871 |     | <span class='neutral'></span>
 872 |     | <span class='neutral'>    function vault() external view returns (address);</span>
 873 |     | <span class='neutral'>}</span>
 874 |     | <span class='neutral'></span>
 875 |     | <span class='neutral'>interface IGmxGlpRewardHandler {</span>
 876 |     | <span class='neutral'>    function harvest() external;</span>
 877 |     | <span class='neutral'></span>
 878 |     | <span class='neutral'>    function swapRewards(</span>
 879 |     | <span class='neutral'>        uint256 amountOutMin,</span>
 880 |     | <span class='neutral'>        IERC20 rewardToken,</span>
 881 |     | <span class='neutral'>        IERC20 outputToken,</span>
 882 |     | <span class='neutral'>        address recipient,</span>
 883 |     | <span class='neutral'>        bytes calldata data</span>
 884 |     | <span class='neutral'>    ) external returns (uint256 amountOut);</span>
 885 |     | <span class='neutral'></span>
 886 |     | <span class='neutral'>    function setFeeParameters(address _feeCollector, uint8 _feePercent) external;</span>
 887 |     | <span class='neutral'></span>
 888 |     | <span class='neutral'>    function setRewardTokenEnabled(IERC20 token, bool enabled) external;</span>
 889 |     | <span class='neutral'></span>
 890 |     | <span class='neutral'>    function setSwappingTokenOutEnabled(IERC20 token, bool enabled) external;</span>
 891 |     | <span class='neutral'></span>
 892 |     | <span class='neutral'>    function setAllowedSwappingRecipient(address recipient, bool enabled) external;</span>
 893 |     | <span class='neutral'></span>
 894 |     | <span class='neutral'>    function setRewardRouter(IGmxRewardRouterV2 _rewardRouter) external;</span>
 895 |     | <span class='neutral'></span>
 896 |     | <span class='neutral'>    function setSwapper(address _swapper) external;</span>
 897 |     | <span class='neutral'></span>
 898 |     | <span class='neutral'>    function unstakeGmx(uint256 amount, uint256 amountTransferToFeeCollector) external;</span>
 899 |     | <span class='neutral'></span>
 900 |     | <span class='neutral'>    function unstakeEsGmxAndVest(uint256 amount, uint256 glpVesterDepositAmount, uint256 gmxVesterDepositAmount) external;</span>
 901 |     | <span class='neutral'></span>
 902 |     | <span class='neutral'>    function withdrawFromVesting(bool withdrawFromGlpVester, bool withdrawFromGmxVester, bool stake) external;</span>
 903 |     | <span class='neutral'></span>
 904 |     | <span class='neutral'>    function claimVestedGmx(bool withdrawFromGlpVester, bool withdrawFromGmxVester, bool stake, bool transferToFeeCollecter) external;</span>
 905 |     | <span class='neutral'>}</span>
 906 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IGmxV2.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// @title Deposit</span>
   5 |     | <span class='neutral'>// @dev Struct for deposits</span>
   6 |     | <span class='neutral'>interface IGmxV2Deposit {</span>
   7 |     | <span class='neutral'>    /** @dev CreateDepositParams struct used in createDeposit to avoid stack</span>
   8 |     | <span class='neutral'>     * too deep errors</span>
   9 |     | <span class='neutral'>     *</span>
  10 |     | <span class='neutral'>     * @param receiver the address to send the market tokens to</span>
  11 |     | <span class='neutral'>     * @param callbackContract the callback contract</span>
  12 |     | <span class='neutral'>     * @param uiFeeReceiver the ui fee receiver</span>
  13 |     | <span class='neutral'>     * @param market the market to deposit into</span>
  14 |     | <span class='neutral'>     * @param minMarketTokens the minimum acceptable number of liquidity tokens</span>
  15 |     | <span class='neutral'>     * @param shouldUnwrapNativeToken whether to unwrap the native token when</span>
  16 |     | <span class='neutral'>     * sending funds back to the user in case the deposit gets cancelled</span>
  17 |     | <span class='neutral'>     * @param executionFee the execution fee for keepers</span>
  18 |     | <span class='neutral'>     * @param callbackGasLimit the gas limit for the callbackContract</span>
  19 |     | <span class='neutral'>     */</span>
  20 |     | <span class='neutral'>    struct CreateDepositParams {</span>
  21 |     | <span class='neutral'>        address receiver;</span>
  22 |     | <span class='neutral'>        address callbackContract;</span>
  23 |     | <span class='neutral'>        address uiFeeReceiver;</span>
  24 |     | <span class='neutral'>        address market;</span>
  25 |     | <span class='neutral'>        address initialLongToken;</span>
  26 |     | <span class='neutral'>        address initialShortToken;</span>
  27 |     | <span class='neutral'>        address[] longTokenSwapPath;</span>
  28 |     | <span class='neutral'>        address[] shortTokenSwapPath;</span>
  29 |     | <span class='neutral'>        uint256 minMarketTokens;</span>
  30 |     | <span class='neutral'>        bool shouldUnwrapNativeToken;</span>
  31 |     | <span class='neutral'>        uint256 executionFee;</span>
  32 |     | <span class='neutral'>        uint256 callbackGasLimit;</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    // @dev there is a limit on the number of fields a struct can have when being passed</span>
  36 |     | <span class='neutral'>    // or returned as a memory variable which can cause &quot;Stack too deep&quot; errors</span>
  37 |     | <span class='neutral'>    // use sub-structs to avoid this issue</span>
  38 |     | <span class='neutral'>    // @param addresses address values</span>
  39 |     | <span class='neutral'>    // @param numbers number values</span>
  40 |     | <span class='neutral'>    // @param flags boolean values</span>
  41 |     | <span class='neutral'>    struct Props {</span>
  42 |     | <span class='neutral'>        Addresses addresses;</span>
  43 |     | <span class='neutral'>        Numbers numbers;</span>
  44 |     | <span class='neutral'>        Flags flags;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    // @param account the account depositing liquidity</span>
  48 |     | <span class='neutral'>    // @param receiver the address to send the liquidity tokens to</span>
  49 |     | <span class='neutral'>    // @param callbackContract the callback contract</span>
  50 |     | <span class='neutral'>    // @param uiFeeReceiver the ui fee receiver</span>
  51 |     | <span class='neutral'>    // @param market the market to deposit to</span>
  52 |     | <span class='neutral'>    struct Addresses {</span>
  53 |     | <span class='neutral'>        address account;</span>
  54 |     | <span class='neutral'>        address receiver;</span>
  55 |     | <span class='neutral'>        address callbackContract;</span>
  56 |     | <span class='neutral'>        address uiFeeReceiver;</span>
  57 |     | <span class='neutral'>        address market;</span>
  58 |     | <span class='neutral'>        address initialLongToken;</span>
  59 |     | <span class='neutral'>        address initialShortToken;</span>
  60 |     | <span class='neutral'>        address[] longTokenSwapPath;</span>
  61 |     | <span class='neutral'>        address[] shortTokenSwapPath;</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    // @param initialLongTokenAmount the amount of long tokens to deposit</span>
  65 |     | <span class='neutral'>    // @param initialShortTokenAmount the amount of short tokens to deposit</span>
  66 |     | <span class='neutral'>    // @param minMarketTokens the minimum acceptable number of liquidity tokens</span>
  67 |     | <span class='neutral'>    // @param updatedAtBlock the block that the deposit was last updated at</span>
  68 |     | <span class='neutral'>    // sending funds back to the user in case the deposit gets cancelled</span>
  69 |     | <span class='neutral'>    // @param executionFee the execution fee for keepers</span>
  70 |     | <span class='neutral'>    // @param callbackGasLimit the gas limit for the callbackContract</span>
  71 |     | <span class='neutral'>    struct Numbers {</span>
  72 |     | <span class='neutral'>        uint256 initialLongTokenAmount;</span>
  73 |     | <span class='neutral'>        uint256 initialShortTokenAmount;</span>
  74 |     | <span class='neutral'>        uint256 minMarketTokens;</span>
  75 |     | <span class='neutral'>        uint256 updatedAtBlock;</span>
  76 |     | <span class='neutral'>        uint256 executionFee;</span>
  77 |     | <span class='neutral'>        uint256 callbackGasLimit;</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    // @param shouldUnwrapNativeToken whether to unwrap the native token when</span>
  81 |     | <span class='neutral'>    struct Flags {</span>
  82 |     | <span class='neutral'>        bool shouldUnwrapNativeToken;</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'>}</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>interface IGmxV2Withdrawal {</span>
  87 |     | <span class='neutral'>    /**</span>
  88 |     | <span class='neutral'>     * @param receiver The address that will receive the withdrawal tokens.</span>
  89 |     | <span class='neutral'>     * @param callbackContract The contract that will be called back.</span>
  90 |     | <span class='neutral'>     * @param market The market on which the withdrawal will be executed.</span>
  91 |     | <span class='neutral'>     * @param minLongTokenAmount The minimum amount of long tokens that must be withdrawn.</span>
  92 |     | <span class='neutral'>     * @param minShortTokenAmount The minimum amount of short tokens that must be withdrawn.</span>
  93 |     | <span class='neutral'>     * @param shouldUnwrapNativeToken Whether the native token should be unwrapped when executing the withdrawal.</span>
  94 |     | <span class='neutral'>     * @param executionFee The execution fee for the withdrawal.</span>
  95 |     | <span class='neutral'>     * @param callbackGasLimit The gas limit for calling the callback contract.</span>
  96 |     | <span class='neutral'>     */</span>
  97 |     | <span class='neutral'>    struct CreateWithdrawalParams {</span>
  98 |     | <span class='neutral'>        address receiver;</span>
  99 |     | <span class='neutral'>        address callbackContract;</span>
 100 |     | <span class='neutral'>        address uiFeeReceiver;</span>
 101 |     | <span class='neutral'>        address market;</span>
 102 |     | <span class='neutral'>        address[] longTokenSwapPath;</span>
 103 |     | <span class='neutral'>        address[] shortTokenSwapPath;</span>
 104 |     | <span class='neutral'>        uint256 minLongTokenAmount;</span>
 105 |     | <span class='neutral'>        uint256 minShortTokenAmount;</span>
 106 |     | <span class='neutral'>        bool shouldUnwrapNativeToken;</span>
 107 |     | <span class='neutral'>        uint256 executionFee;</span>
 108 |     | <span class='neutral'>        uint256 callbackGasLimit;</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    // @dev there is a limit on the number of fields a struct can have when being passed</span>
 112 |     | <span class='neutral'>    // or returned as a memory variable which can cause &quot;Stack too deep&quot; errors</span>
 113 |     | <span class='neutral'>    // use sub-structs to avoid this issue</span>
 114 |     | <span class='neutral'>    // @param addresses address values</span>
 115 |     | <span class='neutral'>    // @param numbers number values</span>
 116 |     | <span class='neutral'>    // @param flags boolean values</span>
 117 |     | <span class='neutral'>    struct Props {</span>
 118 |     | <span class='neutral'>        Addresses addresses;</span>
 119 |     | <span class='neutral'>        Numbers numbers;</span>
 120 |     | <span class='neutral'>        Flags flags;</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    // @param account The account to withdraw for.</span>
 124 |     | <span class='neutral'>    // @param receiver The address that will receive the withdrawn tokens.</span>
 125 |     | <span class='neutral'>    // @param callbackContract The contract that will be called back.</span>
 126 |     | <span class='neutral'>    // @param uiFeeReceiver The ui fee receiver.</span>
 127 |     | <span class='neutral'>    // @param market The market on which the withdrawal will be executed.</span>
 128 |     | <span class='neutral'>    struct Addresses {</span>
 129 |     | <span class='neutral'>        address account;</span>
 130 |     | <span class='neutral'>        address receiver;</span>
 131 |     | <span class='neutral'>        address callbackContract;</span>
 132 |     | <span class='neutral'>        address uiFeeReceiver;</span>
 133 |     | <span class='neutral'>        address market;</span>
 134 |     | <span class='neutral'>        address[] longTokenSwapPath;</span>
 135 |     | <span class='neutral'>        address[] shortTokenSwapPath;</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    // @param marketTokenAmount The amount of market tokens that will be withdrawn.</span>
 139 |     | <span class='neutral'>    // @param minLongTokenAmount The minimum amount of long tokens that must be withdrawn.</span>
 140 |     | <span class='neutral'>    // @param minShortTokenAmount The minimum amount of short tokens that must be withdrawn.</span>
 141 |     | <span class='neutral'>    // @param updatedAtBlock The block at which the withdrawal was last updated.</span>
 142 |     | <span class='neutral'>    // @param executionFee The execution fee for the withdrawal.</span>
 143 |     | <span class='neutral'>    // @param callbackGasLimit The gas limit for calling the callback contract.</span>
 144 |     | <span class='neutral'>    struct Numbers {</span>
 145 |     | <span class='neutral'>        uint256 marketTokenAmount;</span>
 146 |     | <span class='neutral'>        uint256 minLongTokenAmount;</span>
 147 |     | <span class='neutral'>        uint256 minShortTokenAmount;</span>
 148 |     | <span class='neutral'>        uint256 updatedAtBlock;</span>
 149 |     | <span class='neutral'>        uint256 executionFee;</span>
 150 |     | <span class='neutral'>        uint256 callbackGasLimit;</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    // @param shouldUnwrapNativeToken whether to unwrap the native token when</span>
 154 |     | <span class='neutral'>    struct Flags {</span>
 155 |     | <span class='neutral'>        bool shouldUnwrapNativeToken;</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'>}</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>interface IGmxV2EventUtils {</span>
 160 |     | <span class='neutral'>    struct EmitPositionDecreaseParams {</span>
 161 |     | <span class='neutral'>        bytes32 key;</span>
 162 |     | <span class='neutral'>        address account;</span>
 163 |     | <span class='neutral'>        address market;</span>
 164 |     | <span class='neutral'>        address collateralToken;</span>
 165 |     | <span class='neutral'>        bool isLong;</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    struct EventLogData {</span>
 169 |     | <span class='neutral'>        AddressItems addressItems;</span>
 170 |     | <span class='neutral'>        UintItems uintItems;</span>
 171 |     | <span class='neutral'>        IntItems intItems;</span>
 172 |     | <span class='neutral'>        BoolItems boolItems;</span>
 173 |     | <span class='neutral'>        Bytes32Items bytes32Items;</span>
 174 |     | <span class='neutral'>        BytesItems bytesItems;</span>
 175 |     | <span class='neutral'>        StringItems stringItems;</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>    struct AddressItems {</span>
 179 |     | <span class='neutral'>        AddressKeyValue[] items;</span>
 180 |     | <span class='neutral'>        AddressArrayKeyValue[] arrayItems;</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    struct UintItems {</span>
 184 |     | <span class='neutral'>        UintKeyValue[] items;</span>
 185 |     | <span class='neutral'>        UintArrayKeyValue[] arrayItems;</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    struct IntItems {</span>
 189 |     | <span class='neutral'>        IntKeyValue[] items;</span>
 190 |     | <span class='neutral'>        IntArrayKeyValue[] arrayItems;</span>
 191 |     | <span class='neutral'>    }</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>    struct BoolItems {</span>
 194 |     | <span class='neutral'>        BoolKeyValue[] items;</span>
 195 |     | <span class='neutral'>        BoolArrayKeyValue[] arrayItems;</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    struct Bytes32Items {</span>
 199 |     | <span class='neutral'>        Bytes32KeyValue[] items;</span>
 200 |     | <span class='neutral'>        Bytes32ArrayKeyValue[] arrayItems;</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    struct BytesItems {</span>
 204 |     | <span class='neutral'>        BytesKeyValue[] items;</span>
 205 |     | <span class='neutral'>        BytesArrayKeyValue[] arrayItems;</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    struct StringItems {</span>
 209 |     | <span class='neutral'>        StringKeyValue[] items;</span>
 210 |     | <span class='neutral'>        StringArrayKeyValue[] arrayItems;</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    struct AddressKeyValue {</span>
 214 |     | <span class='neutral'>        string key;</span>
 215 |     | <span class='neutral'>        address value;</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    struct AddressArrayKeyValue {</span>
 219 |     | <span class='neutral'>        string key;</span>
 220 |     | <span class='neutral'>        address[] value;</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    struct UintKeyValue {</span>
 224 |     | <span class='neutral'>        string key;</span>
 225 |     | <span class='neutral'>        uint256 value;</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>    struct UintArrayKeyValue {</span>
 229 |     | <span class='neutral'>        string key;</span>
 230 |     | <span class='neutral'>        uint256[] value;</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>    struct IntKeyValue {</span>
 234 |     | <span class='neutral'>        string key;</span>
 235 |     | <span class='neutral'>        int256 value;</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>    struct IntArrayKeyValue {</span>
 239 |     | <span class='neutral'>        string key;</span>
 240 |     | <span class='neutral'>        int256[] value;</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    struct BoolKeyValue {</span>
 244 |     | <span class='neutral'>        string key;</span>
 245 |     | <span class='neutral'>        bool value;</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    struct BoolArrayKeyValue {</span>
 249 |     | <span class='neutral'>        string key;</span>
 250 |     | <span class='neutral'>        bool[] value;</span>
 251 |     | <span class='neutral'>    }</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='neutral'>    struct Bytes32KeyValue {</span>
 254 |     | <span class='neutral'>        string key;</span>
 255 |     | <span class='neutral'>        bytes32 value;</span>
 256 |     | <span class='neutral'>    }</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>    struct Bytes32ArrayKeyValue {</span>
 259 |     | <span class='neutral'>        string key;</span>
 260 |     | <span class='neutral'>        bytes32[] value;</span>
 261 |     | <span class='neutral'>    }</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>    struct BytesKeyValue {</span>
 264 |     | <span class='neutral'>        string key;</span>
 265 |     | <span class='neutral'>        bytes value;</span>
 266 |     | <span class='neutral'>    }</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>    struct BytesArrayKeyValue {</span>
 269 |     | <span class='neutral'>        string key;</span>
 270 |     | <span class='neutral'>        bytes[] value;</span>
 271 |     | <span class='neutral'>    }</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='neutral'>    struct StringKeyValue {</span>
 274 |     | <span class='neutral'>        string key;</span>
 275 |     | <span class='neutral'>        string value;</span>
 276 |     | <span class='neutral'>    }</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='neutral'>    struct StringArrayKeyValue {</span>
 279 |     | <span class='neutral'>        string key;</span>
 280 |     | <span class='neutral'>        string[] value;</span>
 281 |     | <span class='neutral'>    }</span>
 282 |     | <span class='neutral'>}</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>interface IGmxV2Market {</span>
 285 |     | <span class='neutral'>    // @param marketToken address of the market token for the market</span>
 286 |     | <span class='neutral'>    // @param indexToken address of the index token for the market</span>
 287 |     | <span class='neutral'>    // @param longToken address of the long token for the market</span>
 288 |     | <span class='neutral'>    // @param shortToken address of the short token for the market</span>
 289 |     | <span class='neutral'>    // @param data for any additional data</span>
 290 |     | <span class='neutral'>    struct Props {</span>
 291 |     | <span class='neutral'>        address marketToken;</span>
 292 |     | <span class='neutral'>        address indexToken;</span>
 293 |     | <span class='neutral'>        address longToken;</span>
 294 |     | <span class='neutral'>        address shortToken;</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'>}</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='neutral'>// @title Price</span>
 299 |     | <span class='neutral'>// @dev Struct for prices</span>
 300 |     | <span class='neutral'>interface IGmxV2Price {</span>
 301 |     | <span class='neutral'>    // @param min the min price</span>
 302 |     | <span class='neutral'>    // @param max the max price</span>
 303 |     | <span class='neutral'>    struct Props {</span>
 304 |     | <span class='neutral'>        uint256 min;</span>
 305 |     | <span class='neutral'>        uint256 max;</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'>}</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='neutral'>// @title MarketPoolInfo</span>
 310 |     | <span class='neutral'>interface IGmxV2MarketPoolValueInfo {</span>
 311 |     | <span class='neutral'>    // @dev struct to avoid stack too deep errors for the getPoolValue call</span>
 312 |     | <span class='neutral'>    // @param value the pool value</span>
 313 |     | <span class='neutral'>    // @param longTokenAmount the amount of long token in the pool</span>
 314 |     | <span class='neutral'>    // @param shortTokenAmount the amount of short token in the pool</span>
 315 |     | <span class='neutral'>    // @param longTokenUsd the USD value of the long tokens in the pool</span>
 316 |     | <span class='neutral'>    // @param shortTokenUsd the USD value of the short tokens in the pool</span>
 317 |     | <span class='neutral'>    // @param totalBorrowingFees the total pending borrowing fees for the market</span>
 318 |     | <span class='neutral'>    // @param borrowingFeePoolFactor the pool factor for borrowing fees</span>
 319 |     | <span class='neutral'>    // @param impactPoolAmount the amount of tokens in the impact pool</span>
 320 |     | <span class='neutral'>    // @param longPnl the pending pnl of long positions</span>
 321 |     | <span class='neutral'>    // @param shortPnl the pending pnl of short positions</span>
 322 |     | <span class='neutral'>    // @param netPnl the net pnl of long and short positions</span>
 323 |     | <span class='neutral'>    struct Props {</span>
 324 |     | <span class='neutral'>        int256 poolValue;</span>
 325 |     | <span class='neutral'>        int256 longPnl;</span>
 326 |     | <span class='neutral'>        int256 shortPnl;</span>
 327 |     | <span class='neutral'>        int256 netPnl;</span>
 328 |     | <span class='neutral'>        uint256 longTokenAmount;</span>
 329 |     | <span class='neutral'>        uint256 shortTokenAmount;</span>
 330 |     | <span class='neutral'>        uint256 longTokenUsd;</span>
 331 |     | <span class='neutral'>        uint256 shortTokenUsd;</span>
 332 |     | <span class='neutral'>        uint256 totalBorrowingFees;</span>
 333 |     | <span class='neutral'>        uint256 borrowingFeePoolFactor;</span>
 334 |     | <span class='neutral'>        uint256 impactPoolAmount;</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'>}</span>
 337 |     | <span class='neutral'></span>
 338 |     | <span class='neutral'>// @title IDepositCallbackReceiver</span>
 339 |     | <span class='neutral'>// @dev interface for a deposit callback contract</span>
 340 |     | <span class='neutral'>interface IGmxV2DepositCallbackReceiver {</span>
 341 |     | <span class='neutral'>    // @dev called after a deposit execution</span>
 342 |     | <span class='neutral'>    // @param key the key of the deposit</span>
 343 |     | <span class='neutral'>    // @param deposit the deposit that was executed</span>
 344 |     | <span class='neutral'>    function afterDepositExecution(</span>
 345 |     | <span class='neutral'>        bytes32 key,</span>
 346 |     | <span class='neutral'>        IGmxV2Deposit.Props memory deposit,</span>
 347 |     | <span class='neutral'>        IGmxV2EventUtils.EventLogData memory eventData</span>
 348 |     | <span class='neutral'>    ) external;</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>    // @dev called after a deposit cancellation</span>
 351 |     | <span class='neutral'>    // @param key the key of the deposit</span>
 352 |     | <span class='neutral'>    // @param deposit the deposit that was cancelled</span>
 353 |     | <span class='neutral'>    function afterDepositCancellation(</span>
 354 |     | <span class='neutral'>        bytes32 key,</span>
 355 |     | <span class='neutral'>        IGmxV2Deposit.Props memory deposit,</span>
 356 |     | <span class='neutral'>        IGmxV2EventUtils.EventLogData memory eventData</span>
 357 |     | <span class='neutral'>    ) external;</span>
 358 |     | <span class='neutral'>}</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='neutral'>// @title IWithdrawalCallbackReceiver</span>
 361 |     | <span class='neutral'>// @dev interface for a withdrawal callback contract</span>
 362 |     | <span class='neutral'>interface IGmxV2WithdrawalCallbackReceiver {</span>
 363 |     | <span class='neutral'>    // @dev called after a withdrawal execution</span>
 364 |     | <span class='neutral'>    // @param key the key of the withdrawal</span>
 365 |     | <span class='neutral'>    // @param withdrawal the withdrawal that was executed</span>
 366 |     | <span class='neutral'>    function afterWithdrawalExecution(</span>
 367 |     | <span class='neutral'>        bytes32 key,</span>
 368 |     | <span class='neutral'>        IGmxV2Withdrawal.Props memory withdrawal,</span>
 369 |     | <span class='neutral'>        IGmxV2EventUtils.EventLogData memory eventData</span>
 370 |     | <span class='neutral'>    ) external;</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>    // @dev called after a withdrawal cancellation</span>
 373 |     | <span class='neutral'>    // @param key the key of the withdrawal</span>
 374 |     | <span class='neutral'>    // @param withdrawal the withdrawal that was cancelled</span>
 375 |     | <span class='neutral'>    function afterWithdrawalCancellation(</span>
 376 |     | <span class='neutral'>        bytes32 key,</span>
 377 |     | <span class='neutral'>        IGmxV2Withdrawal.Props memory withdrawal,</span>
 378 |     | <span class='neutral'>        IGmxV2EventUtils.EventLogData memory eventData</span>
 379 |     | <span class='neutral'>    ) external;</span>
 380 |     | <span class='neutral'>}</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='neutral'>interface IGmxDataStore {</span>
 383 |     | <span class='neutral'>    function containsBytes32(bytes32 setKey, bytes32 value) external view returns (bool);</span>
 384 |     | <span class='neutral'></span>
 385 |     | <span class='neutral'>    function roleStore() external view returns (IGmxRoleStore);</span>
 386 |     | <span class='neutral'></span>
 387 |     | <span class='neutral'>    function getBool(bytes32 key) external view returns (bool);</span>
 388 |     | <span class='neutral'>}</span>
 389 |     | <span class='neutral'></span>
 390 |     | <span class='neutral'>interface IGmxRoleStore {</span>
 391 |     | <span class='neutral'>    function hasRole(address account, bytes32 roleKey) external view returns (bool);</span>
 392 |     | <span class='neutral'>}</span>
 393 |     | <span class='neutral'></span>
 394 |     | <span class='neutral'>interface IGmxReader {</span>
 395 |     | <span class='neutral'>    function getMarket(address dataStore, address key) external view returns (IGmxV2Market.Props memory);</span>
 396 |     | <span class='neutral'></span>
 397 |     | <span class='neutral'>    // @dev get the market token&#39;s price</span>
 398 |     | <span class='neutral'>    // @param dataStore DataStore</span>
 399 |     | <span class='neutral'>    // @param market the market to check</span>
 400 |     | <span class='neutral'>    // @param longTokenPrice the price of the long token</span>
 401 |     | <span class='neutral'>    // @param shortTokenPrice the price of the short token</span>
 402 |     | <span class='neutral'>    // @param indexTokenPrice the price of the index token</span>
 403 |     | <span class='neutral'>    // @param maximize whether to maximize or minimize the market token price</span>
 404 |     | <span class='neutral'>    // @return returns (the market token&#39;s price, MarketPoolValueInfo.Props)</span>
 405 |     | <span class='neutral'>    function getMarketTokenPrice(</span>
 406 |     | <span class='neutral'>        address dataStore,</span>
 407 |     | <span class='neutral'>        IGmxV2Market.Props memory market,</span>
 408 |     | <span class='neutral'>        IGmxV2Price.Props memory indexTokenPrice,</span>
 409 |     | <span class='neutral'>        IGmxV2Price.Props memory longTokenPrice,</span>
 410 |     | <span class='neutral'>        IGmxV2Price.Props memory shortTokenPrice,</span>
 411 |     | <span class='neutral'>        bytes32 pnlFactorType,</span>
 412 |     | <span class='neutral'>        bool maximize</span>
 413 |     | <span class='neutral'>    ) external view returns (int256, IGmxV2MarketPoolValueInfo.Props memory);</span>
 414 |     | <span class='neutral'>}</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>interface IGmxV2ExchangeRouter {</span>
 417 |     | <span class='neutral'>    function dataStore() external view returns (address);</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='neutral'>    function sendWnt(address receiver, uint256 amount) external payable;</span>
 420 |     | <span class='neutral'></span>
 421 |     | <span class='neutral'>    function sendTokens(address token, address receiver, uint256 amount) external payable;</span>
 422 |     | <span class='neutral'></span>
 423 |     | <span class='neutral'>    function depositHandler() external view returns (address);</span>
 424 |     | <span class='neutral'></span>
 425 |     | <span class='neutral'>    function withdrawalHandler() external view returns (address);</span>
 426 |     | <span class='neutral'></span>
 427 |     | <span class='neutral'>    function createDeposit(IGmxV2Deposit.CreateDepositParams calldata params) external payable returns (bytes32);</span>
 428 |     | <span class='neutral'></span>
 429 |     | <span class='neutral'>    function createWithdrawal(IGmxV2Withdrawal.CreateWithdrawalParams calldata params) external payable returns (bytes32);</span>
 430 |     | <span class='neutral'></span>
 431 |     | <span class='neutral'>    function cancelWithdrawal(bytes32 key) external payable;</span>
 432 |     | <span class='neutral'></span>
 433 |     | <span class='neutral'>    function cancelDeposit(bytes32 key) external payable;</span>
 434 |     | <span class='neutral'>}</span>
 435 |     | <span class='neutral'></span>
 436 |     | <span class='neutral'>interface IGmxV2DepositHandler {</span>
 437 |     | <span class='neutral'>    function depositVault() external view returns (address);</span>
 438 |     | <span class='neutral'></span>
 439 |     | <span class='neutral'>    function dataStore() external view returns (address);</span>
 440 |     | <span class='neutral'>}</span>
 441 |     | <span class='neutral'></span>
 442 |     | <span class='neutral'>interface IGmxV2WithdrawalHandler {</span>
 443 |     | <span class='neutral'>    function withdrawalVault() external view returns (address);</span>
 444 |     | <span class='neutral'>}</span>
 445 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ILPStaking.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>// solhint-disable func-name-mixedcase</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.7.0 &lt;0.9.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface ILPStaking {</span>
  6 |     | <span class='neutral'>    function BONUS_MULTIPLIER() external view returns (uint256);</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    function add(uint256 _allocPoint, address _lpToken) external;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function bonusEndBlock() external view returns (uint256);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function deposit(uint256 _pid, uint256 _amount) external;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function emergencyWithdraw(uint256 _pid) external;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function getMultiplier(uint256 _from, uint256 _to) external view returns (uint256);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function lpBalances(uint256) external view returns (uint256);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function massUpdatePools() external;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    function owner() external view returns (address);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    function pendingStargate(uint256 _pid, address _user) external view returns (uint256);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    function poolInfo(uint256)</span>
 27 |     | <span class='neutral'>        external</span>
 28 |     | <span class='neutral'>        view</span>
 29 |     | <span class='neutral'>        returns (</span>
 30 |     | <span class='neutral'>            address lpToken,</span>
 31 |     | <span class='neutral'>            uint256 allocPoint,</span>
 32 |     | <span class='neutral'>            uint256 lastRewardBlock,</span>
 33 |     | <span class='neutral'>            uint256 accStargatePerShare</span>
 34 |     | <span class='neutral'>        );</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    function poolLength() external view returns (uint256);</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    function renounceOwnership() external;</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    function set(uint256 _pid, uint256 _allocPoint) external;</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    function setStargatePerBlock(uint256 _stargatePerBlock) external;</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function stargate() external view returns (address);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function stargatePerBlock() external view returns (uint256);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    function startBlock() external view returns (uint256);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function totalAllocPoint() external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    function transferOwnership(address newOwner) external;</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    function updatePool(uint256 _pid) external;</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    function userInfo(uint256, address) external view returns (uint256 amount, uint256 rewardDebt);</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    function withdraw(uint256 _pid, uint256 _amount) external;</span>
 59 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ILayerZero.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC165} from &quot;openzeppelin-contracts/utils/introspection/IERC165.sol&quot;;</span>
   5 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>interface ILzCommonOFT is IERC165 {</span>
   8 |     | <span class='neutral'>    struct LzCallParams {</span>
   9 |     | <span class='neutral'>        address payable refundAddress;</span>
  10 |     | <span class='neutral'>        address zroPaymentAddress;</span>
  11 |     | <span class='neutral'>        bytes adapterParams;</span>
  12 |     | <span class='neutral'>    }</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    function estimateSendFee(</span>
  15 |     | <span class='neutral'>        uint16 _dstChainId,</span>
  16 |     | <span class='neutral'>        bytes32 _toAddress,</span>
  17 |     | <span class='neutral'>        uint _amount,</span>
  18 |     | <span class='neutral'>        bool _useZro,</span>
  19 |     | <span class='neutral'>        bytes calldata _adapterParams</span>
  20 |     | <span class='neutral'>    ) external view returns (uint nativeFee, uint zroFee);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    function estimateSendAndCallFee(</span>
  23 |     | <span class='neutral'>        uint16 _dstChainId,</span>
  24 |     | <span class='neutral'>        bytes32 _toAddress,</span>
  25 |     | <span class='neutral'>        uint _amount,</span>
  26 |     | <span class='neutral'>        bytes calldata _payload,</span>
  27 |     | <span class='neutral'>        uint64 _dstGasForCall,</span>
  28 |     | <span class='neutral'>        bool _useZro,</span>
  29 |     | <span class='neutral'>        bytes calldata _adapterParams</span>
  30 |     | <span class='neutral'>    ) external view returns (uint nativeFee, uint zroFee);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    function circulatingSupply() external view returns (uint);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    function token() external view returns (address);</span>
  35 |     | <span class='neutral'>}</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>interface ILzUserApplicationConfig {</span>
  38 |     | <span class='neutral'>    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function setSendVersion(uint16 _version) external;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    function setReceiveVersion(uint16 _version) external;</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;</span>
  45 |     | <span class='neutral'>}</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>interface ILzEndpoint is ILzUserApplicationConfig {</span>
  48 |     | <span class='neutral'>    function defaultSendLibrary() external view returns (address);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    function send(</span>
  51 |     | <span class='neutral'>        uint16 _dstChainId,</span>
  52 |     | <span class='neutral'>        bytes calldata _destination,</span>
  53 |     | <span class='neutral'>        bytes calldata _payload,</span>
  54 |     | <span class='neutral'>        address payable _refundAddress,</span>
  55 |     | <span class='neutral'>        address _zroPaymentAddress,</span>
  56 |     | <span class='neutral'>        bytes calldata _adapterParams</span>
  57 |     | <span class='neutral'>    ) external payable;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    function receivePayload(</span>
  60 |     | <span class='neutral'>        uint16 _srcChainId,</span>
  61 |     | <span class='neutral'>        bytes calldata _srcAddress,</span>
  62 |     | <span class='neutral'>        address _dstAddress,</span>
  63 |     | <span class='neutral'>        uint64 _nonce,</span>
  64 |     | <span class='neutral'>        uint _gasLimit,</span>
  65 |     | <span class='neutral'>        bytes calldata _payload</span>
  66 |     | <span class='neutral'>    ) external;</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function estimateFees(</span>
  73 |     | <span class='neutral'>        uint16 _dstChainId,</span>
  74 |     | <span class='neutral'>        address _userApplication,</span>
  75 |     | <span class='neutral'>        bytes calldata _payload,</span>
  76 |     | <span class='neutral'>        bool _payInZRO,</span>
  77 |     | <span class='neutral'>        bytes calldata _adapterParam</span>
  78 |     | <span class='neutral'>    ) external view returns (uint nativeFee, uint zroFee);</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    function getChainId() external view returns (uint16);</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function getSendLibraryAddress(address _userApplication) external view returns (address);</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function getReceiveLibraryAddress(address _userApplication) external view returns (address);</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    function isSendingPayload() external view returns (bool);</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function isReceivingPayload() external view returns (bool);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function getSendVersion(address _userApplication) external view returns (uint16);</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    function getReceiveVersion(address _userApplication) external view returns (uint16);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    function defaultSendVersion() external view returns (uint16);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    function defaultReceiveVersion() external view returns (uint16);</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    function defaultReceiveLibraryAddress() external view returns (address);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    function uaConfigLookup(</span>
 107 |     | <span class='neutral'>        address _address</span>
 108 |     | <span class='neutral'>    ) external view returns (uint16 sendVersion, uint16 receiveVersion, address receiveLibraryAddress, address sendLibrary);</span>
 109 |     | <span class='neutral'>}</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>interface ILzBaseOFTV2 {</span>
 112 |     | <span class='neutral'>    function sharedDecimals() external view returns (uint8);</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function innerToken() external view returns (address);</span>
 115 |     | <span class='neutral'>}</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>interface ILzApp {</span>
 118 |     | <span class='neutral'>    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    function minDstGasLookup(uint16 _srcChainId, uint16 _dstChainId) external view returns (uint);</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external;</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    function trustedRemoteLookup(uint16 _srcChainId) external view returns (bytes memory);</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    function lzEndpoint() external view returns (ILzEndpoint);</span>
 129 |     | <span class='neutral'>}</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>interface ILzFeeHandler {</span>
 132 |     | <span class='neutral'>    enum QuoteType {</span>
 133 |     | <span class='neutral'>        None,</span>
 134 |     | <span class='neutral'>        Oracle,</span>
 135 |     | <span class='neutral'>        Fixed</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    function getFee() external view returns (uint256);</span>
 139 |     | <span class='neutral'>}</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>interface ILzOFTV2 is ILzCommonOFT {</span>
 142 |     | <span class='neutral'>    function sendFrom(</span>
 143 |     | <span class='neutral'>        address _from,</span>
 144 |     | <span class='neutral'>        uint16 _dstChainId,</span>
 145 |     | <span class='neutral'>        bytes32 _toAddress,</span>
 146 |     | <span class='neutral'>        uint _amount,</span>
 147 |     | <span class='neutral'>        LzCallParams calldata _callParams</span>
 148 |     | <span class='neutral'>    ) external payable;</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    function sendAndCall(</span>
 151 |     | <span class='neutral'>        address _from,</span>
 152 |     | <span class='neutral'>        uint16 _dstChainId,</span>
 153 |     | <span class='neutral'>        bytes32 _toAddress,</span>
 154 |     | <span class='neutral'>        uint _amount,</span>
 155 |     | <span class='neutral'>        bytes calldata _payload,</span>
 156 |     | <span class='neutral'>        uint64 _dstGasForCall,</span>
 157 |     | <span class='neutral'>        LzCallParams calldata _callParams</span>
 158 |     | <span class='neutral'>    ) external payable;</span>
 159 |     | <span class='neutral'>}</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>interface ILzOFTReceiverV2 {</span>
 162 |     | <span class='neutral'>    function onOFTReceived(</span>
 163 |     | <span class='neutral'>        uint16 _srcChainId,</span>
 164 |     | <span class='neutral'>        bytes calldata _srcAddress,</span>
 165 |     | <span class='neutral'>        uint64 _nonce,</span>
 166 |     | <span class='neutral'>        bytes32 _from,</span>
 167 |     | <span class='neutral'>        uint _amount,</span>
 168 |     | <span class='neutral'>        bytes calldata _payload</span>
 169 |     | <span class='neutral'>    ) external;</span>
 170 |     | <span class='neutral'>}</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>interface ILzUltraLightNodeV2 {</span>
 173 |     | <span class='neutral'>    function defaultAppConfig(</span>
 174 |     | <span class='neutral'>        uint16</span>
 175 |     | <span class='neutral'>    )</span>
 176 |     | <span class='neutral'>        external</span>
 177 |     | <span class='neutral'>        view</span>
 178 |     | <span class='neutral'>        returns (</span>
 179 |     | <span class='neutral'>            uint16 inboundProofLibraryVersion,</span>
 180 |     | <span class='neutral'>            uint64 inboundBlockConfirmations,</span>
 181 |     | <span class='neutral'>            address relayer,</span>
 182 |     | <span class='neutral'>            uint16 outboundProofType,</span>
 183 |     | <span class='neutral'>            uint64 outboundBlockConfirmations,</span>
 184 |     | <span class='neutral'>            address oracle</span>
 185 |     | <span class='neutral'>        );</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    function appConfig(</span>
 188 |     | <span class='neutral'>        address,</span>
 189 |     | <span class='neutral'>        uint16</span>
 190 |     | <span class='neutral'>    )</span>
 191 |     | <span class='neutral'>        external</span>
 192 |     | <span class='neutral'>        view</span>
 193 |     | <span class='neutral'>        returns (</span>
 194 |     | <span class='neutral'>            uint16 inboundProofLibraryVersion,</span>
 195 |     | <span class='neutral'>            uint64 inboundBlockConfirmations,</span>
 196 |     | <span class='neutral'>            address relayer,</span>
 197 |     | <span class='neutral'>            uint16 outboundProofType,</span>
 198 |     | <span class='neutral'>            uint64 outboundBlockConfirmations,</span>
 199 |     | <span class='neutral'>            address oracle</span>
 200 |     | <span class='neutral'>        );</span>
 201 |     | <span class='neutral'>}</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>interface ILzReceiver {</span>
 204 |     | <span class='neutral'>    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;</span>
 205 |     | <span class='neutral'>}</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>interface IOFTV2View {</span>
 208 |     | <span class='neutral'>    function lzReceive(uint16 _srcChainId, bytes32 _scrAddress, bytes memory _payload, uint _totalSupply) external view returns (uint);</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>    function getInboundNonce(uint16 _srcChainId) external view returns (uint64);</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    function getCurrentState() external view returns (uint);</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    function isProxy() external view returns (bool);</span>
 215 |     | <span class='neutral'>}</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>interface IOFTWrapper {</span>
 218 |     | <span class='neutral'>    event LogWrapperFeeWithdrawn(address to, uint256 amount);</span>
 219 |     | <span class='neutral'>    event LogDefaultExchangeRateChanged(uint256 oldExchangeRate, uint256 newExchangeRate);</span>
 220 |     | <span class='neutral'>    event LogOracleImplementationChange(IAggregator indexed oldOracle, IAggregator indexed newOracle);</span>
 221 |     | <span class='neutral'>    event LogDefaultQuoteTypeChanged(QUOTE_TYPE oldValue, QUOTE_TYPE newValue);</span>
 222 |     | <span class='neutral'>    event LogFeeToChange(address indexed oldAddress, address indexed newAddress);</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    enum QUOTE_TYPE {</span>
 225 |     | <span class='neutral'>        ORACLE,</span>
 226 |     | <span class='neutral'>        FIXED_EXCHANGE_RATE</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    function sendOFTV2(</span>
 230 |     | <span class='neutral'>        uint16 _dstChainId,</span>
 231 |     | <span class='neutral'>        bytes32 _toAddress,</span>
 232 |     | <span class='neutral'>        uint _amount,</span>
 233 |     | <span class='neutral'>        ILzCommonOFT.LzCallParams calldata _callParams</span>
 234 |     | <span class='neutral'>    ) external payable;</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>    function sendProxyOFTV2(</span>
 237 |     | <span class='neutral'>        uint16 _dstChainId,</span>
 238 |     | <span class='neutral'>        bytes32 _toAddress,</span>
 239 |     | <span class='neutral'>        uint _amount,</span>
 240 |     | <span class='neutral'>        ILzCommonOFT.LzCallParams calldata _callParams</span>
 241 |     | <span class='neutral'>    ) external payable;</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    function estimateSendFeeV2(</span>
 244 |     | <span class='neutral'>        uint16 _dstChainId,</span>
 245 |     | <span class='neutral'>        bytes32 _toAddress,</span>
 246 |     | <span class='neutral'>        uint _amount,</span>
 247 |     | <span class='neutral'>        bytes calldata _adapterParams</span>
 248 |     | <span class='neutral'>    ) external view returns (uint nativeFee, uint zroFee);</span>
 249 |     | <span class='neutral'>}</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>interface IPreCrimeView {</span>
 252 |     | <span class='neutral'>    struct Packet {</span>
 253 |     | <span class='neutral'>        uint16 srcChainId;</span>
 254 |     | <span class='neutral'>        bytes32 srcAddress;</span>
 255 |     | <span class='neutral'>        uint64 nonce;</span>
 256 |     | <span class='neutral'>        bytes payload;</span>
 257 |     | <span class='neutral'>    }</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='neutral'>    struct SimulationResult {</span>
 260 |     | <span class='neutral'>        uint chainTotalSupply;</span>
 261 |     | <span class='neutral'>        bool isProxy;</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>    function getConfig(Packet[] calldata _packets) external view returns (bytes memory);</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    function precrime(Packet[] calldata _packets, bytes[] calldata _simulation) external view returns (uint16 code, bytes memory reason);</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>    function version() external view returns (uint16);</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>    function simulate(Packet[] calldata _packets) external view returns (uint16 code, bytes memory result);</span>
 271 |     | <span class='neutral'>}</span>
 272 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ILevSwapperV2.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface ILevSwapperV2 {</span>
  5 |     | <span class='neutral'>    function swap(</span>
  6 |     | <span class='neutral'>        address recipient,</span>
  7 |     | <span class='neutral'>        uint256 shareToMin,</span>
  8 |     | <span class='neutral'>        uint256 shareFrom,</span>
  9 |     | <span class='neutral'>        bytes calldata data</span>
 10 |     | <span class='neutral'>    ) external returns (uint256 extraShare, uint256 shareReturned);</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IMSpell.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>interface IMSpell {</span>
 5 |     | <span class='neutral'>    function updateReward() external;</span>
 6 |     | <span class='neutral'>}</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IMagicCurveLpRewardHandler.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ICurveRewardGauge} from &quot;interfaces/ICurveRewardGauge.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IMagicCurveLpRewardHandler {</span>
  8 |     | <span class='neutral'>    function harvest(address to) external;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function distributeRewards(uint256 amount) external;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function stakeAsset(uint256 amount) external;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function unstakeAsset(uint256 amount) external;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function skimAssets() external returns (uint256, uint256);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function staking() external view returns (ICurveRewardGauge staking);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function setStaking(ICurveRewardGauge staking) external;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    function isPrivateDelegateFunction(bytes4 sig) external view returns (bool);</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IMagicGlpRewardHandler.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IGmxRewardRouterV2} from &quot;interfaces/IGmxV1.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IMagicGlpRewardHandler {</span>
  8 |     | <span class='neutral'>    function harvest() external;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function setRewardRouter(IGmxRewardRouterV2 _rewardRouter) external;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function distributeRewards(uint256 amount) external;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function skimAssets() external returns (uint256);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function unstakeGmx(</span>
 17 |     | <span class='neutral'>        uint256 amount,</span>
 18 |     | <span class='neutral'>        uint256 amountToTransferToSender,</span>
 19 |     | <span class='neutral'>        address recipient</span>
 20 |     | <span class='neutral'>    ) external;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    function unstakeEsGmxAndVest(</span>
 23 |     | <span class='neutral'>        uint256 amount,</span>
 24 |     | <span class='neutral'>        uint256 glpVesterDepositAmount,</span>
 25 |     | <span class='neutral'>        uint256 gmxVesterDepositAmount</span>
 26 |     | <span class='neutral'>    ) external;</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    function withdrawFromVesting(</span>
 29 |     | <span class='neutral'>        bool withdrawFromGlpVester,</span>
 30 |     | <span class='neutral'>        bool withdrawFromGmxVester,</span>
 31 |     | <span class='neutral'>        bool stake</span>
 32 |     | <span class='neutral'>    ) external;</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    function claimVestedGmx(</span>
 35 |     | <span class='neutral'>        bool withdrawFromGlpVester,</span>
 36 |     | <span class='neutral'>        bool withdrawFromGmxVester,</span>
 37 |     | <span class='neutral'>        bool stake,</span>
 38 |     | <span class='neutral'>        bool transferToFeeCollecter</span>
 39 |     | <span class='neutral'>    ) external;</span>
 40 |     | <span class='neutral'>}</span>
 41 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IMintableBurnable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IMintableBurnable {</span>
  5 |     | <span class='neutral'>    function burn(address from, uint256 amount) external returns (bool);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function mint(address to, uint256 amount) external returns (bool);</span>
  8 |     | <span class='neutral'>}</span>
  9 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IMultiRewardsStaking.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IMultiRewardsStaking {</span>
  5 |     | <span class='neutral'>    struct Reward {</span>
  6 |     | <span class='neutral'>        uint256 rewardsDuration;</span>
  7 |     | <span class='neutral'>        uint256 periodFinish;</span>
  8 |     | <span class='neutral'>        uint256 rewardRate;</span>
  9 |     | <span class='neutral'>        uint256 lastUpdateTime;</span>
 10 |     | <span class='neutral'>        uint256 rewardPerTokenStored;</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function addReward(address rewardToken, uint256 _rewardsDuration) external;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function balanceOf(address user) external view returns (uint256 amount);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function earned(address user, address rewardToken) external view returns (uint256);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function exit() external;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function getRewardForDuration(address rewardToken) external view returns (uint256);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function getRewards() external;</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function lastTimeRewardApplicable(address rewardToken) external view returns (uint256);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function notifyRewardAmount(address rewardToken, uint256 amount) external;</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function operators(address) external view returns (bool);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function owner() external view returns (address);</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    function pause() external;</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function paused() external view returns (bool);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function recover(address tokenAddress, uint256 tokenAmount) external;</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    function rewardData(address token) external view returns (Reward memory);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    function rewardPerToken(address rewardToken) external view returns (uint256);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    function rewardTokens(uint256) external view returns (address);</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    function rewards(address user, address token) external view returns (uint256 amount);</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    function setOperator(address operator, bool status) external;</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    function setRewardsDuration(address rewardToken, uint256 _rewardsDuration) external;</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    function stake(uint256 amount) external;</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    function stakingToken() external view returns (address);</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    function transferOwnership(address newOwner) external;</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    function unpause() external;</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='neutral'>    function userRewardPerTokenPaid(address user, address token) external view returns (uint256 amount);</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='neutral'>    function getRewardTokenLength() external view returns (uint256);</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='neutral'>    function isSupportedReward(address rewardToken) external view returns (bool);</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='neutral'>    function withdraw(uint256 amount) external;</span>
 68 |     | <span class='neutral'>}</span>
 69 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IOracle {</span>
  5 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function get(bytes calldata data) external returns (bool success, uint256 rate);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function peek(bytes calldata data) external view returns (bool success, uint256 rate);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function peekSpot(bytes calldata data) external view returns (uint256 rate);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function symbol(bytes calldata data) external view returns (string memory);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function name(bytes calldata data) external view returns (string memory);</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IStargate.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>// solhint-disable func-name-mixedcase</span>
   3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>interface IStargateLPStaking {</span>
   6 |     | <span class='neutral'>    function deposit(uint256 _pid, uint256 _amount) external;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>    function emergencyWithdraw(uint256 _pid) external;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>    function poolInfo(uint256) external view returns (address lpToken, uint256 allocPoint, uint256 lastReward, uint256 accEmissionPerShare);</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    function userInfo(uint256, address) external view returns (uint256 amount, uint256 rewardDebt);</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    function withdraw(uint256 _pid, uint256 _amount) external;</span>
  15 |     | <span class='neutral'>}</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>interface IStargatePool {</span>
  18 |     | <span class='neutral'>    function deltaCredit() external view returns (uint256);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    function totalLiquidity() external view returns (uint256);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    function decimals() external view returns (uint256);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    function poolId() external view returns (uint256);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function localDecimals() external view returns (uint256);</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    function token() external view returns (address);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    function approve(address spender, uint256 value) external returns (bool);</span>
  35 |     | <span class='neutral'>}</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>interface IStargateRouter {</span>
  38 |     | <span class='neutral'>    struct lzTxObj {</span>
  39 |     | <span class='neutral'>        uint256 dstGasForCall;</span>
  40 |     | <span class='neutral'>        uint256 dstNativeAmount;</span>
  41 |     | <span class='neutral'>        bytes dstNativeAddr;</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function addLiquidity(uint256 _poolId, uint256 _amountLD, address _to) external;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    function swap(</span>
  47 |     | <span class='neutral'>        uint16 _dstChainId,</span>
  48 |     | <span class='neutral'>        uint256 _srcPoolId,</span>
  49 |     | <span class='neutral'>        uint256 _dstPoolId,</span>
  50 |     | <span class='neutral'>        address payable _refundAddress,</span>
  51 |     | <span class='neutral'>        uint256 _amountLD,</span>
  52 |     | <span class='neutral'>        uint256 _minAmountLD,</span>
  53 |     | <span class='neutral'>        lzTxObj memory _lzTxParams,</span>
  54 |     | <span class='neutral'>        bytes calldata _to,</span>
  55 |     | <span class='neutral'>        bytes calldata _payload</span>
  56 |     | <span class='neutral'>    ) external payable;</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    function redeemRemote(</span>
  59 |     | <span class='neutral'>        uint16 _dstChainId,</span>
  60 |     | <span class='neutral'>        uint256 _srcPoolId,</span>
  61 |     | <span class='neutral'>        uint256 _dstPoolId,</span>
  62 |     | <span class='neutral'>        address payable _refundAddress,</span>
  63 |     | <span class='neutral'>        uint256 _amountLP,</span>
  64 |     | <span class='neutral'>        uint256 _minAmountLD,</span>
  65 |     | <span class='neutral'>        bytes calldata _to,</span>
  66 |     | <span class='neutral'>        lzTxObj memory _lzTxParams</span>
  67 |     | <span class='neutral'>    ) external payable;</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    function instantRedeemLocal(uint16 _srcPoolId, uint256 _amountLP, address _to) external returns (uint256);</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    function redeemLocal(</span>
  72 |     | <span class='neutral'>        uint16 _dstChainId,</span>
  73 |     | <span class='neutral'>        uint256 _srcPoolId,</span>
  74 |     | <span class='neutral'>        uint256 _dstPoolId,</span>
  75 |     | <span class='neutral'>        address payable _refundAddress,</span>
  76 |     | <span class='neutral'>        uint256 _amountLP,</span>
  77 |     | <span class='neutral'>        bytes calldata _to,</span>
  78 |     | <span class='neutral'>        lzTxObj memory _lzTxParams</span>
  79 |     | <span class='neutral'>    ) external payable;</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    function sendCredits(uint16 _dstChainId, uint256 _srcPoolId, uint256 _dstPoolId, address payable _refundAddress) external payable;</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    function quoteLayerZeroFee(</span>
  84 |     | <span class='neutral'>        uint16 _dstChainId,</span>
  85 |     | <span class='neutral'>        uint8 _functionType,</span>
  86 |     | <span class='neutral'>        bytes calldata _toAddress,</span>
  87 |     | <span class='neutral'>        bytes calldata _transferAndCallPayload,</span>
  88 |     | <span class='neutral'>        lzTxObj memory _lzTxParams</span>
  89 |     | <span class='neutral'>    ) external view returns (uint256, uint256);</span>
  90 |     | <span class='neutral'>}</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>interface IStargateToken {</span>
  93 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    function chainId() external view returns (uint16);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    function dstContractLookup(uint16) external view returns (bytes memory);</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function endpoint() external view returns (address);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    function estimateSendTokensFee(</span>
 110 |     | <span class='neutral'>        uint16 _dstChainId,</span>
 111 |     | <span class='neutral'>        bool _useZro,</span>
 112 |     | <span class='neutral'>        bytes memory txParameters</span>
 113 |     | <span class='neutral'>    ) external view returns (uint256 nativeFee, uint256 zroFee);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    function forceResumeReceive(uint16 _srcChainId, bytes memory _srcAddress) external;</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    function isMain() external view returns (bool);</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    function lzReceive(uint16 _srcChainId, bytes memory _fromAddress, uint64 nonce, bytes memory _payload) external;</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    function owner() external view returns (address);</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function pauseSendTokens(bool _pause) external;</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    function paused() external view returns (bool);</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    function renounceOwnership() external;</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    function sendTokens(</span>
 134 |     | <span class='neutral'>        uint16 _dstChainId,</span>
 135 |     | <span class='neutral'>        bytes memory _to,</span>
 136 |     | <span class='neutral'>        uint256 _qty,</span>
 137 |     | <span class='neutral'>        address zroPaymentAddress,</span>
 138 |     | <span class='neutral'>        bytes memory adapterParam</span>
 139 |     | <span class='neutral'>    ) external payable;</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>    function setConfig(uint16 _version, uint16 _chainId, uint256 _configType, bytes memory _config) external;</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    function setDestination(uint16 _dstChainId, bytes memory _destinationContractAddress) external;</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>    function setReceiveVersion(uint16 version) external;</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    function setSendVersion(uint16 version) external;</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    function transfer(address recipient, uint256 amount) external returns (bool);</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    function transferOwnership(address newOwner) external;</span>
 158 |     | <span class='neutral'>}</span>
 159 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IStrategy.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IStrategy {</span>
  5 |     | <span class='neutral'>    function skim(uint256 amount) external;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function withdraw(uint256 amount) external returns (uint256 actualAmount);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function exit(uint256 balance) external returns (int256 amountAdded);</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ISwapperV1.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface ISwapperV1 {</span>
  5 |     | <span class='neutral'>    function swap(</span>
  6 |     | <span class='neutral'>        address fromToken,</span>
  7 |     | <span class='neutral'>        address toToken,</span>
  8 |     | <span class='neutral'>        address recipient,</span>
  9 |     | <span class='neutral'>        uint256 shareToMin,</span>
 10 |     | <span class='neutral'>        uint256 shareFrom</span>
 11 |     | <span class='neutral'>    ) external returns (uint256 extraShare, uint256 shareReturned);</span>
 12 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ISwapperV2.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface ISwapperV2 {</span>
  5 |     | <span class='neutral'>    function swap(</span>
  6 |     | <span class='neutral'>        address fromToken,</span>
  7 |     | <span class='neutral'>        address toToken,</span>
  8 |     | <span class='neutral'>        address recipient,</span>
  9 |     | <span class='neutral'>        uint256 shareToMin,</span>
 10 |     | <span class='neutral'>        uint256 shareFrom,</span>
 11 |     | <span class='neutral'>        bytes calldata data</span>
 12 |     | <span class='neutral'>    ) external returns (uint256 extraShare, uint256 shareReturned);</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IUmbrellaFeeds.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IUmbrellaFeeds {</span>
  5 |     | <span class='neutral'>    struct PriceData {</span>
  6 |     | <span class='neutral'>        uint8 data;</span>
  7 |     | <span class='neutral'>        uint24 heartbeat;</span>
  8 |     | <span class='neutral'>        uint32 timestamp;</span>
  9 |     | <span class='neutral'>        uint128 price;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function DECIMALS() external view returns (uint8);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function getChainId() external view returns (uint256 id);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function getManyPriceData(bytes32[] memory _keys) external view returns (PriceData[] memory data);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function getManyPriceDataRaw(bytes32[] memory _keys) external view returns (PriceData[] memory data);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function getName() external pure returns (bytes32);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    function getPrice(bytes32 _key) external view returns (uint128 price);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    function getPriceData(bytes32 _key) external view returns (PriceData memory data);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    function getPriceDataByName(string memory _name) external view returns (PriceData memory data);</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IUniswapV2.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>interface IUniswapV2Pair {</span>
   5 |     | <span class='neutral'>    function name() external pure returns (string memory);</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>    function symbol() external pure returns (string memory);</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    function balanceOf(address owner) external view returns (uint256);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    function approve(address spender, uint256 value) external returns (bool);</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    function transfer(address to, uint256 value) external returns (bool);</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    function mint(address to) external returns (uint256 liquidity);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    function burn(address to) external returns (uint256 amount0, uint256 amount1);</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    function skim(address to) external;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    function sync() external;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 value) external returns (bool);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    function token0() external pure returns (address);</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    function token1() external pure returns (address);</span>
  38 |     | <span class='neutral'>}</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>interface IUniswapV2Router01 {</span>
  41 |     | <span class='neutral'>    function factory() external pure returns (address);</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    function WETH() external pure returns (address);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    function addLiquidity(</span>
  46 |     | <span class='neutral'>        address tokenA,</span>
  47 |     | <span class='neutral'>        address tokenB,</span>
  48 |     | <span class='neutral'>        uint amountADesired,</span>
  49 |     | <span class='neutral'>        uint amountBDesired,</span>
  50 |     | <span class='neutral'>        uint amountAMin,</span>
  51 |     | <span class='neutral'>        uint amountBMin,</span>
  52 |     | <span class='neutral'>        address to,</span>
  53 |     | <span class='neutral'>        uint deadline</span>
  54 |     | <span class='neutral'>    ) external returns (uint amountA, uint amountB, uint liquidity);</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function addLiquidityETH(</span>
  57 |     | <span class='neutral'>        address token,</span>
  58 |     | <span class='neutral'>        uint amountTokenDesired,</span>
  59 |     | <span class='neutral'>        uint amountTokenMin,</span>
  60 |     | <span class='neutral'>        uint amountETHMin,</span>
  61 |     | <span class='neutral'>        address to,</span>
  62 |     | <span class='neutral'>        uint deadline</span>
  63 |     | <span class='neutral'>    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    function removeLiquidity(</span>
  66 |     | <span class='neutral'>        address tokenA,</span>
  67 |     | <span class='neutral'>        address tokenB,</span>
  68 |     | <span class='neutral'>        uint liquidity,</span>
  69 |     | <span class='neutral'>        uint amountAMin,</span>
  70 |     | <span class='neutral'>        uint amountBMin,</span>
  71 |     | <span class='neutral'>        address to,</span>
  72 |     | <span class='neutral'>        uint deadline</span>
  73 |     | <span class='neutral'>    ) external returns (uint amountA, uint amountB);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    function removeLiquidityETH(</span>
  76 |     | <span class='neutral'>        address token,</span>
  77 |     | <span class='neutral'>        uint liquidity,</span>
  78 |     | <span class='neutral'>        uint amountTokenMin,</span>
  79 |     | <span class='neutral'>        uint amountETHMin,</span>
  80 |     | <span class='neutral'>        address to,</span>
  81 |     | <span class='neutral'>        uint deadline</span>
  82 |     | <span class='neutral'>    ) external returns (uint amountToken, uint amountETH);</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    function removeLiquidityWithPermit(</span>
  85 |     | <span class='neutral'>        address tokenA,</span>
  86 |     | <span class='neutral'>        address tokenB,</span>
  87 |     | <span class='neutral'>        uint liquidity,</span>
  88 |     | <span class='neutral'>        uint amountAMin,</span>
  89 |     | <span class='neutral'>        uint amountBMin,</span>
  90 |     | <span class='neutral'>        address to,</span>
  91 |     | <span class='neutral'>        uint deadline,</span>
  92 |     | <span class='neutral'>        bool approveMax,</span>
  93 |     | <span class='neutral'>        uint8 v,</span>
  94 |     | <span class='neutral'>        bytes32 r,</span>
  95 |     | <span class='neutral'>        bytes32 s</span>
  96 |     | <span class='neutral'>    ) external returns (uint amountA, uint amountB);</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    function removeLiquidityETHWithPermit(</span>
  99 |     | <span class='neutral'>        address token,</span>
 100 |     | <span class='neutral'>        uint liquidity,</span>
 101 |     | <span class='neutral'>        uint amountTokenMin,</span>
 102 |     | <span class='neutral'>        uint amountETHMin,</span>
 103 |     | <span class='neutral'>        address to,</span>
 104 |     | <span class='neutral'>        uint deadline,</span>
 105 |     | <span class='neutral'>        bool approveMax,</span>
 106 |     | <span class='neutral'>        uint8 v,</span>
 107 |     | <span class='neutral'>        bytes32 r,</span>
 108 |     | <span class='neutral'>        bytes32 s</span>
 109 |     | <span class='neutral'>    ) external returns (uint amountToken, uint amountETH);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    function swapExactTokensForTokens(</span>
 112 |     | <span class='neutral'>        uint amountIn,</span>
 113 |     | <span class='neutral'>        uint amountOutMin,</span>
 114 |     | <span class='neutral'>        address[] calldata path,</span>
 115 |     | <span class='neutral'>        address to,</span>
 116 |     | <span class='neutral'>        uint deadline</span>
 117 |     | <span class='neutral'>    ) external returns (uint[] memory amounts);</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    function swapTokensForExactTokens(</span>
 120 |     | <span class='neutral'>        uint amountOut,</span>
 121 |     | <span class='neutral'>        uint amountInMax,</span>
 122 |     | <span class='neutral'>        address[] calldata path,</span>
 123 |     | <span class='neutral'>        address to,</span>
 124 |     | <span class='neutral'>        uint deadline</span>
 125 |     | <span class='neutral'>    ) external returns (uint[] memory amounts);</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function swapExactETHForTokens(</span>
 128 |     | <span class='neutral'>        uint amountOutMin,</span>
 129 |     | <span class='neutral'>        address[] calldata path,</span>
 130 |     | <span class='neutral'>        address to,</span>
 131 |     | <span class='neutral'>        uint deadline</span>
 132 |     | <span class='neutral'>    ) external payable returns (uint[] memory amounts);</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    function swapTokensForExactETH(</span>
 135 |     | <span class='neutral'>        uint amountOut,</span>
 136 |     | <span class='neutral'>        uint amountInMax,</span>
 137 |     | <span class='neutral'>        address[] calldata path,</span>
 138 |     | <span class='neutral'>        address to,</span>
 139 |     | <span class='neutral'>        uint deadline</span>
 140 |     | <span class='neutral'>    ) external returns (uint[] memory amounts);</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    function swapExactTokensForETH(</span>
 143 |     | <span class='neutral'>        uint amountIn,</span>
 144 |     | <span class='neutral'>        uint amountOutMin,</span>
 145 |     | <span class='neutral'>        address[] calldata path,</span>
 146 |     | <span class='neutral'>        address to,</span>
 147 |     | <span class='neutral'>        uint deadline</span>
 148 |     | <span class='neutral'>    ) external returns (uint[] memory amounts);</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    function swapETHForExactTokens(</span>
 151 |     | <span class='neutral'>        uint amountOut,</span>
 152 |     | <span class='neutral'>        address[] calldata path,</span>
 153 |     | <span class='neutral'>        address to,</span>
 154 |     | <span class='neutral'>        uint deadline</span>
 155 |     | <span class='neutral'>    ) external payable returns (uint[] memory amounts);</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);</span>
 166 |     | <span class='neutral'>}</span>
 167 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IVaultHarvester.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity &gt;=0.8.10;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>interface IVaultHarvester {</span>
 5 |     | <span class='neutral'>    function harvest(address recipient) external;</span>
 6 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IWETH.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IWETH is IERC20 {</span>
  7 |     | <span class='neutral'>    function deposit() external payable;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function withdraw(uint256) external;</span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>interface IWETHAlike is IWETH {}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IWhitelister.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.12;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IWhitelister {</span>
  5 |     | <span class='neutral'>    function isBorrowingAllowed(address user, uint256 newBorrowPart) external view returns (bool success);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function setMaxBorrow(address user, uint256 maxBorrow, bytes32[] calldata merkleProof) external returns (bool success);</span>
  8 |     | <span class='neutral'>}</span>
  9 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IWitnetPriceRouter.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>interface IWitnetPriceRouter {</span>
 5 |     | <span class='neutral'>    function valueFor(bytes32 _erc2362id) external view returns (int256, uint256, uint256);</span>
 6 |     | <span class='neutral'>}</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IYearnVault.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IYearnVault is IERC20 {</span>
  7 |     | <span class='neutral'>    function withdraw() external returns (uint256);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function deposit(uint256 amount, address recipient) external returns (uint256);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function pricePerShare() external view returns (uint256);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function token() external view returns (address);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function decimals() external view returns (uint256);</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/lenses/GmxLens.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import {MathLib} from &quot;libraries/MathLib.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IGmxVault, IGmxGlpManager, IVaultPriceFeed} from &quot;interfaces/IGmxV1.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>contract GmxLens {</span>
   9 |     | <span class='unexecuted'>    uint256 private constant BASIS_POINTS_DIVISOR = 10000;</span>
  10 |     | <span class='unexecuted'>    uint256 private constant PRICE_PRECISION = 10 ** 30;</span>
  11 |     | <span class='unexecuted'>    uint256 private constant USDG_DECIMALS = 18;</span>
  12 |     | <span class='neutral'>    uint256 private constant PRECISION = 10 ** 18;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    struct TokenFee {</span>
  15 |     | <span class='neutral'>        address token;</span>
  16 |     | <span class='neutral'>        uint256 fee;</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>    IGmxGlpManager public immutable manager;</span>
  20 |     | <span class='unexecuted'>    IGmxVault public immutable vault;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    IERC20 private immutable glp;</span>
  23 |     | <span class='neutral'>    IERC20 private immutable usdg;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    constructor(IGmxGlpManager _manager, IGmxVault _vault) {</span>
  26 |     | <span class='unexecuted'>        manager = _manager;</span>
  27 |     | <span class='unexecuted'>        vault = _vault;</span>
  28 |     | <span class='unexecuted'>        glp = IERC20(manager.glp());</span>
  29 |     | <span class='unexecuted'>        usdg = IERC20(manager.usdg());</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>    function getGlpPrice() public view returns (uint256) {</span>
  33 |     | <span class='unexecuted'>        return (manager.getAumInUsdg(false) * PRICE_PRECISION) / glp.totalSupply();</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    function getTokenOutFromBurningGlp(address tokenOut, uint256 glpAmount) public view returns (uint256 amount, uint256 feeBasisPoints) {</span>
  37 |     | <span class='unexecuted'>        uint256 usdgAmount = (glpAmount * getGlpPrice()) / PRICE_PRECISION;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>        feeBasisPoints = _getFeeBasisPoints(</span>
  40 |     | <span class='unexecuted'>            tokenOut,</span>
  41 |     | <span class='unexecuted'>            vault.usdgAmounts(tokenOut) - usdgAmount,</span>
  42 |     | <span class='unexecuted'>            usdgAmount,</span>
  43 |     | <span class='unexecuted'>            vault.mintBurnFeeBasisPoints(),</span>
  44 |     | <span class='unexecuted'>            vault.taxBasisPoints(),</span>
  45 |     | <span class='unexecuted'>            false</span>
  46 |     | <span class='neutral'>        );</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>        uint256 redemptionAmount = _getRedemptionAmount(tokenOut, usdgAmount);</span>
  49 |     | <span class='unexecuted'>        amount = _collectSwapFees(redemptionAmount, feeBasisPoints);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>    function getMaxAmountIn(IERC20 tokenIn) public view returns (uint256 amount) {</span>
  53 |     | <span class='unexecuted'>        amount = MathLib.subWithZeroFloor(vault.maxUsdgAmounts(address(tokenIn)), vault.usdgAmounts(address(tokenIn)));</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>    function getMintedGlpFromTokenIn(address tokenIn, uint256 amount) public view returns (uint256 amountOut, uint256 feeBasisPoints) {</span>
  57 |     | <span class='unexecuted'>        uint256 aumInUsdg = manager.getAumInUsdg(true);</span>
  58 |     | <span class='unexecuted'>        uint256 usdgAmount;</span>
  59 |     | <span class='unexecuted'>        (usdgAmount, feeBasisPoints) = _simulateBuyUSDG(tokenIn, amount);</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>        amountOut = (aumInUsdg == 0 ? usdgAmount : ((usdgAmount * PRICE_PRECISION) / getGlpPrice()));</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>    function getUsdgAmountFromTokenIn(address tokenIn, uint256 tokenAmount) public view returns (uint256 usdgAmount) {</span>
  65 |     | <span class='unexecuted'>        uint256 price = vault.getMinPrice(tokenIn);</span>
  66 |     | <span class='unexecuted'>        uint256 rawUsdgAmount = (tokenAmount * price) / PRICE_PRECISION;</span>
  67 |     | <span class='unexecuted'>        return vault.adjustForDecimals(rawUsdgAmount, tokenIn, address(usdg));</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>    function _simulateBuyUSDG(address tokenIn, uint256 tokenAmount) private view returns (uint256 mintAmount, uint256 feeBasisPoints) {</span>
  71 |     | <span class='unexecuted'>        uint256 usdgAmount = getUsdgAmountFromTokenIn(tokenIn, tokenAmount);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        feeBasisPoints = _getFeeBasisPoints(</span>
  74 |     | <span class='neutral'>            tokenIn,</span>
  75 |     | <span class='unexecuted'>            vault.usdgAmounts(tokenIn),</span>
  76 |     | <span class='unexecuted'>            usdgAmount,</span>
  77 |     | <span class='unexecuted'>            vault.mintBurnFeeBasisPoints(),</span>
  78 |     | <span class='unexecuted'>            vault.taxBasisPoints(),</span>
  79 |     | <span class='unexecuted'>            true</span>
  80 |     | <span class='neutral'>        );</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        uint256 amountAfterFees = _collectSwapFees(tokenAmount, feeBasisPoints);</span>
  83 |     | <span class='unexecuted'>        mintAmount = getUsdgAmountFromTokenIn(tokenIn, amountAfterFees);</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>    function _collectSwapFees(uint256 _amount, uint256 _feeBasisPoints) private pure returns (uint256) {</span>
  87 |     | <span class='unexecuted'>        return (_amount * (BASIS_POINTS_DIVISOR - _feeBasisPoints)) / BASIS_POINTS_DIVISOR;</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>    function _getFeeBasisPoints(</span>
  91 |     | <span class='neutral'>        address _token,</span>
  92 |     | <span class='neutral'>        uint256 tokenUsdgAmount,</span>
  93 |     | <span class='neutral'>        uint256 _usdgDelta,</span>
  94 |     | <span class='neutral'>        uint256 _feeBasisPoints,</span>
  95 |     | <span class='neutral'>        uint256 _taxBasisPoints,</span>
  96 |     | <span class='neutral'>        bool _increment</span>
  97 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
  98 |     | <span class='unexecuted'>        if (!vault.hasDynamicFees()) {</span>
  99 |     | <span class='unexecuted'>            return _feeBasisPoints;</span>
 100 |     | <span class='neutral'>        }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>        uint256 initialAmount = tokenUsdgAmount;</span>
 103 |     | <span class='unexecuted'>        uint256 nextAmount = initialAmount + _usdgDelta;</span>
 104 |     | <span class='unexecuted'>        if (!_increment) {</span>
 105 |     | <span class='unexecuted'>            nextAmount = _usdgDelta &gt; initialAmount ? 0 : initialAmount - _usdgDelta;</span>
 106 |     | <span class='neutral'>        }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>        uint256 targetAmount = _getTargetUsdgAmount(_token);</span>
 109 |     | <span class='unexecuted'>        if (targetAmount == 0) {</span>
 110 |     | <span class='unexecuted'>            return _feeBasisPoints;</span>
 111 |     | <span class='neutral'>        }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>        uint256 initialDiff = initialAmount &gt; targetAmount ? initialAmount - targetAmount : targetAmount - initialAmount;</span>
 114 |     | <span class='unexecuted'>        uint256 nextDiff = nextAmount &gt; targetAmount ? nextAmount - targetAmount : targetAmount - nextAmount;</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>        if (nextDiff &lt; initialDiff) {</span>
 117 |     | <span class='unexecuted'>            uint256 rebateBps = (_taxBasisPoints * initialDiff) / targetAmount;</span>
 118 |     | <span class='unexecuted'>            return rebateBps &gt; _feeBasisPoints ? 0 : _feeBasisPoints - rebateBps;</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>        uint256 averageDiff = (initialDiff + nextDiff) / 2;</span>
 122 |     | <span class='unexecuted'>        if (averageDiff &gt; targetAmount) {</span>
 123 |     | <span class='unexecuted'>            averageDiff = targetAmount;</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='unexecuted'>        uint256 taxBps = (_taxBasisPoints * averageDiff) / targetAmount;</span>
 126 |     | <span class='unexecuted'>        return _feeBasisPoints + taxBps;</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>    function _getTargetUsdgAmount(address _token) private view returns (uint256) {</span>
 130 |     | <span class='unexecuted'>        uint256 supply = IERC20(usdg).totalSupply();</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='unexecuted'>        if (supply == 0) {</span>
 133 |     | <span class='unexecuted'>            return 0;</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='unexecuted'>        uint256 weight = vault.tokenWeights(_token);</span>
 136 |     | <span class='unexecuted'>        return (weight * supply) / vault.totalTokenWeights();</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    function _decreaseUsdgAmount(address _token, uint256 _amount) private view returns (uint256) {</span>
 140 |     | <span class='neutral'>        uint256 value = vault.usdgAmounts(_token);</span>
 141 |     | <span class='neutral'>        if (value &lt;= _amount) {</span>
 142 |     | <span class='neutral'>            return 0;</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'>        return value - _amount;</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='unexecuted'>    function _getRedemptionAmount(address _token, uint256 _usdgAmount) private view returns (uint256) {</span>
 148 |     | <span class='unexecuted'>        uint256 price = _getMaxPrice(_token);</span>
 149 |     | <span class='unexecuted'>        uint256 redemptionAmount = (_usdgAmount * PRICE_PRECISION) / price;</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>        return _adjustForDecimals(redemptionAmount, address(usdg), _token);</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>    function _adjustForDecimals(uint256 _amount, address _tokenDiv, address _tokenMul) private view returns (uint256) {</span>
 155 |     | <span class='unexecuted'>        uint256 decimalsDiv = _tokenDiv == address(usdg) ? USDG_DECIMALS : vault.tokenDecimals(_tokenDiv);</span>
 156 |     | <span class='unexecuted'>        uint256 decimalsMul = _tokenMul == address(usdg) ? USDG_DECIMALS : vault.tokenDecimals(_tokenMul);</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='unexecuted'>        return (_amount * 10 ** decimalsMul) / 10 ** decimalsDiv;</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>    function _getMaxPrice(address _token) private view returns (uint256) {</span>
 162 |     | <span class='unexecuted'>        return IVaultPriceFeed(vault.priceFeed()).getPrice(_token, true, false, true);</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'>}</span>
 165 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/lenses/InterestStrategyLens.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IInterestStrategy {</span>
  5 |     | <span class='neutral'>    function interestPerSecond() external view returns (uint64);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function lastAccrued() external view returns (uint64);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function pendingFeeEarned() external view returns (uint128);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function principal() external view returns (uint256);</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>contract InterestStrategyLens {</span>
 15 |     | <span class='unexecuted'>    function previewAccrue(IInterestStrategy strategy) external view returns (uint128) {</span>
 16 |     | <span class='unexecuted'>        uint64 lastAccrued = strategy.lastAccrued();</span>
 17 |     | <span class='unexecuted'>        uint64 interestPerSecond = strategy.interestPerSecond();</span>
 18 |     | <span class='unexecuted'>        uint128 pendingFeeEarned = strategy.pendingFeeEarned();</span>
 19 |     | <span class='unexecuted'>        uint128 interest;</span>
 20 |     | <span class='unexecuted'>        uint256 principal = strategy.principal();</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>        if (lastAccrued == 0) {</span>
 23 |     | <span class='unexecuted'>            if (principal &gt; 0) {</span>
 24 |     | <span class='unexecuted'>                lastAccrued = uint64(block.timestamp);</span>
 25 |     | <span class='neutral'>            }</span>
 26 |     | <span class='unexecuted'>            return 0;</span>
 27 |     | <span class='neutral'>        }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>        uint256 elapsedTime = block.timestamp - lastAccrued;</span>
 30 |     | <span class='unexecuted'>        if (elapsedTime == 0) {</span>
 31 |     | <span class='unexecuted'>            return 0;</span>
 32 |     | <span class='neutral'>        }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>        lastAccrued = uint64(block.timestamp);</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>        if (principal == 0) {</span>
 37 |     | <span class='unexecuted'>            return 0;</span>
 38 |     | <span class='neutral'>        }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>        interest = uint128((principal * interestPerSecond * elapsedTime) / 1e18);</span>
 41 |     | <span class='unexecuted'>        pendingFeeEarned += interest;</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>        return interest;</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'>}</span>
 46 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/lenses/MarketLens.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.9;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
   5 |     | <span class='neutral'>import {ICauldronV2} from &quot;interfaces/ICauldronV2.sol&quot;;</span>
   6 |     | <span class='neutral'>import {ICauldronV3} from &quot;interfaces/ICauldronV3.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   8 |     | <span class='neutral'>import {MathLib} from &quot;libraries/MathLib.sol&quot;;</span>
   9 |     | <span class='neutral'>import {CauldronLib} from &quot;libraries/CauldronLib.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>contract MarketLens {</span>
  12 |     | <span class='neutral'>    struct UserPosition {</span>
  13 |     | <span class='neutral'>        address cauldron;</span>
  14 |     | <span class='neutral'>        address account;</span>
  15 |     | <span class='neutral'>        uint256 ltvBps;</span>
  16 |     | <span class='neutral'>        uint256 healthFactor;</span>
  17 |     | <span class='neutral'>        uint256 borrowValue;</span>
  18 |     | <span class='neutral'>        AmountValue collateral;</span>
  19 |     | <span class='neutral'>        uint256 liquidationPrice;</span>
  20 |     | <span class='neutral'>    }</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    struct MarketInfo {</span>
  23 |     | <span class='neutral'>        address cauldron;</span>
  24 |     | <span class='neutral'>        uint256 borrowFee;</span>
  25 |     | <span class='neutral'>        uint256 maximumCollateralRatio;</span>
  26 |     | <span class='neutral'>        uint256 liquidationFee;</span>
  27 |     | <span class='neutral'>        uint256 interestPerYear;</span>
  28 |     | <span class='neutral'>        uint256 marketMaxBorrow;</span>
  29 |     | <span class='neutral'>        uint256 userMaxBorrow;</span>
  30 |     | <span class='neutral'>        uint256 totalBorrowed;</span>
  31 |     | <span class='neutral'>        uint256 oracleExchangeRate;</span>
  32 |     | <span class='neutral'>        uint256 collateralPrice;</span>
  33 |     | <span class='neutral'>        AmountValue totalCollateral;</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    struct AmountValue {</span>
  37 |     | <span class='neutral'>        uint256 amount;</span>
  38 |     | <span class='neutral'>        uint256 value;</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>    uint256 constant PRECISION = 1e18;</span>
  42 |     | <span class='unexecuted'>    uint256 constant TENK_PRECISION = 1e5;</span>
  43 |     | <span class='unexecuted'>    uint256 constant BPS_PRECISION = 1e4;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>    function getBorrowFee(ICauldronV2 cauldron) public view returns (uint256) {</span>
  46 |     | <span class='unexecuted'>        return (cauldron.BORROW_OPENING_FEE() * BPS_PRECISION) / TENK_PRECISION;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    function getMaximumCollateralRatio(ICauldronV2 cauldron) public view returns (uint256) {</span>
  50 |     | <span class='unexecuted'>        return (cauldron.COLLATERIZATION_RATE() * BPS_PRECISION) / TENK_PRECISION;</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>    function getLiquidationFee(ICauldronV2 cauldron) public view returns (uint256) {</span>
  54 |     | <span class='unexecuted'>        uint256 liquidationFee = cauldron.LIQUIDATION_MULTIPLIER() - 100_000;</span>
  55 |     | <span class='unexecuted'>        return (liquidationFee * BPS_PRECISION) / TENK_PRECISION;</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>    function getInterestPerYear(ICauldronV2 cauldron) public view returns (uint64) {</span>
  59 |     | <span class='unexecuted'>        (, , uint64 interestPerSecond) = cauldron.accrueInfo();</span>
  60 |     | <span class='unexecuted'>        return CauldronLib.getInterestPerYearFromInterestPerSecond(interestPerSecond);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>    function getMimInBentoBox(ICauldronV2 cauldron) private view returns (uint256 mimInBentoBox) {</span>
  64 |     | <span class='unexecuted'>        IBentoBoxV1 bentoBox = IBentoBoxV1(cauldron.bentoBox());</span>
  65 |     | <span class='unexecuted'>        IERC20 mim = IERC20(cauldron.magicInternetMoney());</span>
  66 |     | <span class='unexecuted'>        uint256 poolBalance = bentoBox.balanceOf(mim, address(cauldron));</span>
  67 |     | <span class='unexecuted'>        mimInBentoBox = bentoBox.toAmount(mim, poolBalance, false);</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>    function getTokenInBentoBox(IBentoBoxV1 bentoBox, IERC20 token, address account) public view returns (uint256 share, uint256 amount) {</span>
  71 |     | <span class='unexecuted'>        return (bentoBox.balanceOf(token, account), bentoBox.toAmount(token, share, false));</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='unexecuted'>    function getMaxMarketBorrowForCauldronV2(ICauldronV2 cauldron) public view returns (uint256) {</span>
  75 |     | <span class='unexecuted'>        return getMimInBentoBox(cauldron);</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function getMaxUserBorrowForCauldronV2(ICauldronV2 cauldron) public view returns (uint256) {</span>
  79 |     | <span class='neutral'>        return getMimInBentoBox(cauldron);</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    // Returns the maximum amount that can be borrowed across all users</span>
  83 |     | <span class='unexecuted'>    function getMaxMarketBorrowForCauldronV3(ICauldronV3 cauldron) public view returns (uint256) {</span>
  84 |     | <span class='unexecuted'>        (uint256 totalBorrowLimit, ) = cauldron.borrowLimit();</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>        uint256 mimInBentoBox = getMimInBentoBox(cauldron);</span>
  87 |     | <span class='unexecuted'>        uint256 remainingBorrowLimit = MathLib.subWithZeroFloor(totalBorrowLimit, getTotalBorrowed(cauldron));</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>        return MathLib.min(mimInBentoBox, remainingBorrowLimit);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    // Returns the maximum amount that a single user can borrow</span>
  93 |     | <span class='unexecuted'>    function getMaxUserBorrowForCauldronV3(ICauldronV3 cauldron) public view returns (uint256) {</span>
  94 |     | <span class='unexecuted'>        (uint256 totalBorrowLimit, uint256 userBorrowLimit) = cauldron.borrowLimit();</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>        uint256[] memory values = new uint256[](3);</span>
  97 |     | <span class='unexecuted'>        values[0] = getMimInBentoBox(cauldron);</span>
  98 |     | <span class='unexecuted'>        values[1] = MathLib.subWithZeroFloor(totalBorrowLimit, getTotalBorrowed(cauldron));</span>
  99 |     | <span class='unexecuted'>        values[2] = userBorrowLimit;</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>        return MathLib.min(values);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>    function getTotalBorrowed(ICauldronV2 cauldron) public view returns (uint256) {</span>
 105 |     | <span class='unexecuted'>        return CauldronLib.getTotalBorrowWithAccruedInterests(cauldron).elastic;</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>    function getOracleExchangeRate(ICauldronV2 cauldron) public view returns (uint256) {</span>
 109 |     | <span class='unexecuted'>        return CauldronLib.getOracleExchangeRate(cauldron);</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>    function getCollateralPrice(ICauldronV2 cauldron) public view returns (uint256) {</span>
 113 |     | <span class='unexecuted'>        return CauldronLib.getCollateralPrice(cauldron);</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>    function getTotalCollateral(ICauldronV2 cauldron) public view returns (AmountValue memory) {</span>
 117 |     | <span class='unexecuted'>        IBentoBoxV1 bentoBox = IBentoBoxV1(cauldron.bentoBox());</span>
 118 |     | <span class='unexecuted'>        uint256 amount = bentoBox.toAmount(cauldron.collateral(), cauldron.totalCollateralShare(), false);</span>
 119 |     | <span class='unexecuted'>        uint256 value = (amount * PRECISION) / getOracleExchangeRate(cauldron);</span>
 120 |     | <span class='unexecuted'>        return AmountValue(amount, value);</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>    function getUserBorrow(ICauldronV2 cauldron, address account) public view returns (uint256) {</span>
 124 |     | <span class='unexecuted'>        return CauldronLib.getUserBorrowAmount(cauldron, account);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>    function getUserMaxBorrow(ICauldronV2 cauldron, address account) public view returns (uint256) {</span>
 128 |     | <span class='unexecuted'>        (, uint256 value) = CauldronLib.getUserCollateral(cauldron, account);</span>
 129 |     | <span class='unexecuted'>        return (value * getMaximumCollateralRatio(cauldron)) / TENK_PRECISION;</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='unexecuted'>    function getUserCollateral(ICauldronV2 cauldron, address account) public view returns (AmountValue memory) {</span>
 133 |     | <span class='unexecuted'>        (uint256 amount, uint256 value) = CauldronLib.getUserCollateral(cauldron, account);</span>
 134 |     | <span class='unexecuted'>        return AmountValue(amount, value);</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='unexecuted'>    function getUserLtv(ICauldronV2 cauldron, address account) public view returns (uint256 ltvBps) {</span>
 138 |     | <span class='unexecuted'>        (ltvBps, , , , , ) = CauldronLib.getUserPositionInfo(cauldron, account);</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='unexecuted'>    function getHealthFactor(ICauldronV2 cauldron, address account, bool isStable) public view returns (uint256) {</span>
 142 |     | <span class='unexecuted'>        (, uint256 healthFactor, , , , ) = CauldronLib.getUserPositionInfo(cauldron, account);</span>
 143 |     | <span class='unexecuted'>        return isStable ? healthFactor * 10 : healthFactor;</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>    function getUserLiquidationPrice(ICauldronV2 cauldron, address account) public view returns (uint256 liquidationPrice) {</span>
 147 |     | <span class='unexecuted'>        (, , , , liquidationPrice, ) = CauldronLib.getUserPositionInfo(cauldron, account);</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='unexecuted'>    function getUserPosition(ICauldronV2 cauldron, address account) public view returns (UserPosition memory) {</span>
 151 |     | <span class='unexecuted'>        (</span>
 152 |     | <span class='unexecuted'>            uint256 ltvBps,</span>
 153 |     | <span class='unexecuted'>            uint256 healthFactor,</span>
 154 |     | <span class='unexecuted'>            uint256 borrowValue,</span>
 155 |     | <span class='unexecuted'>            uint256 collateralValue,</span>
 156 |     | <span class='unexecuted'>            uint256 liquidationPrice,</span>
 157 |     | <span class='unexecuted'>            uint256 collateralAmount</span>
 158 |     | <span class='unexecuted'>        ) = CauldronLib.getUserPositionInfo(cauldron, account);</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>        return</span>
 161 |     | <span class='unexecuted'>            UserPosition(</span>
 162 |     | <span class='unexecuted'>                address(cauldron),</span>
 163 |     | <span class='unexecuted'>                address(account),</span>
 164 |     | <span class='unexecuted'>                ltvBps,</span>
 165 |     | <span class='unexecuted'>                healthFactor,</span>
 166 |     | <span class='unexecuted'>                borrowValue,</span>
 167 |     | <span class='unexecuted'>                AmountValue({amount: collateralAmount, value: collateralValue}),</span>
 168 |     | <span class='unexecuted'>                liquidationPrice</span>
 169 |     | <span class='neutral'>            );</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    // Get many user position information at once.</span>
 173 |     | <span class='neutral'>    // Beware of hitting RPC `eth_call` gas limit</span>
 174 |     | <span class='unexecuted'>    function getUserPositions(ICauldronV2 cauldron, address[] calldata accounts) public view returns (UserPosition[] memory positions) {</span>
 175 |     | <span class='unexecuted'>        positions = new UserPosition[](accounts.length);</span>
 176 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; accounts.length; i++) {</span>
 177 |     | <span class='unexecuted'>            positions[i] = getUserPosition(cauldron, accounts[i]);</span>
 178 |     | <span class='neutral'>        }</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>    function getMarketInfoCauldronV2(ICauldronV2 cauldron) public view returns (MarketInfo memory) {</span>
 182 |     | <span class='unexecuted'>        return</span>
 183 |     | <span class='unexecuted'>            MarketInfo({</span>
 184 |     | <span class='unexecuted'>                cauldron: address(cauldron),</span>
 185 |     | <span class='unexecuted'>                borrowFee: getBorrowFee(cauldron),</span>
 186 |     | <span class='unexecuted'>                maximumCollateralRatio: getMaximumCollateralRatio(cauldron),</span>
 187 |     | <span class='unexecuted'>                liquidationFee: getLiquidationFee(cauldron),</span>
 188 |     | <span class='unexecuted'>                interestPerYear: getInterestPerYear(cauldron),</span>
 189 |     | <span class='unexecuted'>                marketMaxBorrow: getMaxMarketBorrowForCauldronV2(cauldron),</span>
 190 |     | <span class='unexecuted'>                userMaxBorrow: getMaxUserBorrowForCauldronV2(cauldron),</span>
 191 |     | <span class='unexecuted'>                totalBorrowed: getTotalBorrowed(cauldron),</span>
 192 |     | <span class='unexecuted'>                oracleExchangeRate: getOracleExchangeRate(cauldron),</span>
 193 |     | <span class='unexecuted'>                collateralPrice: getCollateralPrice(cauldron),</span>
 194 |     | <span class='unexecuted'>                totalCollateral: getTotalCollateral(cauldron)</span>
 195 |     | <span class='neutral'>            });</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>    function getMarketInfoCauldronV3(ICauldronV3 cauldron) public view returns (MarketInfo memory marketInfo) {</span>
 199 |     | <span class='unexecuted'>        marketInfo = getMarketInfoCauldronV2(cauldron);</span>
 200 |     | <span class='unexecuted'>        marketInfo.marketMaxBorrow = getMaxMarketBorrowForCauldronV3(cauldron);</span>
 201 |     | <span class='unexecuted'>        marketInfo.userMaxBorrow = getMaxUserBorrowForCauldronV3(cauldron);</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'>}</span>
 204 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/libraries/BabylonianLib.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @notice Babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method).</span>
  5 |     | <span class='unexecuted'>library BabylonianLib {</span>
  6 |     | <span class='neutral'>    // computes square roots using the babylonian method</span>
  7 |     | <span class='neutral'>    // credit for this implementation goes to</span>
  8 |     | <span class='neutral'>    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687</span>
  9 |     | <span class='unexecuted'>    function sqrt(uint256 x) internal pure returns (uint256) {</span>
 10 |     | <span class='unexecuted'>        if (x == 0) return 0;</span>
 11 |     | <span class='neutral'>        // this block is equivalent to r = uint256(1) &lt;&lt; (BitMath.mostSignificantBit(x) / 2);</span>
 12 |     | <span class='neutral'>        // however that code costs significantly more gas</span>
 13 |     | <span class='unexecuted'>        uint256 xx = x;</span>
 14 |     | <span class='unexecuted'>        uint256 r = 1;</span>
 15 |     | <span class='unexecuted'>        if (xx &gt;= 0x100000000000000000000000000000000) {</span>
 16 |     | <span class='unexecuted'>            xx &gt;&gt;= 128;</span>
 17 |     | <span class='unexecuted'>            r &lt;&lt;= 64;</span>
 18 |     | <span class='neutral'>        }</span>
 19 |     | <span class='unexecuted'>        if (xx &gt;= 0x10000000000000000) {</span>
 20 |     | <span class='unexecuted'>            xx &gt;&gt;= 64;</span>
 21 |     | <span class='unexecuted'>            r &lt;&lt;= 32;</span>
 22 |     | <span class='neutral'>        }</span>
 23 |     | <span class='unexecuted'>        if (xx &gt;= 0x100000000) {</span>
 24 |     | <span class='unexecuted'>            xx &gt;&gt;= 32;</span>
 25 |     | <span class='unexecuted'>            r &lt;&lt;= 16;</span>
 26 |     | <span class='neutral'>        }</span>
 27 |     | <span class='unexecuted'>        if (xx &gt;= 0x10000) {</span>
 28 |     | <span class='unexecuted'>            xx &gt;&gt;= 16;</span>
 29 |     | <span class='unexecuted'>            r &lt;&lt;= 8;</span>
 30 |     | <span class='neutral'>        }</span>
 31 |     | <span class='unexecuted'>        if (xx &gt;= 0x100) {</span>
 32 |     | <span class='unexecuted'>            xx &gt;&gt;= 8;</span>
 33 |     | <span class='unexecuted'>            r &lt;&lt;= 4;</span>
 34 |     | <span class='neutral'>        }</span>
 35 |     | <span class='unexecuted'>        if (xx &gt;= 0x10) {</span>
 36 |     | <span class='unexecuted'>            xx &gt;&gt;= 4;</span>
 37 |     | <span class='unexecuted'>            r &lt;&lt;= 2;</span>
 38 |     | <span class='neutral'>        }</span>
 39 |     | <span class='unexecuted'>        if (xx &gt;= 0x8) {</span>
 40 |     | <span class='unexecuted'>            r &lt;&lt;= 1;</span>
 41 |     | <span class='neutral'>        }</span>
 42 |     | <span class='unexecuted'>        r = (r + x / r) &gt;&gt; 1;</span>
 43 |     | <span class='unexecuted'>        r = (r + x / r) &gt;&gt; 1;</span>
 44 |     | <span class='unexecuted'>        r = (r + x / r) &gt;&gt; 1;</span>
 45 |     | <span class='unexecuted'>        r = (r + x / r) &gt;&gt; 1;</span>
 46 |     | <span class='unexecuted'>        r = (r + x / r) &gt;&gt; 1;</span>
 47 |     | <span class='unexecuted'>        r = (r + x / r) &gt;&gt; 1;</span>
 48 |     | <span class='unexecuted'>        r = (r + x / r) &gt;&gt; 1; // Seven iterations should be enough</span>
 49 |     | <span class='unexecuted'>        uint256 r1 = x / r;</span>
 50 |     | <span class='unexecuted'>        return (r &lt; r1 ? r : r1);</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/libraries/BytesLib.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: Unlicense</span>
   2 |     | <span class='neutral'>/*</span>
   3 |     | <span class='neutral'> * @title Solidity Bytes Arrays Utils</span>
   4 |     | <span class='neutral'> * @author Gonalo S &lt;goncalo.sa@consensys.net&gt;</span>
   5 |     | <span class='neutral'> *</span>
   6 |     | <span class='neutral'> * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.</span>
   7 |     | <span class='neutral'> *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='neutral'>pragma solidity &gt;=0.8.0 &lt;0.9.0;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>library BytesLib {</span>
  12 |     | <span class='neutral'>    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {</span>
  13 |     | <span class='neutral'>        bytes memory tempBytes;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>        assembly {</span>
  16 |     | <span class='neutral'>            // Get a location of some free memory and store it in tempBytes as</span>
  17 |     | <span class='neutral'>            // Solidity does for memory variables.</span>
  18 |     | <span class='neutral'>            tempBytes := mload(0x40)</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>            // Store the length of the first bytes array at the beginning of</span>
  21 |     | <span class='neutral'>            // the memory for tempBytes.</span>
  22 |     | <span class='neutral'>            let length := mload(_preBytes)</span>
  23 |     | <span class='neutral'>            mstore(tempBytes, length)</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>            // Maintain a memory counter for the current write location in the</span>
  26 |     | <span class='neutral'>            // temp bytes array by adding the 32 bytes for the array length to</span>
  27 |     | <span class='neutral'>            // the starting location.</span>
  28 |     | <span class='neutral'>            let mc := add(tempBytes, 0x20)</span>
  29 |     | <span class='neutral'>            // Stop copying when the memory counter reaches the length of the</span>
  30 |     | <span class='neutral'>            // first bytes array.</span>
  31 |     | <span class='neutral'>            let end := add(mc, length)</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>            for {</span>
  34 |     | <span class='neutral'>                // Initialize a copy counter to the start of the _preBytes data,</span>
  35 |     | <span class='neutral'>                // 32 bytes into its memory.</span>
  36 |     | <span class='neutral'>                let cc := add(_preBytes, 0x20)</span>
  37 |     | <span class='neutral'>            } lt(mc, end) {</span>
  38 |     | <span class='neutral'>                // Increase both counters by 32 bytes each iteration.</span>
  39 |     | <span class='neutral'>                mc := add(mc, 0x20)</span>
  40 |     | <span class='neutral'>                cc := add(cc, 0x20)</span>
  41 |     | <span class='neutral'>            } {</span>
  42 |     | <span class='neutral'>                // Write the _preBytes data into the tempBytes memory 32 bytes</span>
  43 |     | <span class='neutral'>                // at a time.</span>
  44 |     | <span class='neutral'>                mstore(mc, mload(cc))</span>
  45 |     | <span class='neutral'>            }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>            // Add the length of _postBytes to the current length of tempBytes</span>
  48 |     | <span class='neutral'>            // and store it as the new length in the first 32 bytes of the</span>
  49 |     | <span class='neutral'>            // tempBytes memory.</span>
  50 |     | <span class='neutral'>            length := mload(_postBytes)</span>
  51 |     | <span class='neutral'>            mstore(tempBytes, add(length, mload(tempBytes)))</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>            // Move the memory counter back from a multiple of 0x20 to the</span>
  54 |     | <span class='neutral'>            // actual end of the _preBytes data.</span>
  55 |     | <span class='neutral'>            mc := end</span>
  56 |     | <span class='neutral'>            // Stop copying when the memory counter reaches the new combined</span>
  57 |     | <span class='neutral'>            // length of the arrays.</span>
  58 |     | <span class='neutral'>            end := add(mc, length)</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>            for {</span>
  61 |     | <span class='neutral'>                let cc := add(_postBytes, 0x20)</span>
  62 |     | <span class='neutral'>            } lt(mc, end) {</span>
  63 |     | <span class='neutral'>                mc := add(mc, 0x20)</span>
  64 |     | <span class='neutral'>                cc := add(cc, 0x20)</span>
  65 |     | <span class='neutral'>            } {</span>
  66 |     | <span class='neutral'>                mstore(mc, mload(cc))</span>
  67 |     | <span class='neutral'>            }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>            // Update the free-memory pointer by padding our last write location</span>
  70 |     | <span class='neutral'>            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the</span>
  71 |     | <span class='neutral'>            // next 32 byte block, then round down to the nearest multiple of</span>
  72 |     | <span class='neutral'>            // 32. If the sum of the length of the two arrays is zero then add</span>
  73 |     | <span class='neutral'>            // one before rounding down to leave a blank 32 bytes (the length block with 0).</span>
  74 |     | <span class='neutral'>            mstore(</span>
  75 |     | <span class='neutral'>                0x40,</span>
  76 |     | <span class='neutral'>                and(</span>
  77 |     | <span class='neutral'>                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),</span>
  78 |     | <span class='neutral'>                    not(31) // Round down to the nearest 32 bytes.</span>
  79 |     | <span class='neutral'>                )</span>
  80 |     | <span class='neutral'>            )</span>
  81 |     | <span class='neutral'>        }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>        return tempBytes;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {</span>
  87 |     | <span class='neutral'>        assembly {</span>
  88 |     | <span class='neutral'>            // Read the first 32 bytes of _preBytes storage, which is the length</span>
  89 |     | <span class='neutral'>            // of the array. (We don&#39;t need to use the offset into the slot</span>
  90 |     | <span class='neutral'>            // because arrays use the entire slot.)</span>
  91 |     | <span class='neutral'>            let fslot := sload(_preBytes.slot)</span>
  92 |     | <span class='neutral'>            // Arrays of 31 bytes or less have an even value in their slot,</span>
  93 |     | <span class='neutral'>            // while longer arrays have an odd value. The actual length is</span>
  94 |     | <span class='neutral'>            // the slot divided by two for odd values, and the lowest order</span>
  95 |     | <span class='neutral'>            // byte divided by two for even values.</span>
  96 |     | <span class='neutral'>            // If the slot is even, bitwise and the slot with 255 and divide by</span>
  97 |     | <span class='neutral'>            // two to get the length. If the slot is odd, bitwise and the slot</span>
  98 |     | <span class='neutral'>            // with -1 and divide by two.</span>
  99 |     | <span class='neutral'>            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)</span>
 100 |     | <span class='neutral'>            let mlength := mload(_postBytes)</span>
 101 |     | <span class='neutral'>            let newlength := add(slength, mlength)</span>
 102 |     | <span class='neutral'>            // slength can contain both the length and contents of the array</span>
 103 |     | <span class='neutral'>            // if length &lt; 32 bytes so let&#39;s prepare for that</span>
 104 |     | <span class='neutral'>            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage</span>
 105 |     | <span class='neutral'>            switch add(lt(slength, 32), lt(newlength, 32))</span>
 106 |     | <span class='neutral'>            case 2 {</span>
 107 |     | <span class='neutral'>                // Since the new array still fits in the slot, we just need to</span>
 108 |     | <span class='neutral'>                // update the contents of the slot.</span>
 109 |     | <span class='neutral'>                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length</span>
 110 |     | <span class='neutral'>                sstore(</span>
 111 |     | <span class='neutral'>                    _preBytes.slot,</span>
 112 |     | <span class='neutral'>                    // all the modifications to the slot are inside this</span>
 113 |     | <span class='neutral'>                    // next block</span>
 114 |     | <span class='neutral'>                    add(</span>
 115 |     | <span class='neutral'>                        // we can just add to the slot contents because the</span>
 116 |     | <span class='neutral'>                        // bytes we want to change are the LSBs</span>
 117 |     | <span class='neutral'>                        fslot,</span>
 118 |     | <span class='neutral'>                        add(</span>
 119 |     | <span class='neutral'>                            mul(</span>
 120 |     | <span class='neutral'>                                div(</span>
 121 |     | <span class='neutral'>                                    // load the bytes from memory</span>
 122 |     | <span class='neutral'>                                    mload(add(_postBytes, 0x20)),</span>
 123 |     | <span class='neutral'>                                    // zero all bytes to the right</span>
 124 |     | <span class='neutral'>                                    exp(0x100, sub(32, mlength))</span>
 125 |     | <span class='neutral'>                                ),</span>
 126 |     | <span class='neutral'>                                // and now shift left the number of bytes to</span>
 127 |     | <span class='neutral'>                                // leave space for the length in the slot</span>
 128 |     | <span class='neutral'>                                exp(0x100, sub(32, newlength))</span>
 129 |     | <span class='neutral'>                            ),</span>
 130 |     | <span class='neutral'>                            // increase length by the double of the memory</span>
 131 |     | <span class='neutral'>                            // bytes length</span>
 132 |     | <span class='neutral'>                            mul(mlength, 2)</span>
 133 |     | <span class='neutral'>                        )</span>
 134 |     | <span class='neutral'>                    )</span>
 135 |     | <span class='neutral'>                )</span>
 136 |     | <span class='neutral'>            }</span>
 137 |     | <span class='neutral'>            case 1 {</span>
 138 |     | <span class='neutral'>                // The stored value fits in the slot, but the combined value</span>
 139 |     | <span class='neutral'>                // will exceed it.</span>
 140 |     | <span class='neutral'>                // get the keccak hash to get the contents of the array</span>
 141 |     | <span class='neutral'>                mstore(0x0, _preBytes.slot)</span>
 142 |     | <span class='neutral'>                let sc := add(keccak256(0x0, 0x20), div(slength, 32))</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>                // save new length</span>
 145 |     | <span class='neutral'>                sstore(_preBytes.slot, add(mul(newlength, 2), 1))</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>                // The contents of the _postBytes array start 32 bytes into</span>
 148 |     | <span class='neutral'>                // the structure. Our first read should obtain the `submod`</span>
 149 |     | <span class='neutral'>                // bytes that can fit into the unused space in the last word</span>
 150 |     | <span class='neutral'>                // of the stored array. To get this, we read 32 bytes starting</span>
 151 |     | <span class='neutral'>                // from `submod`, so the data we read overlaps with the array</span>
 152 |     | <span class='neutral'>                // contents by `submod` bytes. Masking the lowest-order</span>
 153 |     | <span class='neutral'>                // `submod` bytes allows us to add that value directly to the</span>
 154 |     | <span class='neutral'>                // stored value.</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>                let submod := sub(32, slength)</span>
 157 |     | <span class='neutral'>                let mc := add(_postBytes, submod)</span>
 158 |     | <span class='neutral'>                let end := add(_postBytes, mlength)</span>
 159 |     | <span class='neutral'>                let mask := sub(exp(0x100, submod), 1)</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>                sstore(sc, add(and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00), and(mload(mc), mask)))</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>                for {</span>
 164 |     | <span class='neutral'>                    mc := add(mc, 0x20)</span>
 165 |     | <span class='neutral'>                    sc := add(sc, 1)</span>
 166 |     | <span class='neutral'>                } lt(mc, end) {</span>
 167 |     | <span class='neutral'>                    sc := add(sc, 1)</span>
 168 |     | <span class='neutral'>                    mc := add(mc, 0x20)</span>
 169 |     | <span class='neutral'>                } {</span>
 170 |     | <span class='neutral'>                    sstore(sc, mload(mc))</span>
 171 |     | <span class='neutral'>                }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>                mask := exp(0x100, sub(mc, end))</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>                sstore(sc, mul(div(mload(mc), mask), mask))</span>
 176 |     | <span class='neutral'>            }</span>
 177 |     | <span class='neutral'>            default {</span>
 178 |     | <span class='neutral'>                // get the keccak hash to get the contents of the array</span>
 179 |     | <span class='neutral'>                mstore(0x0, _preBytes.slot)</span>
 180 |     | <span class='neutral'>                // Start copying to the last used word of the stored array.</span>
 181 |     | <span class='neutral'>                let sc := add(keccak256(0x0, 0x20), div(slength, 32))</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>                // save new length</span>
 184 |     | <span class='neutral'>                sstore(_preBytes.slot, add(mul(newlength, 2), 1))</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>                // Copy over the first `submod` bytes of the new data as in</span>
 187 |     | <span class='neutral'>                // case 1 above.</span>
 188 |     | <span class='neutral'>                let slengthmod := mod(slength, 32)</span>
 189 |     | <span class='neutral'>                let mlengthmod := mod(mlength, 32)</span>
 190 |     | <span class='neutral'>                let submod := sub(32, slengthmod)</span>
 191 |     | <span class='neutral'>                let mc := add(_postBytes, submod)</span>
 192 |     | <span class='neutral'>                let end := add(_postBytes, mlength)</span>
 193 |     | <span class='neutral'>                let mask := sub(exp(0x100, submod), 1)</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>                sstore(sc, add(sload(sc), and(mload(mc), mask)))</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>                for {</span>
 198 |     | <span class='neutral'>                    sc := add(sc, 1)</span>
 199 |     | <span class='neutral'>                    mc := add(mc, 0x20)</span>
 200 |     | <span class='neutral'>                } lt(mc, end) {</span>
 201 |     | <span class='neutral'>                    sc := add(sc, 1)</span>
 202 |     | <span class='neutral'>                    mc := add(mc, 0x20)</span>
 203 |     | <span class='neutral'>                } {</span>
 204 |     | <span class='neutral'>                    sstore(sc, mload(mc))</span>
 205 |     | <span class='neutral'>                }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>                mask := exp(0x100, sub(mc, end))</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>                sstore(sc, mul(div(mload(mc), mask), mask))</span>
 210 |     | <span class='neutral'>            }</span>
 211 |     | <span class='neutral'>        }</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='unexecuted'>    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {</span>
 215 |     | <span class='unexecuted'>        require(_length + 31 &gt;= _length, &quot;slice_overflow&quot;);</span>
 216 |     | <span class='unexecuted'>        require(_bytes.length &gt;= _start + _length, &quot;slice_outOfBounds&quot;);</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='unexecuted'>        bytes memory tempBytes;</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>        assembly {</span>
 221 |     | <span class='unexecuted'>            switch iszero(_length)</span>
 222 |     | <span class='unexecuted'>            case 0 {</span>
 223 |     | <span class='neutral'>                // Get a location of some free memory and store it in tempBytes as</span>
 224 |     | <span class='neutral'>                // Solidity does for memory variables.</span>
 225 |     | <span class='unexecuted'>                tempBytes := mload(0x40)</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>                // The first word of the slice result is potentially a partial</span>
 228 |     | <span class='neutral'>                // word read from the original array. To read it, we calculate</span>
 229 |     | <span class='neutral'>                // the length of that partial word and start copying that many</span>
 230 |     | <span class='neutral'>                // bytes into the array. The first word we copy will start with</span>
 231 |     | <span class='neutral'>                // data we don&#39;t care about, but the last `lengthmod` bytes will</span>
 232 |     | <span class='neutral'>                // land at the beginning of the contents of the new array. When</span>
 233 |     | <span class='neutral'>                // we&#39;re done copying, we overwrite the full first word with</span>
 234 |     | <span class='neutral'>                // the actual length of the slice.</span>
 235 |     | <span class='unexecuted'>                let lengthmod := and(_length, 31)</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>                // The multiplication in the next line is necessary</span>
 238 |     | <span class='neutral'>                // because when slicing multiples of 32 bytes (lengthmod == 0)</span>
 239 |     | <span class='neutral'>                // the following copy loop was copying the origin&#39;s length</span>
 240 |     | <span class='neutral'>                // and then ending prematurely not copying everything it should.</span>
 241 |     | <span class='unexecuted'>                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))</span>
 242 |     | <span class='unexecuted'>                let end := add(mc, _length)</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='unexecuted'>                for {</span>
 245 |     | <span class='neutral'>                    // The multiplication in the next line has the same exact purpose</span>
 246 |     | <span class='neutral'>                    // as the one above.</span>
 247 |     | <span class='unexecuted'>                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)</span>
 248 |     | <span class='unexecuted'>                } lt(mc, end) {</span>
 249 |     | <span class='unexecuted'>                    mc := add(mc, 0x20)</span>
 250 |     | <span class='unexecuted'>                    cc := add(cc, 0x20)</span>
 251 |     | <span class='neutral'>                } {</span>
 252 |     | <span class='unexecuted'>                    mstore(mc, mload(cc))</span>
 253 |     | <span class='neutral'>                }</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='unexecuted'>                mstore(tempBytes, _length)</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>                //update free-memory pointer</span>
 258 |     | <span class='neutral'>                //allocating the array padded to 32 bytes like the compiler does now</span>
 259 |     | <span class='unexecuted'>                mstore(0x40, and(add(mc, 31), not(31)))</span>
 260 |     | <span class='neutral'>            }</span>
 261 |     | <span class='neutral'>            //if we want a zero-length slice let&#39;s just return a zero-length array</span>
 262 |     | <span class='neutral'>            default {</span>
 263 |     | <span class='unexecuted'>                tempBytes := mload(0x40)</span>
 264 |     | <span class='neutral'>                //zero out the 32 bytes slice we are about to return</span>
 265 |     | <span class='neutral'>                //we need to do it because Solidity does not garbage collect</span>
 266 |     | <span class='unexecuted'>                mstore(tempBytes, 0)</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='unexecuted'>                mstore(0x40, add(tempBytes, 0x20))</span>
 269 |     | <span class='neutral'>            }</span>
 270 |     | <span class='neutral'>        }</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='unexecuted'>        return tempBytes;</span>
 273 |     | <span class='neutral'>    }</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='unexecuted'>    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {</span>
 276 |     | <span class='unexecuted'>        require(_bytes.length &gt;= _start + 20, &quot;toAddress_outOfBounds&quot;);</span>
 277 |     | <span class='neutral'>        address tempAddress;</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='neutral'>        assembly {</span>
 280 |     | <span class='unexecuted'>            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)</span>
 281 |     | <span class='neutral'>        }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>        return tempAddress;</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='unexecuted'>    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {</span>
 287 |     | <span class='unexecuted'>        require(_bytes.length &gt;= _start + 1, &quot;toUint8_outOfBounds&quot;);</span>
 288 |     | <span class='neutral'>        uint8 tempUint;</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>        assembly {</span>
 291 |     | <span class='unexecuted'>            tempUint := mload(add(add(_bytes, 0x1), _start))</span>
 292 |     | <span class='neutral'>        }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>        return tempUint;</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {</span>
 298 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 2, &quot;toUint16_outOfBounds&quot;);</span>
 299 |     | <span class='neutral'>        uint16 tempUint;</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='neutral'>        assembly {</span>
 302 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0x2), _start))</span>
 303 |     | <span class='neutral'>        }</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>        return tempUint;</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='neutral'>    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {</span>
 309 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 4, &quot;toUint32_outOfBounds&quot;);</span>
 310 |     | <span class='neutral'>        uint32 tempUint;</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>        assembly {</span>
 313 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0x4), _start))</span>
 314 |     | <span class='neutral'>        }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>        return tempUint;</span>
 317 |     | <span class='neutral'>    }</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='unexecuted'>    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {</span>
 320 |     | <span class='unexecuted'>        require(_bytes.length &gt;= _start + 8, &quot;toUint64_outOfBounds&quot;);</span>
 321 |     | <span class='neutral'>        uint64 tempUint;</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='neutral'>        assembly {</span>
 324 |     | <span class='unexecuted'>            tempUint := mload(add(add(_bytes, 0x8), _start))</span>
 325 |     | <span class='neutral'>        }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>        return tempUint;</span>
 328 |     | <span class='neutral'>    }</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {</span>
 331 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 12, &quot;toUint96_outOfBounds&quot;);</span>
 332 |     | <span class='neutral'>        uint96 tempUint;</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>        assembly {</span>
 335 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0xc), _start))</span>
 336 |     | <span class='neutral'>        }</span>
 337 |     | <span class='neutral'></span>
 338 |     | <span class='neutral'>        return tempUint;</span>
 339 |     | <span class='neutral'>    }</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='neutral'>    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {</span>
 342 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 16, &quot;toUint128_outOfBounds&quot;);</span>
 343 |     | <span class='neutral'>        uint128 tempUint;</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>        assembly {</span>
 346 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0x10), _start))</span>
 347 |     | <span class='neutral'>        }</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='neutral'>        return tempUint;</span>
 350 |     | <span class='neutral'>    }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {</span>
 353 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 32, &quot;toUint256_outOfBounds&quot;);</span>
 354 |     | <span class='neutral'>        uint256 tempUint;</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='neutral'>        assembly {</span>
 357 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0x20), _start))</span>
 358 |     | <span class='neutral'>        }</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='neutral'>        return tempUint;</span>
 361 |     | <span class='neutral'>    }</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='unexecuted'>    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {</span>
 364 |     | <span class='unexecuted'>        require(_bytes.length &gt;= _start + 32, &quot;toBytes32_outOfBounds&quot;);</span>
 365 |     | <span class='neutral'>        bytes32 tempBytes32;</span>
 366 |     | <span class='neutral'></span>
 367 |     | <span class='neutral'>        assembly {</span>
 368 |     | <span class='unexecuted'>            tempBytes32 := mload(add(add(_bytes, 0x20), _start))</span>
 369 |     | <span class='neutral'>        }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>        return tempBytes32;</span>
 372 |     | <span class='neutral'>    }</span>
 373 |     | <span class='neutral'></span>
 374 |     | <span class='neutral'>    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {</span>
 375 |     | <span class='neutral'>        bool success = true;</span>
 376 |     | <span class='neutral'></span>
 377 |     | <span class='neutral'>        assembly {</span>
 378 |     | <span class='neutral'>            let length := mload(_preBytes)</span>
 379 |     | <span class='neutral'></span>
 380 |     | <span class='neutral'>            // if lengths don&#39;t match the arrays are not equal</span>
 381 |     | <span class='neutral'>            switch eq(length, mload(_postBytes))</span>
 382 |     | <span class='neutral'>            case 1 {</span>
 383 |     | <span class='neutral'>                // cb is a circuit breaker in the for loop since there&#39;s</span>
 384 |     | <span class='neutral'>                //  no said feature for inline assembly loops</span>
 385 |     | <span class='neutral'>                // cb = 1 - don&#39;t breaker</span>
 386 |     | <span class='neutral'>                // cb = 0 - break</span>
 387 |     | <span class='neutral'>                let cb := 1</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>                let mc := add(_preBytes, 0x20)</span>
 390 |     | <span class='neutral'>                let end := add(mc, length)</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='neutral'>                for {</span>
 393 |     | <span class='neutral'>                    let cc := add(_postBytes, 0x20)</span>
 394 |     | <span class='neutral'>                    // the next line is the loop condition:</span>
 395 |     | <span class='neutral'>                    // while(uint256(mc &lt; end) + cb == 2)</span>
 396 |     | <span class='neutral'>                } eq(add(lt(mc, end), cb), 2) {</span>
 397 |     | <span class='neutral'>                    mc := add(mc, 0x20)</span>
 398 |     | <span class='neutral'>                    cc := add(cc, 0x20)</span>
 399 |     | <span class='neutral'>                } {</span>
 400 |     | <span class='neutral'>                    // if any of these checks fails then arrays are not equal</span>
 401 |     | <span class='neutral'>                    if iszero(eq(mload(mc), mload(cc))) {</span>
 402 |     | <span class='neutral'>                        // unsuccess:</span>
 403 |     | <span class='neutral'>                        success := 0</span>
 404 |     | <span class='neutral'>                        cb := 0</span>
 405 |     | <span class='neutral'>                    }</span>
 406 |     | <span class='neutral'>                }</span>
 407 |     | <span class='neutral'>            }</span>
 408 |     | <span class='neutral'>            default {</span>
 409 |     | <span class='neutral'>                // unsuccess:</span>
 410 |     | <span class='neutral'>                success := 0</span>
 411 |     | <span class='neutral'>            }</span>
 412 |     | <span class='neutral'>        }</span>
 413 |     | <span class='neutral'></span>
 414 |     | <span class='neutral'>        return success;</span>
 415 |     | <span class='neutral'>    }</span>
 416 |     | <span class='neutral'></span>
 417 |     | <span class='neutral'>    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {</span>
 418 |     | <span class='neutral'>        bool success = true;</span>
 419 |     | <span class='neutral'></span>
 420 |     | <span class='neutral'>        assembly {</span>
 421 |     | <span class='neutral'>            // we know _preBytes_offset is 0</span>
 422 |     | <span class='neutral'>            let fslot := sload(_preBytes.slot)</span>
 423 |     | <span class='neutral'>            // Decode the length of the stored array like in concatStorage().</span>
 424 |     | <span class='neutral'>            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)</span>
 425 |     | <span class='neutral'>            let mlength := mload(_postBytes)</span>
 426 |     | <span class='neutral'></span>
 427 |     | <span class='neutral'>            // if lengths don&#39;t match the arrays are not equal</span>
 428 |     | <span class='neutral'>            switch eq(slength, mlength)</span>
 429 |     | <span class='neutral'>            case 1 {</span>
 430 |     | <span class='neutral'>                // slength can contain both the length and contents of the array</span>
 431 |     | <span class='neutral'>                // if length &lt; 32 bytes so let&#39;s prepare for that</span>
 432 |     | <span class='neutral'>                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage</span>
 433 |     | <span class='neutral'>                if iszero(iszero(slength)) {</span>
 434 |     | <span class='neutral'>                    switch lt(slength, 32)</span>
 435 |     | <span class='neutral'>                    case 1 {</span>
 436 |     | <span class='neutral'>                        // blank the last byte which is the length</span>
 437 |     | <span class='neutral'>                        fslot := mul(div(fslot, 0x100), 0x100)</span>
 438 |     | <span class='neutral'></span>
 439 |     | <span class='neutral'>                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {</span>
 440 |     | <span class='neutral'>                            // unsuccess:</span>
 441 |     | <span class='neutral'>                            success := 0</span>
 442 |     | <span class='neutral'>                        }</span>
 443 |     | <span class='neutral'>                    }</span>
 444 |     | <span class='neutral'>                    default {</span>
 445 |     | <span class='neutral'>                        // cb is a circuit breaker in the for loop since there&#39;s</span>
 446 |     | <span class='neutral'>                        //  no said feature for inline assembly loops</span>
 447 |     | <span class='neutral'>                        // cb = 1 - don&#39;t breaker</span>
 448 |     | <span class='neutral'>                        // cb = 0 - break</span>
 449 |     | <span class='neutral'>                        let cb := 1</span>
 450 |     | <span class='neutral'></span>
 451 |     | <span class='neutral'>                        // get the keccak hash to get the contents of the array</span>
 452 |     | <span class='neutral'>                        mstore(0x0, _preBytes.slot)</span>
 453 |     | <span class='neutral'>                        let sc := keccak256(0x0, 0x20)</span>
 454 |     | <span class='neutral'></span>
 455 |     | <span class='neutral'>                        let mc := add(_postBytes, 0x20)</span>
 456 |     | <span class='neutral'>                        let end := add(mc, mlength)</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='neutral'>                        // the next line is the loop condition:</span>
 459 |     | <span class='neutral'>                        // while(uint256(mc &lt; end) + cb == 2)</span>
 460 |     | <span class='neutral'>                        for {</span>
 461 |     | <span class='neutral'></span>
 462 |     | <span class='neutral'>                        } eq(add(lt(mc, end), cb), 2) {</span>
 463 |     | <span class='neutral'>                            sc := add(sc, 1)</span>
 464 |     | <span class='neutral'>                            mc := add(mc, 0x20)</span>
 465 |     | <span class='neutral'>                        } {</span>
 466 |     | <span class='neutral'>                            if iszero(eq(sload(sc), mload(mc))) {</span>
 467 |     | <span class='neutral'>                                // unsuccess:</span>
 468 |     | <span class='neutral'>                                success := 0</span>
 469 |     | <span class='neutral'>                                cb := 0</span>
 470 |     | <span class='neutral'>                            }</span>
 471 |     | <span class='neutral'>                        }</span>
 472 |     | <span class='neutral'>                    }</span>
 473 |     | <span class='neutral'>                }</span>
 474 |     | <span class='neutral'>            }</span>
 475 |     | <span class='neutral'>            default {</span>
 476 |     | <span class='neutral'>                // unsuccess:</span>
 477 |     | <span class='neutral'>                success := 0</span>
 478 |     | <span class='neutral'>            }</span>
 479 |     | <span class='neutral'>        }</span>
 480 |     | <span class='neutral'></span>
 481 |     | <span class='neutral'>        return success;</span>
 482 |     | <span class='neutral'>    }</span>
 483 |     | <span class='neutral'>}</span>
 484 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/libraries/CauldronLib.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import {RebaseLibrary, Rebase} from &quot;BoringSolidity/libraries/BoringRebase.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ICauldronV2} from &quot;interfaces/ICauldronV2.sol&quot;;</span>
   9 |     | <span class='neutral'>import {ICauldronV3} from &quot;interfaces/ICauldronV3.sol&quot;;</span>
  10 |     | <span class='neutral'>import {ICauldronV4} from &quot;interfaces/ICauldronV4.sol&quot;;</span>
  11 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  12 |     | <span class='neutral'>import {MathLib} from &quot;libraries/MathLib.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>library CauldronLib {</span>
  15 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
  16 |     | <span class='neutral'>    using RebaseLibrary for Rebase;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    uint256 internal constant EXCHANGE_RATE_PRECISION = 1e18;</span>
  19 |     | <span class='unexecuted'>    uint256 internal constant BPS_PRECISION = 1e4;</span>
  20 |     | <span class='unexecuted'>    uint256 internal constant COLLATERIZATION_RATE_PRECISION = 1e5;</span>
  21 |     | <span class='unexecuted'>    uint256 internal constant LIQUIDATION_MULTIPLIER_PRECISION = 1e5;</span>
  22 |     | <span class='unexecuted'>    uint256 internal constant DISTRIBUTION_PART = 10;</span>
  23 |     | <span class='unexecuted'>    uint256 internal constant DISTRIBUTION_PRECISION = 100;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /// @dev example: 200 is 2% interests</span>
  26 |     | <span class='neutral'>    function getInterestPerSecond(uint256 interestBips) internal pure returns (uint64 interestsPerSecond) {</span>
  27 |     | <span class='neutral'>        return uint64((interestBips * 316880878) / 100); // 316880878 is the precomputed integral part of 1e18 / (36525 * 3600 * 24)</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>    function getInterestPerYearFromInterestPerSecond(uint64 interestPerSecond) internal pure returns (uint64 interestPerYearBips) {</span>
  31 |     | <span class='unexecuted'>        return (interestPerSecond * 100) / 316880878;</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    function getUserBorrowAmount(ICauldronV2 cauldron, address user) internal view returns (uint256 borrowAmount) {</span>
  35 |     | <span class='unexecuted'>        Rebase memory totalBorrow = getTotalBorrowWithAccruedInterests(cauldron);</span>
  36 |     | <span class='unexecuted'>        return (cauldron.userBorrowPart(user) * totalBorrow.elastic) / totalBorrow.base;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    // total borrow with on-fly accrued interests</span>
  40 |     | <span class='unexecuted'>    function getTotalBorrowWithAccruedInterests(ICauldronV2 cauldron) internal view returns (Rebase memory totalBorrow) {</span>
  41 |     | <span class='unexecuted'>        totalBorrow = cauldron.totalBorrow();</span>
  42 |     | <span class='unexecuted'>        (uint64 lastAccrued, , uint64 INTEREST_PER_SECOND) = cauldron.accrueInfo();</span>
  43 |     | <span class='unexecuted'>        uint256 elapsedTime = block.timestamp - lastAccrued;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>        if (elapsedTime != 0 &amp;&amp; totalBorrow.base != 0) {</span>
  46 |     | <span class='unexecuted'>            totalBorrow.elastic = totalBorrow.elastic + uint128((uint256(totalBorrow.elastic) * INTEREST_PER_SECOND * elapsedTime) / 1e18);</span>
  47 |     | <span class='neutral'>        }</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>    function getOracleExchangeRate(ICauldronV2 cauldron) internal view returns (uint256) {</span>
  51 |     | <span class='unexecuted'>        IOracle oracle = IOracle(cauldron.oracle());</span>
  52 |     | <span class='unexecuted'>        bytes memory oracleData = cauldron.oracleData();</span>
  53 |     | <span class='unexecuted'>        return oracle.peekSpot(oracleData);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>    function getUserCollateral(ICauldronV2 cauldron, address account) internal view returns (uint256 amount, uint256 value) {</span>
  57 |     | <span class='unexecuted'>        IBentoBoxV1 bentoBox = IBentoBoxV1(cauldron.bentoBox());</span>
  58 |     | <span class='unexecuted'>        uint256 share = cauldron.userCollateralShare(account);</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>        amount = bentoBox.toAmount(cauldron.collateral(), share, false);</span>
  61 |     | <span class='unexecuted'>        value = (amount * EXCHANGE_RATE_PRECISION) / getOracleExchangeRate(cauldron);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>    function getUserPositionInfo(</span>
  65 |     | <span class='neutral'>        ICauldronV2 cauldron,</span>
  66 |     | <span class='neutral'>        address account</span>
  67 |     | <span class='neutral'>    )</span>
  68 |     | <span class='neutral'>        internal</span>
  69 |     | <span class='neutral'>        view</span>
  70 |     | <span class='neutral'>        returns (</span>
  71 |     | <span class='unexecuted'>            uint256 ltvBps,</span>
  72 |     | <span class='unexecuted'>            uint256 healthFactor,</span>
  73 |     | <span class='unexecuted'>            uint256 borrowValue,</span>
  74 |     | <span class='unexecuted'>            uint256 collateralValue,</span>
  75 |     | <span class='unexecuted'>            uint256 liquidationPrice,</span>
  76 |     | <span class='unexecuted'>            uint256 collateralAmount</span>
  77 |     | <span class='neutral'>        )</span>
  78 |     | <span class='neutral'>    {</span>
  79 |     | <span class='unexecuted'>        (collateralAmount, collateralValue) = getUserCollateral(cauldron, account);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>        borrowValue = getUserBorrowAmount(cauldron, account);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        if (collateralValue &gt; 0) {</span>
  84 |     | <span class='unexecuted'>            ltvBps = (borrowValue * BPS_PRECISION) / collateralValue;</span>
  85 |     | <span class='unexecuted'>            uint256 COLLATERALIZATION_RATE = cauldron.COLLATERIZATION_RATE(); // 1e5 precision</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>            // example with WBTC (8 decimals)</span>
  88 |     | <span class='neutral'>            // 18 + 8 + 5 - 5 - 8 - 10 = 8 decimals</span>
  89 |     | <span class='unexecuted'>            IERC20 collateral = cauldron.collateral();</span>
  90 |     | <span class='unexecuted'>            uint256 collateralPrecision = 10 ** collateral.safeDecimals();</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>            liquidationPrice =</span>
  93 |     | <span class='unexecuted'>                (borrowValue * collateralPrecision ** 2 * 1e5) /</span>
  94 |     | <span class='unexecuted'>                COLLATERALIZATION_RATE /</span>
  95 |     | <span class='unexecuted'>                collateralAmount /</span>
  96 |     | <span class='neutral'>                EXCHANGE_RATE_PRECISION;</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='unexecuted'>            healthFactor = MathLib.subWithZeroFloor(</span>
  99 |     | <span class='neutral'>                EXCHANGE_RATE_PRECISION,</span>
 100 |     | <span class='unexecuted'>                (EXCHANGE_RATE_PRECISION * liquidationPrice * getOracleExchangeRate(cauldron)) / collateralPrecision ** 2</span>
 101 |     | <span class='neutral'>            );</span>
 102 |     | <span class='neutral'>        }</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /// @notice the liquidator will get &quot;MIM borrowPart&quot; worth of collateral + liquidation fee incentive but borrowPart needs to be adjusted to take in account</span>
 106 |     | <span class='neutral'>    /// the sSpell distribution taken off the liquidation fee. This function takes in account the bad debt repayment in case</span>
 107 |     | <span class='neutral'>    /// the borrowPart give less collateral than it should.</span>
 108 |     | <span class='neutral'>    /// @param cauldron Cauldron contract</span>
 109 |     | <span class='neutral'>    /// @param account Account to liquidate</span>
 110 |     | <span class='neutral'>    /// @param borrowPart Amount of MIM debt to liquidate</span>
 111 |     | <span class='neutral'>    /// @return collateralAmount Amount of collateral that the liquidator will receive</span>
 112 |     | <span class='neutral'>    /// @return adjustedBorrowPart Adjusted borrowPart to take in account position with bad debt where the</span>
 113 |     | <span class='neutral'>    ///                            borrowPart give out more collateral than what the user has.</span>
 114 |     | <span class='neutral'>    /// @return requiredMim MIM amount that the liquidator will need to pay back to get the collateralShare</span>
 115 |     | <span class='unexecuted'>    function getLiquidationCollateralAndBorrowAmount(</span>
 116 |     | <span class='neutral'>        ICauldronV2 cauldron,</span>
 117 |     | <span class='neutral'>        address account,</span>
 118 |     | <span class='neutral'>        uint256 borrowPart</span>
 119 |     | <span class='unexecuted'>    ) internal view returns (uint256 collateralAmount, uint256 adjustedBorrowPart, uint256 requiredMim) {</span>
 120 |     | <span class='unexecuted'>        uint256 exchangeRate = getOracleExchangeRate(cauldron);</span>
 121 |     | <span class='unexecuted'>        Rebase memory totalBorrow = getTotalBorrowWithAccruedInterests(cauldron);</span>
 122 |     | <span class='unexecuted'>        IBentoBoxV1 box = IBentoBoxV1(cauldron.bentoBox());</span>
 123 |     | <span class='unexecuted'>        uint256 collateralShare = cauldron.userCollateralShare(account);</span>
 124 |     | <span class='unexecuted'>        IERC20 collateral = cauldron.collateral();</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>        // cap to the maximum amount of debt that can be liquidated in case the cauldron has bad debt</span>
 127 |     | <span class='neutral'>        {</span>
 128 |     | <span class='unexecuted'>            Rebase memory bentoBoxTotals = box.totals(collateral);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>            // how much debt can be liquidated</span>
 131 |     | <span class='unexecuted'>            uint256 maxBorrowPart = (bentoBoxTotals.toElastic(collateralShare, false) * 1e23) /</span>
 132 |     | <span class='unexecuted'>                (cauldron.LIQUIDATION_MULTIPLIER() * exchangeRate);</span>
 133 |     | <span class='unexecuted'>            maxBorrowPart = totalBorrow.toBase(maxBorrowPart, false);</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='unexecuted'>            if (borrowPart &gt; maxBorrowPart) {</span>
 136 |     | <span class='unexecuted'>                borrowPart = maxBorrowPart;</span>
 137 |     | <span class='neutral'>            }</span>
 138 |     | <span class='neutral'>        }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>        // convert borrowPart to debt</span>
 141 |     | <span class='unexecuted'>        requiredMim = totalBorrow.toElastic(borrowPart, false);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>        // convert borrowPart to collateralShare</span>
 144 |     | <span class='unexecuted'>        {</span>
 145 |     | <span class='unexecuted'>            Rebase memory bentoBoxTotals = box.totals(collateral);</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>            // how much collateral share the liquidator will get from the given borrow amount</span>
 148 |     | <span class='unexecuted'>            collateralShare = bentoBoxTotals.toBase(</span>
 149 |     | <span class='unexecuted'>                (requiredMim * cauldron.LIQUIDATION_MULTIPLIER() * exchangeRate) /</span>
 150 |     | <span class='unexecuted'>                    (LIQUIDATION_MULTIPLIER_PRECISION * EXCHANGE_RATE_PRECISION),</span>
 151 |     | <span class='unexecuted'>                false</span>
 152 |     | <span class='neutral'>            );</span>
 153 |     | <span class='unexecuted'>            collateralAmount = box.toAmount(collateral, collateralShare, false);</span>
 154 |     | <span class='neutral'>        }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>        // add the sSpell distribution part</span>
 157 |     | <span class='neutral'>        {</span>
 158 |     | <span class='unexecuted'>            requiredMim +=</span>
 159 |     | <span class='unexecuted'>                ((((requiredMim * cauldron.LIQUIDATION_MULTIPLIER()) / LIQUIDATION_MULTIPLIER_PRECISION) - requiredMim) *</span>
 160 |     | <span class='neutral'>                    DISTRIBUTION_PART) /</span>
 161 |     | <span class='neutral'>                DISTRIBUTION_PRECISION;</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='unexecuted'>            IERC20 mim = cauldron.magicInternetMoney();</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>            // convert back and forth to amount to compensate for rounded up toShare conversion inside `liquidate`</span>
 166 |     | <span class='unexecuted'>            requiredMim = box.toAmount(mim, box.toShare(mim, requiredMim, true), true);</span>
 167 |     | <span class='neutral'>        }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='unexecuted'>        adjustedBorrowPart = borrowPart;</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='unexecuted'>    function isSolvent(ICauldronV2 cauldron, address account) internal view returns (bool) {</span>
 173 |     | <span class='unexecuted'>        IBentoBoxV1 bentoBox = IBentoBoxV1(cauldron.bentoBox());</span>
 174 |     | <span class='unexecuted'>        Rebase memory totalBorrow = getTotalBorrowWithAccruedInterests(cauldron);</span>
 175 |     | <span class='unexecuted'>        uint256 exchangeRate = getOracleExchangeRate(cauldron);</span>
 176 |     | <span class='unexecuted'>        IERC20 collateral = cauldron.collateral();</span>
 177 |     | <span class='unexecuted'>        uint256 COLLATERIZATION_RATE = cauldron.COLLATERIZATION_RATE();</span>
 178 |     | <span class='unexecuted'>        uint256 collateralShare = cauldron.userCollateralShare(account);</span>
 179 |     | <span class='unexecuted'>        uint256 borrowPart = cauldron.userBorrowPart(account);</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>        if (borrowPart == 0) {</span>
 182 |     | <span class='unexecuted'>            return true;</span>
 183 |     | <span class='unexecuted'>        } else if (collateralShare == 0) {</span>
 184 |     | <span class='unexecuted'>            return false;</span>
 185 |     | <span class='neutral'>        } else {</span>
 186 |     | <span class='unexecuted'>            return</span>
 187 |     | <span class='unexecuted'>                bentoBox.toAmount(</span>
 188 |     | <span class='unexecuted'>                    collateral,</span>
 189 |     | <span class='unexecuted'>                    (collateralShare * (EXCHANGE_RATE_PRECISION / COLLATERIZATION_RATE_PRECISION)) * COLLATERIZATION_RATE,</span>
 190 |     | <span class='unexecuted'>                    false</span>
 191 |     | <span class='unexecuted'>                ) &gt;= (borrowPart * totalBorrow.elastic * exchangeRate) / totalBorrow.base;</span>
 192 |     | <span class='neutral'>        }</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>    function getCollateralPrice(ICauldronV2 cauldron) internal view returns (uint256) {</span>
 196 |     | <span class='unexecuted'>        IERC20 collateral = cauldron.collateral();</span>
 197 |     | <span class='unexecuted'>        uint256 collateralPrecision = 10 ** collateral.safeDecimals();</span>
 198 |     | <span class='unexecuted'>        return (collateralPrecision * collateralPrecision) / getOracleExchangeRate(cauldron);</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>    function decodeInitData(</span>
 202 |     | <span class='neutral'>        bytes calldata data</span>
 203 |     | <span class='neutral'>    )</span>
 204 |     | <span class='neutral'>        internal</span>
 205 |     | <span class='neutral'>        pure</span>
 206 |     | <span class='neutral'>        returns (</span>
 207 |     | <span class='neutral'>            address collateral,</span>
 208 |     | <span class='neutral'>            address oracle,</span>
 209 |     | <span class='neutral'>            bytes memory oracleData,</span>
 210 |     | <span class='neutral'>            uint64 INTEREST_PER_SECOND,</span>
 211 |     | <span class='neutral'>            uint256 LIQUIDATION_MULTIPLIER,</span>
 212 |     | <span class='neutral'>            uint256 COLLATERIZATION_RATE,</span>
 213 |     | <span class='neutral'>            uint256 BORROW_OPENING_FEE</span>
 214 |     | <span class='neutral'>        )</span>
 215 |     | <span class='neutral'>    {</span>
 216 |     | <span class='neutral'>        (collateral, oracle, oracleData, INTEREST_PER_SECOND, LIQUIDATION_MULTIPLIER, COLLATERIZATION_RATE, BORROW_OPENING_FEE) = abi</span>
 217 |     | <span class='neutral'>            .decode(data, (address, address, bytes, uint64, uint256, uint256, uint256));</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'>}</span>
 220 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/libraries/MathLib.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library MathLib {</span>
  5 |     | <span class='neutral'>    function max(uint256[] memory values) internal pure returns (uint256) {</span>
  6 |     | <span class='neutral'>        uint256 maxValue = values[0];</span>
  7 |     | <span class='neutral'>        for (uint256 i = 1; i &lt; values.length; i++) {</span>
  8 |     | <span class='neutral'>            if (values[i] &gt; maxValue) {</span>
  9 |     | <span class='neutral'>                maxValue = values[i];</span>
 10 |     | <span class='neutral'>            }</span>
 11 |     | <span class='neutral'>        }</span>
 12 |     | <span class='neutral'>        return maxValue;</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function max(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 16 |     | <span class='neutral'>        return a &gt; b ? a : b;</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function min(uint256[] memory values) internal pure returns (uint256) {</span>
 20 |     | <span class='unexecuted'>        uint256 minValue = values[0];</span>
 21 |     | <span class='unexecuted'>        for (uint256 i = 1; i &lt; values.length; i++) {</span>
 22 |     | <span class='unexecuted'>            if (values[i] &lt; minValue) {</span>
 23 |     | <span class='unexecuted'>                minValue = values[i];</span>
 24 |     | <span class='neutral'>            }</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='unexecuted'>        return minValue;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>    function min(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 30 |     | <span class='unexecuted'>        return a &lt; b ? a : b;</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='unexecuted'>    function subWithZeroFloor(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 34 |     | <span class='unexecuted'>        return a &gt; b ? a - b : 0;</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/libraries/SafeApproveLib.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>library SafeApproveLib {</span>
  7 |     | <span class='neutral'>    error ErrApproveFailed();</span>
  8 |     | <span class='neutral'>    error ErrApproveFailedWithData(bytes data);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    function safeApprove(</span>
 11 |     | <span class='neutral'>        IERC20 token,</span>
 12 |     | <span class='neutral'>        address to,</span>
 13 |     | <span class='neutral'>        uint256 value</span>
 14 |     | <span class='unexecuted'>    ) internal {</span>
 15 |     | <span class='unexecuted'>        (bool success, bytes memory data) = address(token).call(abi.encodeCall(IERC20.approve, (to, value)));</span>
 16 |     | <span class='unexecuted'>        if (!success) {</span>
 17 |     | <span class='unexecuted'>            revert ErrApproveFailed();</span>
 18 |     | <span class='neutral'>        }</span>
 19 |     | <span class='unexecuted'>        if (data.length != 0 &amp;&amp; !abi.decode(data, (bool))) {</span>
 20 |     | <span class='unexecuted'>            revert ErrApproveFailedWithData(data);</span>
 21 |     | <span class='neutral'>        }</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/libraries/UniswapV2Lib.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IUniswapV2Pair, IUniswapV2Router01} from &quot;interfaces/IUniswapV2.sol&quot;;</span>
   5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {BabylonianLib} from &quot;./BabylonianLib.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/* </span>
  10 |     | <span class='neutral'>The following library is modified from @sushiswap/core/contracts/uniswapv2/libraries/UniswapV2Library.sol</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>changes: </span>
  13 |     | <span class='neutral'>    - remove SafeMathUniswap library and replace all usage of it with basic operations</span>
  14 |     | <span class='neutral'>    - change casting from uint to bytes20 in pair address calculation and shift by 96 bits before casting</span>
  15 |     | <span class='neutral'> */</span>
  16 |     | <span class='unexecuted'>library UniswapV2Library {</span>
  17 |     | <span class='neutral'>    // returns sorted token addresses, used to handle return values from pairs sorted in this order</span>
  18 |     | <span class='unexecuted'>    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {</span>
  19 |     | <span class='unexecuted'>        require(tokenA != tokenB, &quot;UniswapV2Library: IDENTICAL_ADDRESSES&quot;);</span>
  20 |     | <span class='unexecuted'>        (token0, token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span>
  21 |     | <span class='unexecuted'>        require(token0 != address(0), &quot;UniswapV2Library: ZERO_ADDRESS&quot;);</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    // calculates the CREATE2 address for a pair without making any external calls</span>
  25 |     | <span class='unexecuted'>    function pairFor(address factory, address tokenA, address tokenB, bytes32 pairCodeHash) internal pure returns (address pair) {</span>
  26 |     | <span class='unexecuted'>        (address token0, address token1) = sortTokens(tokenA, tokenB);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>        // Since Solidity 0.8.0 explicit conversions from literals larger than type(uint160).max to address are disallowed.</span>
  29 |     | <span class='neutral'>        // https://docs.soliditylang.org/en/develop/080-breaking-changes.html#new-restrictions</span>
  30 |     | <span class='neutral'>        pair = address(</span>
  31 |     | <span class='neutral'>            uint160(</span>
  32 |     | <span class='neutral'>                uint256(</span>
  33 |     | <span class='unexecuted'>                    keccak256(</span>
  34 |     | <span class='unexecuted'>                        abi.encodePacked(</span>
  35 |     | <span class='neutral'>                            hex&quot;ff&quot;,</span>
  36 |     | <span class='unexecuted'>                            factory,</span>
  37 |     | <span class='unexecuted'>                            keccak256(abi.encodePacked(token0, token1)),</span>
  38 |     | <span class='unexecuted'>                            pairCodeHash // init code hash</span>
  39 |     | <span class='neutral'>                        )</span>
  40 |     | <span class='neutral'>                    )</span>
  41 |     | <span class='neutral'>                )</span>
  42 |     | <span class='neutral'>            )</span>
  43 |     | <span class='neutral'>        );</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    // fetches and sorts the reserves for a pair</span>
  47 |     | <span class='neutral'>    function getReserves(</span>
  48 |     | <span class='neutral'>        address factory,</span>
  49 |     | <span class='neutral'>        address tokenA,</span>
  50 |     | <span class='neutral'>        address tokenB,</span>
  51 |     | <span class='neutral'>        bytes32 pairCodeHash</span>
  52 |     | <span class='neutral'>    ) internal view returns (uint256 reserveA, uint256 reserveB) {</span>
  53 |     | <span class='neutral'>        (address token0, ) = sortTokens(tokenA, tokenB);</span>
  54 |     | <span class='neutral'>        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB, pairCodeHash)).getReserves();</span>
  55 |     | <span class='neutral'>        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset</span>
  59 |     | <span class='neutral'>    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) internal pure returns (uint256 amountB) {</span>
  60 |     | <span class='neutral'>        require(amountA &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_AMOUNT&quot;);</span>
  61 |     | <span class='neutral'>        require(reserveA &gt; 0 &amp;&amp; reserveB &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_LIQUIDITY&quot;);</span>
  62 |     | <span class='neutral'>        amountB = (amountA * reserveB) / reserveA;</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset</span>
  66 |     | <span class='unexecuted'>    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) internal pure returns (uint256 amountOut) {</span>
  67 |     | <span class='unexecuted'>        require(amountIn &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT&quot;);</span>
  68 |     | <span class='unexecuted'>        require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_LIQUIDITY&quot;);</span>
  69 |     | <span class='unexecuted'>        uint256 amountInWithFee = amountIn * 997;</span>
  70 |     | <span class='unexecuted'>        uint256 numerator = amountInWithFee * reserveOut;</span>
  71 |     | <span class='unexecuted'>        uint256 denominator = (reserveIn * 1000) + amountInWithFee;</span>
  72 |     | <span class='unexecuted'>        amountOut = numerator / denominator;</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset</span>
  76 |     | <span class='neutral'>    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) internal pure returns (uint256 amountIn) {</span>
  77 |     | <span class='neutral'>        require(amountOut &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT&quot;);</span>
  78 |     | <span class='neutral'>        require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_LIQUIDITY&quot;);</span>
  79 |     | <span class='neutral'>        uint256 numerator = reserveIn * amountOut * 1000;</span>
  80 |     | <span class='neutral'>        uint256 denominator = (reserveOut - amountOut) * 997;</span>
  81 |     | <span class='neutral'>        amountIn = (numerator / denominator) + 1;</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    // performs chained getAmountOut calculations on any number of pairs</span>
  85 |     | <span class='neutral'>    function getAmountsOut(</span>
  86 |     | <span class='neutral'>        address factory,</span>
  87 |     | <span class='neutral'>        uint256 amountIn,</span>
  88 |     | <span class='neutral'>        address[] memory path,</span>
  89 |     | <span class='neutral'>        bytes32 pairCodeHash</span>
  90 |     | <span class='neutral'>    ) internal view returns (uint256[] memory amounts) {</span>
  91 |     | <span class='neutral'>        require(path.length &gt;= 2, &quot;UniswapV2Library: INVALID_PATH&quot;);</span>
  92 |     | <span class='neutral'>        amounts = new uint256[](path.length);</span>
  93 |     | <span class='neutral'>        amounts[0] = amountIn;</span>
  94 |     | <span class='neutral'>        for (uint256 i; i &lt; path.length - 1; i++) {</span>
  95 |     | <span class='neutral'>            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1], pairCodeHash);</span>
  96 |     | <span class='neutral'>            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    // performs chained getAmountIn calculations on any number of pairs</span>
 101 |     | <span class='neutral'>    function getAmountsIn(</span>
 102 |     | <span class='neutral'>        address factory,</span>
 103 |     | <span class='neutral'>        uint256 amountOut,</span>
 104 |     | <span class='neutral'>        address[] memory path,</span>
 105 |     | <span class='neutral'>        bytes32 pairCodeHash</span>
 106 |     | <span class='neutral'>    ) internal view returns (uint256[] memory amounts) {</span>
 107 |     | <span class='neutral'>        require(path.length &gt;= 2, &quot;UniswapV2Library: INVALID_PATH&quot;);</span>
 108 |     | <span class='neutral'>        amounts = new uint256[](path.length);</span>
 109 |     | <span class='neutral'>        amounts[amounts.length - 1] = amountOut;</span>
 110 |     | <span class='neutral'>        for (uint256 i = path.length - 1; i &gt; 0; i--) {</span>
 111 |     | <span class='neutral'>            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i], pairCodeHash);</span>
 112 |     | <span class='neutral'>            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);</span>
 113 |     | <span class='neutral'>        }</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'>}</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>library UniswapV2OneSided {</span>
 118 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    struct AddLiquidityAndOneSideRemainingParams {</span>
 121 |     | <span class='neutral'>        IUniswapV2Router01 router;</span>
 122 |     | <span class='neutral'>        IUniswapV2Pair pair;</span>
 123 |     | <span class='neutral'>        address token0;</span>
 124 |     | <span class='neutral'>        address token1;</span>
 125 |     | <span class='neutral'>        uint256 reserve0;</span>
 126 |     | <span class='neutral'>        uint256 reserve1;</span>
 127 |     | <span class='neutral'>        uint256 token0Amount;</span>
 128 |     | <span class='neutral'>        uint256 token1Amount;</span>
 129 |     | <span class='neutral'>        uint256 minOneSideableAmount0;</span>
 130 |     | <span class='neutral'>        uint256 minOneSideableAmount1;</span>
 131 |     | <span class='neutral'>        address recipient;</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    struct AddLiquidityFromSingleTokenParams {</span>
 135 |     | <span class='neutral'>        IUniswapV2Router01 router;</span>
 136 |     | <span class='neutral'>        IUniswapV2Pair pair;</span>
 137 |     | <span class='neutral'>        address token0;</span>
 138 |     | <span class='neutral'>        address token1;</span>
 139 |     | <span class='neutral'>        uint256 reserve0;</span>
 140 |     | <span class='neutral'>        uint256 reserve1;</span>
 141 |     | <span class='neutral'>        address tokenIn;</span>
 142 |     | <span class='neutral'>        uint256 tokenInAmount;</span>
 143 |     | <span class='neutral'>        address recipient;</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>    function _calculateSwapInAmount(uint256 reserveIn, uint256 userIn) internal pure returns (uint256) {</span>
 147 |     | <span class='unexecuted'>        return (BabylonianLib.sqrt(reserveIn * ((userIn * 3988000) + (reserveIn * 3988009))) - (reserveIn * 1997)) / 1994;</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    function _calculateSwapInAmountUsingCustomFees(</span>
 151 |     | <span class='neutral'>        uint256 reserveIn,</span>
 152 |     | <span class='neutral'>        uint256 amountIn,</span>
 153 |     | <span class='neutral'>        uint256 swapFeeBps</span>
 154 |     | <span class='neutral'>    ) internal pure returns (uint256) {</span>
 155 |     | <span class='neutral'>        uint256 caclulatedFeeA = 20000 - swapFeeBps;</span>
 156 |     | <span class='neutral'>        uint256 caclulatedFeeB = 10000 - swapFeeBps;</span>
 157 |     | <span class='neutral'>        uint256 caclulatedFeeC = 4 * caclulatedFeeB * 10000;</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>        return</span>
 160 |     | <span class='neutral'>            (BabylonianLib.sqrt((caclulatedFeeA * caclulatedFeeA) * (reserveIn * reserveIn) + (caclulatedFeeC * amountIn * reserveIn)) -</span>
 161 |     | <span class='neutral'>                caclulatedFeeA *</span>
 162 |     | <span class='neutral'>                reserveIn) / (2 * caclulatedFeeB);</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='unexecuted'>    function _getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) internal pure returns (uint256 amountOut) {</span>
 166 |     | <span class='unexecuted'>        uint256 amountInWithFee = amountIn * 997;</span>
 167 |     | <span class='unexecuted'>        uint256 numerator = amountInWithFee * reserveOut;</span>
 168 |     | <span class='unexecuted'>        uint256 denominator = (reserveIn * 1000) + amountInWithFee;</span>
 169 |     | <span class='unexecuted'>        amountOut = numerator / denominator;</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='unexecuted'>    function addLiquidityAndOneSideRemaining(</span>
 173 |     | <span class='neutral'>        AddLiquidityAndOneSideRemainingParams memory params</span>
 174 |     | <span class='unexecuted'>    ) internal returns (uint256 idealAmount0, uint256 idealAmount1, uint256 liquidity) {</span>
 175 |     | <span class='unexecuted'>        (idealAmount0, idealAmount1, liquidity) = params.router.addLiquidity(</span>
 176 |     | <span class='unexecuted'>            params.token0,</span>
 177 |     | <span class='unexecuted'>            params.token1,</span>
 178 |     | <span class='unexecuted'>            params.token0Amount,</span>
 179 |     | <span class='unexecuted'>            params.token1Amount,</span>
 180 |     | <span class='neutral'>            0,</span>
 181 |     | <span class='neutral'>            0,</span>
 182 |     | <span class='unexecuted'>            params.recipient,</span>
 183 |     | <span class='neutral'>            type(uint256).max</span>
 184 |     | <span class='neutral'>        );</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='unexecuted'>        params.token0Amount -= idealAmount0;</span>
 187 |     | <span class='unexecuted'>        params.token1Amount -= idealAmount1;</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='unexecuted'>        address oneSideTokenIn;</span>
 190 |     | <span class='neutral'>        uint256 oneSideTokenAmount;</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='unexecuted'>        if (params.token0Amount &gt;= params.minOneSideableAmount0) {</span>
 193 |     | <span class='unexecuted'>            oneSideTokenIn = params.token0;</span>
 194 |     | <span class='unexecuted'>            oneSideTokenAmount = params.token0Amount;</span>
 195 |     | <span class='unexecuted'>        } else if (params.token1Amount &gt; params.minOneSideableAmount1) {</span>
 196 |     | <span class='unexecuted'>            oneSideTokenIn = params.token1;</span>
 197 |     | <span class='unexecuted'>            oneSideTokenAmount = params.token1Amount;</span>
 198 |     | <span class='neutral'>        }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='unexecuted'>        if (oneSideTokenAmount &gt; 0) {</span>
 201 |     | <span class='unexecuted'>            AddLiquidityFromSingleTokenParams memory _addLiquidityFromSingleTokenParams = AddLiquidityFromSingleTokenParams(</span>
 202 |     | <span class='unexecuted'>                params.router,</span>
 203 |     | <span class='unexecuted'>                params.pair,</span>
 204 |     | <span class='unexecuted'>                params.token0,</span>
 205 |     | <span class='unexecuted'>                params.token1,</span>
 206 |     | <span class='unexecuted'>                params.reserve0,</span>
 207 |     | <span class='unexecuted'>                params.reserve1,</span>
 208 |     | <span class='unexecuted'>                oneSideTokenIn,</span>
 209 |     | <span class='unexecuted'>                oneSideTokenAmount,</span>
 210 |     | <span class='unexecuted'>                params.recipient</span>
 211 |     | <span class='neutral'>            );</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='unexecuted'>            (uint256 _idealAmount0, uint256 _idealAmount1, uint256 _liquidity) = addLiquidityFromSingleToken(</span>
 214 |     | <span class='unexecuted'>                _addLiquidityFromSingleTokenParams</span>
 215 |     | <span class='neutral'>            );</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='unexecuted'>            idealAmount0 += _idealAmount0;</span>
 218 |     | <span class='unexecuted'>            idealAmount1 += _idealAmount1;</span>
 219 |     | <span class='unexecuted'>            liquidity += _liquidity;</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='unexecuted'>    function addLiquidityFromSingleToken(</span>
 224 |     | <span class='neutral'>        AddLiquidityFromSingleTokenParams memory params</span>
 225 |     | <span class='unexecuted'>    ) internal returns (uint256 amountA, uint256 amountB, uint256 liquidity) {</span>
 226 |     | <span class='unexecuted'>        if (params.tokenIn == params.token0) {</span>
 227 |     | <span class='unexecuted'>            uint256 tokenInSwapAmount = _calculateSwapInAmount(params.reserve0, params.tokenInAmount);</span>
 228 |     | <span class='unexecuted'>            params.tokenInAmount -= tokenInSwapAmount;</span>
 229 |     | <span class='unexecuted'>            uint256 sideTokenAmount = _getAmountOut(tokenInSwapAmount, params.reserve0, params.reserve1);</span>
 230 |     | <span class='unexecuted'>            IERC20(params.tokenIn).safeTransfer(address(params.pair), tokenInSwapAmount);</span>
 231 |     | <span class='unexecuted'>            params.pair.swap(0, sideTokenAmount, address(this), &quot;&quot;);</span>
 232 |     | <span class='unexecuted'>            return</span>
 233 |     | <span class='unexecuted'>                params.router.addLiquidity(</span>
 234 |     | <span class='unexecuted'>                    params.token0,</span>
 235 |     | <span class='unexecuted'>                    params.token1,</span>
 236 |     | <span class='unexecuted'>                    params.tokenInAmount,</span>
 237 |     | <span class='neutral'>                    sideTokenAmount,</span>
 238 |     | <span class='neutral'>                    0,</span>
 239 |     | <span class='neutral'>                    0,</span>
 240 |     | <span class='unexecuted'>                    params.recipient,</span>
 241 |     | <span class='neutral'>                    type(uint256).max</span>
 242 |     | <span class='neutral'>                );</span>
 243 |     | <span class='neutral'>        } else {</span>
 244 |     | <span class='unexecuted'>            uint256 tokenInSwapAmount = _calculateSwapInAmount(params.reserve1, params.tokenInAmount);</span>
 245 |     | <span class='unexecuted'>            params.tokenInAmount -= tokenInSwapAmount;</span>
 246 |     | <span class='unexecuted'>            uint256 sideTokenAmount = _getAmountOut(tokenInSwapAmount, params.reserve1, params.reserve0);</span>
 247 |     | <span class='unexecuted'>            IERC20(params.tokenIn).safeTransfer(address(params.pair), tokenInSwapAmount);</span>
 248 |     | <span class='unexecuted'>            params.pair.swap(sideTokenAmount, 0, address(this), &quot;&quot;);</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>            return</span>
 251 |     | <span class='unexecuted'>                params.router.addLiquidity(</span>
 252 |     | <span class='unexecuted'>                    params.token0,</span>
 253 |     | <span class='unexecuted'>                    params.token1,</span>
 254 |     | <span class='neutral'>                    sideTokenAmount,</span>
 255 |     | <span class='unexecuted'>                    params.tokenInAmount,</span>
 256 |     | <span class='neutral'>                    0,</span>
 257 |     | <span class='neutral'>                    0,</span>
 258 |     | <span class='unexecuted'>                    params.recipient,</span>
 259 |     | <span class='neutral'>                    type(uint256).max</span>
 260 |     | <span class='neutral'>                );</span>
 261 |     | <span class='neutral'>        }</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'>}</span>
 264 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/MagicLP.sol</b>
<code>
   1 |     | <span class='neutral'>/*</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>    Copyright 2020 DODO ZOO.</span>
   4 |     | <span class='neutral'>    SPDX-License-Identifier: Apache-2.0</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>*/</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>import {Owned} from &quot;solmate/auth/Owned.sol&quot;;</span>
  11 |     | <span class='neutral'>import {IERC20Metadata} from &quot;openzeppelin-contracts/interfaces/IERC20Metadata.sol&quot;;</span>
  12 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solady/utils/SafeTransferLib.sol&quot;;</span>
  13 |     | <span class='neutral'>import {ReentrancyGuard} from &quot;solady/utils/ReentrancyGuard.sol&quot;;</span>
  14 |     | <span class='neutral'>import {ERC20} from &quot;solady/tokens/ERC20.sol&quot;;</span>
  15 |     | <span class='neutral'>import {SafeCastLib} from &quot;solady/utils/SafeCastLib.sol&quot;;</span>
  16 |     | <span class='neutral'>import {DecimalMath} from &quot;/mimswap/libraries/DecimalMath.sol&quot;;</span>
  17 |     | <span class='neutral'>import {Math} from &quot;/mimswap/libraries/Math.sol&quot;;</span>
  18 |     | <span class='neutral'>import {PMMPricing} from &quot;/mimswap/libraries/PMMPricing.sol&quot;;</span>
  19 |     | <span class='neutral'>import {ICallee} from &quot;/mimswap/interfaces/ICallee.sol&quot;;</span>
  20 |     | <span class='neutral'>import {IFeeRateModel} from &quot;/mimswap/interfaces/IFeeRateModel.sol&quot;;</span>
  21 |     | <span class='neutral'>import {IWETH} from &quot;interfaces/IWETH.sol&quot;;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>/// @title MIMSwap MagicLP</span>
  24 |     | <span class='neutral'>/// @author Adapted from DODOEX DSP https://github.com/DODOEX/contractV2/tree/main/contracts/DODOStablePool</span>
  25 | *   | <span class='executed'>contract MagicLP is ERC20, ReentrancyGuard, Owned {</span>
  26 |     | <span class='neutral'>    using Math for uint256;</span>
  27 |     | <span class='neutral'>    using SafeCastLib for uint256;</span>
  28 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);</span>
  31 |     | <span class='neutral'>    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);</span>
  32 |     | <span class='neutral'>    event Swap(address fromToken, address toToken, uint256 fromAmount, uint256 toAmount, address trader, address receiver);</span>
  33 |     | <span class='neutral'>    event FlashLoan(address borrower, address assetTo, uint256 baseAmount, uint256 quoteAmount);</span>
  34 |     | <span class='neutral'>    event RChange(PMMPricing.RState newRState);</span>
  35 |     | <span class='neutral'>    event TokenRescue(address indexed token, address to, uint256 amount);</span>
  36 |     | <span class='neutral'>    event ParametersChanged(uint256 newLpFeeRate, uint256 newI, uint256 newK, uint256 newBaseReserve, uint256 newQuoteReserve);</span>
  37 |     | <span class='neutral'>    event PausedChanged(bool paused);</span>
  38 |     | <span class='neutral'>    event OperatorChanged(address indexed operator, bool status);</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    error ErrInitialized();</span>
  41 |     | <span class='neutral'>    error ErrBaseQuoteSame();</span>
  42 |     | <span class='neutral'>    error ErrInvalidI();</span>
  43 |     | <span class='neutral'>    error ErrInvalidK();</span>
  44 |     | <span class='neutral'>    error ErrExpired();</span>
  45 |     | <span class='neutral'>    error ErrInvalidSignature();</span>
  46 |     | <span class='neutral'>    error ErrFlashLoanFailed();</span>
  47 |     | <span class='neutral'>    error ErrNoBaseInput();</span>
  48 |     | <span class='neutral'>    error ErrZeroAddress();</span>
  49 |     | <span class='neutral'>    error ErrZeroQuoteAmount();</span>
  50 |     | <span class='neutral'>    error ErrZeroQuoteTarget();</span>
  51 |     | <span class='neutral'>    error ErrMintAmountNotEnough();</span>
  52 |     | <span class='neutral'>    error ErrNotEnough();</span>
  53 |     | <span class='neutral'>    error ErrWithdrawNotEnough();</span>
  54 |     | <span class='neutral'>    error ErrSellBackNotAllowed();</span>
  55 |     | <span class='neutral'>    error ErrInvalidLPFeeRate();</span>
  56 |     | <span class='neutral'>    error ErrNotImplementationOwner();</span>
  57 |     | <span class='neutral'>    error ErrNotImplementation();</span>
  58 |     | <span class='neutral'>    error ErrNotClone();</span>
  59 |     | <span class='neutral'>    error ErrNotAllowed();</span>
  60 |     | <span class='neutral'>    error ErrReserveAmountNotEnough();</span>
  61 |     | <span class='neutral'>    error ErrOverflow();</span>
  62 |     | <span class='neutral'>    error ErrNotPaused();</span>
  63 |     | <span class='neutral'>    error ErrNotAllowedImplementationOperator();</span>
  64 |     | <span class='neutral'>    error ErrInvalidTargets();</span>
  65 |     | <span class='neutral'>    </span>
  66 |     | <span class='unexecuted'>    MagicLP public immutable implementation;</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>    uint256 public constant MAX_I = 10 ** 36;</span>
  69 |     | <span class='unexecuted'>    uint256 public constant MAX_K = 10 ** 18;</span>
  70 |     | <span class='unexecuted'>    uint256 public constant MIN_LP_FEE_RATE = 1e14; // 0.01%</span>
  71 |     | <span class='unexecuted'>    uint256 public constant MAX_LP_FEE_RATE = 1e16; // 1%</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    bool internal _INITIALIZED_;</span>
  74 |     | <span class='unexecuted'>    bool public _PAUSED_;</span>
  75 |     | <span class='unexecuted'>    bool public _PROTOCOL_OWNED_POOL_;</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>    address public _BASE_TOKEN_;</span>
  78 |     | <span class='unexecuted'>    address public _QUOTE_TOKEN_;</span>
  79 |     | <span class='unexecuted'>    uint112 public _BASE_RESERVE_;</span>
  80 |     | <span class='unexecuted'>    uint112 public _QUOTE_RESERVE_;</span>
  81 |     | <span class='unexecuted'>    uint32 public _BLOCK_TIMESTAMP_LAST_;</span>
  82 |     | <span class='unexecuted'>    uint256 public _BASE_PRICE_CUMULATIVE_LAST_;</span>
  83 |     | <span class='unexecuted'>    uint112 public _BASE_TARGET_;</span>
  84 |     | <span class='unexecuted'>    uint112 public _QUOTE_TARGET_;</span>
  85 |     | <span class='unexecuted'>    uint32 public _RState_;</span>
  86 |     | <span class='unexecuted'>    IFeeRateModel public _MT_FEE_RATE_MODEL_;</span>
  87 |     | <span class='unexecuted'>    uint256 public _LP_FEE_RATE_;</span>
  88 |     | <span class='unexecuted'>    uint256 public _K_;</span>
  89 |     | <span class='unexecuted'>    uint256 public _I_;</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public operators;</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>    constructor(address owner_) Owned(owner_) {</span>
  94 |     | <span class='unexecuted'>        implementation = this;</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>        // prevents the implementation contract initialization</span>
  97 |     | <span class='unexecuted'>        _INITIALIZED_ = true;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>    function init(</span>
 101 |     | <span class='neutral'>        address baseTokenAddress,</span>
 102 |     | <span class='neutral'>        address quoteTokenAddress,</span>
 103 |     | <span class='neutral'>        uint256 lpFeeRate,</span>
 104 |     | <span class='neutral'>        address mtFeeRateModel,</span>
 105 |     | <span class='neutral'>        uint256 i,</span>
 106 |     | <span class='neutral'>        uint256 k,</span>
 107 |     | <span class='neutral'>        bool protocolOwnedPool</span>
 108 |     | <span class='neutral'>    ) external {</span>
 109 |     | <span class='unexecuted'>        if (_INITIALIZED_) {</span>
 110 |     | <span class='unexecuted'>            revert ErrInitialized();</span>
 111 |     | <span class='neutral'>        }</span>
 112 |     | <span class='unexecuted'>        if (mtFeeRateModel == address(0) || baseTokenAddress == address(0) || quoteTokenAddress == address(0)) {</span>
 113 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 114 |     | <span class='neutral'>        }</span>
 115 |     | <span class='unexecuted'>        if (baseTokenAddress == quoteTokenAddress) {</span>
 116 |     | <span class='unexecuted'>            revert ErrBaseQuoteSame();</span>
 117 |     | <span class='neutral'>        }</span>
 118 |     | <span class='unexecuted'>        if (i == 0 || i &gt; MAX_I) {</span>
 119 |     | <span class='unexecuted'>            revert ErrInvalidI();</span>
 120 |     | <span class='neutral'>        }</span>
 121 |     | <span class='unexecuted'>        if (k &gt; MAX_K) {</span>
 122 |     | <span class='unexecuted'>            revert ErrInvalidK();</span>
 123 |     | <span class='neutral'>        }</span>
 124 |     | <span class='unexecuted'>        if (lpFeeRate &lt; MIN_LP_FEE_RATE || lpFeeRate &gt; MAX_LP_FEE_RATE) {</span>
 125 |     | <span class='unexecuted'>            revert ErrInvalidLPFeeRate();</span>
 126 |     | <span class='neutral'>        }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>        _INITIALIZED_ = true;</span>
 129 |     | <span class='unexecuted'>        _BASE_TOKEN_ = baseTokenAddress;</span>
 130 |     | <span class='unexecuted'>        _QUOTE_TOKEN_ = quoteTokenAddress;</span>
 131 |     | <span class='unexecuted'>        _I_ = i;</span>
 132 |     | <span class='unexecuted'>        _K_ = k;</span>
 133 |     | <span class='unexecuted'>        _LP_FEE_RATE_ = lpFeeRate;</span>
 134 |     | <span class='unexecuted'>        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);</span>
 135 |     | <span class='unexecuted'>        _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2 ** 32);</span>
 136 |     | <span class='unexecuted'>        _PROTOCOL_OWNED_POOL_ = protocolOwnedPool;</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>        _afterInitialized();</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 142 |     | <span class='neutral'>    /// PUBLIC - CLONES ONLY</span>
 143 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='unexecuted'>    function sync() external nonReentrant onlyClones {</span>
 146 |     | <span class='unexecuted'>        _sync();</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='unexecuted'>    function correctRState() external onlyClones {</span>
 150 |     | <span class='unexecuted'>        if (_RState_ == uint32(PMMPricing.RState.BELOW_ONE) &amp;&amp; _BASE_RESERVE_ &lt; _BASE_TARGET_) {</span>
 151 |     | <span class='unexecuted'>            _RState_ = uint32(PMMPricing.RState.ONE);</span>
 152 |     | <span class='unexecuted'>            _BASE_TARGET_ = _BASE_RESERVE_;</span>
 153 |     | <span class='unexecuted'>            _QUOTE_TARGET_ = _QUOTE_RESERVE_;</span>
 154 |     | <span class='neutral'>        }</span>
 155 |     | <span class='unexecuted'>        if (_RState_ == uint32(PMMPricing.RState.ABOVE_ONE) &amp;&amp; _QUOTE_RESERVE_ &lt; _QUOTE_TARGET_) {</span>
 156 |     | <span class='unexecuted'>            _RState_ = uint32(PMMPricing.RState.ONE);</span>
 157 |     | <span class='unexecuted'>            _BASE_TARGET_ = _BASE_RESERVE_;</span>
 158 |     | <span class='unexecuted'>            _QUOTE_TARGET_ = _QUOTE_RESERVE_;</span>
 159 |     | <span class='neutral'>        }</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 163 |     | <span class='neutral'>    /// VIEWS</span>
 164 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>    function name() public view override returns (string memory) {</span>
 167 |     | <span class='unexecuted'>        return string(abi.encodePacked(&quot;MagicLP &quot;, IERC20Metadata(_BASE_TOKEN_).symbol(), &quot;/&quot;, IERC20Metadata(_QUOTE_TOKEN_).symbol()));</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>    function symbol() public pure override returns (string memory) {</span>
 171 |     | <span class='unexecuted'>        return &quot;MagicLP&quot;;</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='unexecuted'>    function decimals() public view override returns (uint8) {</span>
 175 |     | <span class='unexecuted'>        return IERC20Metadata(_BASE_TOKEN_).decimals();</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>    function isImplementationOperator(address _operator) public view returns (bool) {</span>
 179 |     | <span class='unexecuted'>        return implementation.operators(_operator) || _operator == implementation.owner();</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='unexecuted'>    function querySellBase(</span>
 183 |     | <span class='neutral'>        address trader,</span>
 184 |     | <span class='neutral'>        uint256 payBaseAmount</span>
 185 |     | <span class='unexecuted'>    ) public view returns (uint256 receiveQuoteAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newBaseTarget) {</span>
 186 |     | <span class='unexecuted'>        PMMPricing.PMMState memory state = getPMMState();</span>
 187 |     | <span class='unexecuted'>        (receiveQuoteAmount, newRState) = PMMPricing.sellBaseToken(state, payBaseAmount);</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='unexecuted'>        (uint256 lpFeeRate, uint256 mtFeeRate) = _MT_FEE_RATE_MODEL_.getFeeRate(trader, _LP_FEE_RATE_);</span>
 190 |     | <span class='unexecuted'>        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);</span>
 191 |     | <span class='unexecuted'>        receiveQuoteAmount = receiveQuoteAmount - DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate) - mtFee;</span>
 192 |     | <span class='unexecuted'>        newBaseTarget = state.B0;</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>    function querySellQuote(</span>
 196 |     | <span class='neutral'>        address trader,</span>
 197 |     | <span class='neutral'>        uint256 payQuoteAmount</span>
 198 |     | <span class='unexecuted'>    ) public view returns (uint256 receiveBaseAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newQuoteTarget) {</span>
 199 |     | <span class='unexecuted'>        PMMPricing.PMMState memory state = getPMMState();</span>
 200 |     | <span class='unexecuted'>        (receiveBaseAmount, newRState) = PMMPricing.sellQuoteToken(state, payQuoteAmount);</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>        (uint256 lpFeeRate, uint256 mtFeeRate) = _MT_FEE_RATE_MODEL_.getFeeRate(trader, _LP_FEE_RATE_);</span>
 203 |     | <span class='unexecuted'>        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);</span>
 204 |     | <span class='unexecuted'>        receiveBaseAmount = receiveBaseAmount - DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate) - mtFee;</span>
 205 |     | <span class='unexecuted'>        newQuoteTarget = state.Q0;</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='unexecuted'>    function getPMMState() public view returns (PMMPricing.PMMState memory state) {</span>
 209 |     | <span class='unexecuted'>        state.i = _I_;</span>
 210 |     | <span class='unexecuted'>        state.K = _K_;</span>
 211 |     | <span class='unexecuted'>        state.B = _BASE_RESERVE_;</span>
 212 |     | <span class='unexecuted'>        state.Q = _QUOTE_RESERVE_;</span>
 213 |     | <span class='unexecuted'>        state.B0 = _BASE_TARGET_; // will be calculated in adjustedTarget</span>
 214 |     | <span class='unexecuted'>        state.Q0 = _QUOTE_TARGET_;</span>
 215 |     | <span class='unexecuted'>        state.R = PMMPricing.RState(_RState_);</span>
 216 |     | <span class='unexecuted'>        PMMPricing.adjustedTarget(state);</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='unexecuted'>    function getPMMStateForCall() external view returns (uint256 i, uint256 K, uint256 B, uint256 Q, uint256 B0, uint256 Q0, uint256 R) {</span>
 220 |     | <span class='unexecuted'>        PMMPricing.PMMState memory state = getPMMState();</span>
 221 |     | <span class='unexecuted'>        i = state.i;</span>
 222 |     | <span class='unexecuted'>        K = state.K;</span>
 223 |     | <span class='unexecuted'>        B = state.B;</span>
 224 |     | <span class='unexecuted'>        Q = state.Q;</span>
 225 |     | <span class='unexecuted'>        B0 = state.B0;</span>
 226 |     | <span class='unexecuted'>        Q0 = state.Q0;</span>
 227 |     | <span class='unexecuted'>        R = uint256(state.R);</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='unexecuted'>    function getMidPrice() public view returns (uint256 midPrice) {</span>
 231 |     | <span class='unexecuted'>        return PMMPricing.getMidPrice(getPMMState());</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='unexecuted'>    function getReserves() external view returns (uint256 baseReserve, uint256 quoteReserve) {</span>
 235 |     | <span class='unexecuted'>        baseReserve = _BASE_RESERVE_;</span>
 236 |     | <span class='unexecuted'>        quoteReserve = _QUOTE_RESERVE_;</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='unexecuted'>    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate) {</span>
 240 |     | <span class='unexecuted'>        return _MT_FEE_RATE_MODEL_.getFeeRate(user, _LP_FEE_RATE_);</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='unexecuted'>    function getBaseInput() public view nonReadReentrant returns (uint256 input) {</span>
 244 |     | <span class='unexecuted'>        return _BASE_TOKEN_.balanceOf(address(this)) - uint256(_BASE_RESERVE_);</span>
 245 |     | <span class='neutral'>    }</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='unexecuted'>    function getQuoteInput() public view nonReadReentrant returns (uint256 input) {</span>
 248 |     | <span class='unexecuted'>        return _QUOTE_TOKEN_.balanceOf(address(this)) - uint256(_QUOTE_RESERVE_);</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='unexecuted'>    function version() external pure virtual returns (string memory) {</span>
 252 |     | <span class='unexecuted'>        return &quot;MagicLP 1.0.0&quot;;</span>
 253 |     | <span class='neutral'>    }</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 256 |     | <span class='neutral'>    /// TRADE FUNCTIONS</span>
 257 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='unexecuted'>    function sellBase(address to) external nonReentrant onlyClones whenNotPaused returns (uint256 receiveQuoteAmount) {</span>
 260 |     | <span class='unexecuted'>        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));</span>
 261 |     | <span class='unexecuted'>        uint256 baseInput = baseBalance - uint256(_BASE_RESERVE_);</span>
 262 |     | <span class='unexecuted'>        uint256 mtFee;</span>
 263 |     | <span class='unexecuted'>        uint256 newBaseTarget;</span>
 264 |     | <span class='unexecuted'>        PMMPricing.RState newRState;</span>
 265 |     | <span class='unexecuted'>        (receiveQuoteAmount, mtFee, newRState, newBaseTarget) = querySellBase(tx.origin, baseInput);</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='unexecuted'>        _transferQuoteOut(to, receiveQuoteAmount);</span>
 268 |     | <span class='unexecuted'>        _transferQuoteOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>        // update TARGET</span>
 271 |     | <span class='unexecuted'>        if (_RState_ != uint32(newRState)) {</span>
 272 |     | <span class='unexecuted'>            _BASE_TARGET_ = newBaseTarget.toUint112();</span>
 273 |     | <span class='unexecuted'>            _RState_ = uint32(newRState);</span>
 274 |     | <span class='unexecuted'>            emit RChange(newRState);</span>
 275 |     | <span class='neutral'>        }</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)));</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='unexecuted'>        emit Swap(address(_BASE_TOKEN_), address(_QUOTE_TOKEN_), baseInput, receiveQuoteAmount, msg.sender, to);</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='unexecuted'>    function sellQuote(address to) external nonReentrant onlyClones whenNotPaused returns (uint256 receiveBaseAmount) {</span>
 283 |     | <span class='unexecuted'>        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));</span>
 284 |     | <span class='unexecuted'>        uint256 quoteInput = quoteBalance - uint256(_QUOTE_RESERVE_);</span>
 285 |     | <span class='unexecuted'>        uint256 mtFee;</span>
 286 |     | <span class='unexecuted'>        uint256 newQuoteTarget;</span>
 287 |     | <span class='unexecuted'>        PMMPricing.RState newRState;</span>
 288 |     | <span class='unexecuted'>        (receiveBaseAmount, mtFee, newRState, newQuoteTarget) = querySellQuote(tx.origin, quoteInput);</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='unexecuted'>        _transferBaseOut(to, receiveBaseAmount);</span>
 291 |     | <span class='unexecuted'>        _transferBaseOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);</span>
 292 |     | <span class='neutral'></span>
 293 |     | <span class='neutral'>        // update TARGET</span>
 294 |     | <span class='unexecuted'>        if (_RState_ != uint32(newRState)) {</span>
 295 |     | <span class='unexecuted'>            _QUOTE_TARGET_ = newQuoteTarget.toUint112();</span>
 296 |     | <span class='unexecuted'>            _RState_ = uint32(newRState);</span>
 297 |     | <span class='unexecuted'>            emit RChange(newRState);</span>
 298 |     | <span class='neutral'>        }</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='unexecuted'>        _setReserve(_BASE_TOKEN_.balanceOf(address(this)), quoteBalance);</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='unexecuted'>        emit Swap(address(_QUOTE_TOKEN_), address(_BASE_TOKEN_), quoteInput, receiveBaseAmount, msg.sender, to);</span>
 303 |     | <span class='neutral'>    }</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='unexecuted'>    function flashLoan(uint256 baseAmount, uint256 quoteAmount, address assetTo, bytes calldata data) external nonReentrant onlyClones whenNotPaused {</span>
 306 |     | <span class='unexecuted'>        _transferBaseOut(assetTo, baseAmount);</span>
 307 |     | <span class='unexecuted'>        _transferQuoteOut(assetTo, quoteAmount);</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='unexecuted'>        if (data.length &gt; 0) {</span>
 310 |     | <span class='unexecuted'>            ICallee(assetTo).FlashLoanCall(msg.sender, baseAmount, quoteAmount, data);</span>
 311 |     | <span class='neutral'>        }</span>
 312 |     | <span class='neutral'></span>
 313 |     | <span class='unexecuted'>        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));</span>
 314 |     | <span class='unexecuted'>        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>        // no input -&gt; pure loss</span>
 317 |     | <span class='unexecuted'>        if (baseBalance &lt; _BASE_RESERVE_ &amp;&amp; quoteBalance &lt; _QUOTE_RESERVE_) {</span>
 318 |     | <span class='unexecuted'>            revert ErrFlashLoanFailed();</span>
 319 |     | <span class='neutral'>        }</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='neutral'>        // sell quote case</span>
 322 |     | <span class='neutral'>        // quote input + base output</span>
 323 |     | <span class='unexecuted'>        if (baseBalance &lt; _BASE_RESERVE_) {</span>
 324 |     | <span class='unexecuted'>            uint256 quoteInput = quoteBalance - uint256(_QUOTE_RESERVE_);</span>
 325 |     | <span class='unexecuted'>            (uint256 receiveBaseAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newQuoteTarget) = querySellQuote(</span>
 326 |     | <span class='unexecuted'>                tx.origin,</span>
 327 |     | <span class='unexecuted'>                quoteInput</span>
 328 |     | <span class='neutral'>            );</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='unexecuted'>            if (uint256(_BASE_RESERVE_) - baseBalance &gt; receiveBaseAmount) {</span>
 331 |     | <span class='unexecuted'>                revert ErrFlashLoanFailed();</span>
 332 |     | <span class='neutral'>            }</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='unexecuted'>            _transferBaseOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);</span>
 335 |     | <span class='unexecuted'>            if (_RState_ != uint32(newRState)) {</span>
 336 |     | <span class='unexecuted'>                _QUOTE_TARGET_ = newQuoteTarget.toUint112();</span>
 337 |     | <span class='unexecuted'>                _RState_ = uint32(newRState);</span>
 338 |     | <span class='unexecuted'>                emit RChange(newRState);</span>
 339 |     | <span class='neutral'>            }</span>
 340 |     | <span class='unexecuted'>            emit Swap(address(_QUOTE_TOKEN_), address(_BASE_TOKEN_), quoteInput, receiveBaseAmount, msg.sender, assetTo);</span>
 341 |     | <span class='neutral'>        }</span>
 342 |     | <span class='neutral'></span>
 343 |     | <span class='neutral'>        // sell base case</span>
 344 |     | <span class='neutral'>        // base input + quote output</span>
 345 |     | <span class='unexecuted'>        if (quoteBalance &lt; _QUOTE_RESERVE_) {</span>
 346 |     | <span class='unexecuted'>            uint256 baseInput = baseBalance - uint256(_BASE_RESERVE_);</span>
 347 |     | <span class='unexecuted'>            (uint256 receiveQuoteAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newBaseTarget) = querySellBase(</span>
 348 |     | <span class='unexecuted'>                tx.origin,</span>
 349 |     | <span class='unexecuted'>                baseInput</span>
 350 |     | <span class='neutral'>            );</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='unexecuted'>            if (uint256(_QUOTE_RESERVE_) - quoteBalance &gt; receiveQuoteAmount) {</span>
 353 |     | <span class='unexecuted'>                revert ErrFlashLoanFailed();</span>
 354 |     | <span class='neutral'>            }</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='unexecuted'>            _transferQuoteOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);</span>
 357 |     | <span class='unexecuted'>            if (_RState_ != uint32(newRState)) {</span>
 358 |     | <span class='unexecuted'>                _BASE_TARGET_ = newBaseTarget.toUint112();</span>
 359 |     | <span class='unexecuted'>                _RState_ = uint32(newRState);</span>
 360 |     | <span class='unexecuted'>                emit RChange(newRState);</span>
 361 |     | <span class='neutral'>            }</span>
 362 |     | <span class='unexecuted'>            emit Swap(address(_BASE_TOKEN_), address(_QUOTE_TOKEN_), baseInput, receiveQuoteAmount, msg.sender, assetTo);</span>
 363 |     | <span class='neutral'>        }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='unexecuted'>        _sync();</span>
 366 |     | <span class='neutral'></span>
 367 |     | <span class='unexecuted'>        emit FlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);</span>
 368 |     | <span class='neutral'>    }</span>
 369 |     | <span class='neutral'></span>
 370 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 371 |     | <span class='neutral'>    /// BUY &amp; SELL SHARES</span>
 372 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 373 |     | <span class='neutral'></span>
 374 |     | <span class='neutral'>    // buy shares [round down]</span>
 375 |     | <span class='unexecuted'>    function buyShares(address to) external nonReentrant onlyClones whenNotPaused returns (uint256 shares, uint256 baseInput, uint256 quoteInput) {</span>
 376 |     | <span class='unexecuted'>        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));</span>
 377 |     | <span class='unexecuted'>        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));</span>
 378 |     | <span class='unexecuted'>        uint256 baseReserve = _BASE_RESERVE_;</span>
 379 |     | <span class='unexecuted'>        uint256 quoteReserve = _QUOTE_RESERVE_;</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='unexecuted'>        baseInput = baseBalance - baseReserve;</span>
 382 |     | <span class='unexecuted'>        quoteInput = quoteBalance - quoteReserve;</span>
 383 |     | <span class='neutral'></span>
 384 |     | <span class='unexecuted'>        if (baseInput == 0) {</span>
 385 |     | <span class='unexecuted'>            revert ErrNoBaseInput();</span>
 386 |     | <span class='neutral'>        }</span>
 387 |     | <span class='neutral'></span>
 388 |     | <span class='neutral'>        // Round down when withdrawing. Therefore, never be a situation occurring balance is 0 but totalsupply is not 0</span>
 389 |     | <span class='neutral'>        // But May Happenreserve &gt;0 But totalSupply = 0</span>
 390 |     | <span class='unexecuted'>        if (totalSupply() == 0) {</span>
 391 |     | <span class='neutral'>            // case 1. initial supply</span>
 392 |     | <span class='unexecuted'>            if (quoteBalance == 0) {</span>
 393 |     | <span class='unexecuted'>                revert ErrZeroQuoteAmount();</span>
 394 |     | <span class='neutral'>            }</span>
 395 |     | <span class='neutral'></span>
 396 |     | <span class='unexecuted'>            shares = quoteBalance &lt; DecimalMath.mulFloor(baseBalance, _I_) ? DecimalMath.divFloor(quoteBalance, _I_) : baseBalance;</span>
 397 |     | <span class='unexecuted'>            _BASE_TARGET_ = shares.toUint112();</span>
 398 |     | <span class='unexecuted'>            _QUOTE_TARGET_ = DecimalMath.mulFloor(shares, _I_).toUint112();</span>
 399 |     | <span class='neutral'></span>
 400 |     | <span class='unexecuted'>            if (_QUOTE_TARGET_ == 0) {</span>
 401 |     | <span class='unexecuted'>                revert ErrZeroQuoteTarget();</span>
 402 |     | <span class='neutral'>            }</span>
 403 |     | <span class='neutral'></span>
 404 |     | <span class='unexecuted'>            if (shares &lt;= 2001) {</span>
 405 |     | <span class='unexecuted'>                revert ErrMintAmountNotEnough();</span>
 406 |     | <span class='neutral'>            }</span>
 407 |     | <span class='neutral'></span>
 408 |     | <span class='unexecuted'>            _mint(address(0), 1001);</span>
 409 |     | <span class='unexecuted'>            shares -= 1001;</span>
 410 |     | <span class='unexecuted'>        } else if (baseReserve &gt; 0 &amp;&amp; quoteReserve &gt; 0) {</span>
 411 |     | <span class='neutral'>            // case 2. normal case</span>
 412 |     | <span class='unexecuted'>            uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);</span>
 413 |     | <span class='unexecuted'>            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);</span>
 414 |     | <span class='unexecuted'>            uint256 mintRatio = quoteInputRatio &lt; baseInputRatio ? quoteInputRatio : baseInputRatio;</span>
 415 |     | <span class='unexecuted'>            shares = DecimalMath.mulFloor(totalSupply(), mintRatio);</span>
 416 |     | <span class='neutral'></span>
 417 |     | <span class='unexecuted'>            _BASE_TARGET_ = (uint256(_BASE_TARGET_) + DecimalMath.mulFloor(uint256(_BASE_TARGET_), mintRatio)).toUint112();</span>
 418 |     | <span class='unexecuted'>            _QUOTE_TARGET_ = (uint256(_QUOTE_TARGET_) + DecimalMath.mulFloor(uint256(_QUOTE_TARGET_), mintRatio)).toUint112();</span>
 419 |     | <span class='neutral'>        }</span>
 420 |     | <span class='neutral'></span>
 421 |     | <span class='unexecuted'>        _mint(to, shares);</span>
 422 |     | <span class='unexecuted'>        _setReserve(baseBalance, quoteBalance);</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='unexecuted'>        emit BuyShares(to, shares, balanceOf(to));</span>
 425 |     | <span class='neutral'>    }</span>
 426 |     | <span class='neutral'></span>
 427 |     | <span class='neutral'>    // sell shares [round down]</span>
 428 |     | <span class='unexecuted'>    function sellShares(</span>
 429 |     | <span class='neutral'>        uint256 shareAmount,</span>
 430 |     | <span class='neutral'>        address to,</span>
 431 |     | <span class='neutral'>        uint256 baseMinAmount,</span>
 432 |     | <span class='neutral'>        uint256 quoteMinAmount,</span>
 433 |     | <span class='neutral'>        bytes calldata data,</span>
 434 |     | <span class='neutral'>        uint256 deadline</span>
 435 |     | <span class='unexecuted'>    ) external nonReentrant onlyClones whenNotPaused returns (uint256 baseAmount, uint256 quoteAmount) {</span>
 436 |     | <span class='unexecuted'>        if (deadline &lt; block.timestamp) {</span>
 437 |     | <span class='unexecuted'>            revert ErrExpired();</span>
 438 |     | <span class='neutral'>        }</span>
 439 |     | <span class='unexecuted'>        if (shareAmount &gt; balanceOf(msg.sender)) {</span>
 440 |     | <span class='unexecuted'>            revert ErrNotEnough();</span>
 441 |     | <span class='neutral'>        }</span>
 442 |     | <span class='unexecuted'>        if (to == address(this)) {</span>
 443 |     | <span class='unexecuted'>            revert ErrSellBackNotAllowed();</span>
 444 |     | <span class='neutral'>        }</span>
 445 |     | <span class='neutral'></span>
 446 |     | <span class='unexecuted'>        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));</span>
 447 |     | <span class='unexecuted'>        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));</span>
 448 |     | <span class='unexecuted'>        uint256 totalShares = totalSupply();</span>
 449 |     | <span class='neutral'></span>
 450 |     | <span class='unexecuted'>        baseAmount = (baseBalance * shareAmount) / totalShares;</span>
 451 |     | <span class='unexecuted'>        quoteAmount = (quoteBalance * shareAmount) / totalShares;</span>
 452 |     | <span class='neutral'></span>
 453 |     | <span class='unexecuted'>        _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_) - (uint256(_BASE_TARGET_) * shareAmount).divCeil(totalShares));</span>
 454 |     | <span class='unexecuted'>        _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_) - (uint256(_QUOTE_TARGET_) * shareAmount).divCeil(totalShares));</span>
 455 |     | <span class='neutral'></span>
 456 |     | <span class='unexecuted'>        if (baseAmount &lt; baseMinAmount || quoteAmount &lt; quoteMinAmount) {</span>
 457 |     | <span class='unexecuted'>            revert ErrWithdrawNotEnough();</span>
 458 |     | <span class='neutral'>        }</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='unexecuted'>        _burn(msg.sender, shareAmount);</span>
 461 |     | <span class='unexecuted'>        _transferBaseOut(to, baseAmount);</span>
 462 |     | <span class='unexecuted'>        _transferQuoteOut(to, quoteAmount);</span>
 463 |     | <span class='unexecuted'>        _sync();</span>
 464 |     | <span class='neutral'></span>
 465 |     | <span class='unexecuted'>        if (data.length &gt; 0) {</span>
 466 |     | <span class='unexecuted'>            ICallee(to).SellShareCall(msg.sender, shareAmount, baseAmount, quoteAmount, data);</span>
 467 |     | <span class='neutral'>        }</span>
 468 |     | <span class='neutral'></span>
 469 |     | <span class='unexecuted'>        emit SellShares(msg.sender, to, shareAmount, balanceOf(msg.sender));</span>
 470 |     | <span class='neutral'>    }</span>
 471 |     | <span class='neutral'></span>
 472 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 473 |     | <span class='neutral'>    /// ADMIN - IMPLEMENTATION ONLY</span>
 474 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 475 |     | <span class='neutral'></span>
 476 |     | <span class='unexecuted'>    function setOperator(address _operator, bool _status) external onlyImplementation onlyImplementationOwner {</span>
 477 |     | <span class='unexecuted'>        operators[_operator] = _status;</span>
 478 |     | <span class='unexecuted'>        emit OperatorChanged(_operator, _status);</span>
 479 |     | <span class='neutral'>    }</span>
 480 |     | <span class='neutral'></span>
 481 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 482 |     | <span class='neutral'>    /// OPERATORS / ADMIN - PROTOCOL OWNED POOL AND CLONES ONLY</span>
 483 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 484 |     | <span class='neutral'></span>
 485 |     | <span class='unexecuted'>    function setPaused(bool paused) external onlyClones onlyProtocolOwnedPool onlyImplementationOperators {</span>
 486 |     | <span class='unexecuted'>        _PAUSED_ = paused;</span>
 487 |     | <span class='unexecuted'>        emit PausedChanged(paused);</span>
 488 |     | <span class='neutral'>    }</span>
 489 |     | <span class='neutral'></span>
 490 |     | <span class='unexecuted'>    function rescue(address token, address to, uint256 amount) external onlyClones onlyProtocolOwnedPool onlyImplementationOperators {</span>
 491 |     | <span class='unexecuted'>        if (token == _BASE_TOKEN_ || token == _QUOTE_TOKEN_) {</span>
 492 |     | <span class='unexecuted'>            revert ErrNotAllowed();</span>
 493 |     | <span class='neutral'>        }</span>
 494 |     | <span class='neutral'></span>
 495 |     | <span class='unexecuted'>        token.safeTransfer(to, amount);</span>
 496 |     | <span class='unexecuted'>        emit TokenRescue(token, to, amount);</span>
 497 |     | <span class='neutral'>    }</span>
 498 |     | <span class='neutral'></span>
 499 |     | <span class='neutral'>    /// @notice Set new parameters for the pool</span>
 500 |     | <span class='neutral'>    /// The pool must be paused, preferably blocks earlier to avoid sandwiching</span>
 501 |     | <span class='unexecuted'>    function setParameters(</span>
 502 |     | <span class='neutral'>        address assetTo,</span>
 503 |     | <span class='neutral'>        uint256 newLpFeeRate,</span>
 504 |     | <span class='neutral'>        uint256 newI,</span>
 505 |     | <span class='neutral'>        uint256 newK,</span>
 506 |     | <span class='neutral'>        uint256 baseOutAmount,</span>
 507 |     | <span class='neutral'>        uint256 quoteOutAmount,</span>
 508 |     | <span class='neutral'>        uint256 minBaseReserve,</span>
 509 |     | <span class='neutral'>        uint256 minQuoteReserve</span>
 510 |     | <span class='unexecuted'>    ) public nonReentrant onlyClones whenPaused onlyProtocolOwnedPool onlyImplementationOperators {</span>
 511 |     | <span class='unexecuted'>        if (_BASE_RESERVE_ &lt; minBaseReserve || _QUOTE_RESERVE_ &lt; minQuoteReserve) {</span>
 512 |     | <span class='unexecuted'>            revert ErrReserveAmountNotEnough();</span>
 513 |     | <span class='neutral'>        }</span>
 514 |     | <span class='unexecuted'>        if (newI == 0 || newI &gt; MAX_I) {</span>
 515 |     | <span class='unexecuted'>            revert ErrInvalidI();</span>
 516 |     | <span class='neutral'>        }</span>
 517 |     | <span class='unexecuted'>        if (newK &gt; MAX_K) {</span>
 518 |     | <span class='unexecuted'>            revert ErrInvalidK();</span>
 519 |     | <span class='neutral'>        }</span>
 520 |     | <span class='unexecuted'>        if (newLpFeeRate &lt; MIN_LP_FEE_RATE || newLpFeeRate &gt; MAX_LP_FEE_RATE) {</span>
 521 |     | <span class='unexecuted'>            revert ErrInvalidLPFeeRate();</span>
 522 |     | <span class='neutral'>        }</span>
 523 |     | <span class='neutral'></span>
 524 |     | <span class='unexecuted'>        _LP_FEE_RATE_ = newLpFeeRate;</span>
 525 |     | <span class='unexecuted'>        _K_ = newK;</span>
 526 |     | <span class='unexecuted'>        _I_ = newI;</span>
 527 |     | <span class='neutral'></span>
 528 |     | <span class='unexecuted'>        _transferBaseOut(assetTo, baseOutAmount);</span>
 529 |     | <span class='unexecuted'>        _transferQuoteOut(assetTo, quoteOutAmount);</span>
 530 |     | <span class='unexecuted'>        (uint256 newBaseBalance, uint256 newQuoteBalance) = _resetTargetAndReserve();</span>
 531 |     | <span class='neutral'></span>
 532 |     | <span class='unexecuted'>        emit ParametersChanged(newLpFeeRate, newI, newK, newBaseBalance, newQuoteBalance);</span>
 533 |     | <span class='neutral'>    }</span>
 534 |     | <span class='neutral'></span>
 535 |     | <span class='unexecuted'>    function ratioSync() external nonReentrant onlyClones onlyProtocolOwnedPool onlyImplementationOperators {</span>
 536 |     | <span class='unexecuted'>        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));</span>
 537 |     | <span class='unexecuted'>        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));</span>
 538 |     | <span class='neutral'></span>
 539 |     | <span class='unexecuted'>        if (baseBalance &gt; type(uint112).max || quoteBalance &gt; type(uint112).max) {</span>
 540 |     | <span class='unexecuted'>            revert ErrOverflow();</span>
 541 |     | <span class='neutral'>        }</span>
 542 |     | <span class='neutral'></span>
 543 |     | <span class='unexecuted'>        if (baseBalance != _BASE_RESERVE_) {</span>
 544 |     | <span class='unexecuted'>            _BASE_TARGET_ = uint112((uint256(_BASE_TARGET_) * baseBalance) / uint256(_BASE_RESERVE_));</span>
 545 |     | <span class='unexecuted'>            _BASE_RESERVE_ = uint112(baseBalance);</span>
 546 |     | <span class='neutral'>        }</span>
 547 |     | <span class='unexecuted'>        if (quoteBalance != _QUOTE_RESERVE_) {</span>
 548 |     | <span class='unexecuted'>            _QUOTE_TARGET_ = uint112((uint256(_QUOTE_TARGET_) * quoteBalance) / uint256(_QUOTE_RESERVE_));</span>
 549 |     | <span class='unexecuted'>            _QUOTE_RESERVE_ = uint112(quoteBalance);</span>
 550 |     | <span class='neutral'>        }</span>
 551 |     | <span class='neutral'></span>
 552 |     | <span class='unexecuted'>        if(_BASE_TARGET_ == 0 || _QUOTE_TARGET_ == 0) {</span>
 553 |     | <span class='unexecuted'>            revert ErrInvalidTargets();</span>
 554 |     | <span class='neutral'>        }</span>
 555 |     | <span class='neutral'></span>
 556 |     | <span class='unexecuted'>        _twapUpdate();</span>
 557 |     | <span class='neutral'>    }</span>
 558 |     | <span class='neutral'></span>
 559 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 560 |     | <span class='neutral'>    /// INTERNALS</span>
 561 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 562 |     | <span class='neutral'></span>
 563 |     | <span class='unexecuted'>    function _resetTargetAndReserve() internal returns (uint256 baseBalance, uint256 quoteBalance) {</span>
 564 |     | <span class='unexecuted'>        baseBalance = _BASE_TOKEN_.balanceOf(address(this));</span>
 565 |     | <span class='unexecuted'>        quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));</span>
 566 |     | <span class='neutral'></span>
 567 |     | <span class='unexecuted'>        if (baseBalance &gt; type(uint112).max || quoteBalance &gt; type(uint112).max) {</span>
 568 |     | <span class='unexecuted'>            revert ErrOverflow();</span>
 569 |     | <span class='neutral'>        }</span>
 570 |     | <span class='neutral'></span>
 571 |     | <span class='unexecuted'>        _BASE_RESERVE_ = uint112(baseBalance);</span>
 572 |     | <span class='unexecuted'>        _QUOTE_RESERVE_ = uint112(quoteBalance);</span>
 573 |     | <span class='unexecuted'>        _BASE_TARGET_ = uint112(baseBalance);</span>
 574 |     | <span class='unexecuted'>        _QUOTE_TARGET_ = uint112(quoteBalance);</span>
 575 |     | <span class='unexecuted'>        _RState_ = uint32(PMMPricing.RState.ONE);</span>
 576 |     | <span class='neutral'></span>
 577 |     | <span class='unexecuted'>        _twapUpdate();</span>
 578 |     | <span class='neutral'>    }</span>
 579 |     | <span class='neutral'></span>
 580 |     | <span class='unexecuted'>    function _twapUpdate() internal {</span>
 581 |     | <span class='unexecuted'>        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);</span>
 582 |     | <span class='unexecuted'>        uint32 timeElapsed = blockTimestamp - _BLOCK_TIMESTAMP_LAST_;</span>
 583 |     | <span class='neutral'></span>
 584 |     | <span class='unexecuted'>        if (timeElapsed &gt; 0 &amp;&amp; _BASE_RESERVE_ != 0 &amp;&amp; _QUOTE_RESERVE_ != 0) {</span>
 585 |     | <span class='neutral'>            /// @dev It is desired and expected for this value to</span>
 586 |     | <span class='neutral'>            /// overflow once it has hit the max of `type.uint256`.</span>
 587 |     | <span class='neutral'>            unchecked {</span>
 588 |     | <span class='unexecuted'>                _BASE_PRICE_CUMULATIVE_LAST_ += getMidPrice() * timeElapsed;</span>
 589 |     | <span class='neutral'>            }</span>
 590 |     | <span class='neutral'>        }</span>
 591 |     | <span class='neutral'></span>
 592 |     | <span class='unexecuted'>        _BLOCK_TIMESTAMP_LAST_ = blockTimestamp;</span>
 593 |     | <span class='neutral'>    }</span>
 594 |     | <span class='neutral'></span>
 595 |     | <span class='unexecuted'>    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {</span>
 596 |     | <span class='unexecuted'>        _BASE_RESERVE_ = baseReserve.toUint112();</span>
 597 |     | <span class='unexecuted'>        _QUOTE_RESERVE_ = quoteReserve.toUint112();</span>
 598 |     | <span class='neutral'></span>
 599 |     | <span class='unexecuted'>        _twapUpdate();</span>
 600 |     | <span class='neutral'>    }</span>
 601 |     | <span class='neutral'></span>
 602 |     | <span class='unexecuted'>    function _sync() internal {</span>
 603 |     | <span class='unexecuted'>        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));</span>
 604 |     | <span class='unexecuted'>        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));</span>
 605 |     | <span class='neutral'></span>
 606 |     | <span class='unexecuted'>        if (baseBalance != _BASE_RESERVE_) {</span>
 607 |     | <span class='unexecuted'>            _BASE_RESERVE_ = baseBalance.toUint112();</span>
 608 |     | <span class='neutral'>        }</span>
 609 |     | <span class='unexecuted'>        if (quoteBalance != _QUOTE_RESERVE_) {</span>
 610 |     | <span class='unexecuted'>            _QUOTE_RESERVE_ = quoteBalance.toUint112();</span>
 611 |     | <span class='neutral'>        }</span>
 612 |     | <span class='neutral'></span>
 613 |     | <span class='unexecuted'>        _twapUpdate();</span>
 614 |     | <span class='neutral'>    }</span>
 615 |     | <span class='neutral'></span>
 616 |     | <span class='unexecuted'>    function _transferBaseOut(address to, uint256 amount) internal {</span>
 617 |     | <span class='unexecuted'>        if (amount &gt; 0) {</span>
 618 |     | <span class='unexecuted'>            _BASE_TOKEN_.safeTransfer(to, amount);</span>
 619 |     | <span class='neutral'>        }</span>
 620 |     | <span class='neutral'>    }</span>
 621 |     | <span class='neutral'></span>
 622 |     | <span class='unexecuted'>    function _transferQuoteOut(address to, uint256 amount) internal {</span>
 623 |     | <span class='unexecuted'>        if (amount &gt; 0) {</span>
 624 |     | <span class='unexecuted'>            _QUOTE_TOKEN_.safeTransfer(to, amount);</span>
 625 |     | <span class='neutral'>        }</span>
 626 |     | <span class='neutral'>    }</span>
 627 |     | <span class='neutral'></span>
 628 |     | <span class='unexecuted'>    function _mint(address to, uint256 amount) internal override {</span>
 629 |     | <span class='unexecuted'>        if (amount &lt;= 1000) {</span>
 630 |     | <span class='unexecuted'>            revert ErrMintAmountNotEnough();</span>
 631 |     | <span class='neutral'>        }</span>
 632 |     | <span class='neutral'></span>
 633 |     | <span class='unexecuted'>        super._mint(to, amount);</span>
 634 |     | <span class='neutral'>    }</span>
 635 |     | <span class='neutral'></span>
 636 |     | <span class='neutral'>    function _afterInitialized() internal virtual {}</span>
 637 |     | <span class='neutral'></span>
 638 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 639 |     | <span class='neutral'>    /// MODIFIERS</span>
 640 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 641 |     | <span class='neutral'></span>
 642 |     | <span class='neutral'>    modifier onlyImplementationOwner() {</span>
 643 |     | <span class='unexecuted'>        if (msg.sender != implementation.owner()) {</span>
 644 |     | <span class='unexecuted'>            revert ErrNotImplementationOwner();</span>
 645 |     | <span class='neutral'>        }</span>
 646 |     | <span class='neutral'>        _;</span>
 647 |     | <span class='neutral'>    }</span>
 648 |     | <span class='neutral'></span>
 649 |     | <span class='neutral'>    /// @dev owner is always considered an operator</span>
 650 |     | <span class='neutral'>    modifier onlyImplementationOperators() {</span>
 651 |     | <span class='unexecuted'>        if (!isImplementationOperator(msg.sender)) {</span>
 652 |     | <span class='unexecuted'>            revert ErrNotAllowedImplementationOperator();</span>
 653 |     | <span class='neutral'>        }</span>
 654 |     | <span class='unexecuted'>        _;</span>
 655 |     | <span class='neutral'>    }</span>
 656 |     | <span class='neutral'></span>
 657 |     | <span class='neutral'>    /// @dev can only be called on a clone contract</span>
 658 |     | <span class='neutral'>    modifier onlyClones() {</span>
 659 |     | <span class='unexecuted'>        if (address(this) == address(implementation)) {</span>
 660 |     | <span class='unexecuted'>            revert ErrNotClone();</span>
 661 |     | <span class='neutral'>        }</span>
 662 |     | <span class='neutral'>        _;</span>
 663 |     | <span class='neutral'>    }</span>
 664 |     | <span class='neutral'></span>
 665 |     | <span class='neutral'>    /// @dev can only be called on the implementation contract</span>
 666 |     | <span class='neutral'>    modifier onlyImplementation() {</span>
 667 |     | <span class='unexecuted'>        if (address(this) != address(implementation)) {</span>
 668 |     | <span class='unexecuted'>            revert ErrNotImplementation();</span>
 669 |     | <span class='neutral'>        }</span>
 670 |     | <span class='neutral'>        _;</span>
 671 |     | <span class='neutral'>    }</span>
 672 |     | <span class='neutral'></span>
 673 |     | <span class='neutral'>    modifier onlyProtocolOwnedPool() {</span>
 674 |     | <span class='unexecuted'>        if (!_PROTOCOL_OWNED_POOL_) {</span>
 675 |     | <span class='unexecuted'>            revert ErrNotAllowed();</span>
 676 |     | <span class='neutral'>        }</span>
 677 |     | <span class='neutral'>        _;</span>
 678 |     | <span class='neutral'>    }</span>
 679 |     | <span class='neutral'></span>
 680 |     | <span class='neutral'>    modifier whenPaused() {</span>
 681 |     | <span class='unexecuted'>        if (!_PAUSED_) {</span>
 682 |     | <span class='unexecuted'>            revert ErrNotPaused();</span>
 683 |     | <span class='neutral'>        }</span>
 684 |     | <span class='neutral'>        _;</span>
 685 |     | <span class='neutral'>    }</span>
 686 |     | <span class='neutral'></span>
 687 |     | <span class='neutral'>    /// @dev When it&#39;s a paused protocol owned pool,</span>
 688 |     | <span class='neutral'>    /// only the implementation operators can call the function</span>
 689 |     | <span class='neutral'>    /// A normal pool can never be paused.</span>
 690 |     | <span class='neutral'>    modifier whenNotPaused() {</span>
 691 |     | <span class='unexecuted'>        if (_PROTOCOL_OWNED_POOL_ &amp;&amp; _PAUSED_ &amp;&amp; !isImplementationOperator(msg.sender)) {</span>
 692 |     | <span class='unexecuted'>            revert ErrNotAllowedImplementationOperator();</span>
 693 |     | <span class='neutral'>        }</span>
 694 |     | <span class='neutral'>        _;</span>
 695 |     | <span class='neutral'>    }</span>
 696 |     | <span class='neutral'>}</span>
 697 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/auxiliary/FeeRateModel.sol</b>
<code>
  1 |     | <span class='neutral'>/*</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>    Copyright 2020 DODO ZOO.</span>
  4 |     | <span class='neutral'>    SPDX-License-Identifier: Apache-2.0</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>*/</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>import {Owned} from &quot;solmate/auth/Owned.sol&quot;;</span>
 11 |     | <span class='neutral'>import {IFeeRateImpl} from &quot;../interfaces/IFeeRateModel.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 | *   | <span class='executed'>contract FeeRateModel is Owned {</span>
 14 |     | <span class='neutral'>    event LogImplementationChanged(address indexed implementation);</span>
 15 |     | <span class='neutral'>    event LogMaintainerChanged(address indexed maintainer);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    error ErrZeroAddress();</span>
 18 |     | <span class='neutral'></span>
 19 | *   | <span class='executed'>    address public maintainer;</span>
 20 | *   | <span class='executed'>    address public implementation;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    constructor(address maintainer_, address owner_) Owned(owner_) {</span>
 23 |     | <span class='unexecuted'>        if (maintainer_ == address(0)) {</span>
 24 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>        maintainer = maintainer_;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 31 |     | <span class='neutral'>    /// VIEWS</span>
 32 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 33 |     | <span class='neutral'></span>
 34 | *   | <span class='executed'>    function getFeeRate(address trader, uint256 lpFeeRate) external view returns (uint256 adjustedLpFeeRate, uint256 mtFeeRate) {</span>
 35 | *   | <span class='executed'>        if (implementation == address(0)) {</span>
 36 | *   | <span class='executed'>            return (lpFeeRate, 0);</span>
 37 |     | <span class='neutral'>        }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>        return IFeeRateImpl(implementation).getFeeRate(msg.sender, trader, lpFeeRate);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 43 |     | <span class='neutral'>    /// ADMIN</span>
 44 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>    function setMaintainer(address maintainer_) external onlyOwner {</span>
 47 |     | <span class='unexecuted'>        if (maintainer_ == address(0)) {</span>
 48 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 49 |     | <span class='neutral'>        }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>        maintainer = maintainer_;</span>
 52 |     | <span class='unexecuted'>        emit LogMaintainerChanged(maintainer_);</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    /// @notice Set the fee rate implementation and default fee rate</span>
 56 |     | <span class='neutral'>    /// @param implementation_ The address of the fee rate implementation, use address(0) to disable</span>
 57 |     | <span class='unexecuted'>    function setImplementation(address implementation_) public onlyOwner {</span>
 58 |     | <span class='unexecuted'>        implementation = implementation_;</span>
 59 |     | <span class='unexecuted'>        emit LogImplementationChanged(implementation_);</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'>}</span>
 62 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/auxiliary/FeeRateModelImpl.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IFeeRateImpl} from &quot;../interfaces/IFeeRateModel.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Math} from &quot;/mimswap/libraries/Math.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract FeeRateModelImpl {</span>
  8 |     | <span class='neutral'>    // 50% of the LP fee rate</span>
  9 |     | <span class='unexecuted'>    function getFeeRate(</span>
 10 |     | <span class='neutral'>        address /*pool*/,</span>
 11 |     | <span class='neutral'>        address /*trader*/,</span>
 12 |     | <span class='neutral'>        uint256 lpFeeRate</span>
 13 |     | <span class='unexecuted'>    ) external pure returns (uint256 adjustedLpFeeRate, uint256 mtFeeRate) {</span>
 14 |     | <span class='unexecuted'>        mtFeeRate = Math.divCeil(lpFeeRate, 2);</span>
 15 |     | <span class='unexecuted'>        return (lpFeeRate - mtFeeRate, mtFeeRate);</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/interfaces/ICallee.sol</b>
<code>
  1 |     | <span class='neutral'>/*</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>    Copyright 2020 DODO ZOO.</span>
  4 |     | <span class='neutral'>    SPDX-License-Identifier: Apache-2.0</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>*/</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>interface ICallee {</span>
 11 |     | <span class='neutral'>    function SellShareCall(</span>
 12 |     | <span class='neutral'>        address sender,</span>
 13 |     | <span class='neutral'>        uint256 burnShareAmount,</span>
 14 |     | <span class='neutral'>        uint256 baseAmount,</span>
 15 |     | <span class='neutral'>        uint256 quoteAmount,</span>
 16 |     | <span class='neutral'>        bytes calldata data</span>
 17 |     | <span class='neutral'>    ) external;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function FlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external;</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/interfaces/IFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IFactory {</span>
  5 |     | <span class='neutral'>    function predictDeterministicAddress(</span>
  6 |     | <span class='neutral'>        address creator,</span>
  7 |     | <span class='neutral'>        address baseToken_,</span>
  8 |     | <span class='neutral'>        address quoteToken_,</span>
  9 |     | <span class='neutral'>        uint256 lpFeeRate_,</span>
 10 |     | <span class='neutral'>        uint256 i_,</span>
 11 |     | <span class='neutral'>        uint256 k_</span>
 12 |     | <span class='neutral'>    ) external view returns (address);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function maintainerFeeRateModel() external view returns (address);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function create(</span>
 17 |     | <span class='neutral'>        address baseToken_,</span>
 18 |     | <span class='neutral'>        address quoteToken_,</span>
 19 |     | <span class='neutral'>        uint256 lpFeeRate_,</span>
 20 |     | <span class='neutral'>        uint256 i_,</span>
 21 |     | <span class='neutral'>        uint256 k_,</span>
 22 |     | <span class='neutral'>        bool protocolOwnedPool_</span>
 23 |     | <span class='neutral'>    ) external returns (address clone);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function poolExists(address pool) external view returns (bool);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function addPool(address creator, address baseToken, address quoteToken, address pool) external;</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/interfaces/IFeeRateModel.sol</b>
<code>
  1 |     | <span class='neutral'>/*</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>    Copyright 2020 DODO ZOO.</span>
  4 |     | <span class='neutral'>    SPDX-License-Identifier: Apache-2.0</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>*/</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>interface IFeeRateImpl {</span>
 11 |     | <span class='neutral'>    function getFeeRate(</span>
 12 |     | <span class='neutral'>        address pool,</span>
 13 |     | <span class='neutral'>        address trader,</span>
 14 |     | <span class='neutral'>        uint256 lpFeeRate</span>
 15 |     | <span class='neutral'>    ) external view returns (uint256 adjustedLpFeeRate, uint256 mtFeeRate);</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>interface IFeeRateModel {</span>
 19 |     | <span class='neutral'>    function maintainer() external view returns (address);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function getFeeRate(address trader, uint256 lpFeeRate) external view returns (uint256 adjustedLpFeeRate, uint256 mtFeeRate);</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/interfaces/IMagicLP.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IMagicLP {</span>
  5 |     | <span class='neutral'>    function _BASE_TOKEN_() external view returns (address);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function _QUOTE_TOKEN_() external view returns (address);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function _BASE_RESERVE_() external view returns (uint112);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function _QUOTE_RESERVE_() external view returns (uint112);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function _BASE_TARGET_() external view returns (uint112);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function _QUOTE_TARGET_() external view returns (uint112);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function _I_() external view returns (uint256);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function getReserves() external view returns (uint256 baseReserve, uint256 quoteReserve);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function totalSupply() external view returns (uint256 totalSupply);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function init(</span>
 24 |     | <span class='neutral'>        address baseTokenAddress,</span>
 25 |     | <span class='neutral'>        address quoteTokenAddress,</span>
 26 |     | <span class='neutral'>        uint256 lpFeeRate,</span>
 27 |     | <span class='neutral'>        address mtFeeRateModel,</span>
 28 |     | <span class='neutral'>        uint256 i,</span>
 29 |     | <span class='neutral'>        uint256 k,</span>
 30 |     | <span class='neutral'>        bool protocolOwnedPool</span>
 31 |     | <span class='neutral'>    ) external;</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    function sellBase(address to) external returns (uint256 receiveQuoteAmount);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function sellQuote(address to) external returns (uint256 receiveBaseAmount);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function flashLoan(uint256 baseAmount, uint256 quoteAmount, address assetTo, bytes calldata data) external;</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    function buyShares(address to) external returns (uint256 shares, uint256 baseInput, uint256 quoteInput);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    function sellShares(</span>
 42 |     | <span class='neutral'>        uint256 shareAmount,</span>
 43 |     | <span class='neutral'>        address to,</span>
 44 |     | <span class='neutral'>        uint256 baseMinAmount,</span>
 45 |     | <span class='neutral'>        uint256 quoteMinAmount,</span>
 46 |     | <span class='neutral'>        bytes calldata data,</span>
 47 |     | <span class='neutral'>        uint256 deadline</span>
 48 |     | <span class='neutral'>    ) external returns (uint256 baseAmount, uint256 quoteAmount);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function MIN_LP_FEE_RATE() external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    function MAX_LP_FEE_RATE() external view returns (uint256);</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    function _PAUSED_() external view returns (bool);</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    function setPaused(bool paused) external;</span>
 57 |     | <span class='neutral'>}</span>
 58 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/libraries/DecimalMath.sol</b>
<code>
  1 |     | <span class='neutral'>/*</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>    Copyright 2020 DODO ZOO.</span>
  4 |     | <span class='neutral'>    SPDX-License-Identifier: Apache-2.0</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>*/</span>
  7 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>import {Math} from &quot;/mimswap/libraries/Math.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>/**</span>
 12 |     | <span class='neutral'> * @title DecimalMath</span>
 13 |     | <span class='neutral'> * @author DODO Breeder</span>
 14 |     | <span class='neutral'> *</span>
 15 |     | <span class='neutral'> * @notice Functions for fixed point number with 18 decimals</span>
 16 |     | <span class='neutral'> */</span>
 17 |     | <span class='unexecuted'>library DecimalMath {</span>
 18 |     | <span class='neutral'>    using Math for uint256;</span>
 19 |     | <span class='neutral'></span>
 20 | *   | <span class='executed'>    uint256 internal constant ONE = 10 ** 18;</span>
 21 |     | <span class='unexecuted'>    uint256 internal constant ONE2 = 10 ** 36;</span>
 22 |     | <span class='neutral'></span>
 23 | *   | <span class='executed'>    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {</span>
 24 | *   | <span class='executed'>        return (target * d) / ONE;</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 | *   | <span class='executed'>    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {</span>
 28 | *   | <span class='executed'>        return (target * d).divCeil(ONE);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 | *   | <span class='executed'>    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {</span>
 32 | *   | <span class='executed'>        return (target * ONE) / d;</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {</span>
 36 |     | <span class='unexecuted'>        return (target * ONE).divCeil(d);</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>    function reciprocalFloor(uint256 target) internal pure returns (uint256) {</span>
 40 |     | <span class='unexecuted'>        return ONE2 / target;</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    function reciprocalCeil(uint256 target) internal pure returns (uint256) {</span>
 44 |     | <span class='neutral'>        return ONE2.divCeil(target);</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    function powFloor(uint256 target, uint256 e) internal pure returns (uint256) {</span>
 48 |     | <span class='neutral'>        if (e == 0) {</span>
 49 |     | <span class='neutral'>            return 10 ** 18;</span>
 50 |     | <span class='neutral'>        } else if (e == 1) {</span>
 51 |     | <span class='neutral'>            return target;</span>
 52 |     | <span class='neutral'>        } else {</span>
 53 |     | <span class='neutral'>            uint p = powFloor(target, e / 2);</span>
 54 |     | <span class='neutral'>            p = (p * p) / ONE;</span>
 55 |     | <span class='neutral'>            if (e % 2 == 1) {</span>
 56 |     | <span class='neutral'>                p = (p * target) / ONE;</span>
 57 |     | <span class='neutral'>            }</span>
 58 |     | <span class='neutral'>            return p;</span>
 59 |     | <span class='neutral'>        }</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'>}</span>
 62 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/libraries/Math.sol</b>
<code>
   1 |     | <span class='neutral'>/*</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>    Copyright 2020 DODO ZOO.</span>
   4 |     | <span class='neutral'>    SPDX-License-Identifier: Apache-2.0</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>*/</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>import {DecimalMath} from &quot;/mimswap/libraries/DecimalMath.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/**</span>
  13 |     | <span class='neutral'> * @author Adapted from https://github.com/DODOEX/contractV2/blob/main/contracts/lib/Math.sol</span>
  14 |     | <span class='neutral'> * @notice Functions for complex calculating. Including ONE Integration and TWO Quadratic solutions</span>
  15 |     | <span class='neutral'> */</span>
  16 |     | <span class='unexecuted'>library Math {</span>
  17 |     | <span class='neutral'>    error ErrIsZero();</span>
  18 |     | <span class='neutral'></span>
  19 | *   | <span class='executed'>    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  20 | *   | <span class='executed'>        uint256 quotient = a / b;</span>
  21 | *   | <span class='executed'>        uint256 remainder = a - quotient * b;</span>
  22 | *   | <span class='executed'>        if (remainder &gt; 0) {</span>
  23 | *   | <span class='executed'>            return quotient + 1;</span>
  24 |     | <span class='neutral'>        } else {</span>
  25 | *   | <span class='executed'>            return quotient;</span>
  26 |     | <span class='neutral'>        }</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    function sqrt(uint256 x) internal pure returns (uint256 y) {</span>
  30 |     | <span class='unexecuted'>        uint256 z = x / 2 + 1;</span>
  31 |     | <span class='unexecuted'>        y = x;</span>
  32 |     | <span class='unexecuted'>        while (z &lt; y) {</span>
  33 |     | <span class='unexecuted'>            y = z;</span>
  34 |     | <span class='unexecuted'>            z = (x / z + z) / 2;</span>
  35 |     | <span class='neutral'>        }</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /*</span>
  39 |     | <span class='neutral'>        Integrate dodo curve from V1 to V2</span>
  40 |     | <span class='neutral'>        require V0&gt;=V1&gt;=V2&gt;0</span>
  41 |     | <span class='neutral'>        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)</span>
  42 |     | <span class='neutral'>        let V1-V2=delta</span>
  43 |     | <span class='neutral'>        res = i*delta*(1-k+k(V0^2/V1/V2))</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>        i is the price of V-res trading pair</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>        support k=1 &amp; k=0 case</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>        [round down]</span>
  50 |     | <span class='neutral'>    */</span>
  51 |     | <span class='unexecuted'>    function _GeneralIntegrate(uint256 V0, uint256 V1, uint256 V2, uint256 i, uint256 k) internal pure returns (uint256) {</span>
  52 |     | <span class='unexecuted'>        if (V0 == 0) {</span>
  53 |     | <span class='unexecuted'>            revert ErrIsZero();</span>
  54 |     | <span class='neutral'>        }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>        uint256 fairAmount = i * (V1 - V2); // i*delta</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>        if (k == 0) {</span>
  59 |     | <span class='unexecuted'>            return fairAmount / DecimalMath.ONE;</span>
  60 |     | <span class='neutral'>        }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>        uint256 V0V0V1V2 = DecimalMath.divFloor((V0 * V0) / V1, V2);</span>
  63 |     | <span class='unexecuted'>        uint256 penalty = DecimalMath.mulFloor(k, V0V0V1V2); // k(V0^2/V1/V2)</span>
  64 |     | <span class='unexecuted'>        return (((DecimalMath.ONE - k) + penalty) * fairAmount) / DecimalMath.ONE2;</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /*</span>
  68 |     | <span class='neutral'>        Follow the integration function above</span>
  69 |     | <span class='neutral'>        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)</span>
  70 |     | <span class='neutral'>        Assume Q2=Q0, Given Q1 and deltaB, solve Q0</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>        i is the price of delta-V trading pair</span>
  73 |     | <span class='neutral'>        give out target of V</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>        support k=1 &amp; k=0 case</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        [round down]</span>
  78 |     | <span class='neutral'>    */</span>
  79 |     | <span class='unexecuted'>    function _SolveQuadraticFunctionForTarget(uint256 V1, uint256 delta, uint256 i, uint256 k) internal pure returns (uint256) {</span>
  80 |     | <span class='unexecuted'>        if (k == 0) {</span>
  81 |     | <span class='unexecuted'>            return V1 + DecimalMath.mulFloor(i, delta);</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        // V0 = V1*(1+(sqrt-1)/2k)</span>
  85 |     | <span class='neutral'>        // sqrt = (1+4kidelta/V1)</span>
  86 |     | <span class='neutral'>        // premium = 1+(sqrt-1)/2k</span>
  87 |     | <span class='neutral'>        // uint256 sqrt = (4 * k).mul(i).mul(delta).div(V1).add(DecimalMath.ONE2).sqrt();</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>        if (V1 == 0) {</span>
  90 |     | <span class='unexecuted'>            return 0;</span>
  91 |     | <span class='neutral'>        }</span>
  92 |     | <span class='unexecuted'>        uint256 _sqrt;</span>
  93 |     | <span class='unexecuted'>        uint256 ki = (4 * k) * i;</span>
  94 |     | <span class='unexecuted'>        if (ki == 0) {</span>
  95 |     | <span class='unexecuted'>            _sqrt = DecimalMath.ONE;</span>
  96 |     | <span class='unexecuted'>        } else if ((ki * delta) / ki == delta) {</span>
  97 |     | <span class='unexecuted'>            _sqrt = sqrt(((ki * delta) / V1) + DecimalMath.ONE2);</span>
  98 |     | <span class='neutral'>        } else {</span>
  99 |     | <span class='unexecuted'>            _sqrt = sqrt(((ki / V1) * delta) + DecimalMath.ONE2);</span>
 100 |     | <span class='neutral'>        }</span>
 101 |     | <span class='unexecuted'>        uint256 premium = DecimalMath.divFloor(_sqrt - DecimalMath.ONE, k * 2) + DecimalMath.ONE;</span>
 102 |     | <span class='neutral'>        // V0 is greater than or equal to V1 according to the solution</span>
 103 |     | <span class='unexecuted'>        return DecimalMath.mulFloor(V1, premium);</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    /*</span>
 107 |     | <span class='neutral'>        Follow the integration expression above, we have:</span>
 108 |     | <span class='neutral'>        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)</span>
 109 |     | <span class='neutral'>        Given Q1 and deltaB, solve Q2</span>
 110 |     | <span class='neutral'>        This is a quadratic function and the standard version is</span>
 111 |     | <span class='neutral'>        aQ2^2 + bQ2 + c = 0, where</span>
 112 |     | <span class='neutral'>        a=1-k</span>
 113 |     | <span class='neutral'>        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB</span>
 114 |     | <span class='neutral'>        c=-kQ0^2 </span>
 115 |     | <span class='neutral'>        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)</span>
 116 |     | <span class='neutral'>        note: another root is negative, abondan</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>        if deltaBSig=true, then Q2&gt;Q1, user sell Q and receive B</span>
 119 |     | <span class='neutral'>        if deltaBSig=false, then Q2&lt;Q1, user sell B and receive Q</span>
 120 |     | <span class='neutral'>        return |Q1-Q2|</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>        as we only support sell amount as delta, the deltaB is always negative</span>
 123 |     | <span class='neutral'>        the input ideltaB is actually -ideltaB in the equation</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>        i is the price of delta-V trading pair</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>        support k=1 &amp; k=0 case</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>        [round down]</span>
 130 |     | <span class='neutral'>    */</span>
 131 |     | <span class='unexecuted'>    function _SolveQuadraticFunctionForTrade(uint256 V0, uint256 V1, uint256 delta, uint256 i, uint256 k) internal pure returns (uint256) {</span>
 132 |     | <span class='unexecuted'>        if (V0 == 0) {</span>
 133 |     | <span class='unexecuted'>            revert ErrIsZero();</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='unexecuted'>        if (delta == 0) {</span>
 137 |     | <span class='unexecuted'>            return 0;</span>
 138 |     | <span class='neutral'>        }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>        if (k == 0) {</span>
 141 |     | <span class='unexecuted'>            return DecimalMath.mulFloor(i, delta) &gt; V1 ? V1 : DecimalMath.mulFloor(i, delta);</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>        if (k == DecimalMath.ONE) {</span>
 145 |     | <span class='neutral'>            // if k==1</span>
 146 |     | <span class='neutral'>            // Q2=Q1/(1+ideltaBQ1/Q0/Q0)</span>
 147 |     | <span class='neutral'>            // temp = ideltaBQ1/Q0/Q0</span>
 148 |     | <span class='neutral'>            // Q2 = Q1/(1+temp)</span>
 149 |     | <span class='neutral'>            // Q1-Q2 = Q1*(1-1/(1+temp)) = Q1*(temp/(1+temp))</span>
 150 |     | <span class='neutral'>            // uint256 temp = i.mul(delta).mul(V1).div(V0.mul(V0));</span>
 151 |     | <span class='unexecuted'>            uint256 temp;</span>
 152 |     | <span class='unexecuted'>            uint256 idelta = i * delta;</span>
 153 |     | <span class='unexecuted'>            if (idelta == 0) {</span>
 154 |     | <span class='unexecuted'>                temp = 0;</span>
 155 |     | <span class='unexecuted'>            } else if ((idelta * V1) / idelta == V1) {</span>
 156 |     | <span class='unexecuted'>                temp = (idelta * V1) / (V0 * V0);</span>
 157 |     | <span class='neutral'>            } else {</span>
 158 |     | <span class='unexecuted'>                temp = (((delta * V1) / V0) * i) / V0;</span>
 159 |     | <span class='neutral'>            }</span>
 160 |     | <span class='unexecuted'>            return (V1 * temp) / (temp + DecimalMath.ONE);</span>
 161 |     | <span class='neutral'>        }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>        // calculate -b value and sig</span>
 164 |     | <span class='neutral'>        // b = kQ0^2/Q1-i*deltaB-(1-k)Q1</span>
 165 |     | <span class='neutral'>        // part1 = (1-k)Q1 &gt;=0</span>
 166 |     | <span class='neutral'>        // part2 = kQ0^2/Q1-i*deltaB &gt;=0</span>
 167 |     | <span class='neutral'>        // bAbs = abs(part1-part2)</span>
 168 |     | <span class='neutral'>        // if part1&gt;part2 =&gt; b is negative =&gt; bSig is false</span>
 169 |     | <span class='neutral'>        // if part2&gt;part1 =&gt; b is positive =&gt; bSig is true</span>
 170 |     | <span class='unexecuted'>        uint256 part2 = (((k * V0) / V1) * V0) + (i * delta); // kQ0^2/Q1-i*deltaB</span>
 171 |     | <span class='unexecuted'>        uint256 bAbs = (DecimalMath.ONE - k) * V1; // (1-k)Q1</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='unexecuted'>        bool bSig;</span>
 174 |     | <span class='unexecuted'>        if (bAbs &gt;= part2) {</span>
 175 |     | <span class='unexecuted'>            bAbs = bAbs - part2;</span>
 176 |     | <span class='unexecuted'>            bSig = false;</span>
 177 |     | <span class='neutral'>        } else {</span>
 178 |     | <span class='unexecuted'>            bAbs = part2 - bAbs;</span>
 179 |     | <span class='unexecuted'>            bSig = true;</span>
 180 |     | <span class='neutral'>        }</span>
 181 |     | <span class='unexecuted'>        bAbs = bAbs / DecimalMath.ONE;</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>        // calculate sqrt</span>
 184 |     | <span class='unexecuted'>        uint256 squareRoot = DecimalMath.mulFloor((DecimalMath.ONE - k) * 4, DecimalMath.mulFloor(k, V0) * V0); // 4(1-k)kQ0^2</span>
 185 |     | <span class='unexecuted'>        squareRoot = sqrt((bAbs * bAbs) + squareRoot); // sqrt(b*b+4(1-k)kQ0*Q0)</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>        // final res</span>
 188 |     | <span class='unexecuted'>        uint256 denominator = (DecimalMath.ONE - k) * 2; // 2(1-k)</span>
 189 |     | <span class='unexecuted'>        uint256 numerator;</span>
 190 |     | <span class='unexecuted'>        if (bSig) {</span>
 191 |     | <span class='unexecuted'>            numerator = squareRoot - bAbs;</span>
 192 |     | <span class='unexecuted'>            if (numerator == 0) {</span>
 193 |     | <span class='unexecuted'>                revert ErrIsZero();</span>
 194 |     | <span class='neutral'>            }</span>
 195 |     | <span class='neutral'>        } else {</span>
 196 |     | <span class='unexecuted'>            numerator = bAbs + squareRoot;</span>
 197 |     | <span class='neutral'>        }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='unexecuted'>        uint256 V2 = DecimalMath.divCeil(numerator, denominator);</span>
 200 |     | <span class='unexecuted'>        if (V2 &gt; V1) {</span>
 201 |     | <span class='unexecuted'>            return 0;</span>
 202 |     | <span class='neutral'>        } else {</span>
 203 |     | <span class='unexecuted'>            return V1 - V2;</span>
 204 |     | <span class='neutral'>        }</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'>}</span>
 207 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/libraries/PMMPricing.sol</b>
<code>
   1 |     | <span class='neutral'>/*</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>    Copyright 2020 DODO ZOO.</span>
   4 |     | <span class='neutral'>    SPDX-License-Identifier: Apache-2.0</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>*/</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>import {DecimalMath} from &quot;/mimswap/libraries/DecimalMath.sol&quot;;</span>
  11 |     | <span class='neutral'>import {Math} from &quot;/mimswap/libraries/Math.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>/**</span>
  14 |     | <span class='neutral'> * @title Pricing</span>
  15 |     | <span class='neutral'> * @author DODO Breeder</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * @notice DODO Pricing model</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>library PMMPricing {</span>
  21 |     | <span class='neutral'>    enum RState {</span>
  22 |     | <span class='neutral'>        ONE,</span>
  23 |     | <span class='neutral'>        ABOVE_ONE,</span>
  24 |     | <span class='neutral'>        BELOW_ONE</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    struct PMMState {</span>
  28 |     | <span class='neutral'>        uint256 i;</span>
  29 |     | <span class='neutral'>        uint256 K;</span>
  30 |     | <span class='neutral'>        uint256 B;</span>
  31 |     | <span class='neutral'>        uint256 Q;</span>
  32 |     | <span class='neutral'>        uint256 B0;</span>
  33 |     | <span class='neutral'>        uint256 Q0;</span>
  34 |     | <span class='neutral'>        RState R;</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    // ============ buy &amp; sell ============</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    function sellBaseToken(PMMState memory state, uint256 payBaseAmount) internal pure returns (uint256 receiveQuoteAmount, RState newR) {</span>
  40 |     | <span class='unexecuted'>        if (state.R == RState.ONE) {</span>
  41 |     | <span class='neutral'>            // case 1: R=1</span>
  42 |     | <span class='neutral'>            // R falls below one</span>
  43 |     | <span class='unexecuted'>            receiveQuoteAmount = _ROneSellBaseToken(state, payBaseAmount);</span>
  44 |     | <span class='unexecuted'>            newR = RState.BELOW_ONE;</span>
  45 |     | <span class='unexecuted'>        } else if (state.R == RState.ABOVE_ONE) {</span>
  46 |     | <span class='unexecuted'>            uint256 backToOnePayBase = state.B0 - state.B;</span>
  47 |     | <span class='unexecuted'>            uint256 backToOneReceiveQuote = state.Q - state.Q0;</span>
  48 |     | <span class='neutral'>            // case 2: R&gt;1</span>
  49 |     | <span class='neutral'>            // complex case, R status depends on trading amount</span>
  50 |     | <span class='unexecuted'>            if (payBaseAmount &lt; backToOnePayBase) {</span>
  51 |     | <span class='neutral'>                // case 2.1: R status do not change</span>
  52 |     | <span class='unexecuted'>                receiveQuoteAmount = _RAboveSellBaseToken(state, payBaseAmount);</span>
  53 |     | <span class='unexecuted'>                newR = RState.ABOVE_ONE;</span>
  54 |     | <span class='unexecuted'>                if (receiveQuoteAmount &gt; backToOneReceiveQuote) {</span>
  55 |     | <span class='neutral'>                    // [Important corner case!] may enter this branch when some precision problem happens. And consequently contribute to negative spare quote amount</span>
  56 |     | <span class='neutral'>                    // to make sure spare quote&gt;=0, mannually set receiveQuote=backToOneReceiveQuote</span>
  57 |     | <span class='unexecuted'>                    receiveQuoteAmount = backToOneReceiveQuote;</span>
  58 |     | <span class='neutral'>                }</span>
  59 |     | <span class='unexecuted'>            } else if (payBaseAmount == backToOnePayBase) {</span>
  60 |     | <span class='neutral'>                // case 2.2: R status changes to ONE</span>
  61 |     | <span class='unexecuted'>                receiveQuoteAmount = backToOneReceiveQuote;</span>
  62 |     | <span class='unexecuted'>                newR = RState.ONE;</span>
  63 |     | <span class='neutral'>            } else {</span>
  64 |     | <span class='neutral'>                // case 2.3: R status changes to BELOW_ONE</span>
  65 |     | <span class='unexecuted'>                receiveQuoteAmount = backToOneReceiveQuote + _ROneSellBaseToken(state, payBaseAmount - backToOnePayBase);</span>
  66 |     | <span class='unexecuted'>                newR = RState.BELOW_ONE;</span>
  67 |     | <span class='neutral'>            }</span>
  68 |     | <span class='neutral'>        } else {</span>
  69 |     | <span class='neutral'>            // state.R == RState.BELOW_ONE</span>
  70 |     | <span class='neutral'>            // case 3: R&lt;1</span>
  71 |     | <span class='unexecuted'>            receiveQuoteAmount = _RBelowSellBaseToken(state, payBaseAmount);</span>
  72 |     | <span class='unexecuted'>            newR = RState.BELOW_ONE;</span>
  73 |     | <span class='neutral'>        }</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>    function sellQuoteToken(PMMState memory state, uint256 payQuoteAmount) internal pure returns (uint256 receiveBaseAmount, RState newR) {</span>
  77 |     | <span class='unexecuted'>        if (state.R == RState.ONE) {</span>
  78 |     | <span class='unexecuted'>            receiveBaseAmount = _ROneSellQuoteToken(state, payQuoteAmount);</span>
  79 |     | <span class='unexecuted'>            newR = RState.ABOVE_ONE;</span>
  80 |     | <span class='unexecuted'>        } else if (state.R == RState.ABOVE_ONE) {</span>
  81 |     | <span class='unexecuted'>            receiveBaseAmount = _RAboveSellQuoteToken(state, payQuoteAmount);</span>
  82 |     | <span class='neutral'>            newR = RState.ABOVE_ONE;</span>
  83 |     | <span class='unexecuted'>        } else {</span>
  84 |     | <span class='unexecuted'>            uint256 backToOnePayQuote = state.Q0 - state.Q;</span>
  85 |     | <span class='unexecuted'>            uint256 backToOneReceiveBase = state.B - state.B0;</span>
  86 |     | <span class='unexecuted'>            if (payQuoteAmount &lt; backToOnePayQuote) {</span>
  87 |     | <span class='unexecuted'>                receiveBaseAmount = _RBelowSellQuoteToken(state, payQuoteAmount);</span>
  88 |     | <span class='unexecuted'>                newR = RState.BELOW_ONE;</span>
  89 |     | <span class='unexecuted'>                if (receiveBaseAmount &gt; backToOneReceiveBase) {</span>
  90 |     | <span class='unexecuted'>                    receiveBaseAmount = backToOneReceiveBase;</span>
  91 |     | <span class='neutral'>                }</span>
  92 |     | <span class='unexecuted'>            } else if (payQuoteAmount == backToOnePayQuote) {</span>
  93 |     | <span class='unexecuted'>                receiveBaseAmount = backToOneReceiveBase;</span>
  94 |     | <span class='unexecuted'>                newR = RState.ONE;</span>
  95 |     | <span class='neutral'>            } else {</span>
  96 |     | <span class='unexecuted'>                receiveBaseAmount = backToOneReceiveBase + _ROneSellQuoteToken(state, payQuoteAmount - backToOnePayQuote);</span>
  97 |     | <span class='unexecuted'>                newR = RState.ABOVE_ONE;</span>
  98 |     | <span class='neutral'>            }</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    // ============ R = 1 cases ============</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>    function _ROneSellBaseToken(</span>
 105 |     | <span class='neutral'>        PMMState memory state,</span>
 106 |     | <span class='neutral'>        uint256 payBaseAmount</span>
 107 |     | <span class='neutral'>    )</span>
 108 |     | <span class='neutral'>        internal</span>
 109 |     | <span class='neutral'>        pure</span>
 110 |     | <span class='neutral'>        returns (</span>
 111 |     | <span class='unexecuted'>            uint256 // receiveQuoteToken</span>
 112 |     | <span class='neutral'>        )</span>
 113 |     | <span class='neutral'>    {</span>
 114 |     | <span class='neutral'>        // in theory Q2 &lt;= targetQuoteTokenAmount</span>
 115 |     | <span class='neutral'>        // however when amount is close to 0, precision problems may cause Q2 &gt; targetQuoteTokenAmount</span>
 116 |     | <span class='unexecuted'>        return Math._SolveQuadraticFunctionForTrade(state.Q0, state.Q0, payBaseAmount, state.i, state.K);</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>    function _ROneSellQuoteToken(</span>
 120 |     | <span class='neutral'>        PMMState memory state,</span>
 121 |     | <span class='neutral'>        uint256 payQuoteAmount</span>
 122 |     | <span class='neutral'>    )</span>
 123 |     | <span class='neutral'>        internal</span>
 124 |     | <span class='neutral'>        pure</span>
 125 |     | <span class='neutral'>        returns (</span>
 126 |     | <span class='unexecuted'>            uint256 // receiveBaseToken</span>
 127 |     | <span class='neutral'>        )</span>
 128 |     | <span class='neutral'>    {</span>
 129 |     | <span class='unexecuted'>        return Math._SolveQuadraticFunctionForTrade(state.B0, state.B0, payQuoteAmount, DecimalMath.reciprocalFloor(state.i), state.K);</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    // ============ R &lt; 1 cases ============</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>    function _RBelowSellQuoteToken(</span>
 135 |     | <span class='neutral'>        PMMState memory state,</span>
 136 |     | <span class='neutral'>        uint256 payQuoteAmount</span>
 137 |     | <span class='neutral'>    )</span>
 138 |     | <span class='neutral'>        internal</span>
 139 |     | <span class='neutral'>        pure</span>
 140 |     | <span class='neutral'>        returns (</span>
 141 |     | <span class='unexecuted'>            uint256 // receiveBaseToken</span>
 142 |     | <span class='neutral'>        )</span>
 143 |     | <span class='neutral'>    {</span>
 144 |     | <span class='unexecuted'>        return Math._GeneralIntegrate(state.Q0, state.Q + payQuoteAmount, state.Q, DecimalMath.reciprocalFloor(state.i), state.K);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='unexecuted'>    function _RBelowSellBaseToken(</span>
 148 |     | <span class='neutral'>        PMMState memory state,</span>
 149 |     | <span class='neutral'>        uint256 payBaseAmount</span>
 150 |     | <span class='neutral'>    )</span>
 151 |     | <span class='neutral'>        internal</span>
 152 |     | <span class='neutral'>        pure</span>
 153 |     | <span class='neutral'>        returns (</span>
 154 |     | <span class='unexecuted'>            uint256 // receiveQuoteToken</span>
 155 |     | <span class='neutral'>        )</span>
 156 |     | <span class='neutral'>    {</span>
 157 |     | <span class='unexecuted'>        return Math._SolveQuadraticFunctionForTrade(state.Q0, state.Q, payBaseAmount, state.i, state.K);</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    // ============ R &gt; 1 cases ============</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='unexecuted'>    function _RAboveSellBaseToken(</span>
 163 |     | <span class='neutral'>        PMMState memory state,</span>
 164 |     | <span class='neutral'>        uint256 payBaseAmount</span>
 165 |     | <span class='neutral'>    )</span>
 166 |     | <span class='neutral'>        internal</span>
 167 |     | <span class='neutral'>        pure</span>
 168 |     | <span class='neutral'>        returns (</span>
 169 |     | <span class='unexecuted'>            uint256 // receiveQuoteToken</span>
 170 |     | <span class='neutral'>        )</span>
 171 |     | <span class='neutral'>    {</span>
 172 |     | <span class='unexecuted'>        return Math._GeneralIntegrate(state.B0, state.B + payBaseAmount, state.B, state.i, state.K);</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='unexecuted'>    function _RAboveSellQuoteToken(</span>
 176 |     | <span class='neutral'>        PMMState memory state,</span>
 177 |     | <span class='neutral'>        uint256 payQuoteAmount</span>
 178 |     | <span class='neutral'>    )</span>
 179 |     | <span class='neutral'>        internal</span>
 180 |     | <span class='neutral'>        pure</span>
 181 |     | <span class='neutral'>        returns (</span>
 182 |     | <span class='unexecuted'>            uint256 // receiveBaseToken</span>
 183 |     | <span class='neutral'>        )</span>
 184 |     | <span class='neutral'>    {</span>
 185 |     | <span class='unexecuted'>        return Math._SolveQuadraticFunctionForTrade(state.B0, state.B, payQuoteAmount, DecimalMath.reciprocalFloor(state.i), state.K);</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    // ============ Helper functions ============</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='unexecuted'>    function adjustedTarget(PMMState memory state) internal pure {</span>
 191 |     | <span class='unexecuted'>        if (state.R == RState.BELOW_ONE) {</span>
 192 |     | <span class='unexecuted'>            state.Q0 = Math._SolveQuadraticFunctionForTarget(state.Q, state.B - state.B0, state.i, state.K);</span>
 193 |     | <span class='unexecuted'>        } else if (state.R == RState.ABOVE_ONE) {</span>
 194 |     | <span class='unexecuted'>            state.B0 = Math._SolveQuadraticFunctionForTarget(</span>
 195 |     | <span class='unexecuted'>                state.B,</span>
 196 |     | <span class='unexecuted'>                state.Q - state.Q0,</span>
 197 |     | <span class='unexecuted'>                DecimalMath.reciprocalFloor(state.i),</span>
 198 |     | <span class='unexecuted'>                state.K</span>
 199 |     | <span class='neutral'>            );</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='unexecuted'>    function getMidPrice(PMMState memory state) internal pure returns (uint256) {</span>
 204 |     | <span class='unexecuted'>        if (state.R == RState.BELOW_ONE) {</span>
 205 |     | <span class='unexecuted'>            uint256 R = DecimalMath.divFloor((state.Q0 * state.Q0) / state.Q, state.Q);</span>
 206 |     | <span class='unexecuted'>            R = (DecimalMath.ONE - state.K) + DecimalMath.mulFloor(state.K, R);</span>
 207 |     | <span class='unexecuted'>            return DecimalMath.divFloor(state.i, R);</span>
 208 |     | <span class='neutral'>        } else {</span>
 209 |     | <span class='unexecuted'>            uint256 R = DecimalMath.divFloor((state.B0 * state.B0) / state.B, state.B);</span>
 210 |     | <span class='unexecuted'>            R = (DecimalMath.ONE - state.K) + DecimalMath.mulFloor(state.K, R);</span>
 211 |     | <span class='unexecuted'>            return DecimalMath.mulFloor(state.i, R);</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'>}</span>
 215 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/periphery/Factory.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Owned} from &quot;solmate/auth/Owned.sol&quot;;</span>
   5 |     | <span class='neutral'>import {LibClone} from &quot;solady/utils/LibClone.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IFeeRateModel} from &quot;/mimswap/interfaces/IFeeRateModel.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IMagicLP} from &quot;/mimswap/interfaces/IMagicLP.sol&quot;;</span>
   8 |     | <span class='neutral'>import {MagicLP} from &quot;/mimswap/MagicLP.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/// @notice Create and register MagicLP pools</span>
  11 | *   | <span class='executed'>contract Factory is Owned {</span>
  12 |     | <span class='neutral'>    event LogCreated(</span>
  13 |     | <span class='neutral'>        address clone_,</span>
  14 |     | <span class='neutral'>        address indexed baseToken_,</span>
  15 |     | <span class='neutral'>        address indexed quoteToken_,</span>
  16 |     | <span class='neutral'>        address indexed creator_,</span>
  17 |     | <span class='neutral'>        uint256 lpFeeRate_,</span>
  18 |     | <span class='neutral'>        IFeeRateModel maintainerFeeRateModel,</span>
  19 |     | <span class='neutral'>        uint256 i_,</span>
  20 |     | <span class='neutral'>        uint256 k_</span>
  21 |     | <span class='neutral'>    );</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    event LogPoolAdded(address baseToken, address quoteToken, address creator, address pool);</span>
  24 |     | <span class='neutral'>    event LogPoolRemoved(address pool);</span>
  25 |     | <span class='neutral'>    event LogSetImplementation(address indexed implementation);</span>
  26 |     | <span class='neutral'>    event LogSetMaintainer(address indexed newMaintainer);</span>
  27 |     | <span class='neutral'>    event LogSetMaintainerFeeRateModel(IFeeRateModel newMaintainerFeeRateModel);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    error ErrInvalidUserPoolIndex();</span>
  30 |     | <span class='neutral'>    error ErrZeroAddress();</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>    address public implementation;</span>
  33 | *   | <span class='executed'>    IFeeRateModel public maintainerFeeRateModel;</span>
  34 |     | <span class='neutral'></span>
  35 | *   | <span class='executed'>    mapping(address pool =&gt; bool exists) public poolExists;</span>
  36 |     | <span class='unexecuted'>    mapping(address base =&gt; mapping(address quote =&gt; address[] pools)) public pools;</span>
  37 |     | <span class='unexecuted'>    mapping(address creator =&gt; address[] pools) public userPools;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    constructor(address implementation_, IFeeRateModel maintainerFeeRateModel_, address owner_) Owned(owner_) {</span>
  40 |     | <span class='unexecuted'>        if (implementation_ == address(0)) {</span>
  41 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
  42 |     | <span class='neutral'>        }</span>
  43 |     | <span class='unexecuted'>        if (address(maintainerFeeRateModel_) == address(0)) {</span>
  44 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
  45 |     | <span class='neutral'>        }</span>
  46 |     | <span class='unexecuted'>        implementation = implementation_;</span>
  47 |     | <span class='unexecuted'>        maintainerFeeRateModel = maintainerFeeRateModel_;</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  51 |     | <span class='neutral'>    /// VIEWS</span>
  52 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>    function getPoolCount(address token0, address token1) external view returns (uint256) {</span>
  55 |     | <span class='unexecuted'>        return pools[token0][token1].length;</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>    function getUserPoolCount(address creator) external view returns (uint256) {</span>
  59 |     | <span class='unexecuted'>        return userPools[creator].length;</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  63 |     | <span class='neutral'>    /// PUBLIC</span>
  64 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>    function predictDeterministicAddress(</span>
  67 |     | <span class='neutral'>        address creator,</span>
  68 |     | <span class='neutral'>        address baseToken_,</span>
  69 |     | <span class='neutral'>        address quoteToken_,</span>
  70 |     | <span class='neutral'>        uint256 lpFeeRate_,</span>
  71 |     | <span class='neutral'>        uint256 i_,</span>
  72 |     | <span class='neutral'>        uint256 k_,</span>
  73 |     | <span class='neutral'>        bool protocolOwnedPool_</span>
  74 |     | <span class='unexecuted'>    ) public view returns (address) {</span>
  75 |     | <span class='unexecuted'>        return</span>
  76 |     | <span class='unexecuted'>            LibClone.predictDeterministicAddress(</span>
  77 |     | <span class='unexecuted'>                implementation,</span>
  78 |     | <span class='unexecuted'>                _computeSalt(creator, baseToken_, quoteToken_, lpFeeRate_, i_, k_, protocolOwnedPool_),</span>
  79 |     | <span class='unexecuted'>                address(this)</span>
  80 |     | <span class='neutral'>            );</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 | *   | <span class='executed'>    function create(</span>
  84 |     | <span class='neutral'>        address baseToken_,</span>
  85 |     | <span class='neutral'>        address quoteToken_,</span>
  86 |     | <span class='neutral'>        uint256 lpFeeRate_,</span>
  87 |     | <span class='neutral'>        uint256 i_,</span>
  88 |     | <span class='neutral'>        uint256 k_,</span>
  89 |     | <span class='neutral'>        bool protocolOwnedPool_</span>
  90 | *   | <span class='executed'>    ) external returns (address clone) {</span>
  91 | *   | <span class='executed'>        address creator = tx.origin;</span>
  92 |     | <span class='neutral'></span>
  93 | *   | <span class='executed'>        bytes32 salt = _computeSalt(creator, baseToken_, quoteToken_, lpFeeRate_, i_, k_, protocolOwnedPool_);</span>
  94 | *   | <span class='executed'>        clone = LibClone.cloneDeterministic(address(implementation), salt);</span>
  95 | *   | <span class='executed'>        IMagicLP(clone).init(</span>
  96 |     | <span class='neutral'>            address(baseToken_),</span>
  97 |     | <span class='neutral'>            address(quoteToken_),</span>
  98 |     | <span class='neutral'>            lpFeeRate_,</span>
  99 | *   | <span class='executed'>            address(maintainerFeeRateModel),</span>
 100 |     | <span class='neutral'>            i_,</span>
 101 |     | <span class='neutral'>            k_,</span>
 102 |     | <span class='neutral'>            protocolOwnedPool_</span>
 103 |     | <span class='neutral'>        );</span>
 104 |     | <span class='neutral'></span>
 105 | *   | <span class='executed'>        emit LogCreated(clone, baseToken_, quoteToken_, creator, lpFeeRate_, maintainerFeeRateModel, i_, k_);</span>
 106 | *   | <span class='executed'>        _addPool(creator, baseToken_, quoteToken_, clone);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 110 |     | <span class='neutral'>    /// ADMIN</span>
 111 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>    function setLpImplementation(address implementation_) external onlyOwner {</span>
 114 |     | <span class='unexecuted'>        if (implementation_ == address(0)) {</span>
 115 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 116 |     | <span class='neutral'>        }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>        implementation = implementation_;</span>
 119 |     | <span class='unexecuted'>        emit LogSetImplementation(implementation_);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>    function setMaintainerFeeRateModel(IFeeRateModel maintainerFeeRateModel_) external onlyOwner {</span>
 123 |     | <span class='unexecuted'>        if (address(maintainerFeeRateModel_) == address(0)) {</span>
 124 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
 125 |     | <span class='neutral'>        }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>        maintainerFeeRateModel = maintainerFeeRateModel_;</span>
 128 |     | <span class='unexecuted'>        emit LogSetMaintainerFeeRateModel(maintainerFeeRateModel_);</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /// @notice Register a pool to the list</span>
 132 |     | <span class='neutral'>    /// Note this doesn&#39;t check if the pool is valid or if it&#39;s already registered.</span>
 133 |     | <span class='unexecuted'>    function addPool(address creator, address baseToken, address quoteToken, address pool) external onlyOwner {</span>
 134 |     | <span class='unexecuted'>        _addPool(creator, baseToken, quoteToken, pool);</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='unexecuted'>    function removePool(</span>
 138 |     | <span class='neutral'>        address creator,</span>
 139 |     | <span class='neutral'>        address baseToken,</span>
 140 |     | <span class='neutral'>        address quoteToken,</span>
 141 |     | <span class='neutral'>        uint256 poolIndex,</span>
 142 |     | <span class='neutral'>        uint256 userPoolIndex</span>
 143 |     | <span class='unexecuted'>    ) external onlyOwner {</span>
 144 |     | <span class='unexecuted'>        address[] storage _pools = pools[baseToken][quoteToken];</span>
 145 |     | <span class='unexecuted'>        address pool = _pools[poolIndex];</span>
 146 |     | <span class='unexecuted'>        address[] storage _userPools = userPools[creator];</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='unexecuted'>        _pools[poolIndex] = _pools[_pools.length - 1];</span>
 149 |     | <span class='unexecuted'>        _pools.pop();</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>        if (_userPools[userPoolIndex] != pool) {</span>
 152 |     | <span class='unexecuted'>            revert ErrInvalidUserPoolIndex();</span>
 153 |     | <span class='neutral'>        }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>        _userPools[userPoolIndex] = _userPools[_userPools.length - 1];</span>
 156 |     | <span class='unexecuted'>        _userPools.pop();</span>
 157 |     | <span class='unexecuted'>        poolExists[pool] = false;</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>        emit LogPoolRemoved(pool);</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 163 |     | <span class='neutral'>    /// INTERNALS</span>
 164 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 165 |     | <span class='neutral'></span>
 166 | *   | <span class='executed'>    function _addPool(address creator, address baseToken, address quoteToken, address pool) internal {</span>
 167 | *   | <span class='executed'>        pools[baseToken][quoteToken].push(pool);</span>
 168 | *   | <span class='executed'>        userPools[creator].push(pool);</span>
 169 | *   | <span class='executed'>        poolExists[pool] = true;</span>
 170 |     | <span class='neutral'></span>
 171 | *   | <span class='executed'>        emit LogPoolAdded(baseToken, quoteToken, creator, pool);</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 | *   | <span class='executed'>    function _computeSalt(</span>
 175 |     | <span class='neutral'>        address sender_,</span>
 176 |     | <span class='neutral'>        address baseToken_,</span>
 177 |     | <span class='neutral'>        address quoteToken_,</span>
 178 |     | <span class='neutral'>        uint256 lpFeeRate_,</span>
 179 |     | <span class='neutral'>        uint256 i_,</span>
 180 |     | <span class='neutral'>        uint256 k_,</span>
 181 |     | <span class='neutral'>        bool protocolOwnedPool_</span>
 182 |     | <span class='neutral'>    ) internal view returns (bytes32) {</span>
 183 | *   | <span class='executed'>        return keccak256(abi.encodePacked(sender_, implementation, baseToken_, quoteToken_, lpFeeRate_, i_, k_, protocolOwnedPool_));</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'>}</span>
 186 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/periphery/PrivateRouter.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Router} from &quot;/mimswap/periphery/Router.sol&quot;;</span>
   5 |     | <span class='neutral'>import {OperatableV2} from &quot;mixins/OperatableV2.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IFactory} from &quot;/mimswap/interfaces/IFactory.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IWETH} from &quot;interfaces/IWETH.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/// @notice Same as Router, but with an OperatableV2 modifier</span>
  10 |     | <span class='neutral'>/// so it can be whitelisted as an authorized protocol owned pool</span>
  11 |     | <span class='neutral'>/// MagicLP operator</span>
  12 |     | <span class='unexecuted'>contract PrivateRouter is Router, OperatableV2 {</span>
  13 |     | <span class='unexecuted'>    constructor(IWETH weth_, IFactory factory_, address owner_) Router(weth_, factory_) OperatableV2(owner_) {}</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>    function createPool(</span>
  16 |     | <span class='neutral'>        address baseToken,</span>
  17 |     | <span class='neutral'>        address quoteToken,</span>
  18 |     | <span class='neutral'>        uint256 lpFeeRate,</span>
  19 |     | <span class='neutral'>        uint256 i,</span>
  20 |     | <span class='neutral'>        uint256 k,</span>
  21 |     | <span class='neutral'>        address to,</span>
  22 |     | <span class='neutral'>        uint256 baseInAmount,</span>
  23 |     | <span class='neutral'>        uint256 quoteInAmount,</span>
  24 |     | <span class='neutral'>        bool protocolOwnedPool</span>
  25 |     | <span class='unexecuted'>    ) public override onlyOperators returns (address clone, uint256 shares) {</span>
  26 |     | <span class='unexecuted'>        return super.createPool(baseToken, quoteToken, lpFeeRate, i, k, to, baseInAmount, quoteInAmount, protocolOwnedPool);</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    function createPoolETH(</span>
  30 |     | <span class='neutral'>        address token,</span>
  31 |     | <span class='neutral'>        bool useTokenAsQuote,</span>
  32 |     | <span class='neutral'>        uint256 lpFeeRate,</span>
  33 |     | <span class='neutral'>        uint256 i,</span>
  34 |     | <span class='neutral'>        uint256 k,</span>
  35 |     | <span class='neutral'>        address to,</span>
  36 |     | <span class='neutral'>        uint256 tokenInAmount,</span>
  37 |     | <span class='neutral'>        bool protocolOwnedPool</span>
  38 |     | <span class='unexecuted'>    ) public payable override onlyOperators returns (address clone, uint256 shares) {</span>
  39 |     | <span class='unexecuted'>        return super.createPoolETH(token, useTokenAsQuote, lpFeeRate, i, k, to, tokenInAmount, protocolOwnedPool);</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>    function addLiquidity(</span>
  43 |     | <span class='neutral'>        address lp,</span>
  44 |     | <span class='neutral'>        address to,</span>
  45 |     | <span class='neutral'>        uint256 baseInAmount,</span>
  46 |     | <span class='neutral'>        uint256 quoteInAmount,</span>
  47 |     | <span class='neutral'>        uint256 minimumShares,</span>
  48 |     | <span class='neutral'>        uint256 deadline</span>
  49 |     | <span class='unexecuted'>    ) public override onlyOperators returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {</span>
  50 |     | <span class='unexecuted'>        return super.addLiquidity(lp, to, baseInAmount, quoteInAmount, minimumShares, deadline);</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>    function addLiquidityUnsafe(</span>
  54 |     | <span class='neutral'>        address lp,</span>
  55 |     | <span class='neutral'>        address to,</span>
  56 |     | <span class='neutral'>        uint256 baseInAmount,</span>
  57 |     | <span class='neutral'>        uint256 quoteInAmount,</span>
  58 |     | <span class='neutral'>        uint256 minimumShares,</span>
  59 |     | <span class='neutral'>        uint256 deadline</span>
  60 |     | <span class='unexecuted'>    ) public override onlyOperators returns (uint256 shares) {</span>
  61 |     | <span class='unexecuted'>        return super.addLiquidityUnsafe(lp, to, baseInAmount, quoteInAmount, minimumShares, deadline);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>    function addLiquidityETH(</span>
  65 |     | <span class='neutral'>        address lp,</span>
  66 |     | <span class='neutral'>        address to,</span>
  67 |     | <span class='neutral'>        address payable refundTo,</span>
  68 |     | <span class='neutral'>        uint256 tokenInAmount,</span>
  69 |     | <span class='neutral'>        uint256 minimumShares,</span>
  70 |     | <span class='neutral'>        uint256 deadline</span>
  71 |     | <span class='unexecuted'>    ) public payable override onlyOperators returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {</span>
  72 |     | <span class='unexecuted'>        return super.addLiquidityETH(lp, to, refundTo, tokenInAmount, minimumShares, deadline);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>    function addLiquidityETHUnsafe(</span>
  76 |     | <span class='neutral'>        address lp,</span>
  77 |     | <span class='neutral'>        address to,</span>
  78 |     | <span class='neutral'>        uint256 tokenInAmount,</span>
  79 |     | <span class='neutral'>        uint256 minimumShares,</span>
  80 |     | <span class='neutral'>        uint256 deadline</span>
  81 |     | <span class='unexecuted'>    ) public payable override onlyOperators returns (uint256 shares) {</span>
  82 |     | <span class='unexecuted'>        return super.addLiquidityETHUnsafe(lp, to, tokenInAmount, minimumShares, deadline);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>    function removeLiquidity(</span>
  86 |     | <span class='neutral'>        address lp,</span>
  87 |     | <span class='neutral'>        address to,</span>
  88 |     | <span class='neutral'>        uint256 sharesIn,</span>
  89 |     | <span class='neutral'>        uint256 minimumBaseAmount,</span>
  90 |     | <span class='neutral'>        uint256 minimumQuoteAmount,</span>
  91 |     | <span class='neutral'>        uint256 deadline</span>
  92 |     | <span class='unexecuted'>    ) public override onlyOperators returns (uint256 baseAmountOut, uint256 quoteAmountOut) {</span>
  93 |     | <span class='unexecuted'>        return super.removeLiquidity(lp, to, sharesIn, minimumBaseAmount, minimumQuoteAmount, deadline);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>    function removeLiquidityETH(</span>
  97 |     | <span class='neutral'>        address lp,</span>
  98 |     | <span class='neutral'>        address to,</span>
  99 |     | <span class='neutral'>        uint256 sharesIn,</span>
 100 |     | <span class='neutral'>        uint256 minimumETHAmount,</span>
 101 |     | <span class='neutral'>        uint256 minimumTokenAmount,</span>
 102 |     | <span class='neutral'>        uint256 deadline</span>
 103 |     | <span class='unexecuted'>    ) public override onlyOperators returns (uint256 ethAmountOut, uint256 tokenAmountOut) {</span>
 104 |     | <span class='unexecuted'>        return super.removeLiquidityETH(lp, to, sharesIn, minimumETHAmount, minimumTokenAmount, deadline);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>    function swapTokensForTokens(</span>
 108 |     | <span class='neutral'>        address to,</span>
 109 |     | <span class='neutral'>        uint256 amountIn,</span>
 110 |     | <span class='neutral'>        address[] calldata path,</span>
 111 |     | <span class='neutral'>        uint256 directions,</span>
 112 |     | <span class='neutral'>        uint256 minimumOut,</span>
 113 |     | <span class='neutral'>        uint256 deadline</span>
 114 |     | <span class='unexecuted'>    ) public override onlyOperators returns (uint256 amountOut) {</span>
 115 |     | <span class='unexecuted'>        return super.swapTokensForTokens(to, amountIn, path, directions, minimumOut, deadline);</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>    function swapETHForTokens(</span>
 119 |     | <span class='neutral'>        address to,</span>
 120 |     | <span class='neutral'>        address[] calldata path,</span>
 121 |     | <span class='neutral'>        uint256 directions,</span>
 122 |     | <span class='neutral'>        uint256 minimumOut,</span>
 123 |     | <span class='neutral'>        uint256 deadline</span>
 124 |     | <span class='unexecuted'>    ) public payable override onlyOperators returns (uint256 amountOut) {</span>
 125 |     | <span class='unexecuted'>        return super.swapETHForTokens(to, path, directions, minimumOut, deadline);</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>    function swapTokensForETH(</span>
 129 |     | <span class='neutral'>        address to,</span>
 130 |     | <span class='neutral'>        uint256 amountIn,</span>
 131 |     | <span class='neutral'>        address[] calldata path,</span>
 132 |     | <span class='neutral'>        uint256 directions,</span>
 133 |     | <span class='neutral'>        uint256 minimumOut,</span>
 134 |     | <span class='neutral'>        uint256 deadline</span>
 135 |     | <span class='unexecuted'>    ) public override onlyOperators returns (uint256 amountOut) {</span>
 136 |     | <span class='unexecuted'>        return super.swapTokensForETH(to, amountIn, path, directions, minimumOut, deadline);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>    function sellBaseTokensForTokens(</span>
 140 |     | <span class='neutral'>        address lp,</span>
 141 |     | <span class='neutral'>        address to,</span>
 142 |     | <span class='neutral'>        uint256 amountIn,</span>
 143 |     | <span class='neutral'>        uint256 minimumOut,</span>
 144 |     | <span class='neutral'>        uint256 deadline</span>
 145 |     | <span class='unexecuted'>    ) public override onlyOperators returns (uint256 amountOut) {</span>
 146 |     | <span class='unexecuted'>        return super.sellBaseTokensForTokens(lp, to, amountIn, minimumOut, deadline);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='unexecuted'>    function sellBaseETHForTokens(</span>
 150 |     | <span class='neutral'>        address lp,</span>
 151 |     | <span class='neutral'>        address to,</span>
 152 |     | <span class='neutral'>        uint256 minimumOut,</span>
 153 |     | <span class='neutral'>        uint256 deadline</span>
 154 |     | <span class='unexecuted'>    ) public payable override onlyOperators returns (uint256 amountOut) {</span>
 155 |     | <span class='unexecuted'>        return super.sellBaseETHForTokens(lp, to, minimumOut, deadline);</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='unexecuted'>    function sellBaseTokensForETH(</span>
 159 |     | <span class='neutral'>        address lp,</span>
 160 |     | <span class='neutral'>        address to,</span>
 161 |     | <span class='neutral'>        uint256 amountIn,</span>
 162 |     | <span class='neutral'>        uint256 minimumOut,</span>
 163 |     | <span class='neutral'>        uint256 deadline</span>
 164 |     | <span class='unexecuted'>    ) public override onlyOperators returns (uint256 amountOut) {</span>
 165 |     | <span class='unexecuted'>        return super.sellBaseTokensForETH(lp, to, amountIn, minimumOut, deadline);</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>    function sellQuoteTokensForTokens(</span>
 169 |     | <span class='neutral'>        address lp,</span>
 170 |     | <span class='neutral'>        address to,</span>
 171 |     | <span class='neutral'>        uint256 amountIn,</span>
 172 |     | <span class='neutral'>        uint256 minimumOut,</span>
 173 |     | <span class='neutral'>        uint256 deadline</span>
 174 |     | <span class='unexecuted'>    ) public override onlyOperators returns (uint256 amountOut) {</span>
 175 |     | <span class='unexecuted'>        return super.sellQuoteTokensForTokens(lp, to, amountIn, minimumOut, deadline);</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>    function sellQuoteETHForTokens(</span>
 179 |     | <span class='neutral'>        address lp,</span>
 180 |     | <span class='neutral'>        address to,</span>
 181 |     | <span class='neutral'>        uint256 minimumOut,</span>
 182 |     | <span class='neutral'>        uint256 deadline</span>
 183 |     | <span class='unexecuted'>    ) public payable override onlyOperators returns (uint256 amountOut) {</span>
 184 |     | <span class='unexecuted'>        return super.sellQuoteETHForTokens(lp, to, minimumOut, deadline);</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='unexecuted'>    function sellQuoteTokensForETH(</span>
 188 |     | <span class='neutral'>        address lp,</span>
 189 |     | <span class='neutral'>        address to,</span>
 190 |     | <span class='neutral'>        uint256 amountIn,</span>
 191 |     | <span class='neutral'>        uint256 minimumOut,</span>
 192 |     | <span class='neutral'>        uint256 deadline</span>
 193 |     | <span class='unexecuted'>    ) public override onlyOperators returns (uint256 amountOut) {</span>
 194 |     | <span class='unexecuted'>        return super.sellQuoteTokensForETH(lp, to, amountIn, minimumOut, deadline);</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'>}</span>
 197 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/periphery/Router.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solady/utils/SafeTransferLib.sol&quot;;</span>
   5 |     | <span class='neutral'>import {IERC20} from &quot;openzeppelin-contracts/interfaces/IERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import {Math} from &quot;/mimswap/libraries/Math.sol&quot;;</span>
   7 |     | <span class='neutral'>import {DecimalMath} from &quot;/mimswap/libraries/DecimalMath.sol&quot;;</span>
   8 |     | <span class='neutral'>import {IWETH} from &quot;interfaces/IWETH.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IMagicLP} from &quot;/mimswap/interfaces/IMagicLP.sol&quot;;</span>
  10 |     | <span class='neutral'>import {IFactory} from &quot;/mimswap/interfaces/IFactory.sol&quot;;</span>
  11 |     | <span class='neutral'>import {IERC20Metadata} from &quot;openzeppelin-contracts/interfaces/IERC20Metadata.sol&quot;;</span>
  12 |     | <span class='neutral'>import {ReentrancyGuard} from &quot;solady/utils/ReentrancyGuard.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/// @notice Router for creating and interacting with MagicLP</span>
  15 |     | <span class='neutral'>/// Can only be used for pool created by the Factory</span>
  16 |     | <span class='neutral'>///</span>
  17 |     | <span class='neutral'>/// @dev A pool can be removed from the Factory. So, when integrating with this contract,</span>
  18 |     | <span class='neutral'>/// validate that the pool exists using the Factory `poolExists` function.</span>
  19 | *   | <span class='executed'>contract Router is ReentrancyGuard {</span>
  20 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
  21 |     | <span class='neutral'>    using SafeTransferLib for address payable;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    error ErrNotETHLP();</span>
  24 |     | <span class='neutral'>    error ErrExpired();</span>
  25 |     | <span class='neutral'>    error ErrZeroAddress();</span>
  26 |     | <span class='neutral'>    error ErrPathTooLong();</span>
  27 |     | <span class='neutral'>    error ErrEmptyPath();</span>
  28 |     | <span class='neutral'>    error ErrBadPath();</span>
  29 |     | <span class='neutral'>    error ErrTooHighSlippage(uint256 amountOut);</span>
  30 |     | <span class='neutral'>    error ErrInvalidBaseToken();</span>
  31 |     | <span class='neutral'>    error ErrInvalidQuoteToken();</span>
  32 |     | <span class='neutral'>    error ErrInTokenNotETH();</span>
  33 |     | <span class='neutral'>    error ErrOutTokenNotETH();</span>
  34 |     | <span class='neutral'>    error ErrInvalidQuoteTarget();</span>
  35 |     | <span class='neutral'>    error ErrZeroDecimals();</span>
  36 |     | <span class='neutral'>    error ErrDecimalsDifferenceTooLarge();</span>
  37 |     | <span class='neutral'>    error ErrUnknownPool();</span>
  38 |     | <span class='neutral'></span>
  39 | *   | <span class='executed'>    uint256 public constant MAX_BASE_QUOTE_DECIMALS_DIFFERENCE = 12;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>    IWETH public immutable weth;</span>
  42 |     | <span class='unexecuted'>    IFactory public immutable factory;</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    receive() external payable {}</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>    constructor(IWETH weth_, IFactory factory_) {</span>
  47 |     | <span class='unexecuted'>        if (address(weth_) == address(0) || address(factory_) == address(0)) {</span>
  48 |     | <span class='unexecuted'>            revert ErrZeroAddress();</span>
  49 |     | <span class='neutral'>        }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>        weth = weth_;</span>
  52 |     | <span class='unexecuted'>        factory = factory_;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    modifier ensureDeadline(uint256 deadline) {</span>
  56 | *   | <span class='executed'>        if (block.timestamp &gt; deadline) {</span>
  57 |     | <span class='unexecuted'>            revert ErrExpired();</span>
  58 |     | <span class='neutral'>        }</span>
  59 | *   | <span class='executed'>        _;</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    modifier onlyKnownPool(address pool) {</span>
  63 | *   | <span class='executed'>        if (!factory.poolExists(pool)) {</span>
  64 |     | <span class='unexecuted'>            revert ErrUnknownPool();</span>
  65 |     | <span class='neutral'>        }</span>
  66 | *   | <span class='executed'>        _;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 | *   | <span class='executed'>    function createPool(</span>
  70 |     | <span class='neutral'>        address baseToken,</span>
  71 |     | <span class='neutral'>        address quoteToken,</span>
  72 |     | <span class='neutral'>        uint256 lpFeeRate,</span>
  73 |     | <span class='neutral'>        uint256 i,</span>
  74 |     | <span class='neutral'>        uint256 k,</span>
  75 |     | <span class='neutral'>        address to,</span>
  76 |     | <span class='neutral'>        uint256 baseInAmount,</span>
  77 |     | <span class='neutral'>        uint256 quoteInAmount,</span>
  78 |     | <span class='neutral'>        bool protocolOwnedPool</span>
  79 | *   | <span class='executed'>    ) public virtual returns (address clone, uint256 shares) {</span>
  80 | *   | <span class='executed'>        _validateDecimals(IERC20Metadata(baseToken).decimals(), IERC20Metadata(quoteToken).decimals());</span>
  81 |     | <span class='neutral'></span>
  82 | *   | <span class='executed'>        clone = IFactory(factory).create(baseToken, quoteToken, lpFeeRate, i, k, protocolOwnedPool);</span>
  83 |     | <span class='neutral'></span>
  84 | *   | <span class='executed'>        baseToken.safeTransferFrom(msg.sender, clone, baseInAmount);</span>
  85 | *   | <span class='executed'>        quoteToken.safeTransferFrom(msg.sender, clone, quoteInAmount);</span>
  86 | *   | <span class='executed'>        (shares, , ) = IMagicLP(clone).buyShares(to);</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 | *   | <span class='executed'>    function createPoolETH(</span>
  90 |     | <span class='neutral'>        address token,</span>
  91 |     | <span class='neutral'>        bool useTokenAsQuote,</span>
  92 |     | <span class='neutral'>        uint256 lpFeeRate,</span>
  93 |     | <span class='neutral'>        uint256 i,</span>
  94 |     | <span class='neutral'>        uint256 k,</span>
  95 |     | <span class='neutral'>        address to,</span>
  96 |     | <span class='neutral'>        uint256 tokenInAmount,</span>
  97 |     | <span class='neutral'>        bool protocolOwnedPool</span>
  98 | *   | <span class='executed'>    ) public payable virtual returns (address clone, uint256 shares) {</span>
  99 | *   | <span class='executed'>        if (useTokenAsQuote) {</span>
 100 | *   | <span class='executed'>            _validateDecimals(18, IERC20Metadata(token).decimals());</span>
 101 |     | <span class='neutral'>        } else {</span>
 102 | *   | <span class='executed'>            _validateDecimals(IERC20Metadata(token).decimals(), 18);</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='neutral'></span>
 105 | *   | <span class='executed'>        clone = IFactory(factory).create(</span>
 106 | *   | <span class='executed'>            useTokenAsQuote ? address(weth) : token,</span>
 107 | *   | <span class='executed'>            useTokenAsQuote ? token : address(weth),</span>
 108 |     | <span class='neutral'>            lpFeeRate,</span>
 109 |     | <span class='neutral'>            i,</span>
 110 |     | <span class='neutral'>            k,</span>
 111 |     | <span class='neutral'>            protocolOwnedPool</span>
 112 |     | <span class='neutral'>        );</span>
 113 |     | <span class='neutral'></span>
 114 | *   | <span class='executed'>        weth.deposit{value: msg.value}();</span>
 115 | *   | <span class='executed'>        token.safeTransferFrom(msg.sender, clone, tokenInAmount);</span>
 116 | *   | <span class='executed'>        address(weth).safeTransferFrom(address(this), clone, msg.value);</span>
 117 | *   | <span class='executed'>        (shares, , ) = IMagicLP(clone).buyShares(to);</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>    function previewCreatePool(</span>
 121 |     | <span class='neutral'>        uint256 i,</span>
 122 |     | <span class='neutral'>        uint256 baseInAmount,</span>
 123 |     | <span class='neutral'>        uint256 quoteInAmount</span>
 124 |     | <span class='unexecuted'>    ) external pure returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {</span>
 125 |     | <span class='unexecuted'>        shares = quoteInAmount &lt; DecimalMath.mulFloor(baseInAmount, i) ? DecimalMath.divFloor(quoteInAmount, i) : baseInAmount;</span>
 126 |     | <span class='unexecuted'>        baseAdjustedInAmount = shares;</span>
 127 |     | <span class='unexecuted'>        quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>        if (shares &lt;= 2001) {</span>
 130 |     | <span class='unexecuted'>            return (0, 0, 0);</span>
 131 |     | <span class='neutral'>        }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>        shares -= 1001;</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 | *   | <span class='executed'>    function previewAddLiquidity(</span>
 137 |     | <span class='neutral'>        address lp,</span>
 138 |     | <span class='neutral'>        uint256 baseInAmount,</span>
 139 |     | <span class='neutral'>        uint256 quoteInAmount</span>
 140 |     | <span class='neutral'>    )</span>
 141 |     | <span class='neutral'>        external</span>
 142 |     | <span class='neutral'>        view</span>
 143 |     | <span class='neutral'>        nonReadReentrant</span>
 144 | *   | <span class='executed'>        onlyKnownPool(lp)</span>
 145 | *   | <span class='executed'>        returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares)</span>
 146 | *   | <span class='executed'>    {</span>
 147 | *   | <span class='executed'>        (uint256 baseReserve, uint256 quoteReserve) = IMagicLP(lp).getReserves();</span>
 148 |     | <span class='neutral'></span>
 149 | *   | <span class='executed'>        uint256 baseBalance = IMagicLP(lp)._BASE_TOKEN_().balanceOf(address(lp)) + baseInAmount;</span>
 150 | *   | <span class='executed'>        uint256 quoteBalance = IMagicLP(lp)._QUOTE_TOKEN_().balanceOf(address(lp)) + quoteInAmount;</span>
 151 |     | <span class='neutral'></span>
 152 | *   | <span class='executed'>        baseInAmount = baseBalance - baseReserve;</span>
 153 | *   | <span class='executed'>        quoteInAmount = quoteBalance - quoteReserve;</span>
 154 |     | <span class='neutral'></span>
 155 | *   | <span class='executed'>        if (baseInAmount == 0) {</span>
 156 | *   | <span class='executed'>            return (0, 0, 0);</span>
 157 |     | <span class='neutral'>        }</span>
 158 |     | <span class='neutral'></span>
 159 | *   | <span class='executed'>        uint256 totalSupply = IERC20(lp).totalSupply();</span>
 160 |     | <span class='neutral'></span>
 161 | *   | <span class='executed'>        if (totalSupply == 0) {</span>
 162 | *   | <span class='executed'>            if (quoteBalance == 0) {</span>
 163 | *   | <span class='executed'>                return (0, 0, 0);</span>
 164 |     | <span class='neutral'>            }</span>
 165 |     | <span class='neutral'></span>
 166 | *   | <span class='executed'>            uint256 i = IMagicLP(lp)._I_();</span>
 167 |     | <span class='neutral'></span>
 168 | *   | <span class='executed'>            shares = quoteBalance &lt; DecimalMath.mulFloor(baseBalance, i) ? DecimalMath.divFloor(quoteBalance, i) : baseBalance;</span>
 169 | *   | <span class='executed'>            baseAdjustedInAmount = shares;</span>
 170 | *   | <span class='executed'>            quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);</span>
 171 |     | <span class='neutral'></span>
 172 | *   | <span class='executed'>            if (shares &lt;= 2001) {</span>
 173 | *   | <span class='executed'>                return (0, 0, 0);</span>
 174 |     | <span class='neutral'>            }</span>
 175 |     | <span class='neutral'></span>
 176 | *   | <span class='executed'>            shares -= 1001;</span>
 177 | *   | <span class='executed'>        } else if (baseReserve &gt; 0 &amp;&amp; quoteReserve &gt; 0) {</span>
 178 | *   | <span class='executed'>            uint256 baseInputRatio = DecimalMath.divFloor(baseInAmount, baseReserve);</span>
 179 | *   | <span class='executed'>            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInAmount, quoteReserve);</span>
 180 | *   | <span class='executed'>            if (baseInputRatio &lt;= quoteInputRatio) {</span>
 181 | *   | <span class='executed'>                baseAdjustedInAmount = baseInAmount;</span>
 182 | *   | <span class='executed'>                quoteAdjustedInAmount = DecimalMath.mulCeil(quoteReserve, baseInputRatio);</span>
 183 | *   | <span class='executed'>                shares = DecimalMath.mulFloor(totalSupply, baseInputRatio);</span>
 184 |     | <span class='neutral'>            } else {</span>
 185 | *   | <span class='executed'>                quoteAdjustedInAmount = quoteInAmount;</span>
 186 | *   | <span class='executed'>                baseAdjustedInAmount = DecimalMath.mulCeil(baseReserve, quoteInputRatio);</span>
 187 | *   | <span class='executed'>                shares = DecimalMath.mulFloor(totalSupply, quoteInputRatio);</span>
 188 |     | <span class='neutral'>            }</span>
 189 |     | <span class='neutral'>        }</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 | *   | <span class='executed'>    function addLiquidity(</span>
 193 |     | <span class='neutral'>        address lp,</span>
 194 |     | <span class='neutral'>        address to,</span>
 195 |     | <span class='neutral'>        uint256 baseInAmount,</span>
 196 |     | <span class='neutral'>        uint256 quoteInAmount,</span>
 197 |     | <span class='neutral'>        uint256 minimumShares,</span>
 198 |     | <span class='neutral'>        uint256 deadline</span>
 199 |     | <span class='neutral'>    )</span>
 200 |     | <span class='neutral'>        public</span>
 201 |     | <span class='neutral'>        virtual</span>
 202 | *   | <span class='executed'>        ensureDeadline(deadline)</span>
 203 | *   | <span class='executed'>        onlyKnownPool(lp)</span>
 204 | *   | <span class='executed'>        returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares)</span>
 205 |     | <span class='neutral'>    {</span>
 206 | *   | <span class='executed'>        (baseAdjustedInAmount, quoteAdjustedInAmount) = _adjustAddLiquidity(lp, baseInAmount, quoteInAmount);</span>
 207 |     | <span class='neutral'></span>
 208 | *   | <span class='executed'>        IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, baseAdjustedInAmount);</span>
 209 | *   | <span class='executed'>        IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, quoteAdjustedInAmount);</span>
 210 |     | <span class='neutral'></span>
 211 | *   | <span class='executed'>        shares = _addLiquidity(lp, to, minimumShares);</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 | *   | <span class='executed'>    function addLiquidityUnsafe(</span>
 215 |     | <span class='neutral'>        address lp,</span>
 216 |     | <span class='neutral'>        address to,</span>
 217 |     | <span class='neutral'>        uint256 baseInAmount,</span>
 218 |     | <span class='neutral'>        uint256 quoteInAmount,</span>
 219 |     | <span class='neutral'>        uint256 minimumShares,</span>
 220 |     | <span class='neutral'>        uint256 deadline</span>
 221 | *   | <span class='executed'>    ) public virtual ensureDeadline(deadline) onlyKnownPool(lp) returns (uint256 shares) {</span>
 222 | *   | <span class='executed'>        IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, baseInAmount);</span>
 223 | *   | <span class='executed'>        IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, quoteInAmount);</span>
 224 |     | <span class='neutral'></span>
 225 | *   | <span class='executed'>        return _addLiquidity(lp, to, minimumShares);</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='unexecuted'>    function addLiquidityETH(</span>
 229 |     | <span class='neutral'>        address lp,</span>
 230 |     | <span class='neutral'>        address to,</span>
 231 |     | <span class='neutral'>        address payable refundTo,</span>
 232 |     | <span class='neutral'>        uint256 tokenInAmount,</span>
 233 |     | <span class='neutral'>        uint256 minimumShares,</span>
 234 |     | <span class='neutral'>        uint256 deadline</span>
 235 |     | <span class='neutral'>    )</span>
 236 |     | <span class='neutral'>        public</span>
 237 |     | <span class='neutral'>        payable</span>
 238 |     | <span class='neutral'>        virtual</span>
 239 |     | <span class='neutral'>        nonReentrant</span>
 240 |     | <span class='unexecuted'>        ensureDeadline(deadline)</span>
 241 |     | <span class='unexecuted'>        onlyKnownPool(lp)</span>
 242 |     | <span class='unexecuted'>        returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares)</span>
 243 |     | <span class='unexecuted'>    {</span>
 244 |     | <span class='unexecuted'>        uint256 wethAdjustedAmount;</span>
 245 |     | <span class='unexecuted'>        uint256 tokenAdjustedAmount;</span>
 246 |     | <span class='unexecuted'>        address token = IMagicLP(lp)._BASE_TOKEN_();</span>
 247 |     | <span class='unexecuted'>        if (token == address(weth)) {</span>
 248 |     | <span class='unexecuted'>            token = IMagicLP(lp)._QUOTE_TOKEN_();</span>
 249 |     | <span class='unexecuted'>            (baseAdjustedInAmount, quoteAdjustedInAmount) = _adjustAddLiquidity(lp, msg.value, tokenInAmount);</span>
 250 |     | <span class='neutral'>            wethAdjustedAmount = baseAdjustedInAmount;</span>
 251 |     | <span class='neutral'>            tokenAdjustedAmount = quoteAdjustedInAmount;</span>
 252 |     | <span class='unexecuted'>        } else if (IMagicLP(lp)._QUOTE_TOKEN_() == address(weth)) {</span>
 253 |     | <span class='unexecuted'>            (baseAdjustedInAmount, quoteAdjustedInAmount) = _adjustAddLiquidity(lp, tokenInAmount, msg.value);</span>
 254 |     | <span class='neutral'>            wethAdjustedAmount = quoteAdjustedInAmount;</span>
 255 |     | <span class='neutral'>            tokenAdjustedAmount = baseAdjustedInAmount;</span>
 256 |     | <span class='neutral'>        } else {</span>
 257 |     | <span class='unexecuted'>            revert ErrNotETHLP();</span>
 258 |     | <span class='neutral'>        }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='unexecuted'>        weth.deposit{value: wethAdjustedAmount}();</span>
 261 |     | <span class='unexecuted'>        address(weth).safeTransfer(lp, wethAdjustedAmount);</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>        // Refund unused ETH</span>
 264 |     | <span class='unexecuted'>        if (msg.value &gt; wethAdjustedAmount) {</span>
 265 |     | <span class='unexecuted'>            refundTo.safeTransferETH(msg.value - wethAdjustedAmount);</span>
 266 |     | <span class='neutral'>        }</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='unexecuted'>        token.safeTransferFrom(msg.sender, lp, tokenAdjustedAmount);</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='unexecuted'>        shares = _addLiquidity(lp, to, minimumShares);</span>
 271 |     | <span class='neutral'>    }</span>
 272 |     | <span class='neutral'></span>
 273 | *   | <span class='executed'>    function addLiquidityETHUnsafe(</span>
 274 |     | <span class='neutral'>        address lp,</span>
 275 |     | <span class='neutral'>        address to,</span>
 276 |     | <span class='neutral'>        uint256 tokenInAmount,</span>
 277 |     | <span class='neutral'>        uint256 minimumShares,</span>
 278 |     | <span class='neutral'>        uint256 deadline</span>
 279 |     | <span class='unexecuted'>    ) public payable virtual ensureDeadline(deadline) onlyKnownPool(lp) returns (uint256 shares) {</span>
 280 |     | <span class='unexecuted'>        address token = IMagicLP(lp)._BASE_TOKEN_();</span>
 281 |     | <span class='unexecuted'>        if (token == address(weth)) {</span>
 282 |     | <span class='unexecuted'>            token = IMagicLP(lp)._QUOTE_TOKEN_();</span>
 283 |     | <span class='unexecuted'>        } else if (IMagicLP(lp)._QUOTE_TOKEN_() != address(weth)) {</span>
 284 |     | <span class='unexecuted'>            revert ErrNotETHLP();</span>
 285 |     | <span class='neutral'>        }</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='unexecuted'>        weth.deposit{value: msg.value}();</span>
 288 |     | <span class='unexecuted'>        address(weth).safeTransfer(lp, msg.value);</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='unexecuted'>        token.safeTransferFrom(msg.sender, lp, tokenInAmount);</span>
 291 |     | <span class='neutral'></span>
 292 | *   | <span class='executed'>        return _addLiquidity(lp, to, minimumShares);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 | *   | <span class='executed'>    function previewRemoveLiquidity(</span>
 296 |     | <span class='neutral'>        address lp,</span>
 297 |     | <span class='neutral'>        uint256 sharesIn</span>
 298 | *   | <span class='executed'>    ) external view nonReadReentrant onlyKnownPool(lp) returns (uint256 baseAmountOut, uint256 quoteAmountOut) {</span>
 299 | *   | <span class='executed'>        uint256 baseBalance = IMagicLP(lp)._BASE_TOKEN_().balanceOf(address(lp));</span>
 300 | *   | <span class='executed'>        uint256 quoteBalance = IMagicLP(lp)._QUOTE_TOKEN_().balanceOf(address(lp));</span>
 301 |     | <span class='neutral'></span>
 302 | *   | <span class='executed'>        uint256 totalShares = IERC20(lp).totalSupply();</span>
 303 |     | <span class='neutral'></span>
 304 | *   | <span class='executed'>        baseAmountOut = (baseBalance * sharesIn) / totalShares;</span>
 305 | *   | <span class='executed'>        quoteAmountOut = (quoteBalance * sharesIn) / totalShares;</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'></span>
 308 | *   | <span class='executed'>    function removeLiquidity(</span>
 309 |     | <span class='neutral'>        address lp,</span>
 310 |     | <span class='neutral'>        address to,</span>
 311 |     | <span class='neutral'>        uint256 sharesIn,</span>
 312 |     | <span class='neutral'>        uint256 minimumBaseAmount,</span>
 313 |     | <span class='neutral'>        uint256 minimumQuoteAmount,</span>
 314 |     | <span class='neutral'>        uint256 deadline</span>
 315 |     | <span class='neutral'>    ) public virtual onlyKnownPool(lp) returns (uint256 baseAmountOut, uint256 quoteAmountOut) {</span>
 316 | *   | <span class='executed'>        lp.safeTransferFrom(msg.sender, address(this), sharesIn);</span>
 317 |     | <span class='neutral'></span>
 318 | *   | <span class='executed'>        return IMagicLP(lp).sellShares(sharesIn, to, minimumBaseAmount, minimumQuoteAmount, &quot;&quot;, deadline);</span>
 319 |     | <span class='neutral'>    }</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='unexecuted'>    function removeLiquidityETH(</span>
 322 |     | <span class='neutral'>        address lp,</span>
 323 |     | <span class='neutral'>        address to,</span>
 324 |     | <span class='neutral'>        uint256 sharesIn,</span>
 325 |     | <span class='neutral'>        uint256 minimumETHAmount,</span>
 326 |     | <span class='neutral'>        uint256 minimumTokenAmount,</span>
 327 |     | <span class='neutral'>        uint256 deadline</span>
 328 |     | <span class='unexecuted'>    ) public virtual onlyKnownPool(lp) returns (uint256 ethAmountOut, uint256 tokenAmountOut) {</span>
 329 |     | <span class='unexecuted'>        lp.safeTransferFrom(msg.sender, address(this), sharesIn);</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='unexecuted'>        address token = IMagicLP(lp)._BASE_TOKEN_();</span>
 332 |     | <span class='unexecuted'>        if (token == address(weth)) {</span>
 333 |     | <span class='unexecuted'>            token = IMagicLP(lp)._QUOTE_TOKEN_();</span>
 334 |     | <span class='unexecuted'>            (ethAmountOut, tokenAmountOut) = IMagicLP(lp).sellShares(</span>
 335 |     | <span class='neutral'>                sharesIn,</span>
 336 |     | <span class='unexecuted'>                address(this),</span>
 337 |     | <span class='neutral'>                minimumETHAmount,</span>
 338 |     | <span class='neutral'>                minimumTokenAmount,</span>
 339 |     | <span class='neutral'>                &quot;&quot;,</span>
 340 |     | <span class='neutral'>                deadline</span>
 341 |     | <span class='neutral'>            );</span>
 342 |     | <span class='unexecuted'>        } else if (IMagicLP(lp)._QUOTE_TOKEN_() == address(weth)) {</span>
 343 |     | <span class='unexecuted'>            (tokenAmountOut, ethAmountOut) = IMagicLP(lp).sellShares(</span>
 344 |     | <span class='neutral'>                sharesIn,</span>
 345 |     | <span class='unexecuted'>                address(this),</span>
 346 |     | <span class='neutral'>                minimumTokenAmount,</span>
 347 |     | <span class='neutral'>                minimumETHAmount,</span>
 348 |     | <span class='neutral'>                &quot;&quot;,</span>
 349 |     | <span class='neutral'>                deadline</span>
 350 |     | <span class='neutral'>            );</span>
 351 |     | <span class='neutral'>        } else {</span>
 352 |     | <span class='neutral'>            revert ErrNotETHLP();</span>
 353 |     | <span class='neutral'>        }</span>
 354 |     | <span class='neutral'></span>
 355 |     | <span class='unexecuted'>        weth.withdraw(ethAmountOut);</span>
 356 |     | <span class='unexecuted'>        to.safeTransferETH(ethAmountOut);</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='unexecuted'>        token.safeTransfer(to, tokenAmountOut);</span>
 359 |     | <span class='neutral'>    }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='unexecuted'>    function swapTokensForTokens(</span>
 362 |     | <span class='neutral'>        address to,</span>
 363 |     | <span class='neutral'>        uint256 amountIn,</span>
 364 |     | <span class='neutral'>        address[] calldata path,</span>
 365 |     | <span class='neutral'>        uint256 directions,</span>
 366 |     | <span class='neutral'>        uint256 minimumOut,</span>
 367 |     | <span class='neutral'>        uint256 deadline</span>
 368 |     | <span class='unexecuted'>    ) public virtual ensureDeadline(deadline) returns (uint256 amountOut) {</span>
 369 |     | <span class='unexecuted'>        _validatePath(path);</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='unexecuted'>        address firstLp = path[0];</span>
 372 |     | <span class='neutral'></span>
 373 |     | <span class='neutral'>        // Transfer to the first LP</span>
 374 |     | <span class='unexecuted'>        if (directions &amp; 1 == 0) {</span>
 375 |     | <span class='unexecuted'>            IMagicLP(firstLp)._BASE_TOKEN_().safeTransferFrom(msg.sender, address(firstLp), amountIn);</span>
 376 |     | <span class='neutral'>        } else {</span>
 377 |     | <span class='unexecuted'>            IMagicLP(firstLp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, address(firstLp), amountIn);</span>
 378 |     | <span class='neutral'>        }</span>
 379 |     | <span class='neutral'></span>
 380 |     | <span class='unexecuted'>        return _swap(to, path, directions, minimumOut);</span>
 381 |     | <span class='neutral'>    }</span>
 382 |     | <span class='neutral'></span>
 383 |     | <span class='unexecuted'>    function swapETHForTokens(</span>
 384 |     | <span class='neutral'>        address to,</span>
 385 |     | <span class='neutral'>        address[] calldata path,</span>
 386 |     | <span class='neutral'>        uint256 directions,</span>
 387 |     | <span class='neutral'>        uint256 minimumOut,</span>
 388 |     | <span class='neutral'>        uint256 deadline</span>
 389 |     | <span class='unexecuted'>    ) public payable virtual ensureDeadline(deadline) returns (uint256 amountOut) {</span>
 390 |     | <span class='unexecuted'>        _validatePath(path);</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='unexecuted'>        address firstLp = path[0];</span>
 393 |     | <span class='unexecuted'>        address inToken;</span>
 394 |     | <span class='neutral'></span>
 395 |     | <span class='unexecuted'>        if (directions &amp; 1 == 0) {</span>
 396 |     | <span class='unexecuted'>            inToken = IMagicLP(firstLp)._BASE_TOKEN_();</span>
 397 |     | <span class='neutral'>        } else {</span>
 398 |     | <span class='unexecuted'>            inToken = IMagicLP(firstLp)._QUOTE_TOKEN_();</span>
 399 |     | <span class='neutral'>        }</span>
 400 |     | <span class='neutral'></span>
 401 |     | <span class='neutral'>        // Transfer to the first LP</span>
 402 |     | <span class='unexecuted'>        if (inToken != address(weth)) {</span>
 403 |     | <span class='unexecuted'>            revert ErrInTokenNotETH();</span>
 404 |     | <span class='neutral'>        }</span>
 405 |     | <span class='neutral'></span>
 406 |     | <span class='unexecuted'>        weth.deposit{value: msg.value}();</span>
 407 |     | <span class='unexecuted'>        inToken.safeTransfer(address(firstLp), msg.value);</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='unexecuted'>        return _swap(to, path, directions, minimumOut);</span>
 410 |     | <span class='neutral'>    }</span>
 411 |     | <span class='neutral'></span>
 412 |     | <span class='unexecuted'>    function swapTokensForETH(</span>
 413 |     | <span class='neutral'>        address to,</span>
 414 |     | <span class='neutral'>        uint256 amountIn,</span>
 415 |     | <span class='neutral'>        address[] calldata path,</span>
 416 |     | <span class='neutral'>        uint256 directions,</span>
 417 |     | <span class='neutral'>        uint256 minimumOut,</span>
 418 |     | <span class='neutral'>        uint256 deadline</span>
 419 |     | <span class='unexecuted'>    ) public virtual ensureDeadline(deadline) returns (uint256 amountOut) {</span>
 420 |     | <span class='unexecuted'>        _validatePath(path);</span>
 421 |     | <span class='neutral'></span>
 422 |     | <span class='unexecuted'>        uint256 lastLpIndex = path.length - 1;</span>
 423 |     | <span class='unexecuted'>        address lastLp = path[lastLpIndex];</span>
 424 |     | <span class='unexecuted'>        address outToken;</span>
 425 |     | <span class='neutral'></span>
 426 |     | <span class='unexecuted'>        if ((directions &gt;&gt; lastLpIndex) &amp; 1 == 0) {</span>
 427 |     | <span class='unexecuted'>            outToken = IMagicLP(lastLp)._QUOTE_TOKEN_();</span>
 428 |     | <span class='neutral'>        } else {</span>
 429 |     | <span class='unexecuted'>            outToken = IMagicLP(lastLp)._BASE_TOKEN_();</span>
 430 |     | <span class='neutral'>        }</span>
 431 |     | <span class='neutral'></span>
 432 |     | <span class='unexecuted'>        if (outToken != address(weth)) {</span>
 433 |     | <span class='unexecuted'>            revert ErrOutTokenNotETH();</span>
 434 |     | <span class='neutral'>        }</span>
 435 |     | <span class='neutral'></span>
 436 |     | <span class='unexecuted'>        address firstLp = path[0];</span>
 437 |     | <span class='neutral'></span>
 438 |     | <span class='neutral'>        // Transfer to the first LP</span>
 439 |     | <span class='unexecuted'>        if (directions &amp; 1 == 0) {</span>
 440 |     | <span class='unexecuted'>            IMagicLP(firstLp)._BASE_TOKEN_().safeTransferFrom(msg.sender, firstLp, amountIn);</span>
 441 |     | <span class='neutral'>        } else {</span>
 442 |     | <span class='unexecuted'>            IMagicLP(firstLp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, firstLp, amountIn);</span>
 443 |     | <span class='neutral'>        }</span>
 444 |     | <span class='neutral'></span>
 445 |     | <span class='unexecuted'>        amountOut = _swap(address(this), path, directions, minimumOut);</span>
 446 |     | <span class='unexecuted'>        weth.withdraw(amountOut);</span>
 447 |     | <span class='neutral'></span>
 448 |     | <span class='unexecuted'>        to.safeTransferETH(amountOut);</span>
 449 |     | <span class='neutral'>    }</span>
 450 |     | <span class='neutral'></span>
 451 | *   | <span class='executed'>    function sellBaseTokensForTokens(</span>
 452 |     | <span class='neutral'>        address lp,</span>
 453 |     | <span class='neutral'>        address to,</span>
 454 |     | <span class='neutral'>        uint256 amountIn,</span>
 455 |     | <span class='neutral'>        uint256 minimumOut,</span>
 456 |     | <span class='neutral'>        uint256 deadline</span>
 457 | *   | <span class='executed'>    ) public virtual ensureDeadline(deadline) onlyKnownPool(lp) returns (uint256 amountOut) {</span>
 458 | *   | <span class='executed'>        IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, amountIn);</span>
 459 | *   | <span class='executed'>        return _sellBase(lp, to, minimumOut);</span>
 460 |     | <span class='neutral'>    }</span>
 461 |     | <span class='neutral'></span>
 462 | *   | <span class='executed'>    function sellBaseETHForTokens(</span>
 463 |     | <span class='neutral'>        address lp,</span>
 464 |     | <span class='neutral'>        address to,</span>
 465 |     | <span class='neutral'>        uint256 minimumOut,</span>
 466 |     | <span class='neutral'>        uint256 deadline</span>
 467 |     | <span class='unexecuted'>    ) public payable virtual ensureDeadline(deadline) onlyKnownPool(lp) returns (uint256 amountOut) {</span>
 468 |     | <span class='unexecuted'>        address baseToken = IMagicLP(lp)._BASE_TOKEN_();</span>
 469 |     | <span class='neutral'></span>
 470 |     | <span class='unexecuted'>        if (baseToken != address(weth)) {</span>
 471 |     | <span class='unexecuted'>            revert ErrInvalidBaseToken();</span>
 472 |     | <span class='neutral'>        }</span>
 473 |     | <span class='neutral'></span>
 474 |     | <span class='unexecuted'>        weth.deposit{value: msg.value}();</span>
 475 |     | <span class='unexecuted'>        baseToken.safeTransfer(lp, msg.value);</span>
 476 | *   | <span class='executed'>        return _sellBase(lp, to, minimumOut);</span>
 477 |     | <span class='neutral'>    }</span>
 478 |     | <span class='neutral'></span>
 479 |     | <span class='unexecuted'>    function sellBaseTokensForETH(</span>
 480 |     | <span class='neutral'>        address lp,</span>
 481 |     | <span class='neutral'>        address to,</span>
 482 |     | <span class='neutral'>        uint256 amountIn,</span>
 483 |     | <span class='neutral'>        uint256 minimumOut,</span>
 484 |     | <span class='neutral'>        uint256 deadline</span>
 485 |     | <span class='unexecuted'>    ) public virtual ensureDeadline(deadline) onlyKnownPool(lp) returns (uint256 amountOut) {</span>
 486 |     | <span class='unexecuted'>        if (IMagicLP(lp)._QUOTE_TOKEN_() != address(weth)) {</span>
 487 |     | <span class='unexecuted'>            revert ErrInvalidQuoteToken();</span>
 488 |     | <span class='neutral'>        }</span>
 489 |     | <span class='neutral'></span>
 490 |     | <span class='unexecuted'>        IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, amountIn);</span>
 491 |     | <span class='unexecuted'>        amountOut = _sellBase(lp, address(this), minimumOut);</span>
 492 |     | <span class='neutral'>        weth.withdraw(amountOut);</span>
 493 |     | <span class='neutral'>        to.safeTransferETH(amountOut);</span>
 494 |     | <span class='neutral'>    }</span>
 495 |     | <span class='neutral'></span>
 496 | *   | <span class='executed'>    function sellQuoteTokensForTokens(</span>
 497 |     | <span class='neutral'>        address lp,</span>
 498 |     | <span class='neutral'>        address to,</span>
 499 |     | <span class='neutral'>        uint256 amountIn,</span>
 500 |     | <span class='neutral'>        uint256 minimumOut,</span>
 501 |     | <span class='neutral'>        uint256 deadline</span>
 502 | *   | <span class='executed'>    ) public virtual ensureDeadline(deadline) onlyKnownPool(lp) returns (uint256 amountOut) {</span>
 503 | *   | <span class='executed'>        IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, amountIn);</span>
 504 |     | <span class='neutral'></span>
 505 | *   | <span class='executed'>        return _sellQuote(lp, to, minimumOut);</span>
 506 |     | <span class='neutral'>    }</span>
 507 |     | <span class='neutral'></span>
 508 |     | <span class='unexecuted'>    function sellQuoteETHForTokens(</span>
 509 |     | <span class='neutral'>        address lp,</span>
 510 |     | <span class='neutral'>        address to,</span>
 511 |     | <span class='neutral'>        uint256 minimumOut,</span>
 512 |     | <span class='neutral'>        uint256 deadline</span>
 513 |     | <span class='unexecuted'>    ) public payable virtual ensureDeadline(deadline) onlyKnownPool(lp) returns (uint256 amountOut) {</span>
 514 |     | <span class='unexecuted'>        address quoteToken = IMagicLP(lp)._QUOTE_TOKEN_();</span>
 515 |     | <span class='neutral'></span>
 516 |     | <span class='unexecuted'>        if (quoteToken != address(weth)) {</span>
 517 |     | <span class='unexecuted'>            revert ErrInvalidQuoteToken();</span>
 518 |     | <span class='neutral'>        }</span>
 519 |     | <span class='neutral'></span>
 520 |     | <span class='unexecuted'>        weth.deposit{value: msg.value}();</span>
 521 |     | <span class='unexecuted'>        quoteToken.safeTransfer(lp, msg.value);</span>
 522 |     | <span class='unexecuted'>        return _sellQuote(lp, to, minimumOut);</span>
 523 |     | <span class='neutral'>    }</span>
 524 |     | <span class='neutral'></span>
 525 | *   | <span class='executed'>    function sellQuoteTokensForETH(</span>
 526 |     | <span class='neutral'>        address lp,</span>
 527 |     | <span class='neutral'>        address to,</span>
 528 |     | <span class='neutral'>        uint256 amountIn,</span>
 529 |     | <span class='neutral'>        uint256 minimumOut,</span>
 530 |     | <span class='neutral'>        uint256 deadline</span>
 531 |     | <span class='unexecuted'>    ) public virtual ensureDeadline(deadline) onlyKnownPool(lp) returns (uint256 amountOut) {</span>
 532 |     | <span class='unexecuted'>        if (IMagicLP(lp)._BASE_TOKEN_() != address(weth)) {</span>
 533 |     | <span class='unexecuted'>            revert ErrInvalidBaseToken();</span>
 534 |     | <span class='neutral'>        }</span>
 535 |     | <span class='neutral'></span>
 536 | *   | <span class='executed'>        IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, amountIn);</span>
 537 |     | <span class='unexecuted'>        amountOut = _sellQuote(lp, address(this), minimumOut);</span>
 538 |     | <span class='unexecuted'>        weth.withdraw(amountOut);</span>
 539 |     | <span class='unexecuted'>        to.safeTransferETH(amountOut);</span>
 540 |     | <span class='neutral'>    }</span>
 541 |     | <span class='neutral'></span>
 542 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 543 |     | <span class='neutral'>    /// INTERNALS</span>
 544 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////</span>
 545 |     | <span class='neutral'></span>
 546 | *   | <span class='executed'>    function _addLiquidity(address lp, address to, uint256 minimumShares) internal returns (uint256 shares) {</span>
 547 | *   | <span class='executed'>        (shares, , ) = IMagicLP(lp).buyShares(to);</span>
 548 |     | <span class='neutral'></span>
 549 | *   | <span class='executed'>        if (shares &lt; minimumShares) {</span>
 550 | *   | <span class='executed'>            revert ErrTooHighSlippage(shares);</span>
 551 |     | <span class='neutral'>        }</span>
 552 |     | <span class='neutral'>    }</span>
 553 |     | <span class='neutral'></span>
 554 |     | <span class='neutral'>    /// Adapted from: https://github.com/DODOEX/contractV2/blob/main/contracts/SmartRoute/proxies/DODODspProxy.sol</span>
 555 |     | <span class='neutral'>    /// Copyright 2020 DODO ZOO. Licensed under Apache-2.0.</span>
 556 | *   | <span class='executed'>    function _adjustAddLiquidity(</span>
 557 |     | <span class='neutral'>        address lp,</span>
 558 |     | <span class='neutral'>        uint256 baseInAmount,</span>
 559 |     | <span class='neutral'>        uint256 quoteInAmount</span>
 560 | *   | <span class='executed'>    ) internal view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount) {</span>
 561 | *   | <span class='executed'>        (uint256 baseReserve, uint256 quoteReserve) = IMagicLP(lp).getReserves();</span>
 562 | *   | <span class='executed'>        uint256 baseBalance = IMagicLP(lp)._BASE_TOKEN_().balanceOf(address(lp)) + baseInAmount;</span>
 563 | *   | <span class='executed'>        uint256 quoteBalance = IMagicLP(lp)._QUOTE_TOKEN_().balanceOf(address(lp)) + quoteInAmount;</span>
 564 |     | <span class='neutral'></span>
 565 | *   | <span class='executed'>        baseInAmount = baseBalance - baseReserve;</span>
 566 | *   | <span class='executed'>        quoteInAmount = quoteBalance - quoteReserve;</span>
 567 |     | <span class='neutral'></span>
 568 | *   | <span class='executed'>        if (IERC20(lp).totalSupply() == 0) {</span>
 569 | *   | <span class='executed'>            uint256 i = IMagicLP(lp)._I_();</span>
 570 | *   | <span class='executed'>            uint256 shares = quoteInAmount &lt; DecimalMath.mulFloor(baseInAmount, i) ? DecimalMath.divFloor(quoteInAmount, i) : baseInAmount;</span>
 571 | *   | <span class='executed'>            baseAdjustedInAmount = shares;</span>
 572 | *   | <span class='executed'>            quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);</span>
 573 |     | <span class='neutral'>        } else {</span>
 574 | *   | <span class='executed'>            if (quoteReserve &gt; 0 &amp;&amp; baseReserve &gt; 0) {</span>
 575 | *   | <span class='executed'>                uint256 baseIncreaseRatio = DecimalMath.divFloor(baseInAmount, baseReserve);</span>
 576 | *   | <span class='executed'>                uint256 quoteIncreaseRatio = DecimalMath.divFloor(quoteInAmount, quoteReserve);</span>
 577 | *   | <span class='executed'>                if (baseIncreaseRatio &lt;= quoteIncreaseRatio) {</span>
 578 | *   | <span class='executed'>                    baseAdjustedInAmount = baseInAmount;</span>
 579 | *   | <span class='executed'>                    quoteAdjustedInAmount = DecimalMath.mulFloor(quoteReserve, baseIncreaseRatio);</span>
 580 |     | <span class='neutral'>                } else {</span>
 581 | *   | <span class='executed'>                    quoteAdjustedInAmount = quoteInAmount;</span>
 582 | *   | <span class='executed'>                    baseAdjustedInAmount = DecimalMath.mulFloor(baseReserve, quoteIncreaseRatio);</span>
 583 |     | <span class='neutral'>                }</span>
 584 |     | <span class='neutral'>            }</span>
 585 |     | <span class='neutral'>        }</span>
 586 |     | <span class='neutral'>    }</span>
 587 |     | <span class='neutral'></span>
 588 |     | <span class='unexecuted'>    function _swap(address to, address[] calldata path, uint256 directions, uint256 minimumOut) internal returns (uint256 amountOut) {</span>
 589 |     | <span class='unexecuted'>        uint256 iterations = path.length - 1; // Subtract by one as last swap is done separately</span>
 590 |     | <span class='neutral'></span>
 591 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; iterations; ) {</span>
 592 |     | <span class='unexecuted'>            address lp = path[i];</span>
 593 |     | <span class='unexecuted'>            if (!factory.poolExists(lp)) {</span>
 594 |     | <span class='unexecuted'>                revert ErrUnknownPool();</span>
 595 |     | <span class='neutral'>            }</span>
 596 |     | <span class='neutral'></span>
 597 |     | <span class='unexecuted'>            if (directions &amp; 1 == 0) {</span>
 598 |     | <span class='neutral'>                // Sell base</span>
 599 |     | <span class='unexecuted'>                IMagicLP(lp).sellBase(address(path[i + 1]));</span>
 600 |     | <span class='neutral'>            } else {</span>
 601 |     | <span class='neutral'>                // Sell quote</span>
 602 |     | <span class='unexecuted'>                IMagicLP(lp).sellQuote(address(path[i + 1]));</span>
 603 |     | <span class='neutral'>            }</span>
 604 |     | <span class='neutral'></span>
 605 |     | <span class='unexecuted'>            directions &gt;&gt;= 1;</span>
 606 |     | <span class='neutral'></span>
 607 |     | <span class='neutral'>            unchecked {</span>
 608 |     | <span class='unexecuted'>                ++i;</span>
 609 |     | <span class='neutral'>            }</span>
 610 |     | <span class='neutral'>        }</span>
 611 |     | <span class='neutral'></span>
 612 |     | <span class='unexecuted'>        if ((directions &amp; 1 == 0)) {</span>
 613 |     | <span class='unexecuted'>            amountOut = IMagicLP(path[iterations]).sellBase(to);</span>
 614 |     | <span class='neutral'>        } else {</span>
 615 |     | <span class='unexecuted'>            amountOut = IMagicLP(path[iterations]).sellQuote(to);</span>
 616 |     | <span class='neutral'>        }</span>
 617 |     | <span class='neutral'></span>
 618 |     | <span class='unexecuted'>        if (amountOut &lt; minimumOut) {</span>
 619 |     | <span class='unexecuted'>            revert ErrTooHighSlippage(amountOut);</span>
 620 |     | <span class='neutral'>        }</span>
 621 |     | <span class='neutral'>    }</span>
 622 |     | <span class='neutral'></span>
 623 | *   | <span class='executed'>    function _sellBase(address lp, address to, uint256 minimumOut) internal returns (uint256 amountOut) {</span>
 624 | *   | <span class='executed'>        amountOut = IMagicLP(lp).sellBase(to);</span>
 625 |     | <span class='neutral'>        if (amountOut &lt; minimumOut) {</span>
 626 |     | <span class='neutral'>            revert ErrTooHighSlippage(amountOut);</span>
 627 |     | <span class='neutral'>        }</span>
 628 |     | <span class='neutral'>    }</span>
 629 |     | <span class='neutral'></span>
 630 | *   | <span class='executed'>    function _sellQuote(address lp, address to, uint256 minimumOut) internal returns (uint256 amountOut) {</span>
 631 | *   | <span class='executed'>        amountOut = IMagicLP(lp).sellQuote(to);</span>
 632 |     | <span class='neutral'></span>
 633 | *   | <span class='executed'>        if (amountOut &lt; minimumOut) {</span>
 634 | *   | <span class='executed'>            revert ErrTooHighSlippage(amountOut);</span>
 635 |     | <span class='neutral'>        }</span>
 636 |     | <span class='neutral'>    }</span>
 637 |     | <span class='neutral'></span>
 638 |     | <span class='unexecuted'>    function _validatePath(address[] calldata path) internal pure {</span>
 639 |     | <span class='unexecuted'>        uint256 pathLength = path.length;</span>
 640 |     | <span class='neutral'></span>
 641 |     | <span class='neutral'>        // Max 256 because of bits in directions</span>
 642 |     | <span class='unexecuted'>        if (pathLength &gt; 256) {</span>
 643 |     | <span class='unexecuted'>            revert ErrPathTooLong();</span>
 644 |     | <span class='neutral'>        }</span>
 645 |     | <span class='unexecuted'>        if (pathLength &lt;= 0) {</span>
 646 |     | <span class='unexecuted'>            revert ErrEmptyPath();</span>
 647 |     | <span class='neutral'>        }</span>
 648 |     | <span class='neutral'>    }</span>
 649 |     | <span class='neutral'></span>
 650 | *   | <span class='executed'>    function _validateDecimals(uint8 baseDecimals, uint8 quoteDecimals) internal pure {</span>
 651 | *   | <span class='executed'>        if (baseDecimals == 0 || quoteDecimals == 0) {</span>
 652 |     | <span class='unexecuted'>            revert ErrZeroDecimals();</span>
 653 |     | <span class='neutral'>        }</span>
 654 |     | <span class='neutral'></span>
 655 | *   | <span class='executed'>        uint256 deltaDecimals = baseDecimals &gt; quoteDecimals ? baseDecimals - quoteDecimals : quoteDecimals - baseDecimals;</span>
 656 |     | <span class='neutral'></span>
 657 | *   | <span class='executed'>        if (deltaDecimals &gt; MAX_BASE_QUOTE_DECIMALS_DIFFERENCE) {</span>
 658 | *   | <span class='executed'>            revert ErrDecimalsDifferenceTooLarge();</span>
 659 |     | <span class='neutral'>        }</span>
 660 |     | <span class='neutral'>    }</span>
 661 |     | <span class='neutral'>}</span>
 662 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/Create3Factory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {CREATE3} from &quot;solmate/utils/CREATE3.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract Create3Factory {</span>
  7 |     | <span class='neutral'>    event LogDeployed(address deployed, address sender, bytes32 salt);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function deploy(bytes32 salt, bytes memory bytecode, uint256 value) public returns (address deployed) {</span>
 10 |     | <span class='unexecuted'>        deployed = CREATE3.deploy(_getSalt(msg.sender, salt), bytecode, value);</span>
 11 |     | <span class='unexecuted'>        emit LogDeployed(deployed, msg.sender, salt);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    function getDeployed(address account, bytes32 salt) public view returns (address) {</span>
 15 |     | <span class='unexecuted'>        return CREATE3.getDeployed(_getSalt(account, salt));</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function _getSalt(address account, bytes32 salt) internal pure returns (bytes32) {</span>
 19 |     | <span class='unexecuted'>        return keccak256(abi.encode(account, salt));</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'>}</span>
 22 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/FeeCollectable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>abstract contract FeeCollectable {</span>
  7 |     | <span class='neutral'>    error ErrInvalidFeeBips();</span>
  8 |     | <span class='neutral'>    error ErrInvalidFeeOperator(address);</span>
  9 |     | <span class='neutral'>    event LogFeeParametersChanged(</span>
 10 |     | <span class='neutral'>        address indexed previousFeeCollector,</span>
 11 |     | <span class='neutral'>        uint16 previousFeeAmount,</span>
 12 |     | <span class='neutral'>        address indexed feeCollector,</span>
 13 |     | <span class='neutral'>        uint16 feeAmount</span>
 14 |     | <span class='neutral'>    );</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    uint256 internal constant BIPS = 10_000;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>    uint16 public feeBips;</span>
 19 |     | <span class='unexecuted'>    address public feeCollector;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    modifier onlyAllowedFeeOperator() {</span>
 22 |     | <span class='unexecuted'>        if (!isFeeOperator(msg.sender)) {</span>
 23 |     | <span class='unexecuted'>            revert ErrInvalidFeeOperator(msg.sender);</span>
 24 |     | <span class='neutral'>        }</span>
 25 |     | <span class='neutral'>        _;</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>    function setFeeParameters(address _feeCollector, uint16 _feeBips) external onlyAllowedFeeOperator {</span>
 29 |     | <span class='unexecuted'>        if (feeBips &gt; BIPS) {</span>
 30 |     | <span class='unexecuted'>            revert ErrInvalidFeeBips();</span>
 31 |     | <span class='neutral'>        }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='unexecuted'>        emit LogFeeParametersChanged(feeCollector, feeBips, _feeCollector, _feeBips);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>        feeCollector = _feeCollector;</span>
 36 |     | <span class='unexecuted'>        feeBips = _feeBips;</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>    function calculateFees(uint256 amountIn) internal view returns (uint userAmount, uint feeAmount) {</span>
 40 |     | <span class='unexecuted'>        feeAmount = (amountIn * feeBips) / BIPS;</span>
 41 |     | <span class='unexecuted'>        userAmount = amountIn - feeAmount;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function isFeeOperator(address account) public virtual returns (bool);</span>
 45 |     | <span class='neutral'>}</span>
 46 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/LzApp.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Owned} from &quot;solmate/auth/Owned.sol&quot;;</span>
   5 |     | <span class='neutral'>import {ILzReceiver, ILzUserApplicationConfig, ILzEndpoint} from &quot;interfaces/ILayerZero.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BytesLib} from &quot;libraries/BytesLib.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/*</span>
   9 |     | <span class='neutral'> * a generic LzReceiver implementation</span>
  10 |     | <span class='neutral'> */</span>
  11 |     | <span class='neutral'>abstract contract LzApp is Owned, ILzReceiver, ILzUserApplicationConfig {</span>
  12 |     | <span class='neutral'>    using BytesLib for bytes;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    // ua can not send payload larger than this by default, but it can be changed by the ua owner</span>
  15 |     | <span class='unexecuted'>    uint public constant DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>    ILzEndpoint public immutable lzEndpoint;</span>
  18 |     | <span class='unexecuted'>    mapping(uint16 =&gt; bytes) public trustedRemoteLookup;</span>
  19 |     | <span class='unexecuted'>    mapping(uint16 =&gt; mapping(uint16 =&gt; uint)) public minDstGasLookup;</span>
  20 |     | <span class='unexecuted'>    mapping(uint16 =&gt; uint) public payloadSizeLimitLookup;</span>
  21 |     | <span class='unexecuted'>    address public precrime;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    event SetPrecrime(address precrime);</span>
  24 |     | <span class='neutral'>    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);</span>
  25 |     | <span class='neutral'>    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);</span>
  26 |     | <span class='neutral'>    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    constructor(address _endpoint, address _owner) Owned(_owner) {</span>
  29 |     | <span class='unexecuted'>        lzEndpoint = ILzEndpoint(_endpoint);</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {</span>
  33 |     | <span class='neutral'>        // lzReceive must be called by the endpoint for security</span>
  34 |     | <span class='unexecuted'>        require(msg.sender == address(lzEndpoint), &quot;LzApp: invalid endpoint caller&quot;);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];</span>
  37 |     | <span class='neutral'>        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.</span>
  38 |     | <span class='unexecuted'>        require(</span>
  39 |     | <span class='unexecuted'>            _srcAddress.length == trustedRemote.length &amp;&amp; trustedRemote.length &gt; 0 &amp;&amp; keccak256(_srcAddress) == keccak256(trustedRemote),</span>
  40 |     | <span class='neutral'>            &quot;LzApp: invalid source sending contract&quot;</span>
  41 |     | <span class='neutral'>        );</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging</span>
  47 |     | <span class='neutral'>    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    function _lzSend(</span>
  50 |     | <span class='neutral'>        uint16 _dstChainId,</span>
  51 |     | <span class='neutral'>        bytes memory _payload,</span>
  52 |     | <span class='neutral'>        address payable _refundAddress,</span>
  53 |     | <span class='neutral'>        address _zroPaymentAddress,</span>
  54 |     | <span class='neutral'>        bytes memory _adapterParams,</span>
  55 |     | <span class='neutral'>        uint _nativeFee</span>
  56 |     | <span class='unexecuted'>    ) internal virtual {</span>
  57 |     | <span class='unexecuted'>        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];</span>
  58 |     | <span class='unexecuted'>        require(trustedRemote.length != 0, &quot;LzApp: destination chain is not a trusted source&quot;);</span>
  59 |     | <span class='unexecuted'>        _checkPayloadSize(_dstChainId, _payload.length);</span>
  60 |     | <span class='unexecuted'>        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {</span>
  64 |     | <span class='unexecuted'>        uint providedGasLimit = _getGasLimit(_adapterParams);</span>
  65 |     | <span class='unexecuted'>        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;</span>
  66 |     | <span class='unexecuted'>        require(minGasLimit &gt; 0, &quot;LzApp: minGasLimit not set&quot;);</span>
  67 |     | <span class='unexecuted'>        require(providedGasLimit &gt;= minGasLimit, &quot;LzApp: gas limit is too low&quot;);</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {</span>
  71 |     | <span class='unexecuted'>        require(_adapterParams.length &gt;= 34, &quot;LzApp: invalid adapterParams&quot;);</span>
  72 |     | <span class='neutral'>        assembly {</span>
  73 |     | <span class='unexecuted'>            gasLimit := mload(add(_adapterParams, 34))</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {</span>
  78 |     | <span class='unexecuted'>        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];</span>
  79 |     | <span class='unexecuted'>        if (payloadSizeLimit == 0) {</span>
  80 |     | <span class='neutral'>            // use default if not set</span>
  81 |     | <span class='neutral'>            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='unexecuted'>        require(_payloadSize &lt;= payloadSizeLimit, &quot;LzApp: payload size is too large&quot;);</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    //---------------------------UserApplication config----------------------------------------</span>
  87 |     | <span class='unexecuted'>    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {</span>
  88 |     | <span class='unexecuted'>        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    // generic config for LayerZero user Application</span>
  92 |     | <span class='unexecuted'>    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {</span>
  93 |     | <span class='unexecuted'>        lzEndpoint.setConfig(_version, _chainId, _configType, _config);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>    function setSendVersion(uint16 _version) external override onlyOwner {</span>
  97 |     | <span class='unexecuted'>        lzEndpoint.setSendVersion(_version);</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>    function setReceiveVersion(uint16 _version) external override onlyOwner {</span>
 101 |     | <span class='unexecuted'>        lzEndpoint.setReceiveVersion(_version);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {</span>
 105 |     | <span class='unexecuted'>        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    // _path = abi.encodePacked(remoteAddress, localAddress)</span>
 109 |     | <span class='neutral'>    // this function set the trusted path for the cross-chain communication</span>
 110 |     | <span class='unexecuted'>    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {</span>
 111 |     | <span class='unexecuted'>        trustedRemoteLookup[_remoteChainId] = _path;</span>
 112 |     | <span class='unexecuted'>        emit SetTrustedRemote(_remoteChainId, _path);</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {</span>
 116 |     | <span class='unexecuted'>        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));</span>
 117 |     | <span class='unexecuted'>        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {</span>
 121 |     | <span class='unexecuted'>        bytes memory path = trustedRemoteLookup[_remoteChainId];</span>
 122 |     | <span class='unexecuted'>        require(path.length != 0, &quot;LzApp: no trusted path record&quot;);</span>
 123 |     | <span class='unexecuted'>        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>    function setPrecrime(address _precrime) external onlyOwner {</span>
 127 |     | <span class='unexecuted'>        precrime = _precrime;</span>
 128 |     | <span class='unexecuted'>        emit SetPrecrime(_precrime);</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {</span>
 132 |     | <span class='unexecuted'>        require(_minGas &gt; 0, &quot;LzApp: invalid minGas&quot;);</span>
 133 |     | <span class='unexecuted'>        minDstGasLookup[_dstChainId][_packetType] = _minGas;</span>
 134 |     | <span class='unexecuted'>        emit SetMinDstGas(_dstChainId, _packetType, _minGas);</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    // if the size is 0, it means default size limit</span>
 138 |     | <span class='unexecuted'>    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {</span>
 139 |     | <span class='unexecuted'>        payloadSizeLimitLookup[_dstChainId] = _size;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    //--------------------------- VIEW FUNCTION ----------------------------------------</span>
 143 |     | <span class='unexecuted'>    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {</span>
 144 |     | <span class='unexecuted'>        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];</span>
 145 |     | <span class='unexecuted'>        return keccak256(trustedSource) == keccak256(_srcAddress);</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'>}</span>
 148 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/LzNonblockingApp.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {LzApp} from &quot;mixins/LzApp.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ExcessivelySafeCall} from &quot;ExcessivelySafeCall/ExcessivelySafeCall.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/*</span>
  8 |     | <span class='neutral'> * the default LayerZero messaging behaviour is blocking, i.e. any failed message will block the channel</span>
  9 |     | <span class='neutral'> * this abstract class try-catch all fail messages and store locally for future retry. hence, non-blocking</span>
 10 |     | <span class='neutral'> * NOTE: if the srcAddress is not configured properly, it will still block the message pathway from (srcChainId, srcAddress)</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='neutral'>abstract contract LzNonblockingApp is LzApp {</span>
 13 |     | <span class='neutral'>    using ExcessivelySafeCall for address;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    constructor(address _endpoint, address _owner) LzApp(_endpoint, _owner) {}</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    mapping(uint16 =&gt; mapping(bytes =&gt; mapping(uint64 =&gt; bytes32))) public failedMessages;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);</span>
 20 |     | <span class='neutral'>    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    // overriding the virtual function in LzReceiver</span>
 23 |     | <span class='unexecuted'>    function _blockingLzReceive(</span>
 24 |     | <span class='neutral'>        uint16 _srcChainId,</span>
 25 |     | <span class='neutral'>        bytes memory _srcAddress,</span>
 26 |     | <span class='neutral'>        uint64 _nonce,</span>
 27 |     | <span class='neutral'>        bytes memory _payload</span>
 28 |     | <span class='neutral'>    ) internal virtual override {</span>
 29 |     | <span class='unexecuted'>        (bool success, bytes memory reason) = address(this).excessivelySafeCall(</span>
 30 |     | <span class='unexecuted'>            gasleft(),</span>
 31 |     | <span class='unexecuted'>            150,</span>
 32 |     | <span class='unexecuted'>            abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload)</span>
 33 |     | <span class='neutral'>        );</span>
 34 |     | <span class='neutral'>        // try-catch all errors/exceptions</span>
 35 |     | <span class='unexecuted'>        if (!success) {</span>
 36 |     | <span class='unexecuted'>            _storeFailedMessage(_srcChainId, _srcAddress, _nonce, _payload, reason);</span>
 37 |     | <span class='neutral'>        }</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>    function _storeFailedMessage(</span>
 41 |     | <span class='neutral'>        uint16 _srcChainId,</span>
 42 |     | <span class='neutral'>        bytes memory _srcAddress,</span>
 43 |     | <span class='neutral'>        uint64 _nonce,</span>
 44 |     | <span class='neutral'>        bytes memory _payload,</span>
 45 |     | <span class='neutral'>        bytes memory _reason</span>
 46 |     | <span class='neutral'>    ) internal virtual {</span>
 47 |     | <span class='unexecuted'>        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);</span>
 48 |     | <span class='unexecuted'>        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>    function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual {</span>
 52 |     | <span class='neutral'>        // only internal transaction</span>
 53 |     | <span class='unexecuted'>        require(msg.sender == address(this), &quot;NonblockingLzApp: caller must be LzApp&quot;);</span>
 54 |     | <span class='unexecuted'>        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload, false);</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    //@notice override this function</span>
 58 |     | <span class='neutral'>    function _nonblockingLzReceive(</span>
 59 |     | <span class='neutral'>        uint16 _srcChainId,</span>
 60 |     | <span class='neutral'>        bytes memory _srcAddress,</span>
 61 |     | <span class='neutral'>        uint64 _nonce,</span>
 62 |     | <span class='neutral'>        bytes memory _payload,</span>
 63 |     | <span class='neutral'>        bool retry</span>
 64 |     | <span class='neutral'>    ) internal virtual;</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='unexecuted'>    function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public payable virtual {</span>
 67 |     | <span class='neutral'>        // assert there is message to retry</span>
 68 |     | <span class='unexecuted'>        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];</span>
 69 |     | <span class='unexecuted'>        require(payloadHash != bytes32(0), &quot;NonblockingLzApp: no stored message&quot;);</span>
 70 |     | <span class='unexecuted'>        require(keccak256(_payload) == payloadHash, &quot;NonblockingLzApp: invalid payload&quot;);</span>
 71 |     | <span class='neutral'>        // clear the stored message</span>
 72 |     | <span class='unexecuted'>        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);</span>
 73 |     | <span class='neutral'>        // execute the message. revert if it fails again</span>
 74 |     | <span class='unexecuted'>        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload, true);</span>
 75 |     | <span class='unexecuted'>        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);</span>
 76 |     | <span class='neutral'>    }</span>
 77 |     | <span class='neutral'>}</span>
 78 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/MasterContractManager.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>// Copyright (c) 2021 BoringCrypto - All rights reserved</span>
   3 |     | <span class='neutral'>// Twitter: @Boring_Crypto</span>
   4 |     | <span class='neutral'>// Special thanks to Keno for all his hard work and support</span>
   5 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
   8 |     | <span class='neutral'>// solhint-disable not-rely-on-time</span>
   9 |     | <span class='neutral'>// solhint-disable no-inline-assembly</span>
  10 |     | <span class='neutral'>import {BoringOwnable} from &quot;BoringSolidity/BoringOwnable.sol&quot;;</span>
  11 |     | <span class='neutral'>import {BoringFactory} from &quot;BoringSolidity/BoringFactory.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>contract MasterContractManager is BoringOwnable, BoringFactory {</span>
  14 |     | <span class='neutral'>    event LogWhiteListMasterContract(address indexed masterContract, bool approved);</span>
  15 |     | <span class='neutral'>    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);</span>
  16 |     | <span class='neutral'>    event LogRegisterProtocol(address indexed protocol);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    /// @notice masterContract to user to approval state</span>
  19 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; bool)) public masterContractApproved;</span>
  20 |     | <span class='neutral'>    /// @notice masterContract to whitelisted state for approval without signed message</span>
  21 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public whitelistedMasterContracts;</span>
  22 |     | <span class='neutral'>    /// @notice user nonces for masterContract approvals</span>
  23 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public nonces;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH =</span>
  26 |     | <span class='unexecuted'>        keccak256(&quot;EIP712Domain(string name,uint256 chainId,address verifyingContract)&quot;);</span>
  27 |     | <span class='neutral'>    // See https://eips.ethereum.org/EIPS/eip-191</span>
  28 |     | <span class='neutral'>    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = &quot;\x19\x01&quot;;</span>
  29 |     | <span class='neutral'>    bytes32 private constant APPROVAL_SIGNATURE_HASH =</span>
  30 |     | <span class='unexecuted'>        keccak256(&quot;SetMasterContractApproval(string warning,address user,address masterContract,bool approved,uint256 nonce)&quot;);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    // solhint-disable-next-line var-name-mixedcase</span>
  33 |     | <span class='neutral'>    bytes32 private immutable _DOMAIN_SEPARATOR;</span>
  34 |     | <span class='neutral'>    // solhint-disable-next-line var-name-mixedcase</span>
  35 |     | <span class='neutral'>    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>    constructor() {</span>
  38 |     | <span class='neutral'>        uint256 chainId;</span>
  39 |     | <span class='neutral'>        assembly {</span>
  40 |     | <span class='unexecuted'>            chainId := chainid()</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='unexecuted'>        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {</span>
  46 |     | <span class='unexecuted'>        return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, keccak256(&quot;BentoBox V1&quot;), chainId, address(this)));</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
  50 |     | <span class='unexecuted'>    function DOMAIN_SEPARATOR() public view returns (bytes32) {</span>
  51 |     | <span class='neutral'>        uint256 chainId;</span>
  52 |     | <span class='neutral'>        assembly {</span>
  53 |     | <span class='unexecuted'>            chainId := chainid()</span>
  54 |     | <span class='neutral'>        }</span>
  55 |     | <span class='unexecuted'>        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /// @notice Other contracts need to register with this master contract so that users can approve them for the BentoBox.</span>
  59 |     | <span class='unexecuted'>    function registerProtocol() public {</span>
  60 |     | <span class='unexecuted'>        masterContractOf[msg.sender] = msg.sender;</span>
  61 |     | <span class='unexecuted'>        emit LogRegisterProtocol(msg.sender);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /// @notice Enables or disables a contract for approval without signed message.</span>
  65 |     | <span class='unexecuted'>    function whitelistMasterContract(address masterContract, bool approved) public onlyOwner {</span>
  66 |     | <span class='neutral'>        // Checks</span>
  67 |     | <span class='unexecuted'>        require(masterContract != address(0), &quot;MasterCMgr: Cannot approve 0&quot;);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>        // Effects</span>
  70 |     | <span class='unexecuted'>        whitelistedMasterContracts[masterContract] = approved;</span>
  71 |     | <span class='unexecuted'>        emit LogWhiteListMasterContract(masterContract, approved);</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /// @notice Approves or revokes a `masterContract` access to `user` funds.</span>
  75 |     | <span class='neutral'>    /// @param user The address of the user that approves or revokes access.</span>
  76 |     | <span class='neutral'>    /// @param masterContract The address who gains or loses access.</span>
  77 |     | <span class='neutral'>    /// @param approved If True approves access. If False revokes access.</span>
  78 |     | <span class='neutral'>    /// @param v Part of the signature. (See EIP-191)</span>
  79 |     | <span class='neutral'>    /// @param r Part of the signature. (See EIP-191)</span>
  80 |     | <span class='neutral'>    /// @param s Part of the signature. (See EIP-191)</span>
  81 |     | <span class='neutral'>    // F4 - Check behaviour for all function arguments when wrong or extreme</span>
  82 |     | <span class='neutral'>    // F4: Don&#39;t allow masterContract 0 to be approved. Unknown contracts will have a masterContract of 0.</span>
  83 |     | <span class='neutral'>    // F4: User can&#39;t be 0 for signed approvals because the recoveredAddress will be 0 if ecrecover fails</span>
  84 |     | <span class='unexecuted'>    function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) public {</span>
  85 |     | <span class='neutral'>        // Checks</span>
  86 |     | <span class='unexecuted'>        require(masterContract != address(0), &quot;MasterCMgr: masterC not set&quot;); // Important for security</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        // If no signature is provided, the fallback is executed</span>
  89 |     | <span class='unexecuted'>        if (r == 0 &amp;&amp; s == 0 &amp;&amp; v == 0) {</span>
  90 |     | <span class='unexecuted'>            require(user == msg.sender, &quot;MasterCMgr: user not sender&quot;);</span>
  91 |     | <span class='unexecuted'>            require(masterContractOf[user] == address(0), &quot;MasterCMgr: user is clone&quot;);</span>
  92 |     | <span class='unexecuted'>            require(whitelistedMasterContracts[masterContract], &quot;MasterCMgr: not whitelisted&quot;);</span>
  93 |     | <span class='unexecuted'>        } else {</span>
  94 |     | <span class='neutral'>            // Important for security - any address without masterContract has address(0) as masterContract</span>
  95 |     | <span class='neutral'>            // So approving address(0) would approve every address, leading to full loss of funds</span>
  96 |     | <span class='neutral'>            // Also, ecrecover returns address(0) on failure. So we check this:</span>
  97 |     | <span class='unexecuted'>            require(user != address(0), &quot;MasterCMgr: User cannot be 0&quot;);</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>            // C10 - Protect signatures against replay, use nonce and chainId (SWC-121)</span>
 100 |     | <span class='neutral'>            // C10: nonce + chainId are used to prevent replays</span>
 101 |     | <span class='neutral'>            // C11 - All signatures strictly EIP-712 (SWC-117 SWC-122)</span>
 102 |     | <span class='neutral'>            // C11: signature is EIP-712 compliant</span>
 103 |     | <span class='neutral'>            // C12 - abi.encodePacked can&#39;t contain variable length user input (SWC-133)</span>
 104 |     | <span class='neutral'>            // C12: abi.encodePacked has fixed length parameters</span>
 105 |     | <span class='unexecuted'>            bytes32 digest = keccak256(</span>
 106 |     | <span class='unexecuted'>                abi.encodePacked(</span>
 107 |     | <span class='unexecuted'>                    EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,</span>
 108 |     | <span class='unexecuted'>                    DOMAIN_SEPARATOR(),</span>
 109 |     | <span class='unexecuted'>                    keccak256(</span>
 110 |     | <span class='unexecuted'>                        abi.encode(</span>
 111 |     | <span class='neutral'>                            APPROVAL_SIGNATURE_HASH,</span>
 112 |     | <span class='unexecuted'>                            approved</span>
 113 |     | <span class='unexecuted'>                                ? keccak256(&quot;Give FULL access to funds in (and approved to) BentoBox?&quot;)</span>
 114 |     | <span class='unexecuted'>                                : keccak256(&quot;Revoke access to BentoBox?&quot;),</span>
 115 |     | <span class='unexecuted'>                            user,</span>
 116 |     | <span class='unexecuted'>                            masterContract,</span>
 117 |     | <span class='unexecuted'>                            approved,</span>
 118 |     | <span class='unexecuted'>                            nonces[user]++</span>
 119 |     | <span class='neutral'>                        )</span>
 120 |     | <span class='neutral'>                    )</span>
 121 |     | <span class='neutral'>                )</span>
 122 |     | <span class='neutral'>            );</span>
 123 |     | <span class='unexecuted'>            address recoveredAddress = ecrecover(digest, v, r, s);</span>
 124 |     | <span class='unexecuted'>            require(recoveredAddress == user, &quot;MasterCMgr: Invalid Signature&quot;);</span>
 125 |     | <span class='neutral'>        }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>        // Effects</span>
 128 |     | <span class='unexecuted'>        masterContractApproved[masterContract][user] = approved;</span>
 129 |     | <span class='unexecuted'>        emit LogSetMasterContractApproval(masterContract, user, approved);</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'>}</span>
 132 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/OFTWrapper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ReentrancyGuard} from &quot;openzeppelin-contracts/security/ReentrancyGuard.sol&quot;;</span>
   5 |     | <span class='neutral'>import {OperatableV2} from &quot;mixins/OperatableV2.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IERC20, SafeERC20} from &quot;openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {ILzOFTV2, IOFTWrapper, ILzApp, ILzCommonOFT, ILzEndpoint} from &quot;interfaces/ILayerZero.sol&quot;;</span>
   8 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>contract OFTWrapper is IOFTWrapper, OperatableV2, ReentrancyGuard {</span>
  11 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>    address public feeTo;</span>
  14 |     | <span class='unexecuted'>    IAggregator public aggregator;</span>
  15 |     | <span class='unexecuted'>    ILzOFTV2 public immutable oft;</span>
  16 |     | <span class='unexecuted'>    IERC20 public immutable token;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    uint256 public defaultExchangeRate;</span>
  19 |     | <span class='unexecuted'>    QUOTE_TYPE public defaultQuoteType = QUOTE_TYPE.FIXED_EXCHANGE_RATE;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    error InvalidQuoteType(QUOTE_TYPE);</span>
  22 |     | <span class='neutral'>    error ErrWithdrawFailed();</span>
  23 |     | <span class='neutral'>    error MessageValueIsLow(uint256);</span>
  24 |     | <span class='neutral'>    error InvalidAddress();</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>    constructor(uint256 _defaultExchangeRate, address _oft, address _aggregator, address _multisig) OperatableV2(_multisig) {</span>
  27 |     | <span class='unexecuted'>        defaultExchangeRate = _defaultExchangeRate;</span>
  28 |     | <span class='unexecuted'>        require(_oft != address(0), &quot;OFTWrapper: invalid oft&quot;);</span>
  29 |     | <span class='unexecuted'>        oft = ILzOFTV2(_oft);</span>
  30 |     | <span class='unexecuted'>        token = IERC20(oft.token());</span>
  31 |     | <span class='unexecuted'>        require(_aggregator != address(0), &quot;OFTWrapper: invalid aggregator&quot;);</span>
  32 |     | <span class='unexecuted'>        aggregator = IAggregator(_aggregator);</span>
  33 |     | <span class='unexecuted'>        token.safeApprove(address(oft), type(uint256).max);</span>
  34 |     | <span class='unexecuted'>        feeTo = _multisig;</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>    function setDefaultExchangeRate(uint256 _defaultExchangeRate) external onlyOperators {</span>
  38 |     | <span class='unexecuted'>        emit LogDefaultExchangeRateChanged(defaultExchangeRate, _defaultExchangeRate);</span>
  39 |     | <span class='unexecuted'>        defaultExchangeRate = _defaultExchangeRate;</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>    function setAggregator(IAggregator _aggregator) external onlyOperators {</span>
  43 |     | <span class='unexecuted'>        if (address(_aggregator) == address(0)) revert InvalidAddress();</span>
  44 |     | <span class='unexecuted'>        emit LogOracleImplementationChange(aggregator, _aggregator);</span>
  45 |     | <span class='unexecuted'>        aggregator = _aggregator;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>    function setDefaultQuoteType(QUOTE_TYPE _quoteType) external onlyOperators {</span>
  49 |     | <span class='unexecuted'>        if (_quoteType &gt; QUOTE_TYPE.FIXED_EXCHANGE_RATE) revert InvalidQuoteType(_quoteType);</span>
  50 |     | <span class='unexecuted'>        emit LogDefaultQuoteTypeChanged(defaultQuoteType, _quoteType);</span>
  51 |     | <span class='unexecuted'>        defaultQuoteType = _quoteType;</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>    function setFeeTo(address _feeTo) external onlyOwner {</span>
  55 |     | <span class='unexecuted'>        if (_feeTo == address(0)) revert InvalidAddress();</span>
  56 |     | <span class='unexecuted'>        emit LogFeeToChange(feeTo, _feeTo);</span>
  57 |     | <span class='unexecuted'>        feeTo = _feeTo;</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>    function withdrawFees() external {</span>
  61 |     | <span class='unexecuted'>        uint balance = address(this).balance;</span>
  62 |     | <span class='unexecuted'>        (bool success, ) = feeTo.call{value: balance}(&quot;&quot;);</span>
  63 |     | <span class='unexecuted'>        if (!success) revert ErrWithdrawFailed();</span>
  64 |     | <span class='unexecuted'>        emit LogWrapperFeeWithdrawn(feeTo, balance);</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>    function sendOFTV2(</span>
  68 |     | <span class='neutral'>        uint16 _dstChainId,</span>
  69 |     | <span class='neutral'>        bytes32 _toAddress,</span>
  70 |     | <span class='neutral'>        uint256 _amount,</span>
  71 |     | <span class='neutral'>        ILzCommonOFT.LzCallParams calldata _callParams</span>
  72 |     | <span class='unexecuted'>    ) external payable override nonReentrant {</span>
  73 |     | <span class='unexecuted'>        uint fee = _estimateFee();</span>
  74 |     | <span class='unexecuted'>        if (msg.value &lt; fee) revert MessageValueIsLow(msg.value);</span>
  75 |     | <span class='unexecuted'>        uint256 val = msg.value - fee;</span>
  76 |     | <span class='unexecuted'>        oft.sendFrom{value: val}(msg.sender, _dstChainId, _toAddress, _amount, _callParams);</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>    function sendProxyOFTV2(</span>
  80 |     | <span class='neutral'>        uint16 _dstChainId,</span>
  81 |     | <span class='neutral'>        bytes32 _toAddress,</span>
  82 |     | <span class='neutral'>        uint256 _amount,</span>
  83 |     | <span class='neutral'>        ILzCommonOFT.LzCallParams calldata _callParams</span>
  84 |     | <span class='neutral'>    ) external payable override nonReentrant {</span>
  85 |     | <span class='unexecuted'>        uint fee = _estimateFee();</span>
  86 |     | <span class='unexecuted'>        if (msg.value &lt; fee) revert MessageValueIsLow(msg.value);</span>
  87 |     | <span class='unexecuted'>        uint256 val = msg.value - fee;</span>
  88 |     | <span class='unexecuted'>        token.safeTransferFrom(msg.sender, address(this), _amount);</span>
  89 |     | <span class='unexecuted'>        oft.sendFrom{value: val}(address(this), _dstChainId, _toAddress, _amount, _callParams);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>    function estimateSendFeeV2(</span>
  93 |     | <span class='neutral'>        uint16 _dstChainId,</span>
  94 |     | <span class='neutral'>        bytes32 _toAddress,</span>
  95 |     | <span class='neutral'>        uint256 _amount,</span>
  96 |     | <span class='neutral'>        bytes calldata _adapterParams</span>
  97 |     | <span class='unexecuted'>    ) external view override returns (uint nativeFee, uint zroFee) {</span>
  98 |     | <span class='unexecuted'>        (nativeFee, zroFee) = oft.estimateSendFee(_dstChainId, _toAddress, _amount, false, _adapterParams);</span>
  99 |     | <span class='unexecuted'>        nativeFee += _estimateFee();</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>    function _estimateFee() internal view returns (uint256 fee) {</span>
 103 |     | <span class='unexecuted'>        if (defaultQuoteType == QUOTE_TYPE.ORACLE) {</span>
 104 |     | <span class='unexecuted'>            fee = ((10 ** aggregator.decimals()) * 1e18) / uint256(aggregator.latestAnswer());</span>
 105 |     | <span class='neutral'>        } else {</span>
 106 |     | <span class='unexecuted'>            fee = defaultExchangeRate;</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>    function lzEndpoint() external view returns (ILzEndpoint) {</span>
 111 |     | <span class='unexecuted'>        return ILzApp(address(oft)).lzEndpoint();</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>    function minDstGasLookup(uint16 _srcChainId, uint16 _dstChainId) external view returns (uint) {</span>
 115 |     | <span class='unexecuted'>        return ILzApp(address(oft)).minDstGasLookup(_srcChainId, _dstChainId);</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'>}</span>
 118 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/Operatable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {BoringOwnable} from &quot;BoringSolidity/BoringOwnable.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract Operatable is BoringOwnable {</span>
  7 |     | <span class='neutral'>    event OperatorChanged(address indexed, bool);</span>
  8 |     | <span class='neutral'>    error NotAllowedOperator();</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public operators;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    constructor() {}</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    modifier onlyOperators() {</span>
 15 |     | <span class='unexecuted'>        if (!operators[msg.sender] &amp;&amp; msg.sender != owner) {</span>
 16 |     | <span class='unexecuted'>            revert NotAllowedOperator();</span>
 17 |     | <span class='neutral'>        }</span>
 18 |     | <span class='neutral'>        _;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    function setOperator(address operator, bool status) external onlyOwner {</span>
 22 |     | <span class='unexecuted'>        operators[operator] = status;</span>
 23 |     | <span class='unexecuted'>        emit OperatorChanged(operator, status);</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/OperatableV2.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Owned} from &quot;solmate/auth/Owned.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @title OperatableV2</span>
  7 |     | <span class='neutral'>/// @notice OperatableV2 is a contract that allows operator management.</span>
  8 |     | <span class='neutral'>/// The difference with OperatableV1 apart from using solmate `Owned` vs `BoringOwnable` is that</span>
  9 |     | <span class='neutral'>/// the constructor is taking in the owner except of using msg.sender.</span>
 10 |     | <span class='neutral'>/// This allows ensuring that the owner is right one.</span>
 11 |     | <span class='neutral'>/// For example, when deploying from a CREATE2 factory, the msg.sender would the factory address</span>
 12 |     | <span class='neutral'>/// which is usually not what we want.</span>
 13 |     | <span class='unexecuted'>contract OperatableV2 is Owned {</span>
 14 |     | <span class='neutral'>    event OperatorChanged(address indexed, bool);</span>
 15 |     | <span class='neutral'>    error NotAllowedOperator();</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public operators;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    constructor(address _owner) Owned(_owner) {}</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    modifier onlyOperators() {</span>
 22 |     | <span class='unexecuted'>        if (!operators[msg.sender] &amp;&amp; msg.sender != owner) {</span>
 23 |     | <span class='unexecuted'>            revert NotAllowedOperator();</span>
 24 |     | <span class='neutral'>        }</span>
 25 |     | <span class='unexecuted'>        _;</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>    function setOperator(address operator, bool status) external onlyOwner {</span>
 29 |     | <span class='unexecuted'>        operators[operator] = status;</span>
 30 |     | <span class='unexecuted'>        emit OperatorChanged(operator, status);</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'>}</span>
 33 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/OperatableV3.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title OperatableV3</span>
  5 |     | <span class='neutral'>/// @notice Same as OperatableV2 but without taking care of the Ownable part.</span>
  6 |     | <span class='neutral'>/// This is useful when the contract inheriting this is already inheriting from Owned.</span>
  7 |     | <span class='neutral'>abstract contract OperatableV3 {</span>
  8 |     | <span class='neutral'>    event LogOperatorChanged(address indexed, bool);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    error ErrNotAllowedOperator();</span>
 11 |     | <span class='neutral'>    error ErrNotOwner();</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public operators;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    constructor() {}</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    modifier onlyOperators() {</span>
 18 |     | <span class='unexecuted'>        if (!operators[msg.sender] &amp;&amp; !isOwner(msg.sender)) {</span>
 19 |     | <span class='unexecuted'>            revert ErrNotAllowedOperator();</span>
 20 |     | <span class='neutral'>        }</span>
 21 |     | <span class='neutral'>        _;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    function setOperator(address operator, bool status) external {</span>
 25 |     | <span class='unexecuted'>        if (!isOwner(msg.sender)) {</span>
 26 |     | <span class='unexecuted'>            revert ErrNotOwner();</span>
 27 |     | <span class='neutral'>        }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>        operators[operator] = status;</span>
 30 |     | <span class='unexecuted'>        emit LogOperatorChanged(operator, status);</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    function isOwner(address _account) internal view virtual returns (bool);</span>
 34 |     | <span class='neutral'>}</span>
 35 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/Whitelister.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {MerkleProof} from &quot;openzeppelin-contracts/utils/cryptography/MerkleProof.sol&quot;;</span>
  5 |     | <span class='neutral'>import {BoringOwnable} from &quot;BoringSolidity/BoringOwnable.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IWhitelister} from &quot;interfaces/IWhitelister.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>contract Whitelister is IWhitelister, BoringOwnable {</span>
  9 |     | <span class='neutral'>    event LogSetMaxBorrow(address user, uint256 maxBorrowAmount);</span>
 10 |     | <span class='neutral'>    event LogSetMerkleRoot(bytes32 newRoot, string ipfsMerkleProofs);</span>
 11 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public amountAllowed;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    bytes32 public merkleRoot;</span>
 14 |     | <span class='unexecuted'>    string public ipfsMerkleProofs;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    constructor(bytes32 _merkleRoot, string memory _ipfsMerkleProofs) {</span>
 17 |     | <span class='unexecuted'>        merkleRoot = _merkleRoot;</span>
 18 |     | <span class='unexecuted'>        ipfsMerkleProofs = _ipfsMerkleProofs;</span>
 19 |     | <span class='unexecuted'>        emit LogSetMerkleRoot(_merkleRoot, _ipfsMerkleProofs);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function setMaxBorrowOwner(address user, uint256 maxBorrow) external onlyOwner {</span>
 23 |     | <span class='unexecuted'>        amountAllowed[user] = maxBorrow;</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>        emit LogSetMaxBorrow(user, maxBorrow);</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    /// @inheritdoc IWhitelister</span>
 29 |     | <span class='unexecuted'>    function isBorrowingAllowed(address user, uint256 newBorrowAmount) external view override returns (bool success) {</span>
 30 |     | <span class='unexecuted'>        return amountAllowed[user] &gt;= newBorrowAmount;</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    /// @inheritdoc IWhitelister</span>
 34 |     | <span class='unexecuted'>    function setMaxBorrow(address user, uint256 maxBorrow, bytes32[] calldata merkleProof) external returns (bool success) {</span>
 35 |     | <span class='neutral'>        // Verify the merkle proof.</span>
 36 |     | <span class='unexecuted'>        bytes32 node = keccak256(abi.encodePacked(user, maxBorrow));</span>
 37 |     | <span class='unexecuted'>        require(MerkleProof.verify(merkleProof, merkleRoot, node), &quot;Whitelister: Invalid proof.&quot;);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>        amountAllowed[user] = maxBorrow;</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='unexecuted'>        emit LogSetMaxBorrow(user, maxBorrow);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>        return true;</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>    function changeMerkleRoot(bytes32 newRoot, string calldata ipfsMerkleProofs_) external onlyOwner {</span>
 47 |     | <span class='unexecuted'>        ipfsMerkleProofs = ipfsMerkleProofs_;</span>
 48 |     | <span class='unexecuted'>        merkleRoot = newRoot;</span>
 49 |     | <span class='unexecuted'>        emit LogSetMerkleRoot(newRoot, ipfsMerkleProofs_);</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'>}</span>
 52 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/ChainlinkOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract ChainlinkOracle is IOracle {</span>
  8 |     | <span class='unexecuted'>    IAggregator public immutable aggregator;</span>
  9 |     | <span class='unexecuted'>    uint256 public immutable decimalScale;</span>
 10 |     | <span class='unexecuted'>    uint8 public immutable decimals;</span>
 11 |     | <span class='neutral'>    string private desc;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    /// @notice Uses chainlink aggregator with optional upscaling decimals</span>
 14 |     | <span class='neutral'>    /// @param _desc A description of the oracle</span>
 15 |     | <span class='neutral'>    /// @param _aggregator The aggregator to use</span>
 16 |     | <span class='neutral'>    /// @param _upscaledTargetDecimals The number of decimals to return, 0 to use the aggregator&#39;s decimals</span>
 17 |     | <span class='unexecuted'>    constructor(string memory _desc, IAggregator _aggregator, uint8 _upscaledTargetDecimals) {</span>
 18 |     | <span class='unexecuted'>        aggregator = _aggregator;</span>
 19 |     | <span class='unexecuted'>        desc = _desc;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>        uint8 aggregatorDecimals = _aggregator.decimals();</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>        decimals = _upscaledTargetDecimals &gt; aggregatorDecimals ? _upscaledTargetDecimals : aggregatorDecimals;</span>
 24 |     | <span class='unexecuted'>        decimalScale = _upscaledTargetDecimals &gt; aggregatorDecimals ? 10 ** (_upscaledTargetDecimals - aggregatorDecimals) : 1;</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function _get() internal view returns (uint256) {</span>
 28 |     | <span class='unexecuted'>        return uint256(aggregator.latestAnswer()) * decimalScale;</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    // Get the latest exchange rate</span>
 32 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 33 |     | <span class='unexecuted'>    function get(bytes calldata) public view override returns (bool, uint256) {</span>
 34 |     | <span class='unexecuted'>        return (true, _get());</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    // Check the last exchange rate without any state changes</span>
 38 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 39 |     | <span class='neutral'>    function peek(bytes calldata) public view override returns (bool, uint256) {</span>
 40 |     | <span class='neutral'>        return (true, _get());</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    // Check the current spot exchange rate without any state changes</span>
 44 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 45 |     | <span class='unexecuted'>    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {</span>
 46 |     | <span class='unexecuted'>        (, rate) = peek(data);</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 50 |     | <span class='neutral'>    function name(bytes calldata) public view override returns (string memory) {</span>
 51 |     | <span class='neutral'>        return desc;</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 55 |     | <span class='unexecuted'>    function symbol(bytes calldata) public view override returns (string memory) {</span>
 56 |     | <span class='unexecuted'>        return desc;</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'>}</span>
 59 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/FixedPriceOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Owned} from &quot;solmate/auth/Owned.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract FixedPriceOracle is IOracle, Owned {</span>
  8 |     | <span class='neutral'>    event LogPriceChanged(uint256 price);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    uint8 public immutable decimals;</span>
 11 |     | <span class='unexecuted'>    uint256 public price;</span>
 12 |     | <span class='unexecuted'>    string public desc;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    constructor(string memory _desc, uint256 _price, uint8 _decimals) Owned(msg.sender) {</span>
 15 |     | <span class='unexecuted'>        desc = _desc;</span>
 16 |     | <span class='unexecuted'>        price = _price;</span>
 17 |     | <span class='unexecuted'>        decimals = _decimals;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function setPrice(uint256 _price) public onlyOwner {</span>
 21 |     | <span class='unexecuted'>        price = _price;</span>
 22 |     | <span class='unexecuted'>        emit LogPriceChanged(_price);</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>    function _get() internal view returns (uint256) {</span>
 26 |     | <span class='unexecuted'>        return price;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 30 |     | <span class='unexecuted'>    function get(bytes calldata) public view override returns (bool, uint256) {</span>
 31 |     | <span class='unexecuted'>        return (true, _get());</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 35 |     | <span class='neutral'>    function peek(bytes calldata) public view override returns (bool, uint256) {</span>
 36 |     | <span class='neutral'>        return (true, _get());</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 40 |     | <span class='unexecuted'>    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {</span>
 41 |     | <span class='unexecuted'>        (, rate) = peek(data);</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 45 |     | <span class='neutral'>    function name(bytes calldata) public view override returns (string memory) {</span>
 46 |     | <span class='neutral'>        return desc;</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 50 |     | <span class='unexecuted'>    function symbol(bytes calldata) public view override returns (string memory) {</span>
 51 |     | <span class='unexecuted'>        return desc;</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/FloorPriceOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Owned} from &quot;solmate/auth/Owned.sol&quot;;</span>
  5 |     | <span class='neutral'>import {MathLib} from &quot;libraries/MathLib.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>contract FloorPriceOracle is IOracle, Owned {</span>
 10 |     | <span class='unexecuted'>    IOracle public immutable oracle;</span>
 11 |     | <span class='unexecuted'>    uint256 public floor;</span>
 12 |     | <span class='unexecuted'>    bytes public oracleData;</span>
 13 |     | <span class='unexecuted'>    string public desc;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    constructor(string memory _desc, IOracle _oracle, bytes memory _oracleData, uint256 _floor) Owned(msg.sender) {</span>
 16 |     | <span class='unexecuted'>        desc = _desc;</span>
 17 |     | <span class='unexecuted'>        oracle = _oracle;</span>
 18 |     | <span class='unexecuted'>        oracleData = _oracleData;</span>
 19 |     | <span class='unexecuted'>        floor = _floor;</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function decimals() external view returns (uint8) {</span>
 23 |     | <span class='unexecuted'>        return oracle.decimals();</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    function setFloor(uint256 _floor) public onlyOwner {</span>
 27 |     | <span class='unexecuted'>        floor = _floor;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>    function _get() internal view returns (uint256) {</span>
 31 |     | <span class='unexecuted'>        (, uint256 price) = oracle.peek(oracleData);</span>
 32 |     | <span class='unexecuted'>        return MathLib.min(floor, price);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 36 |     | <span class='unexecuted'>    function get(bytes calldata) public view override returns (bool, uint256) {</span>
 37 |     | <span class='unexecuted'>        return (true, _get());</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 41 |     | <span class='neutral'>    function peek(bytes calldata) public view override returns (bool, uint256) {</span>
 42 |     | <span class='neutral'>        return (true, _get());</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 46 |     | <span class='unexecuted'>    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {</span>
 47 |     | <span class='unexecuted'>        (, rate) = peek(data);</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 51 |     | <span class='neutral'>    function name(bytes calldata) public view override returns (string memory) {</span>
 52 |     | <span class='neutral'>        return desc;</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 56 |     | <span class='unexecuted'>    function symbol(bytes calldata) public view override returns (string memory) {</span>
 57 |     | <span class='unexecuted'>        return desc;</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'>}</span>
 60 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/GmOracleWithAggregator.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  8 |     | <span class='neutral'>import {IGmxV2Market, IGmxV2Price, IGmxReader} from &quot;interfaces/IGmxV2.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>contract GmOracleWithAggregator is IOracle {</span>
 11 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 12 |     | <span class='unexecuted'>    bytes32 private constant PNL_TYPE = keccak256(abi.encode(&quot;MAX_PNL_FACTOR_FOR_TRADERS&quot;));</span>
 13 |     | <span class='unexecuted'>    IGmxReader public immutable reader;</span>
 14 |     | <span class='unexecuted'>    IAggregator public immutable indexAggregator;</span>
 15 |     | <span class='unexecuted'>    uint256 public immutable expansionFactorIndex;</span>
 16 |     | <span class='unexecuted'>    uint256 public immutable expansionFactorShort;</span>
 17 |     | <span class='unexecuted'>    IAggregator public immutable shortAggregator;</span>
 18 |     | <span class='unexecuted'>    address public immutable dataStore;</span>
 19 |     | <span class='neutral'>    address immutable marketToken;</span>
 20 |     | <span class='neutral'>    address immutable indexToken;</span>
 21 |     | <span class='neutral'>    address immutable longToken;</span>
 22 |     | <span class='neutral'>    address immutable shortToken;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    string private desc;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    constructor(</span>
 27 |     | <span class='neutral'>        IGmxReader _reader,</span>
 28 |     | <span class='neutral'>        IAggregator _indexTokenAggregator,</span>
 29 |     | <span class='neutral'>        IAggregator _shortTokenAggregator,</span>
 30 |     | <span class='neutral'>        address _market,</span>
 31 |     | <span class='neutral'>        address _indexToken,</span>
 32 |     | <span class='neutral'>        address _dataStore,</span>
 33 |     | <span class='neutral'>        string memory _desc</span>
 34 |     | <span class='unexecuted'>    ) {</span>
 35 |     | <span class='unexecuted'>        reader = _reader;</span>
 36 |     | <span class='unexecuted'>        indexAggregator = _indexTokenAggregator;</span>
 37 |     | <span class='unexecuted'>        shortAggregator = _shortTokenAggregator;</span>
 38 |     | <span class='unexecuted'>        indexToken = _indexToken;</span>
 39 |     | <span class='unexecuted'>        dataStore = _dataStore;</span>
 40 |     | <span class='unexecuted'>        IGmxV2Market.Props memory props = _reader.getMarket(_dataStore, _market);</span>
 41 |     | <span class='unexecuted'>        (marketToken, , longToken, shortToken) = (props.marketToken, props.indexToken, props.longToken, props.shortToken);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>        // GMX uses an internal precision of 1e30</span>
 44 |     | <span class='unexecuted'>        expansionFactorIndex = 10 ** (30 - indexAggregator.decimals() - IERC20(indexToken).safeDecimals());</span>
 45 |     | <span class='unexecuted'>        expansionFactorShort = 10 ** (30 - shortAggregator.decimals() - IERC20(shortToken).safeDecimals());</span>
 46 |     | <span class='unexecuted'>        desc = _desc;</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='unexecuted'>    function decimals() external pure returns (uint8) {</span>
 50 |     | <span class='unexecuted'>        return uint8(18);</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='unexecuted'>    function _get() internal view returns (uint256 lpPrice) {</span>
 54 |     | <span class='unexecuted'>        uint256 indexTokenPrice = uint256(indexAggregator.latestAnswer()) * expansionFactorIndex;</span>
 55 |     | <span class='unexecuted'>        uint256 shortTokenPrice = uint256(shortAggregator.latestAnswer()) * expansionFactorShort;</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='unexecuted'>        (int256 price, ) = reader.getMarketTokenPrice(</span>
 58 |     | <span class='unexecuted'>            dataStore,</span>
 59 |     | <span class='unexecuted'>            IGmxV2Market.Props(marketToken, indexToken, longToken, shortToken),</span>
 60 |     | <span class='unexecuted'>            IGmxV2Price.Props(indexTokenPrice, indexTokenPrice),</span>
 61 |     | <span class='unexecuted'>            IGmxV2Price.Props(indexTokenPrice, indexTokenPrice),</span>
 62 |     | <span class='unexecuted'>            IGmxV2Price.Props(shortTokenPrice, shortTokenPrice),</span>
 63 |     | <span class='neutral'>            PNL_TYPE,</span>
 64 |     | <span class='unexecuted'>            false</span>
 65 |     | <span class='neutral'>        );</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='neutral'>        // GMX uses an internal precision of 1e30</span>
 68 |     | <span class='unexecuted'>        lpPrice = (1e18 * 1e30) / uint256(price);</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 72 |     | <span class='unexecuted'>    function get(bytes calldata) public view override returns (bool, uint256) {</span>
 73 |     | <span class='unexecuted'>        return (true, _get());</span>
 74 |     | <span class='neutral'>    }</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 77 |     | <span class='neutral'>    function peek(bytes calldata) public view override returns (bool, uint256) {</span>
 78 |     | <span class='neutral'>        return (true, _get());</span>
 79 |     | <span class='neutral'>    }</span>
 80 |     | <span class='neutral'></span>
 81 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 82 |     | <span class='unexecuted'>    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {</span>
 83 |     | <span class='unexecuted'>        (, rate) = peek(data);</span>
 84 |     | <span class='neutral'>    }</span>
 85 |     | <span class='neutral'></span>
 86 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 87 |     | <span class='neutral'>    function name(bytes calldata) public view override returns (string memory) {</span>
 88 |     | <span class='neutral'>        return desc;</span>
 89 |     | <span class='neutral'>    }</span>
 90 |     | <span class='neutral'></span>
 91 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 92 |     | <span class='unexecuted'>    function symbol(bytes calldata) public view override returns (string memory) {</span>
 93 |     | <span class='unexecuted'>        return desc;</span>
 94 |     | <span class='neutral'>    }</span>
 95 |     | <span class='neutral'>}</span>
 96 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/InverseOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/// @title InverseOracle</span>
  8 |     | <span class='neutral'>/// @notice An oracle that inverts the price of an aggregator</span>
  9 |     | <span class='unexecuted'>contract InverseOracle is IOracle {</span>
 10 |     | <span class='unexecuted'>    IAggregator public immutable aggregator;</span>
 11 |     | <span class='unexecuted'>    uint256 public immutable decimalScale;</span>
 12 |     | <span class='unexecuted'>    uint8 public immutable decimals;</span>
 13 |     | <span class='neutral'>    string private desc;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /// @notice Construct an oracle that inverts the price of an aggregator</span>
 16 |     | <span class='neutral'>    /// @param _desc A description of the oracle</span>
 17 |     | <span class='neutral'>    /// @param _aggregator The aggregator to invert</span>
 18 |     | <span class='neutral'>    /// @param _upscaledTargetDecimals The number of decimals to return, 0 to use the aggregator&#39;s decimals</span>
 19 |     | <span class='unexecuted'>    constructor(string memory _desc, IAggregator _aggregator, uint8 _upscaledTargetDecimals) {</span>
 20 |     | <span class='unexecuted'>        aggregator = _aggregator;</span>
 21 |     | <span class='unexecuted'>        desc = _desc;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>        uint8 aggregatorDecimals = _aggregator.decimals();</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>        decimalScale = _upscaledTargetDecimals &gt; aggregatorDecimals</span>
 26 |     | <span class='unexecuted'>            ? 10 ** ((_upscaledTargetDecimals * 2) - (_upscaledTargetDecimals - aggregatorDecimals))</span>
 27 |     | <span class='unexecuted'>            : 10 ** (aggregatorDecimals * 2);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>        decimals = _upscaledTargetDecimals &gt; aggregatorDecimals ? _upscaledTargetDecimals : aggregatorDecimals;</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    function _get() internal view returns (uint256) {</span>
 33 |     | <span class='unexecuted'>        return decimalScale / uint256(aggregator.latestAnswer());</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    // Get the latest exchange rate</span>
 37 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 38 |     | <span class='unexecuted'>    function get(bytes calldata) public view override returns (bool, uint256) {</span>
 39 |     | <span class='unexecuted'>        return (true, _get());</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    // Check the last exchange rate without any state changes</span>
 43 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 44 |     | <span class='neutral'>    function peek(bytes calldata) public view override returns (bool, uint256) {</span>
 45 |     | <span class='neutral'>        return (true, _get());</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    // Check the current spot exchange rate without any state changes</span>
 49 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 50 |     | <span class='unexecuted'>    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {</span>
 51 |     | <span class='unexecuted'>        (, rate) = peek(data);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 55 |     | <span class='neutral'>    function name(bytes calldata) public view override returns (string memory) {</span>
 56 |     | <span class='neutral'>        return desc;</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 60 |     | <span class='unexecuted'>    function symbol(bytes calldata) public view override returns (string memory) {</span>
 61 |     | <span class='unexecuted'>        return desc;</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'>}</span>
 64 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/MagicGlpOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IERC4626} from &quot;interfaces/IERC4626.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IGmxGlpManager} from &quot;interfaces/IGmxV1.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>contract MagicGlpOracle is IOracle {</span>
 10 |     | <span class='neutral'>    IGmxGlpManager private immutable glpManager;</span>
 11 |     | <span class='neutral'>    IERC20 private immutable glp;</span>
 12 |     | <span class='unexecuted'>    IERC4626 public immutable magicGlp;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    constructor(IGmxGlpManager glpManager_, IERC20 glp_, IERC4626 magicGlp_) {</span>
 15 |     | <span class='unexecuted'>        glpManager = glpManager_;</span>
 16 |     | <span class='unexecuted'>        glp = glp_;</span>
 17 |     | <span class='unexecuted'>        magicGlp = magicGlp_;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function decimals() external pure returns (uint8) {</span>
 21 |     | <span class='unexecuted'>        return 18;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    function _get() internal view returns (uint256) {</span>
 25 |     | <span class='unexecuted'>        uint256 glpPrice = (uint256(glpManager.getAum(false)) / glp.totalSupply());</span>
 26 |     | <span class='unexecuted'>        return 1e30 / magicGlp.convertToAssets(glpPrice);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    // Get the latest exchange rate</span>
 30 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 31 |     | <span class='unexecuted'>    function get(bytes calldata) public view override returns (bool, uint256) {</span>
 32 |     | <span class='unexecuted'>        return (true, _get());</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    // Check the last exchange rate without any state changes</span>
 36 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 37 |     | <span class='neutral'>    function peek(bytes calldata) public view override returns (bool, uint256) {</span>
 38 |     | <span class='neutral'>        return (true, _get());</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    // Check the current spot exchange rate without any state changes</span>
 42 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 43 |     | <span class='unexecuted'>    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {</span>
 44 |     | <span class='unexecuted'>        (, rate) = peek(data);</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 48 |     | <span class='unexecuted'>    function name(bytes calldata) public pure override returns (string memory) {</span>
 49 |     | <span class='unexecuted'>        return &quot;MagicGlp USD Oracle&quot;;</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 53 |     | <span class='unexecuted'>    function symbol(bytes calldata) public pure override returns (string memory) {</span>
 54 |     | <span class='unexecuted'>        return &quot;MagicGlp/USD&quot;;</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'>}</span>
 57 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/MagicVaultOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IERC4626} from &quot;interfaces/IERC4626.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  8 |     | <span class='neutral'>import {IGmxGlpManager} from &quot;interfaces/IGmxV1.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>contract MagicVaultOracle is IOracle {</span>
 11 |     | <span class='unexecuted'>    IERC4626 public immutable vault;</span>
 12 |     | <span class='unexecuted'>    IAggregator public immutable aggregator;</span>
 13 |     | <span class='unexecuted'>    uint256 public immutable decimalScale;</span>
 14 |     | <span class='neutral'>    string private desc;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /// @notice Magic vault oracle</span>
 17 |     | <span class='neutral'>    /// @param _desc The description of the oracle</span>
 18 |     | <span class='neutral'>    /// @param _vault The vault to use</span>
 19 |     | <span class='neutral'>    /// @param _aggregator The aggregator to use for the asset.</span>
 20 |     | <span class='unexecuted'>    constructor(string memory _desc, IERC4626 _vault, IAggregator _aggregator) {</span>
 21 |     | <span class='unexecuted'>        assert(_vault.decimals() == _aggregator.decimals());</span>
 22 |     | <span class='unexecuted'>        desc = _desc;</span>
 23 |     | <span class='unexecuted'>        vault = _vault;</span>
 24 |     | <span class='unexecuted'>        aggregator = _aggregator;</span>
 25 |     | <span class='unexecuted'>        decimalScale = 10 ** (_vault.decimals() * 2);</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>    function decimals() external view returns (uint8) {</span>
 29 |     | <span class='unexecuted'>        return vault.decimals();</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    function _get() internal view returns (uint256) {</span>
 33 |     | <span class='unexecuted'>        return decimalScale / vault.convertToAssets(uint256(aggregator.latestAnswer()));</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    // Get the latest exchange rate</span>
 37 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 38 |     | <span class='unexecuted'>    function get(bytes calldata) public view override returns (bool, uint256) {</span>
 39 |     | <span class='unexecuted'>        return (true, _get());</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    // Check the last exchange rate without any state changes</span>
 43 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 44 |     | <span class='neutral'>    function peek(bytes calldata) public view override returns (bool, uint256) {</span>
 45 |     | <span class='neutral'>        return (true, _get());</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    // Check the current spot exchange rate without any state changes</span>
 49 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 50 |     | <span class='unexecuted'>    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {</span>
 51 |     | <span class='unexecuted'>        (, rate) = peek(data);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 55 |     | <span class='neutral'>    function name(bytes calldata) public view override returns (string memory) {</span>
 56 |     | <span class='neutral'>        return desc;</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 60 |     | <span class='unexecuted'>    function symbol(bytes calldata) public view override returns (string memory) {</span>
 61 |     | <span class='unexecuted'>        return desc;</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'>}</span>
 64 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/ProxyOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Owned} from &quot;solmate/auth/Owned.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/// @title ProxyOracle</span>
  8 |     | <span class='neutral'>/// @author 0xMerlin</span>
  9 |     | <span class='neutral'>/// @notice Oracle used for getting the price of an oracle implementation</span>
 10 |     | <span class='unexecuted'>contract ProxyOracle is IOracle, Owned {</span>
 11 |     | <span class='unexecuted'>    IOracle public oracleImplementation;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    event LogOracleImplementationChange(IOracle indexed oldOracle, IOracle indexed newOracle);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    constructor() Owned(msg.sender) {}</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    function changeOracleImplementation(IOracle newOracle) external onlyOwner {</span>
 18 |     | <span class='unexecuted'>        IOracle oldOracle = oracleImplementation;</span>
 19 |     | <span class='unexecuted'>        oracleImplementation = newOracle;</span>
 20 |     | <span class='unexecuted'>        emit LogOracleImplementationChange(oldOracle, newOracle);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function decimals() external view returns (uint8) {</span>
 24 |     | <span class='unexecuted'>        return oracleImplementation.decimals();</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    // Get the latest exchange rate</span>
 28 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 29 |     | <span class='unexecuted'>    function get(bytes calldata data) public override returns (bool, uint256) {</span>
 30 |     | <span class='unexecuted'>        return oracleImplementation.get(data);</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    // Check the last exchange rate without any state changes</span>
 34 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 35 |     | <span class='unexecuted'>    function peek(bytes calldata data) public view override returns (bool, uint256) {</span>
 36 |     | <span class='unexecuted'>        return oracleImplementation.peek(data);</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    // Check the current spot exchange rate without any state changes</span>
 40 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 41 |     | <span class='unexecuted'>    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {</span>
 42 |     | <span class='unexecuted'>        return oracleImplementation.peekSpot(data);</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 46 |     | <span class='unexecuted'>    function name(bytes calldata) public pure override returns (string memory) {</span>
 47 |     | <span class='unexecuted'>        return &quot;Proxy Oracle&quot;;</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 51 |     | <span class='unexecuted'>    function symbol(bytes calldata) public pure override returns (string memory) {</span>
 52 |     | <span class='unexecuted'>        return &quot;Proxy&quot;;</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'>}</span>
 55 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/StargateLPOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IStargatePool} from &quot;interfaces/IStargate.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>contract StargateLPOracle is IOracle {</span>
  9 |     | <span class='unexecuted'>    IStargatePool public immutable pool;</span>
 10 |     | <span class='unexecuted'>    IAggregator public immutable tokenAggregator;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    uint256 public immutable decimalScale;</span>
 13 |     | <span class='neutral'>    string private desc;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    constructor(IStargatePool _pool, IAggregator _tokenAggregator, string memory _desc) {</span>
 16 |     | <span class='unexecuted'>        pool = _pool;</span>
 17 |     | <span class='unexecuted'>        tokenAggregator = _tokenAggregator;</span>
 18 |     | <span class='unexecuted'>        desc = _desc;</span>
 19 |     | <span class='unexecuted'>        decimalScale = 10 ** (_pool.decimals() + _tokenAggregator.decimals());</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function decimals() external view returns (uint8) {</span>
 23 |     | <span class='unexecuted'>        return uint8(pool.decimals());</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    function _get() internal view returns (uint256) {</span>
 27 |     | <span class='unexecuted'>        uint256 lpPrice = (pool.totalLiquidity() * uint256(tokenAggregator.latestAnswer())) / pool.totalSupply();</span>
 28 |     | <span class='unexecuted'>        return decimalScale / lpPrice;</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 32 |     | <span class='unexecuted'>    function get(bytes calldata) public view override returns (bool, uint256) {</span>
 33 |     | <span class='unexecuted'>        return (true, _get());</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 37 |     | <span class='neutral'>    function peek(bytes calldata) public view override returns (bool, uint256) {</span>
 38 |     | <span class='neutral'>        return (true, _get());</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 42 |     | <span class='unexecuted'>    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {</span>
 43 |     | <span class='unexecuted'>        (, rate) = peek(data);</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 47 |     | <span class='neutral'>    function name(bytes calldata) public view override returns (string memory) {</span>
 48 |     | <span class='neutral'>        return desc;</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 52 |     | <span class='unexecuted'>    function symbol(bytes calldata) public view override returns (string memory) {</span>
 53 |     | <span class='unexecuted'>        return desc;</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'>}</span>
 56 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/YearnCurvePoolOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ICurveStablePoolAggregator} from &quot;interfaces/ICurveStablePoolAggregator.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IYearnVault} from &quot;interfaces/IYearnVault.sol&quot;;</span>
  7 |     | <span class='neutral'>import {ICurvePool} from &quot;interfaces/ICurvePool.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/// @notice Yearn oracle version using CurveStablePoolAggregator</span>
 10 |     | <span class='unexecuted'>contract YearnCurvePoolOracle is IOracle {</span>
 11 |     | <span class='unexecuted'>    ICurveStablePoolAggregator public immutable aggregator;</span>
 12 |     | <span class='unexecuted'>    IYearnVault public immutable vault;</span>
 13 |     | <span class='unexecuted'>    uint256 public immutable decimalScale;</span>
 14 |     | <span class='neutral'>    string private desc;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    constructor(IYearnVault _vault, ICurveStablePoolAggregator _aggregator, string memory _desc) {</span>
 17 |     | <span class='unexecuted'>        assert(_vault.token() == _aggregator.curvePool());</span>
 18 |     | <span class='unexecuted'>        assert(_vault.decimals() == _aggregator.decimals());</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>        vault = _vault;</span>
 21 |     | <span class='unexecuted'>        aggregator = _aggregator;</span>
 22 |     | <span class='unexecuted'>        desc = _desc;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>        decimalScale = 10 ** (_aggregator.decimals() + (vault.decimals() * 2));</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function decimals() external view returns (uint8) {</span>
 28 |     | <span class='unexecuted'>        return uint8(vault.decimals());</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function _get() internal view returns (uint256) {</span>
 32 |     | <span class='unexecuted'>        return decimalScale / (uint256(aggregator.latestAnswer()) * vault.pricePerShare());</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 36 |     | <span class='unexecuted'>    function get(bytes calldata) public view override returns (bool, uint256) {</span>
 37 |     | <span class='unexecuted'>        return (true, _get());</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 41 |     | <span class='neutral'>    function peek(bytes calldata) public view override returns (bool, uint256) {</span>
 42 |     | <span class='neutral'>        return (true, _get());</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 46 |     | <span class='unexecuted'>    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {</span>
 47 |     | <span class='unexecuted'>        (, rate) = peek(data);</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 51 |     | <span class='neutral'>    function name(bytes calldata) public view override returns (string memory) {</span>
 52 |     | <span class='neutral'>        return desc;</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 56 |     | <span class='unexecuted'>    function symbol(bytes calldata) public view override returns (string memory) {</span>
 57 |     | <span class='unexecuted'>        return desc;</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'>}</span>
 60 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/YearnTriCryptoOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IYearnVault} from &quot;interfaces/IYearnVault.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface ITriCryptoOracle {</span>
  8 |     | <span class='neutral'>    function lp_price() external view returns (uint256 price);</span>
  9 |     | <span class='neutral'>}</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>contract YearnTriCryptoOracle is IOracle {</span>
 12 |     | <span class='unexecuted'>    ITriCryptoOracle public immutable LP_ORACLE;</span>
 13 |     | <span class='unexecuted'>    IYearnVault public immutable vault;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    constructor(address vault_, address _lpOracle) {</span>
 16 |     | <span class='unexecuted'>        vault = IYearnVault(vault_);</span>
 17 |     | <span class='unexecuted'>        LP_ORACLE = ITriCryptoOracle(_lpOracle);</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function decimals() external pure returns (uint8) {</span>
 21 |     | <span class='unexecuted'>        return 18;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    // Calculates the lastest exchange rate</span>
 25 |     | <span class='neutral'>    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD</span>
 26 |     | <span class='unexecuted'>    function _get() internal view returns (uint256) {</span>
 27 |     | <span class='unexecuted'>        return 1e54 / (LP_ORACLE.lp_price() * vault.pricePerShare());</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    // Get the latest exchange rate</span>
 31 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 32 |     | <span class='unexecuted'>    function get(bytes calldata) public view override returns (bool, uint256) {</span>
 33 |     | <span class='unexecuted'>        return (true, _get());</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    // Check the last exchange rate without any state changes</span>
 37 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 38 |     | <span class='neutral'>    function peek(bytes calldata) public view override returns (bool, uint256) {</span>
 39 |     | <span class='neutral'>        return (true, _get());</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    // Check the current spot exchange rate without any state changes</span>
 43 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 44 |     | <span class='unexecuted'>    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {</span>
 45 |     | <span class='unexecuted'>        (, rate) = peek(data);</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 49 |     | <span class='neutral'>    function name(bytes calldata) public pure override returns (string memory) {</span>
 50 |     | <span class='neutral'>        return &quot;y3Crypto&quot;;</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    /// @inheritdoc IOracle</span>
 54 |     | <span class='unexecuted'>    function symbol(bytes calldata) public pure override returns (string memory) {</span>
 55 |     | <span class='unexecuted'>        return &quot;y3Crypto&quot;;</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'>}</span>
 58 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/aggregators/CurveStablePoolAggregator.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ICurvePool} from &quot;interfaces/ICurvePool.sol&quot;;</span>
  6 |     | <span class='neutral'>import {MathLib} from &quot;libraries/MathLib.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/// @title CurveStablePoolAggregator</span>
  9 |     | <span class='neutral'>/// @notice An aggregator that expect a CurvePool with stablecoins and uses</span>
 10 |     | <span class='neutral'>/// the one with the lowest price as the price of the pool along with the virtual price</span>
 11 |     | <span class='unexecuted'>contract CurveStablePoolAggregator is IAggregator {</span>
 12 |     | <span class='unexecuted'>    ICurvePool public immutable curvePool;</span>
 13 |     | <span class='unexecuted'>    uint256 public immutable decimalScale;</span>
 14 |     | <span class='unexecuted'>    IAggregator[] public aggregators;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    constructor(ICurvePool _curvePool, IAggregator[] memory _aggregators) {</span>
 17 |     | <span class='unexecuted'>        curvePool = _curvePool;</span>
 18 |     | <span class='unexecuted'>        aggregators = _aggregators;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>        // assert that all aggregators are the same decimals</span>
 21 |     | <span class='unexecuted'>        uint8 aggregatorDecimals = _aggregators[0].decimals();</span>
 22 |     | <span class='unexecuted'>        for (uint256 i = 1; i &lt; _aggregators.length; ) {</span>
 23 |     | <span class='unexecuted'>            assert(_aggregators[i].decimals() == aggregatorDecimals);</span>
 24 |     | <span class='neutral'>            unchecked {</span>
 25 |     | <span class='unexecuted'>                ++i;</span>
 26 |     | <span class='neutral'>            }</span>
 27 |     | <span class='neutral'>        }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>        decimalScale = 10 ** aggregatorDecimals;</span>
 30 |     | <span class='unexecuted'>        assert(decimalScale != 0);</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='unexecuted'>    function decimals() external view returns (uint8) {</span>
 34 |     | <span class='unexecuted'>        return uint8(curvePool.decimals());</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function latestAnswer() public view override returns (int256) {</span>
 38 |     | <span class='unexecuted'>        uint256 minStable = uint256(aggregators[0].latestAnswer());</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>        for (uint256 i = 1; i &lt; aggregators.length - 1; ) {</span>
 41 |     | <span class='unexecuted'>            uint256 price = uint256(aggregators[i].latestAnswer());</span>
 42 |     | <span class='unexecuted'>            if (price &lt; minStable) {</span>
 43 |     | <span class='unexecuted'>                minStable = price;</span>
 44 |     | <span class='neutral'>            }</span>
 45 |     | <span class='neutral'>            unchecked {</span>
 46 |     | <span class='unexecuted'>                ++i;</span>
 47 |     | <span class='neutral'>            }</span>
 48 |     | <span class='neutral'>        }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='unexecuted'>        return int256((curvePool.get_virtual_price() * minStable) / decimalScale);</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='unexecuted'>    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {</span>
 54 |     | <span class='unexecuted'>        return (0, latestAnswer(), 0, 0, 0);</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'>}</span>
 57 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/aggregators/MagicLpAggregator.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {FixedPointMathLib} from &quot;solady/utils/FixedPointMathLib.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IERC20Metadata} from &quot;openzeppelin-contracts/interfaces/IERC20Metadata.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IMagicLP} from &quot;/mimswap/interfaces/IMagicLP.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>contract MagicLpAggregator is IAggregator {</span>
 10 |     | <span class='unexecuted'>    IMagicLP public immutable pair;</span>
 11 |     | <span class='unexecuted'>    IAggregator public immutable baseOracle;</span>
 12 |     | <span class='unexecuted'>    IAggregator public immutable quoteOracle;</span>
 13 |     | <span class='unexecuted'>    uint8 public immutable baseDecimals;</span>
 14 |     | <span class='unexecuted'>    uint8 public immutable quoteDecimals;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    uint256 public constant WAD = 18;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /// @param pair_ The MagicLP pair address</span>
 19 |     | <span class='neutral'>    /// @param baseOracle_ The base oracle</span>
 20 |     | <span class='neutral'>    /// @param quoteOracle_ The quote oracle</span>
 21 |     | <span class='unexecuted'>    constructor(IMagicLP pair_, IAggregator baseOracle_, IAggregator quoteOracle_) {</span>
 22 |     | <span class='unexecuted'>        pair = pair_;</span>
 23 |     | <span class='unexecuted'>        baseOracle = baseOracle_;</span>
 24 |     | <span class='unexecuted'>        quoteOracle = quoteOracle_;</span>
 25 |     | <span class='unexecuted'>        baseDecimals = IERC20Metadata(pair_._BASE_TOKEN_()).decimals();</span>
 26 |     | <span class='unexecuted'>        quoteDecimals = IERC20Metadata(pair_._QUOTE_TOKEN_()).decimals();</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>    function decimals() external pure override returns (uint8) {</span>
 30 |     | <span class='unexecuted'>        return 18;</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='unexecuted'>    function _getReserves() internal view virtual returns (uint256, uint256) {</span>
 34 |     | <span class='unexecuted'>        return pair.getReserves();</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function latestAnswer() public view override returns (int256) {</span>
 38 |     | <span class='unexecuted'>        uint256 baseAnswerNomalized = uint256(baseOracle.latestAnswer()) * (10 ** (WAD - baseOracle.decimals()));</span>
 39 |     | <span class='unexecuted'>        uint256 quoteAnswerNormalized = uint256(quoteOracle.latestAnswer()) * (10 ** (WAD - quoteOracle.decimals()));</span>
 40 |     | <span class='unexecuted'>        uint256 minAnswer = baseAnswerNomalized &lt; quoteAnswerNormalized ? baseAnswerNomalized : quoteAnswerNormalized;</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='unexecuted'>        (uint256 baseReserve, uint256 quoteReserve) = _getReserves();</span>
 43 |     | <span class='unexecuted'>        baseReserve = baseReserve * (10 ** (WAD - baseDecimals));</span>
 44 |     | <span class='unexecuted'>        quoteReserve = quoteReserve * (10 ** (WAD - quoteDecimals));</span>
 45 |     | <span class='unexecuted'>        return int256(minAnswer * (baseReserve + quoteReserve) / pair.totalSupply());</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {</span>
 49 |     | <span class='unexecuted'>        return (0, latestAnswer(), 0, 0, 0);</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/aggregators/RedstoneAggregator.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IRedstoneAdapter {</span>
  7 |     | <span class='neutral'>    function getValueForDataFeed(bytes32 dataFeedId) external view returns (uint256);</span>
  8 |     | <span class='neutral'>}</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>contract RedstoneAggregator is IAggregator {</span>
 11 |     | <span class='neutral'>    error ErrUnsafeUintToIntConversion();</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    uint8 public constant decimals = 8;</span>
 14 |     | <span class='unexecuted'>    IRedstoneAdapter public immutable priceFeedAdapter;</span>
 15 |     | <span class='unexecuted'>    bytes32 public immutable dataFeedId;</span>
 16 |     | <span class='unexecuted'>    string public description;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>    constructor(string memory _description, IRedstoneAdapter _priceFeedAdapter, bytes32 _dataFeedId) {</span>
 19 |     | <span class='unexecuted'>        description = _description;</span>
 20 |     | <span class='unexecuted'>        priceFeedAdapter = _priceFeedAdapter;</span>
 21 |     | <span class='unexecuted'>        dataFeedId = _dataFeedId;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    function latestRoundData() public view override returns (uint80, int256, uint256, uint256, uint80) {</span>
 25 |     | <span class='unexecuted'>        return (0, latestAnswer(), 0, 0, 0);</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>    function latestAnswer() public view override returns (int256) {</span>
 29 |     | <span class='unexecuted'>        uint256 uintAnswer = priceFeedAdapter.getValueForDataFeed(dataFeedId);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>        if (uintAnswer &gt; uint256(type(int256).max)) {</span>
 32 |     | <span class='unexecuted'>            revert ErrUnsafeUintToIntConversion();</span>
 33 |     | <span class='neutral'>        }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>        return int256(uintAnswer);</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'>}</span>
 38 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/aggregators/TokenAggregator.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @title TokenAggregator</span>
  7 |     | <span class='neutral'>/// @notice Aggregator used for getting the price of 1 token in given denominator using Chainlink</span>
  8 |     | <span class='unexecuted'>contract TokenAggregator is IAggregator {</span>
  9 |     | <span class='neutral'>    error NegativePriceFeed();</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    IAggregator public immutable tokenUSD;</span>
 12 |     | <span class='unexecuted'>    IAggregator public immutable denominatorUSD;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    uint8 public immutable oracle0Decimals;</span>
 15 |     | <span class='unexecuted'>    uint8 public immutable oracle1Decimals;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    uint8 public immutable _decimals;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    constructor(IAggregator _tokenUSD, IAggregator _denominatorUSD, uint8 __decimals) {</span>
 20 |     | <span class='unexecuted'>        tokenUSD = _tokenUSD;</span>
 21 |     | <span class='unexecuted'>        denominatorUSD = _denominatorUSD;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>        oracle0Decimals = _tokenUSD.decimals();</span>
 24 |     | <span class='unexecuted'>        oracle1Decimals = _denominatorUSD.decimals();</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>        _decimals = __decimals;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>    function decimals() external view override returns (uint8) {</span>
 30 |     | <span class='unexecuted'>        return _decimals;</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='unexecuted'>    function latestAnswer() public view override returns (int256 answer) {</span>
 34 |     | <span class='unexecuted'>        int256 tokenUSDFeed = tokenUSD.latestAnswer();</span>
 35 |     | <span class='unexecuted'>        int256 denominatorUSDFeed = denominatorUSD.latestAnswer();</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>        if (tokenUSDFeed &lt; 0 || denominatorUSDFeed &lt; 0) {</span>
 38 |     | <span class='unexecuted'>            revert NegativePriceFeed();</span>
 39 |     | <span class='neutral'>        }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='unexecuted'>        uint256 normalizedTokenUSDFeed = uint256(tokenUSDFeed) * (10 ** (_decimals - oracle0Decimals));</span>
 42 |     | <span class='unexecuted'>        uint256 normalizedDenominatorUSDFeed = uint256(denominatorUSDFeed) * (10 ** (_decimals - oracle1Decimals));</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='unexecuted'>        return int256((normalizedTokenUSDFeed * (10**_decimals)) / normalizedDenominatorUSDFeed);</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {</span>
 48 |     | <span class='unexecuted'>        return (0, latestAnswer(), 0, 0, 0);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'>}</span>
 51 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/aggregators/UmbrellaAggregator.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IUmbrellaFeeds} from &quot;interfaces/IUmbrellaFeeds.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IUmbrellaRegistry {</span>
  8 |     | <span class='neutral'>    function getAddress(bytes32 _bytes) external view returns (address);</span>
  9 |     | <span class='neutral'>}</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>/// @title UmbrellaAggregator</span>
 12 |     | <span class='neutral'>/// @notice Wraps umbrella price feed in an aggregator interface</span>
 13 |     | <span class='unexecuted'>contract UmbrellaAggregator is IAggregator {</span>
 14 |     | <span class='unexecuted'>    bytes32 public constant FEEDS_KEY_NAME = bytes32(&quot;UmbrellaFeeds&quot;);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    IUmbrellaRegistry public immutable registry;</span>
 17 |     | <span class='unexecuted'>    bytes32 public immutable key;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    constructor(bytes32 _key, IUmbrellaRegistry _registry) {</span>
 20 |     | <span class='unexecuted'>        key = _key;</span>
 21 |     | <span class='unexecuted'>        registry = _registry;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    function decimals() external view override returns (uint8) {</span>
 25 |     | <span class='unexecuted'>        return _getFeeds().DECIMALS();</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>    function latestAnswer() external view returns (int256 answer) {</span>
 29 |     | <span class='unexecuted'>        (, answer, , , ) = latestRoundData();</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    function latestRoundData() public view returns (uint80, int256 answer, uint256, uint256 updatedAt, uint80) {</span>
 33 |     | <span class='unexecuted'>        IUmbrellaFeeds.PriceData memory data = _getFeeds().getPriceData(key);</span>
 34 |     | <span class='unexecuted'>        return (0, int256(uint256(data.price)), 0, data.timestamp, 0);</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function _getFeeds() private view returns (IUmbrellaFeeds) {</span>
 38 |     | <span class='unexecuted'>        return IUmbrellaFeeds(registry.getAddress(FEEDS_KEY_NAME));</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'>}</span>
 41 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/aggregators/UniswapLikeLPAggregator.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IUniswapV2Pair} from &quot;interfaces/IUniswapV2.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
  7 |     | <span class='neutral'>import {BabylonianLib} from &quot;libraries/BabylonianLib.sol&quot;;</span>
  8 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>/// @title UniswapLikeLPAggregator</span>
 11 |     | <span class='neutral'>/// @author BoringCrypto, 0xCalibur</span>
 12 |     | <span class='neutral'>/// @notice Aggregator used for getting the price of an LP token denominated in tokenOracle.</span>
 13 |     | <span class='neutral'>/// @dev Optimized version based on https://blog.alphafinance.io/fair-lp-token-pricing/</span>
 14 |     | <span class='unexecuted'>contract UniswapLikeLPAggregator is IAggregator {</span>
 15 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    IUniswapV2Pair public immutable pair;</span>
 18 |     | <span class='unexecuted'>    IAggregator public immutable tokenOracle;</span>
 19 |     | <span class='unexecuted'>    uint8 public immutable token0Decimals;</span>
 20 |     | <span class='unexecuted'>    uint8 public immutable token1Decimals;</span>
 21 |     | <span class='unexecuted'>    uint8 public immutable oracleDecimals;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    uint256 public constant WAD = 18;</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    /// @param pair_ The UniswapV2 compatible pair address</span>
 26 |     | <span class='neutral'>    /// @param tokenOracle_ The token price 1 lp should be denominated with.</span>
 27 |     | <span class='unexecuted'>    constructor(IUniswapV2Pair pair_, IAggregator tokenOracle_) {</span>
 28 |     | <span class='unexecuted'>        pair = pair_;</span>
 29 |     | <span class='unexecuted'>        tokenOracle = tokenOracle_;</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>        token0Decimals = IERC20(pair_.token0()).safeDecimals();</span>
 32 |     | <span class='unexecuted'>        token1Decimals = IERC20(pair_.token1()).safeDecimals();</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>        oracleDecimals = tokenOracle_.decimals();</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function decimals() external pure override returns (uint8) {</span>
 38 |     | <span class='unexecuted'>        return 18;</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /// Calculates the lastest exchange rate</span>
 42 |     | <span class='neutral'>    /// @return the price of 1 lp in token price</span>
 43 |     | <span class='neutral'>    /// Example:</span>
 44 |     | <span class='neutral'>    /// - For 1 AVAX = $82</span>
 45 |     | <span class='neutral'>    /// - Total LP Value is: $160,000,000</span>
 46 |     | <span class='neutral'>    /// - LP supply is 8.25</span>
 47 |     | <span class='neutral'>    /// - latestAnswer() returns 234420638348190662349201 / 1e18 = 234420.63 AVAX</span>
 48 |     | <span class='neutral'>    /// - 1 LP = 234420.63 AVAX =&gt; 234420.63 * 8.25 * 82 = $160,000,000</span>
 49 |     | <span class='unexecuted'>    function latestAnswer() public view override returns (int256) {</span>
 50 |     | <span class='unexecuted'>        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pair).getReserves();</span>
 51 |     | <span class='unexecuted'>        uint256 totalSupply = pair.totalSupply();</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='unexecuted'>        uint256 normalizedReserve0 = reserve0 * (10 ** (WAD - token0Decimals));</span>
 54 |     | <span class='unexecuted'>        uint256 normalizedReserve1 = reserve1 * (10 ** (WAD - token1Decimals));</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='unexecuted'>        uint256 k = normalizedReserve0 * normalizedReserve1;</span>
 57 |     | <span class='unexecuted'>        (, int256 priceFeed, , , ) = tokenOracle.latestRoundData();</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>        uint256 normalizedPriceFeed = uint256(priceFeed) * (10 ** (WAD - oracleDecimals));</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='unexecuted'>        uint256 totalValue = uint256(BabylonianLib.sqrt((k / 1e18) * normalizedPriceFeed)) * 2;</span>
 62 |     | <span class='unexecuted'>        return int256((totalValue * 1e18) / totalSupply);</span>
 63 |     | <span class='neutral'>    }</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='unexecuted'>    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {</span>
 66 |     | <span class='unexecuted'>        return (0, latestAnswer(), 0, 0, 0);</span>
 67 |     | <span class='neutral'>    }</span>
 68 |     | <span class='neutral'>}</span>
 69 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/aggregators/WitnetAggregator.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IWitnetPriceRouter} from &quot;interfaces/IWitnetPriceRouter.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/// @title WitnetAggregator</span>
  8 |     | <span class='neutral'>/// @notice Wraps witnet price router in an aggregator interface</span>
  9 |     | <span class='unexecuted'>contract WitnetAggregator is IAggregator {</span>
 10 |     | <span class='unexecuted'>    IWitnetPriceRouter public immutable router;</span>
 11 |     | <span class='unexecuted'>    bytes4 public immutable id;</span>
 12 |     | <span class='unexecuted'>    uint8 public immutable _decimals;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    constructor(bytes4 _id, address _router, uint8 __decimals) {</span>
 15 |     | <span class='unexecuted'>        id = _id;</span>
 16 |     | <span class='unexecuted'>        router = IWitnetPriceRouter(_router);</span>
 17 |     | <span class='unexecuted'>        _decimals = __decimals;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function decimals() external view override returns (uint8) {</span>
 21 |     | <span class='unexecuted'>        return _decimals;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    function latestAnswer() external view returns (int256 _price) {</span>
 25 |     | <span class='unexecuted'>        (_price, , ) = router.valueFor(id);</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>    function latestRoundData() public view returns (uint80, int256 answer, uint256, uint256 updatedAt, uint80) {</span>
 29 |     | <span class='unexecuted'>        (answer, updatedAt, ) = router.valueFor(id);</span>
 30 |     | <span class='unexecuted'>        return (0, answer, 0, updatedAt, 0);</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'>}</span>
 33 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/CauldronFeeWithdrawer.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import {ILzOFTV2, ILzApp, ILzCommonOFT} from &quot;interfaces/ILayerZero.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ICauldronV1} from &quot;interfaces/ICauldronV1.sol&quot;;</span>
   9 |     | <span class='neutral'>import {ICauldronV2} from &quot;interfaces/ICauldronV2.sol&quot;;</span>
  10 |     | <span class='neutral'>import {SafeApproveLib} from &quot;libraries/SafeApproveLib.sol&quot;;</span>
  11 |     | <span class='neutral'>import {OperatableV2} from &quot;mixins/OperatableV2.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>library CauldronFeeWithdrawWithdrawerEvents {</span>
  14 |     | <span class='neutral'>    event LogMimWithdrawn(IBentoBoxV1 indexed bentoBox, uint256 amount);</span>
  15 |     | <span class='neutral'>    event LogMimTotalWithdrawn(uint256 amount);</span>
  16 |     | <span class='neutral'>    event LogBentoBoxChanged(IBentoBoxV1 indexed bentoBox, bool previous, bool current);</span>
  17 |     | <span class='neutral'>    event LogCauldronChanged(address indexed cauldron, bool previous, bool current);</span>
  18 |     | <span class='neutral'>    event LogParametersChanged(address mimProvider, bytes32 bridgeRecipient, address mimWithdrawRecipient);</span>
  19 |     | <span class='neutral'>    event LogFeeToOverrideChanged(address indexed cauldron, address previous, address current);</span>
  20 |     | <span class='neutral'>}</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>/// @notice Responsible of withdrawing MIM fees from Cauldron and in case of altchains, bridge</span>
  23 |     | <span class='neutral'>/// MIM inside this contract to mainnet CauldronFeeWithdrawer</span>
  24 |     | <span class='unexecuted'>contract CauldronFeeWithdrawer is OperatableV2 {</span>
  25 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
  26 |     | <span class='neutral'>    using SafeApproveLib for IERC20;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    error ErrInvalidFeeTo(address masterContract);</span>
  29 |     | <span class='neutral'>    error ErrNotEnoughNativeTokenToCoverFee();</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    struct CauldronInfo {</span>
  32 |     | <span class='neutral'>        address cauldron;</span>
  33 |     | <span class='neutral'>        address masterContract;</span>
  34 |     | <span class='neutral'>        IBentoBoxV1 bentoBox;</span>
  35 |     | <span class='neutral'>        uint8 version;</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    uint16 public constant LZ_MAINNET_CHAINID = 101;</span>
  39 |     | <span class='unexecuted'>    IERC20 public immutable mim;</span>
  40 |     | <span class='unexecuted'>    ILzOFTV2 public immutable lzOftv2;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>    mapping(address =&gt; address) public feeToOverrides;</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /// @dev By default withdraw MIM from bentoBox to this contract because they will need</span>
  45 |     | <span class='neutral'>    /// to get bridge from altchains to mainnet SpellStakingRewardDistributor.</span>
  46 |     | <span class='neutral'>    /// On mainnet, this should be withdrawn to SpellStakingRewardDistributor directly.</span>
  47 |     | <span class='unexecuted'>    address public mimWithdrawRecipient;</span>
  48 |     | <span class='unexecuted'>    bytes32 public bridgeRecipient;</span>
  49 |     | <span class='unexecuted'>    address public mimProvider;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>    CauldronInfo[] public cauldronInfos;</span>
  52 |     | <span class='unexecuted'>    IBentoBoxV1[] public bentoBoxes;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>    constructor(address _owner, IERC20 _mim, ILzOFTV2 _lzOftv2) OperatableV2(_owner) {</span>
  55 |     | <span class='unexecuted'>        mim = _mim;</span>
  56 |     | <span class='unexecuted'>        lzOftv2 = _lzOftv2;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    receive() external payable {}</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>    function bentoBoxesCount() external view returns (uint256) {</span>
  62 |     | <span class='unexecuted'>        return bentoBoxes.length;</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function cauldronInfosCount() external view returns (uint256) {</span>
  66 |     | <span class='unexecuted'>        return cauldronInfos.length;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>    function withdraw() external returns (uint256 amount) {</span>
  70 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; cauldronInfos.length; i++) {</span>
  71 |     | <span class='unexecuted'>            CauldronInfo memory info = cauldronInfos[i];</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>            if (ICauldronV1(info.masterContract).feeTo() != address(this)) {</span>
  74 |     | <span class='unexecuted'>                revert ErrInvalidFeeTo(info.masterContract);</span>
  75 |     | <span class='neutral'>            }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>            ICauldronV1(info.cauldron).accrue();</span>
  78 |     | <span class='unexecuted'>            uint256 feesEarned;</span>
  79 |     | <span class='unexecuted'>            IBentoBoxV1 bentoBox = info.bentoBox;</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>            if (info.version == 1) {</span>
  82 |     | <span class='unexecuted'>                (, feesEarned) = ICauldronV1(info.cauldron).accrueInfo();</span>
  83 |     | <span class='unexecuted'>            } else if (info.version &gt;= 2) {</span>
  84 |     | <span class='unexecuted'>                (, feesEarned, ) = ICauldronV2(info.cauldron).accrueInfo();</span>
  85 |     | <span class='neutral'>            }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>            uint256 cauldronMimAmount = bentoBox.toAmount(mim, bentoBox.balanceOf(mim, info.cauldron), false);</span>
  88 |     | <span class='unexecuted'>            if (feesEarned &gt; cauldronMimAmount) {</span>
  89 |     | <span class='neutral'>                // only transfer the required mim amount</span>
  90 |     | <span class='unexecuted'>                uint256 diff = feesEarned - cauldronMimAmount;</span>
  91 |     | <span class='unexecuted'>                mim.safeTransferFrom(mimProvider, address(bentoBox), diff);</span>
  92 |     | <span class='unexecuted'>                bentoBox.deposit(mim, address(bentoBox), info.cauldron, diff, 0);</span>
  93 |     | <span class='neutral'>            }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>            ICauldronV1(info.cauldron).withdrawFees();</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>            // redirect fees to override address if set</span>
  98 |     | <span class='unexecuted'>            address feeToOverride = feeToOverrides[info.cauldron];</span>
  99 |     | <span class='unexecuted'>            if (feeToOverride != address(0)) {</span>
 100 |     | <span class='unexecuted'>                info.bentoBox.transfer(mim, address(this), feeToOverride, bentoBox.toShare(mim, feesEarned, false));</span>
 101 |     | <span class='neutral'>            }</span>
 102 |     | <span class='neutral'>        }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>        amount = _withdrawAllMimFromBentoBoxes();</span>
 105 |     | <span class='unexecuted'>        emit CauldronFeeWithdrawWithdrawerEvents.LogMimTotalWithdrawn(amount);</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>    function estimateBridgingFee(uint256 amount) external view returns (uint256 fee, uint256 gas) {</span>
 109 |     | <span class='unexecuted'>        gas = ILzApp(address(lzOftv2)).minDstGasLookup(LZ_MAINNET_CHAINID, 0 /* packet type for sendFrom */);</span>
 110 |     | <span class='unexecuted'>        (fee, ) = lzOftv2.estimateSendFee(LZ_MAINNET_CHAINID, bridgeRecipient, amount, false, abi.encodePacked(uint16(1), uint256(gas)));</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>    function bridge(uint256 amount, uint256 fee, uint256 gas) external onlyOperators {</span>
 114 |     | <span class='neutral'>        // optionnal check for convenience</span>
 115 |     | <span class='neutral'>        // check if there is enough native token to cover the bridging fees</span>
 116 |     | <span class='unexecuted'>        if (fee &gt; address(this).balance) {</span>
 117 |     | <span class='unexecuted'>            revert ErrNotEnoughNativeTokenToCoverFee();</span>
 118 |     | <span class='neutral'>        }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>        ILzCommonOFT.LzCallParams memory lzCallParams = ILzCommonOFT.LzCallParams({</span>
 121 |     | <span class='unexecuted'>            refundAddress: payable(address(this)),</span>
 122 |     | <span class='neutral'>            zroPaymentAddress: address(0),</span>
 123 |     | <span class='unexecuted'>            adapterParams: abi.encodePacked(uint16(1), uint256(gas))</span>
 124 |     | <span class='neutral'>        });</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>        lzOftv2.sendFrom{value: fee}(</span>
 127 |     | <span class='unexecuted'>            address(this), // &#39;from&#39; address to send tokens</span>
 128 |     | <span class='neutral'>            LZ_MAINNET_CHAINID, // mainnet remote LayerZero chainId</span>
 129 |     | <span class='unexecuted'>            bridgeRecipient, // &#39;to&#39; address to send tokens</span>
 130 |     | <span class='unexecuted'>            amount, // amount of tokens to send (in wei)</span>
 131 |     | <span class='unexecuted'>            lzCallParams</span>
 132 |     | <span class='neutral'>        );</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='unexecuted'>    function setFeeToOverride(address cauldron, address feeTo) external onlyOwner {</span>
 136 |     | <span class='unexecuted'>        emit CauldronFeeWithdrawWithdrawerEvents.LogFeeToOverrideChanged(cauldron, feeToOverrides[cauldron], feeTo);</span>
 137 |     | <span class='unexecuted'>        feeToOverrides[cauldron] = feeTo;</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>    function setCauldron(address cauldron, uint8 version, bool enabled) external onlyOwner {</span>
 141 |     | <span class='unexecuted'>        _setCauldron(cauldron, version, enabled);</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>    function setCauldrons(address[] memory cauldrons, uint8[] memory versions, bool[] memory enabled) external onlyOwner {</span>
 145 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; cauldrons.length; i++) {</span>
 146 |     | <span class='unexecuted'>            _setCauldron(cauldrons[i], versions[i], enabled[i]);</span>
 147 |     | <span class='neutral'>        }</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='unexecuted'>    function _setCauldron(address cauldron, uint8 version, bool enabled) private {</span>
 151 |     | <span class='unexecuted'>        bool previousEnabled;</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; cauldronInfos.length; i++) {</span>
 154 |     | <span class='unexecuted'>            if (cauldronInfos[i].cauldron == cauldron) {</span>
 155 |     | <span class='unexecuted'>                cauldronInfos[i] = cauldronInfos[cauldronInfos.length - 1];</span>
 156 |     | <span class='unexecuted'>                cauldronInfos.pop();</span>
 157 |     | <span class='unexecuted'>                break;</span>
 158 |     | <span class='neutral'>            }</span>
 159 |     | <span class='neutral'>        }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>        if (enabled) {</span>
 162 |     | <span class='unexecuted'>            cauldronInfos.push(</span>
 163 |     | <span class='unexecuted'>                CauldronInfo({</span>
 164 |     | <span class='unexecuted'>                    cauldron: cauldron,</span>
 165 |     | <span class='unexecuted'>                    masterContract: address(ICauldronV1(cauldron).masterContract()),</span>
 166 |     | <span class='unexecuted'>                    bentoBox: IBentoBoxV1(ICauldronV1(cauldron).bentoBox()),</span>
 167 |     | <span class='neutral'>                    version: version</span>
 168 |     | <span class='neutral'>                })</span>
 169 |     | <span class='neutral'>            );</span>
 170 |     | <span class='neutral'>        }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='unexecuted'>        emit CauldronFeeWithdrawWithdrawerEvents.LogCauldronChanged(cauldron, previousEnabled, enabled);</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='unexecuted'>    function _withdrawAllMimFromBentoBoxes() private returns (uint256 totalAmount) {</span>
 176 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; bentoBoxes.length; i++) {</span>
 177 |     | <span class='unexecuted'>            uint256 share = bentoBoxes[i].balanceOf(mim, address(this));</span>
 178 |     | <span class='unexecuted'>            (uint256 amount, ) = bentoBoxes[i].withdraw(mim, address(this), mimWithdrawRecipient, 0, share);</span>
 179 |     | <span class='unexecuted'>            totalAmount += amount;</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>            emit CauldronFeeWithdrawWithdrawerEvents.LogMimWithdrawn(bentoBoxes[i], amount);</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='unexecuted'>    function setParameters(address _mimProvider, address _bridgeRecipient, address _mimWithdrawRecipient) external onlyOwner {</span>
 186 |     | <span class='unexecuted'>        mimProvider = _mimProvider;</span>
 187 |     | <span class='unexecuted'>        bridgeRecipient = bytes32(uint256(uint160(_bridgeRecipient)));</span>
 188 |     | <span class='unexecuted'>        mimWithdrawRecipient = _mimWithdrawRecipient;</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='unexecuted'>        emit CauldronFeeWithdrawWithdrawerEvents.LogParametersChanged(_mimProvider, bridgeRecipient, _mimWithdrawRecipient);</span>
 191 |     | <span class='neutral'>    }</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='unexecuted'>    function setBentoBox(IBentoBoxV1 bentoBox, bool enabled) external onlyOwner {</span>
 194 |     | <span class='unexecuted'>        bool previousEnabled;</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; bentoBoxes.length; i++) {</span>
 197 |     | <span class='unexecuted'>            if (bentoBoxes[i] == bentoBox) {</span>
 198 |     | <span class='unexecuted'>                bentoBoxes[i] = bentoBoxes[bentoBoxes.length - 1];</span>
 199 |     | <span class='unexecuted'>                bentoBoxes.pop();</span>
 200 |     | <span class='neutral'>                previousEnabled = true;</span>
 201 |     | <span class='unexecuted'>                break;</span>
 202 |     | <span class='neutral'>            }</span>
 203 |     | <span class='neutral'>        }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='unexecuted'>        if (enabled) {</span>
 206 |     | <span class='unexecuted'>            bentoBoxes.push(bentoBox);</span>
 207 |     | <span class='neutral'>        }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='unexecuted'>        emit CauldronFeeWithdrawWithdrawerEvents.LogBentoBoxChanged(bentoBox, previousEnabled, enabled);</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    ////////////////////////////////////////////////////////</span>
 213 |     | <span class='neutral'>    // Emergency Functions</span>
 214 |     | <span class='neutral'>    ////////////////////////////////////////////////////////</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='unexecuted'>    function rescueTokens(IERC20 token, address to, uint256 amount) external onlyOwner {</span>
 217 |     | <span class='unexecuted'>        token.safeTransfer(to, amount);</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='unexecuted'>    function execute(address to, uint256 value, bytes calldata data) external onlyOwner returns (bool success, bytes memory result) {</span>
 221 |     | <span class='neutral'>        // solhint-disable-next-line avoid-low-level-calls</span>
 222 |     | <span class='unexecuted'>        (success, result) = to.call{value: value}(data);</span>
 223 |     | <span class='neutral'>    }</span>
 224 |     | <span class='neutral'>}</span>
 225 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/CauldronOwner.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ERC20} from &quot;BoringSolidity/ERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import {BoringOwnable} from &quot;BoringSolidity/BoringOwnable.sol&quot;;</span>
   6 |     | <span class='neutral'>import {ICauldronV2} from &quot;interfaces/ICauldronV2.sol&quot;;</span>
   7 |     | <span class='neutral'>import {ICauldronV3} from &quot;interfaces/ICauldronV3.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ICauldronV4} from &quot;interfaces/ICauldronV4.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>contract CauldronOwner is BoringOwnable {</span>
  12 |     | <span class='neutral'>    error ErrNotOperator(address operator);</span>
  13 |     | <span class='neutral'>    error ErrNotDeprecated(address cauldron);</span>
  14 |     | <span class='neutral'>    error ErrNotMasterContract(address cauldron);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    event LogOperatorChanged(address indexed operator, bool previous, bool current);</span>
  17 |     | <span class='neutral'>    event LogTreasuryChanged(address indexed previous, address indexed current);</span>
  18 |     | <span class='neutral'>    event LogDeprecated(address indexed cauldron, bool previous, bool current);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    ERC20 public immutable mim;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public operators;</span>
  23 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public deprecated;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    address public treasury;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    modifier onlyOperators() {</span>
  28 |     | <span class='unexecuted'>        if (msg.sender != owner &amp;&amp; !operators[msg.sender]) {</span>
  29 |     | <span class='unexecuted'>            revert ErrNotOperator(msg.sender);</span>
  30 |     | <span class='neutral'>        }</span>
  31 |     | <span class='neutral'>        _;</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    constructor(address _treasury, ERC20 _mim) {</span>
  35 |     | <span class='unexecuted'>        treasury = _treasury;</span>
  36 |     | <span class='unexecuted'>        mim = _mim;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>        emit LogTreasuryChanged(address(0), _treasury);</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>    function reduceSupply(ICauldronV2 cauldron, uint256 amount) external onlyOperators {</span>
  42 |     | <span class='unexecuted'>        cauldron.reduceSupply(amount);</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>    function changeInterestRate(ICauldronV3 cauldron, uint64 newInterestRate) external onlyOperators {</span>
  46 |     | <span class='unexecuted'>        cauldron.changeInterestRate(newInterestRate);</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    function reduceCompletely(ICauldronV2 cauldron) external {</span>
  50 |     | <span class='unexecuted'>        if (!deprecated[address(cauldron)]) {</span>
  51 |     | <span class='unexecuted'>            revert ErrNotDeprecated(address(cauldron));</span>
  52 |     | <span class='neutral'>        }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>        IBentoBoxV1 bentoBox = IBentoBoxV1(cauldron.bentoBox());</span>
  55 |     | <span class='unexecuted'>        uint256 amount = bentoBox.toAmount(mim, bentoBox.balanceOf(mim, address(cauldron)), false);</span>
  56 |     | <span class='unexecuted'>        cauldron.reduceSupply(amount);</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>    function changeBorrowLimit(ICauldronV3 cauldron, uint128 newBorrowLimit, uint128 perAddressPart) external onlyOperators {</span>
  60 |     | <span class='unexecuted'>        cauldron.changeBorrowLimit(newBorrowLimit, perAddressPart);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>    function withdrawMIMToTreasury(IBentoBoxV1 bentoBox, uint256 share) external onlyOperators {</span>
  64 |     | <span class='unexecuted'>        uint256 maxShare = bentoBox.balanceOf(mim, address(this));</span>
  65 |     | <span class='unexecuted'>        if (share &gt; maxShare) {</span>
  66 |     | <span class='unexecuted'>            share = maxShare;</span>
  67 |     | <span class='neutral'>        }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>        bentoBox.withdraw(mim, address(this), treasury, 0, share);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>    function setFeeTo(ICauldronV2 cauldron, address newFeeTo) external onlyOperators {</span>
  73 |     | <span class='unexecuted'>        if (cauldron.masterContract() != cauldron) {</span>
  74 |     | <span class='unexecuted'>            revert ErrNotMasterContract(address(cauldron));</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>        cauldron.setFeeTo(newFeeTo);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>    function setDeprecated(address cauldron, bool _deprecated) external onlyOperators {</span>
  81 |     | <span class='unexecuted'>        emit LogDeprecated(cauldron, deprecated[cauldron], _deprecated);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        deprecated[cauldron] = _deprecated;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>    function setBlacklistedCallee(ICauldronV4 cauldron, address callee, bool blacklisted) external onlyOperators {</span>
  87 |     | <span class='unexecuted'>        cauldron.setBlacklistedCallee(callee, blacklisted);</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>    function setOperator(address operator, bool enabled) external onlyOwner {</span>
  91 |     | <span class='unexecuted'>        emit LogOperatorChanged(operator, operators[operator], enabled);</span>
  92 |     | <span class='unexecuted'>        operators[operator] = enabled;</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>    function setTreasury(address _treasury) external onlyOwner {</span>
  96 |     | <span class='unexecuted'>        emit LogTreasuryChanged(treasury, _treasury);</span>
  97 |     | <span class='unexecuted'>        treasury = _treasury;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>    function transferMasterContractOwnership(BoringOwnable masterContract, address newOwner) external onlyOwner {</span>
 101 |     | <span class='unexecuted'>        masterContract.transferOwnership(newOwner, true, false);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>    function rescueMIM() external {</span>
 105 |     | <span class='unexecuted'>        mim.transfer(treasury, mim.balanceOf(address(this)));</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// low level execution for any other future added functions</span>
 109 |     | <span class='unexecuted'>    function execute(address to, uint256 value, bytes calldata data) external onlyOwner returns (bool success, bytes memory result) {</span>
 110 |     | <span class='neutral'>        // solhint-disable-next-line avoid-low-level-calls</span>
 111 |     | <span class='unexecuted'>        (success, result) = to.call{value: value}(data);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'>}</span>
 114 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/CauldronRegistry.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Owned} from &quot;solmate/auth/Owned.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ICauldronV1} from &quot;interfaces/ICauldronV1.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract CauldronRegistry is Owned {</span>
  8 |     | <span class='neutral'>    error ErrAlreadyRegistered(ICauldronV1 cauldron_);</span>
  9 |     | <span class='neutral'>    error ErrNotRegistered(ICauldronV1 cauldron_);</span>
 10 |     | <span class='neutral'>    error ErrEmptyRegistry();</span>
 11 |     | <span class='neutral'>    error ErrTooManyCauldrons();</span>
 12 |     | <span class='neutral'>    error ErrInvalidCauldron(ICauldronV1 cauldron_);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    ICauldronV1[] public cauldrons;</span>
 15 |     | <span class='neutral'>    mapping(ICauldronV1 =&gt; uint256) internal cauldronIndicies;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    constructor(address owner_) Owned(owner_) {}</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function addCauldrons(ICauldronV1[] calldata cauldrons_) external onlyOwner {</span>
 20 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; cauldrons_.length; ++i) {</span>
 21 |     | <span class='unexecuted'>            ICauldronV1 cauldron = cauldrons_[i];</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>            if (address(cauldron) == address(0)) {</span>
 24 |     | <span class='unexecuted'>                revert ErrInvalidCauldron(cauldron);</span>
 25 |     | <span class='neutral'>            }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>            if (cauldronIndicies[cauldron] != 0 || (cauldrons.length != 0 &amp;&amp; cauldrons[0] == cauldron)) {</span>
 28 |     | <span class='unexecuted'>                revert ErrAlreadyRegistered(cauldron);</span>
 29 |     | <span class='neutral'>            }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>            uint256 cauldronIndex = cauldrons.length;</span>
 32 |     | <span class='unexecuted'>            cauldrons.push(cauldron);</span>
 33 |     | <span class='unexecuted'>            cauldronIndicies[cauldron] = cauldronIndex;</span>
 34 |     | <span class='neutral'>        }</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function removeCauldrons(ICauldronV1[] calldata cauldrons_) external onlyOwner {</span>
 38 |     | <span class='unexecuted'>        if (cauldrons.length == 0) {</span>
 39 |     | <span class='unexecuted'>            revert ErrEmptyRegistry();</span>
 40 |     | <span class='neutral'>        }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='unexecuted'>        if (cauldrons.length &lt; cauldrons_.length) {</span>
 43 |     | <span class='unexecuted'>            revert ErrTooManyCauldrons();</span>
 44 |     | <span class='neutral'>        }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; cauldrons_.length; ++i) {</span>
 47 |     | <span class='unexecuted'>            ICauldronV1 cauldron = cauldrons_[i];</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='unexecuted'>            if (address(cauldron) == address(0)) {</span>
 50 |     | <span class='unexecuted'>                revert ErrInvalidCauldron(cauldron);</span>
 51 |     | <span class='neutral'>            }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='unexecuted'>            uint256 cauldronIndex = cauldronIndicies[cauldron];</span>
 54 |     | <span class='unexecuted'>            if (cauldronIndex == 0 &amp;&amp; cauldrons[0] != cauldron) {</span>
 55 |     | <span class='unexecuted'>                revert ErrNotRegistered(cauldron);</span>
 56 |     | <span class='neutral'>            }</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='unexecuted'>            uint256 lastIndex = cauldrons.length - 1;</span>
 59 |     | <span class='unexecuted'>            if (cauldronIndex == lastIndex) {</span>
 60 |     | <span class='unexecuted'>                cauldrons.pop();</span>
 61 |     | <span class='unexecuted'>                delete cauldronIndicies[cauldron];</span>
 62 |     | <span class='neutral'>            } else {</span>
 63 |     | <span class='unexecuted'>                cauldronIndicies[cauldrons[lastIndex]] = cauldronIndex;</span>
 64 |     | <span class='unexecuted'>                cauldrons[cauldronIndex] = cauldrons[lastIndex];</span>
 65 |     | <span class='unexecuted'>                cauldrons.pop();</span>
 66 |     | <span class='unexecuted'>                delete cauldronIndicies[cauldron];</span>
 67 |     | <span class='neutral'>            }</span>
 68 |     | <span class='neutral'>        }</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='unexecuted'>    function cauldronsLength() public view returns (uint256) {</span>
 72 |     | <span class='unexecuted'>        return cauldrons.length;</span>
 73 |     | <span class='neutral'>    }</span>
 74 |     | <span class='neutral'>}</span>
 75 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/DegenBoxConvexWrapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {SafeApproveLib} from &quot;libraries/SafeApproveLib.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IConvexWrapper} from &quot;interfaces/IConvexWrapper.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/// @notice Wrap token to ConvexWrapper and deposit into DegenBox for recipient</span>
 10 |     | <span class='neutral'>/// Need to be used atomically, do not transfer fund in it and then wrap / unwrap on another block as</span>
 11 |     | <span class='neutral'>/// it could be retrieved by anyone else, by calling deposit or withdraw.</span>
 12 |     | <span class='unexecuted'>contract DegenBoxConvexWrapper {</span>
 13 |     | <span class='neutral'>    using SafeApproveLib for IERC20;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    IBentoBoxV1 immutable degenBox;</span>
 16 |     | <span class='neutral'>    IConvexWrapper immutable wrapper;</span>
 17 |     | <span class='neutral'>    IERC20 immutable underlying;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    constructor(IBentoBoxV1 _degenBox, IConvexWrapper _wrapper) {</span>
 20 |     | <span class='unexecuted'>        degenBox = _degenBox;</span>
 21 |     | <span class='unexecuted'>        wrapper = _wrapper;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>        IERC20 _underlying = IERC20(wrapper.curveToken());</span>
 24 |     | <span class='unexecuted'>        _underlying.approve(address(wrapper), type(uint256).max);</span>
 25 |     | <span class='unexecuted'>        _underlying.approve(address(degenBox), type(uint256).max);</span>
 26 |     | <span class='unexecuted'>        underlying = _underlying;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>    function wrap(address recipient, uint256 amount) external returns (uint256 amountOut, uint256 shareOut) {</span>
 30 |     | <span class='unexecuted'>        wrapper.deposit(amount, address(degenBox));</span>
 31 |     | <span class='unexecuted'>        return degenBox.deposit(IERC20(address(wrapper)), address(degenBox), recipient, amount, 0);</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>    function unwrap(address recipient, uint256 amount) external returns (uint256 amountOut, uint256 shareOut) {</span>
 35 |     | <span class='unexecuted'>        wrapper.withdrawAndUnwrap(amount);</span>
 36 |     | <span class='unexecuted'>        return degenBox.deposit(underlying, address(this), recipient, amount, 0);</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'>}</span>
 39 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/DegenBoxERC4626Wrapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {SafeApproveLib} from &quot;libraries/SafeApproveLib.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IERC4626} from &quot;interfaces/IERC4626.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/// @notice Wrap token to ERC4626 Tokenized Vault and deposit into DegenBox for recipient</span>
 10 |     | <span class='neutral'>/// Need to be used atomically, do not transfer fund in it and then wrap / unwrap on another block as</span>
 11 |     | <span class='neutral'>/// it could be retrieved by anyone else, by calling deposit or withdraw.</span>
 12 |     | <span class='unexecuted'>contract DegenBoxERC4626Wrapper {</span>
 13 |     | <span class='neutral'>    using SafeApproveLib for IERC20;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    IBentoBoxV1 immutable degenBox;</span>
 16 |     | <span class='neutral'>    IERC4626 immutable wrapper;</span>
 17 |     | <span class='neutral'>    IERC20 immutable underlying;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    constructor(IBentoBoxV1 _degenBox, IERC4626 _wrapper) {</span>
 20 |     | <span class='unexecuted'>        degenBox = _degenBox;</span>
 21 |     | <span class='unexecuted'>        wrapper = _wrapper;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>        IERC20 _underlying = wrapper.asset();</span>
 24 |     | <span class='unexecuted'>        _underlying.approve(address(wrapper), type(uint256).max);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>        underlying = _underlying;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>    function wrap(address recipient, uint256 amount) external returns (uint256 amountOut, uint256 shareOut) {</span>
 30 |     | <span class='unexecuted'>        uint256 shares = wrapper.deposit(amount, address(degenBox));</span>
 31 |     | <span class='unexecuted'>        return degenBox.deposit(IERC20(address(wrapper)), address(degenBox), recipient, shares, 0);</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>    function unwrap(address recipient, uint256 shares) external returns (uint256 amountOut, uint256 shareOut) {</span>
 35 |     | <span class='unexecuted'>        uint256 amount = wrapper.redeem(shares, address(degenBox), address(this));</span>
 36 |     | <span class='unexecuted'>        return degenBox.deposit(underlying, address(degenBox), recipient, amount, 0);</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'>}</span>
 39 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/ElevatedMinterBurner.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Operatable} from &quot;mixins/Operatable.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IMintableBurnable} from &quot;interfaces/IMintableBurnable.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/// @title ElevatedMinterBurner</span>
  8 |     | <span class='neutral'>/// @notice ElevatedMinterBurner is a periphery contract for minting and burning tokens and executing arbitrary calls.</span>
  9 |     | <span class='unexecuted'>contract ElevatedMinterBurner is IMintableBurnable, Operatable {</span>
 10 |     | <span class='unexecuted'>    IMintableBurnable public immutable token;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    constructor(IMintableBurnable token_) {</span>
 13 |     | <span class='unexecuted'>        token = token_;</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    function burn(address from, uint256 amount) external override onlyOperators returns (bool) {</span>
 17 |     | <span class='unexecuted'>        return token.burn(from, amount);</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function mint(address to, uint256 amount) external override onlyOperators returns (bool) {</span>
 21 |     | <span class='unexecuted'>        return token.mint(to, amount);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    function exec(address target, bytes calldata data) external onlyOwner {</span>
 25 |     | <span class='unexecuted'>        (bool success, bytes memory result) = target.call(data);</span>
 26 |     | <span class='unexecuted'>        if (!success) {</span>
 27 |     | <span class='unexecuted'>            if (result.length == 0) revert();</span>
 28 |     | <span class='neutral'>            assembly {</span>
 29 |     | <span class='unexecuted'>                revert(add(32, result), mload(result))</span>
 30 |     | <span class='neutral'>            }</span>
 31 |     | <span class='neutral'>        }</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'>}</span>
 34 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/EpochBasedRewardDistributor.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {OperatableV2} from &quot;mixins/OperatableV2.sol&quot;;</span>
   5 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solady/utils/SafeTransferLib.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>interface IEpochBasedStaking {</span>
   8 |     | <span class='neutral'>    function epoch() external view returns (uint256);</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>    function nextEpoch() external view returns (uint256);</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    function rewardData(</span>
  13 |     | <span class='neutral'>        address token</span>
  14 |     | <span class='neutral'>    ) external view returns (uint256 periodFinish, uint256 rewardRate, uint256 rewardPerTokenStored, bool exists, uint248 lastUpdateTime);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    function notifyRewardAmount(address rewardToken, uint256 amount, uint minRemainingTime) external;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    function rewardTokensLength() external view returns (uint);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    function rewardTokens(uint index) external view returns (address);</span>
  21 |     | <span class='neutral'>}</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>/// @notice Distribute rewards to staking contracts based on epochs</span>
  24 |     | <span class='neutral'>/// Amounts deposited to this contract are distributed to staking contracts</span>
  25 |     | <span class='neutral'>/// only on the next epoch</span>
  26 |     | <span class='unexecuted'>contract EpochBasedRewardDistributor is OperatableV2 {</span>
  27 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    event LogRewardAdded(address indexed reward, uint256 amount);</span>
  30 |     | <span class='neutral'>    event LogWithdraw(address indexed token, address indexed to, uint256 amount);</span>
  31 |     | <span class='neutral'>    event LogDistributed(uint256 epoch);</span>
  32 |     | <span class='neutral'>    event LogMinRemainingTimeSet(uint256 previous, uint256 current);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    error ErrInvalidRewardToken();</span>
  35 |     | <span class='neutral'>    error ErrNotReady();</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>    address public immutable staking;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    uint256 public epoch;</span>
  40 |     | <span class='unexecuted'>    uint256 public minRemainingTime;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public balanceOf;</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='unexecuted'>    constructor(address _staking, uint256 _minRemainingTime, address _owner) OperatableV2(_owner) {</span>
  45 |     | <span class='unexecuted'>        staking = _staking;</span>
  46 |     | <span class='unexecuted'>        minRemainingTime = _minRemainingTime;</span>
  47 |     | <span class='unexecuted'>        epoch = IEpochBasedStaking(_staking).nextEpoch();</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    ////////////////////////////////////////////////////////////////////////////////////////////////</span>
  51 |     | <span class='neutral'>    /// VIEWS</span>
  52 |     | <span class='neutral'>    ////////////////////////////////////////////////////////////////////////////////////////////////</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>    function ready() public view returns (bool) {</span>
  55 |     | <span class='unexecuted'>        return epoch &lt;= IEpochBasedStaking(staking).epoch();</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    ////////////////////////////////////////////////////////////////////////////////////////////////</span>
  59 |     | <span class='neutral'>    /// OPERATORS</span>
  60 |     | <span class='neutral'>    ////////////////////////////////////////////////////////////////////////////////////////////////</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>    function deposit(address _token, uint256 _amount) external onlyOperators {</span>
  63 |     | <span class='unexecuted'>        (, , , bool exists, ) = IEpochBasedStaking(staking).rewardData(_token);</span>
  64 |     | <span class='unexecuted'>        if (!exists) {</span>
  65 |     | <span class='unexecuted'>            revert ErrInvalidRewardToken();</span>
  66 |     | <span class='neutral'>        }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>        _token.safeTransferFrom(msg.sender, address(this), _amount);</span>
  69 |     | <span class='unexecuted'>        balanceOf[_token] += _amount;</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>        _token.safeApprove(staking, balanceOf[_token]);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        emit LogRewardAdded(_token, _amount);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>    function distribute() external onlyOperators {</span>
  77 |     | <span class='unexecuted'>        if (!ready()) {</span>
  78 |     | <span class='unexecuted'>            revert ErrNotReady();</span>
  79 |     | <span class='neutral'>        }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>        uint256 rewardLength = IEpochBasedStaking(staking).rewardTokensLength();</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; rewardLength; i++) {</span>
  84 |     | <span class='unexecuted'>            address reward = IEpochBasedStaking(staking).rewardTokens(i);</span>
  85 |     | <span class='unexecuted'>            uint256 rewardAmount = balanceOf[reward];</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>            delete balanceOf[reward];</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>            if (rewardAmount &gt; 0) {</span>
  90 |     | <span class='unexecuted'>                IEpochBasedStaking(staking).notifyRewardAmount(reward, rewardAmount, minRemainingTime);</span>
  91 |     | <span class='neutral'>            }</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        epoch = IEpochBasedStaking(staking).nextEpoch();</span>
  95 |     | <span class='unexecuted'>        emit LogDistributed(epoch);</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    ////////////////////////////////////////////////////////////////////////////////////////////////</span>
  99 |     | <span class='neutral'>    /// ADMIN</span>
 100 |     | <span class='neutral'>    ////////////////////////////////////////////////////////////////////////////////////////////////</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>    function withdraw(address _token, address _to, uint256 _amount) external onlyOwner {</span>
 103 |     | <span class='unexecuted'>        _token.safeTransfer(_to, _amount);</span>
 104 |     | <span class='unexecuted'>        balanceOf[_token] = _token.balanceOf(address(this));</span>
 105 |     | <span class='unexecuted'>        emit LogWithdraw(_token, _to, _amount);</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>    function setMinRemainingTime(uint256 _minRemainingTime) external onlyOwner {</span>
 109 |     | <span class='unexecuted'>        emit LogMinRemainingTimeSet(minRemainingTime, _minRemainingTime);</span>
 110 |     | <span class='unexecuted'>        minRemainingTime = _minRemainingTime;</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'>}</span>
 113 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/GmxV2CauldronOrderAgent.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
   5 |     | <span class='neutral'>import {ICauldronV4GmxV2} from &quot;interfaces/ICauldronV4GmxV2.sol&quot;;</span>
   6 |     | <span class='neutral'>import {ICauldronV4} from &quot;interfaces/ICauldronV4.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   8 |     | <span class='neutral'>import {OperatableV2} from &quot;mixins/OperatableV2.sol&quot;;</span>
   9 |     | <span class='neutral'>import {LibClone} from &quot;solady/utils/LibClone.sol&quot;;</span>
  10 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solady/utils/SafeTransferLib.sol&quot;;</span>
  11 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  12 |     | <span class='neutral'>import {IGmxV2Deposit, IGmxV2WithdrawalCallbackReceiver, IGmxV2Withdrawal, IGmxV2EventUtils, IGmxV2Market, IGmxDataStore, IGmxV2DepositCallbackReceiver, IGmxReader, IGmxV2DepositHandler, IGmxV2WithdrawalHandler, IGmxV2ExchangeRouter} from &quot;interfaces/IGmxV2.sol&quot;;</span>
  13 |     | <span class='neutral'>import {IWETH} from &quot;interfaces/IWETH.sol&quot;;</span>
  14 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>struct GmRouterOrderParams {</span>
  17 |     | <span class='neutral'>    address inputToken;</span>
  18 |     | <span class='neutral'>    bool deposit;</span>
  19 |     | <span class='neutral'>    uint128 inputAmount;</span>
  20 |     | <span class='neutral'>    uint128 executionFee;</span>
  21 |     | <span class='neutral'>    uint128 minOutput;</span>
  22 |     | <span class='neutral'>    uint128 minOutLong; // 0 for deposit</span>
  23 |     | <span class='neutral'>}</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>interface IGmCauldronOrderAgent {</span>
  26 |     | <span class='neutral'>    function createOrder(address user, GmRouterOrderParams memory params) external payable returns (address order);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function setOracle(address market, IOracle oracle) external;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    function oracles(address market) external view returns (IOracle);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    function callbackGasLimit() external view returns (uint256);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    function setCallbackGasLimit(uint256 _callbackGasLimit) external;</span>
  35 |     | <span class='neutral'>}</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>interface IGmRouterOrder {</span>
  38 |     | <span class='neutral'>    function init(address _cauldron, address user, GmRouterOrderParams memory _params) external payable;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /// @notice cancelling an order</span>
  41 |     | <span class='neutral'>    function cancelOrder() external;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    function getExchangeRates() external view returns (uint256 shortExchangeRate, uint256 marketExchangeRate);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /// @notice withdraw from an order that does not end in addition of collateral.</span>
  46 |     | <span class='neutral'>    function withdrawFromOrder(address token, address to, uint256 amount, bool closeOrder) external;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /// @notice the value of the order in collateral terms</span>
  49 |     | <span class='neutral'>    function orderValueInCollateral() external view returns (uint256);</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /// @notice sends a specific value to recipient</span>
  52 |     | <span class='neutral'>    function sendValueInCollateral(address recipient, uint256 share) external;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    function isActive() external view returns (bool);</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function orderKey() external view returns (bytes32);</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    function orderAgent() external view returns (IGmCauldronOrderAgent);</span>
  59 |     | <span class='neutral'>}</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>contract GmxV2CauldronRouterOrder is IGmRouterOrder, IGmxV2DepositCallbackReceiver, IGmxV2WithdrawalCallbackReceiver {</span>
  62 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
  63 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    error ErrFinalized();</span>
  66 |     | <span class='neutral'>    error ErrNotOwner();</span>
  67 |     | <span class='neutral'>    error ErrAlreadyInitialized();</span>
  68 |     | <span class='neutral'>    error ErrMinOutTooLarge();</span>
  69 |     | <span class='neutral'>    error ErrUnauthorized();</span>
  70 |     | <span class='neutral'>    error ErrWrongUser();</span>
  71 |     | <span class='neutral'>    error ErrIncorrectInitialization();</span>
  72 |     | <span class='neutral'>    error ErrExecuteDepositsDisabled();</span>
  73 |     | <span class='neutral'>    error ErrExecuteWithdrawalsDisabled();</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    event LogRefundWETH(address indexed user, uint256 amount);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>    bytes32 public constant DEPOSIT_LIST = keccak256(abi.encode(&quot;DEPOSIT_LIST&quot;));</span>
  78 |     | <span class='unexecuted'>    bytes32 public constant WITHDRAWAL_LIST = keccak256(abi.encode(&quot;WITHDRAWAL_LIST&quot;));</span>
  79 |     | <span class='unexecuted'>    bytes32 public constant ORDER_KEEPER = keccak256(abi.encode(&quot;ORDER_KEEPER&quot;));</span>
  80 |     | <span class='unexecuted'>    bytes32 public constant EXECUTE_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(&quot;EXECUTE_DEPOSIT_FEATURE_DISABLED&quot;));</span>
  81 |     | <span class='unexecuted'>    bytes32 public constant EXECUTE_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(&quot;EXECUTE_WITHDRAWAL_FEATURE_DISABLED&quot;));</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>    IGmxV2ExchangeRouter public immutable GMX_ROUTER;</span>
  84 |     | <span class='unexecuted'>    IGmxReader public immutable GMX_READER;</span>
  85 |     | <span class='unexecuted'>    IGmxDataStore public immutable DATASTORE;</span>
  86 |     | <span class='unexecuted'>    address public immutable DEPOSIT_VAULT;</span>
  87 |     | <span class='unexecuted'>    address public immutable WITHDRAWAL_VAULT;</span>
  88 |     | <span class='unexecuted'>    address public immutable SYNTHETICS_ROUTER;</span>
  89 |     | <span class='unexecuted'>    IWETH public immutable WETH;</span>
  90 |     | <span class='unexecuted'>    address public immutable REFUND_TO;</span>
  91 |     | <span class='unexecuted'>    IBentoBoxV1 public immutable degenBox;</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>    address public cauldron;</span>
  94 |     | <span class='unexecuted'>    address public user;</span>
  95 |     | <span class='unexecuted'>    bytes32 public orderKey;</span>
  96 |     | <span class='unexecuted'>    address public market;</span>
  97 |     | <span class='unexecuted'>    address public shortToken;</span>
  98 |     | <span class='unexecuted'>    IOracle public oracle;</span>
  99 |     | <span class='unexecuted'>    uint128 public inputAmount;</span>
 100 |     | <span class='unexecuted'>    uint128 public minOut;</span>
 101 |     | <span class='unexecuted'>    uint128 public minOutLong;</span>
 102 |     | <span class='unexecuted'>    uint128 public oracleDecimalScale;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>    bool public depositType;</span>
 105 |     | <span class='unexecuted'>    bool public isHomogenousMarket;</span>
 106 |     | <span class='unexecuted'>    IGmCauldronOrderAgent public orderAgent;</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    modifier onlyCauldron() virtual {</span>
 109 |     | <span class='unexecuted'>        if (msg.sender != cauldron) {</span>
 110 |     | <span class='unexecuted'>            revert ErrNotOwner();</span>
 111 |     | <span class='neutral'>        }</span>
 112 |     | <span class='neutral'>        _;</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    modifier onlyDepositHandler() {</span>
 116 |     | <span class='unexecuted'>        if (msg.sender != address(GMX_ROUTER.depositHandler())) {</span>
 117 |     | <span class='unexecuted'>            revert ErrUnauthorized();</span>
 118 |     | <span class='neutral'>        }</span>
 119 |     | <span class='neutral'>        _;</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    modifier onlyWithdrawalHandler() {</span>
 123 |     | <span class='unexecuted'>        if (msg.sender != address(GMX_ROUTER.withdrawalHandler())) {</span>
 124 |     | <span class='neutral'>            revert ErrUnauthorized();</span>
 125 |     | <span class='neutral'>        }</span>
 126 |     | <span class='neutral'>        _;</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>    receive() external payable virtual {</span>
 130 |     | <span class='unexecuted'>        (bool success, ) = REFUND_TO.call{value: msg.value}(&quot;&quot;);</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>        // ignore failures</span>
 133 |     | <span class='unexecuted'>        if (!success) {</span>
 134 |     | <span class='unexecuted'>            return;</span>
 135 |     | <span class='neutral'>        }</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>    constructor(</span>
 139 |     | <span class='neutral'>        IBentoBoxV1 _degenBox,</span>
 140 |     | <span class='neutral'>        IGmxV2ExchangeRouter _gmxRouter,</span>
 141 |     | <span class='neutral'>        address _syntheticsRouter,</span>
 142 |     | <span class='neutral'>        IGmxReader _gmxReader,</span>
 143 |     | <span class='neutral'>        IWETH _weth,</span>
 144 |     | <span class='neutral'>        address _refundTo</span>
 145 |     | <span class='neutral'>    ) {</span>
 146 |     | <span class='unexecuted'>        degenBox = _degenBox;</span>
 147 |     | <span class='unexecuted'>        GMX_ROUTER = _gmxRouter;</span>
 148 |     | <span class='unexecuted'>        GMX_READER = _gmxReader;</span>
 149 |     | <span class='unexecuted'>        SYNTHETICS_ROUTER = _syntheticsRouter;</span>
 150 |     | <span class='unexecuted'>        DATASTORE = IGmxDataStore(_gmxRouter.dataStore());</span>
 151 |     | <span class='unexecuted'>        DEPOSIT_VAULT = IGmxV2DepositHandler(_gmxRouter.depositHandler()).depositVault();</span>
 152 |     | <span class='unexecuted'>        WITHDRAWAL_VAULT = IGmxV2WithdrawalHandler(_gmxRouter.withdrawalHandler()).withdrawalVault();</span>
 153 |     | <span class='unexecuted'>        WETH = _weth;</span>
 154 |     | <span class='unexecuted'>        REFUND_TO = _refundTo;</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='unexecuted'>    function init(address _cauldron, address _user, GmRouterOrderParams memory params) external payable {</span>
 158 |     | <span class='unexecuted'>        if (cauldron != address(0)) {</span>
 159 |     | <span class='unexecuted'>            revert ErrAlreadyInitialized();</span>
 160 |     | <span class='neutral'>        }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='unexecuted'>        if (_cauldron == address(0)) {</span>
 163 |     | <span class='unexecuted'>            revert ErrIncorrectInitialization();</span>
 164 |     | <span class='neutral'>        }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>        orderAgent = GmxV2CauldronOrderAgent(msg.sender);</span>
 167 |     | <span class='unexecuted'>        cauldron = _cauldron;</span>
 168 |     | <span class='unexecuted'>        user = _user;</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>        market = address(ICauldronV4(_cauldron).collateral());</span>
 171 |     | <span class='unexecuted'>        IGmxV2Market.Props memory props = GMX_READER.getMarket(address(DATASTORE), market);</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='unexecuted'>        inputAmount = params.inputAmount;</span>
 174 |     | <span class='unexecuted'>        minOut = params.minOutput;</span>
 175 |     | <span class='unexecuted'>        minOutLong = params.minOutLong;</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='unexecuted'>        if (uint256(params.minOutput) + uint256(params.minOutLong) &gt; type(uint128).max) {</span>
 178 |     | <span class='unexecuted'>            revert ErrMinOutTooLarge();</span>
 179 |     | <span class='neutral'>        }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>        isHomogenousMarket = props.longToken == props.shortToken;</span>
 182 |     | <span class='unexecuted'>        shortToken = props.shortToken;</span>
 183 |     | <span class='unexecuted'>        depositType = params.deposit;</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='unexecuted'>        oracleDecimalScale = uint128(10 ** (orderAgent.oracles(shortToken).decimals() + IERC20(shortToken).safeDecimals()));</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='unexecuted'>        if (depositType) {</span>
 188 |     | <span class='unexecuted'>            if (isDepositExecutionDisabled()) {</span>
 189 |     | <span class='unexecuted'>                revert ErrExecuteDepositsDisabled();</span>
 190 |     | <span class='neutral'>            }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='unexecuted'>            shortToken.safeApprove(address(SYNTHETICS_ROUTER), params.inputAmount);</span>
 193 |     | <span class='unexecuted'>            orderKey = _createDepositOrder(</span>
 194 |     | <span class='unexecuted'>                market,</span>
 195 |     | <span class='unexecuted'>                props.shortToken,</span>
 196 |     | <span class='unexecuted'>                props.longToken,</span>
 197 |     | <span class='unexecuted'>                params.inputAmount,</span>
 198 |     | <span class='unexecuted'>                params.minOutput,</span>
 199 |     | <span class='unexecuted'>                params.executionFee</span>
 200 |     | <span class='neutral'>            );</span>
 201 |     | <span class='neutral'>        } else {</span>
 202 |     | <span class='unexecuted'>            if (isWithdrawalExecutionDisabled()) {</span>
 203 |     | <span class='unexecuted'>                revert ErrExecuteWithdrawalsDisabled();</span>
 204 |     | <span class='neutral'>            }</span>
 205 |     | <span class='neutral'>            </span>
 206 |     | <span class='unexecuted'>            market.safeApprove(address(SYNTHETICS_ROUTER), params.inputAmount);</span>
 207 |     | <span class='unexecuted'>            orderKey = _createWithdrawalOrder(params.inputAmount, params.minOutput, params.minOutLong, params.executionFee);</span>
 208 |     | <span class='neutral'>        }</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='unexecuted'>    function isDepositExecutionDisabled() public view returns (bool) {</span>
 212 |     | <span class='unexecuted'>        bytes32 depositExecutionDisabledKey = keccak256(abi.encode(EXECUTE_DEPOSIT_FEATURE_DISABLED, GMX_ROUTER.depositHandler()));</span>
 213 |     | <span class='neutral'>        return DATASTORE.getBool(depositExecutionDisabledKey);</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='unexecuted'>    function isWithdrawalExecutionDisabled() public view returns (bool) {</span>
 217 |     | <span class='unexecuted'>        bytes32 withdrawalExecutionDisabledKey = keccak256(abi.encode(EXECUTE_WITHDRAWAL_FEATURE_DISABLED, GMX_ROUTER.withdrawalHandler()));</span>
 218 |     | <span class='unexecuted'>        return DATASTORE.getBool(withdrawalExecutionDisabledKey);</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='unexecuted'>    function cancelOrder() external onlyCauldron {</span>
 222 |     | <span class='unexecuted'>        if (depositType) {</span>
 223 |     | <span class='unexecuted'>            GMX_ROUTER.cancelDeposit(orderKey);</span>
 224 |     | <span class='neutral'>        } else {</span>
 225 |     | <span class='unexecuted'>            GMX_ROUTER.cancelWithdrawal(orderKey);</span>
 226 |     | <span class='neutral'>        }</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='unexecuted'>    function withdrawFromOrder(address token, address to, uint256 amount, bool) external onlyCauldron {</span>
 230 |     | <span class='unexecuted'>        token.safeTransfer(address(degenBox), amount);</span>
 231 |     | <span class='unexecuted'>        degenBox.deposit(IERC20(token), address(degenBox), to, amount, 0);</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='unexecuted'>        uint256 balance = shortToken.balanceOf(address(this));</span>
 234 |     | <span class='unexecuted'>        if (balance &gt; 0) {</span>
 235 |     | <span class='unexecuted'>            shortToken.safeTransfer(address(degenBox), balance);</span>
 236 |     | <span class='unexecuted'>            degenBox.deposit(IERC20(shortToken), address(degenBox), user, balance, 0);</span>
 237 |     | <span class='neutral'>        }</span>
 238 |     | <span class='unexecuted'>        ICauldronV4GmxV2(cauldron).closeOrder(user);</span>
 239 |     | <span class='neutral'>    }</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='unexecuted'>    function sendValueInCollateral(address recipient, uint256 shareMarketToken) public onlyCauldron {</span>
 242 |     | <span class='unexecuted'>        (uint256 shortExchangeRate, uint256 marketExchangeRate) = getExchangeRates();</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>        /// @dev For oracleDecimalScale = 1e14:</span>
 245 |     | <span class='neutral'>        /// (18 decimals + 14 decimals) - (8 decimals + 18 decimals) = 6 decimals</span>
 246 |     | <span class='neutral'>        ///</span>
 247 |     | <span class='neutral'>        /// Ex:</span>
 248 |     | <span class='neutral'>        /// - 100,000 GM token where 1 GM = 0.5 USD each</span>
 249 |     | <span class='neutral'>        /// - 1 USDC = 0.997 USD</span>
 250 |     | <span class='neutral'>        /// - 99700000 is the chainlink oracle USDC price in USD with 8 decimals</span>
 251 |     | <span class='neutral'>        /// - 2e18 is how many GM tokens 1 USD can buy</span>
 252 |     | <span class='neutral'>        /// - 1e14 is 8 decimals for the chainlink oracle + 6 decimals for USDC</span>
 253 |     | <span class='neutral'>        /// (100_000e18 * 1e14) / (99700000 *  2e18) = 50150.45e6 USDC</span>
 254 |     | <span class='unexecuted'>        uint256 amountShortToken = (degenBox.toAmount(IERC20(market), shareMarketToken, true) * oracleDecimalScale) /</span>
 255 |     | <span class='unexecuted'>            (shortExchangeRate * marketExchangeRate);</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='unexecuted'>        shortToken.safeTransfer(address(degenBox), amountShortToken);</span>
 258 |     | <span class='unexecuted'>        degenBox.deposit(IERC20(shortToken), address(degenBox), recipient, amountShortToken, 0);</span>
 259 |     | <span class='neutral'>    }</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>    /// @notice the value of the order in collateral terms</span>
 262 |     | <span class='unexecuted'>    function orderValueInCollateral() public view returns (uint256 result) {</span>
 263 |     | <span class='unexecuted'>        (uint256 shortExchangeRate, uint256 marketExchangeRate) = getExchangeRates();</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>        /// @dev short exchangeRate is in USD in native decimals</span>
 266 |     | <span class='neutral'>        /// marketExchangeRate is in inverse similar to other cauldron oracles 1e36 / (price in 18 decimals)</span>
 267 |     | <span class='neutral'>        /// Ex:</span>
 268 |     | <span class='neutral'>        /// - input is 100,000 USDC</span>
 269 |     | <span class='neutral'>        /// - 1 USDC = 0.997 USD</span>
 270 |     | <span class='neutral'>        /// - 99700000 is the chainlink oracle USDC price in USD with 8 decimals</span>
 271 |     | <span class='neutral'>        /// - 2e18 is how many GM tokens 1 USD can buy</span>
 272 |     | <span class='neutral'>        ///  (100_000e6 * 99700000 * 2e18) / 1e14 = 199400e18 GM tokens</span>
 273 |     | <span class='unexecuted'>        if (depositType) {</span>
 274 |     | <span class='unexecuted'>            uint256 marketTokenFromValue = (inputAmount * shortExchangeRate * marketExchangeRate) / oracleDecimalScale;</span>
 275 |     | <span class='unexecuted'>            result = minOut &lt; marketTokenFromValue ? minOut : marketTokenFromValue;</span>
 276 |     | <span class='unexecuted'>        } else {</span>
 277 |     | <span class='unexecuted'>            uint256 marketTokenFromValue = ((minOut + minOutLong) * shortExchangeRate * marketExchangeRate) / oracleDecimalScale;</span>
 278 |     | <span class='unexecuted'>            result = inputAmount &lt; marketTokenFromValue ? inputAmount : marketTokenFromValue;</span>
 279 |     | <span class='neutral'>        }</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='unexecuted'>    function getExchangeRates() public view returns (uint256 shortExchangeRate, uint256 marketExchangeRate) {</span>
 283 |     | <span class='unexecuted'>        (, shortExchangeRate) = orderAgent.oracles(shortToken).peek(bytes(&quot;&quot;));</span>
 284 |     | <span class='unexecuted'>        (, marketExchangeRate) = orderAgent.oracles(market).peek(bytes(&quot;&quot;));</span>
 285 |     | <span class='neutral'>    }</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='unexecuted'>    function isActive() public view returns (bool) {</span>
 288 |     | <span class='unexecuted'>        return DATASTORE.containsBytes32(DEPOSIT_LIST, orderKey) || DATASTORE.containsBytes32(WITHDRAWAL_LIST, orderKey);</span>
 289 |     | <span class='neutral'>    }</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='unexecuted'>    function _createDepositOrder(</span>
 292 |     | <span class='neutral'>        address _gmToken,</span>
 293 |     | <span class='neutral'>        address _inputToken,</span>
 294 |     | <span class='neutral'>        address _underlyingToken,</span>
 295 |     | <span class='neutral'>        uint128 _usdcAmount,</span>
 296 |     | <span class='neutral'>        uint128 _minGmTokenOutput,</span>
 297 |     | <span class='neutral'>        uint128 _executionFee</span>
 298 |     | <span class='neutral'>    ) private returns (bytes32) {</span>
 299 |     | <span class='unexecuted'>        GMX_ROUTER.sendWnt{value: _executionFee}(address(DEPOSIT_VAULT), _executionFee);</span>
 300 |     | <span class='unexecuted'>        GMX_ROUTER.sendTokens(_inputToken, address(DEPOSIT_VAULT), _usdcAmount);</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='unexecuted'>        address[] memory emptyPath = new address[](0);</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='unexecuted'>        IGmxV2Deposit.CreateDepositParams memory params = IGmxV2Deposit.CreateDepositParams({</span>
 305 |     | <span class='unexecuted'>            receiver: address(this),</span>
 306 |     | <span class='unexecuted'>            callbackContract: address(this),</span>
 307 |     | <span class='unexecuted'>            uiFeeReceiver: address(0),</span>
 308 |     | <span class='unexecuted'>            market: _gmToken,</span>
 309 |     | <span class='unexecuted'>            initialLongToken: _underlyingToken,</span>
 310 |     | <span class='unexecuted'>            initialShortToken: _inputToken,</span>
 311 |     | <span class='unexecuted'>            longTokenSwapPath: emptyPath,</span>
 312 |     | <span class='unexecuted'>            shortTokenSwapPath: emptyPath,</span>
 313 |     | <span class='unexecuted'>            minMarketTokens: _minGmTokenOutput,</span>
 314 |     | <span class='unexecuted'>            shouldUnwrapNativeToken: false,</span>
 315 |     | <span class='unexecuted'>            executionFee: _executionFee,</span>
 316 |     | <span class='unexecuted'>            callbackGasLimit: orderAgent.callbackGasLimit()</span>
 317 |     | <span class='neutral'>        });</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='unexecuted'>        return GMX_ROUTER.createDeposit(params);</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='unexecuted'>    function _createWithdrawalOrder(</span>
 323 |     | <span class='neutral'>        uint128 _inputAmount,</span>
 324 |     | <span class='neutral'>        uint128 _minUsdcOutput,</span>
 325 |     | <span class='neutral'>        uint128 _minOutLong,</span>
 326 |     | <span class='neutral'>        uint128 _executionFee</span>
 327 |     | <span class='neutral'>    ) private returns (bytes32) {</span>
 328 |     | <span class='unexecuted'>        GMX_ROUTER.sendWnt{value: _executionFee}(address(WITHDRAWAL_VAULT), _executionFee);</span>
 329 |     | <span class='unexecuted'>        GMX_ROUTER.sendTokens(market, address(WITHDRAWAL_VAULT), _inputAmount);</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='unexecuted'>        address[] memory path = new address[](1);</span>
 332 |     | <span class='unexecuted'>        path[0] = market;</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='unexecuted'>        address[] memory emptyPath = new address[](0);</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='unexecuted'>        IGmxV2Withdrawal.CreateWithdrawalParams memory params = IGmxV2Withdrawal.CreateWithdrawalParams({</span>
 337 |     | <span class='unexecuted'>            receiver: address(this),</span>
 338 |     | <span class='neutral'>            callbackContract: address(this),</span>
 339 |     | <span class='neutral'>            uiFeeReceiver: address(0),</span>
 340 |     | <span class='unexecuted'>            market: market,</span>
 341 |     | <span class='unexecuted'>            longTokenSwapPath: isHomogenousMarket ? emptyPath : path,</span>
 342 |     | <span class='unexecuted'>            shortTokenSwapPath: emptyPath,</span>
 343 |     | <span class='unexecuted'>            minLongTokenAmount: _minOutLong,</span>
 344 |     | <span class='unexecuted'>            minShortTokenAmount: _minUsdcOutput,</span>
 345 |     | <span class='unexecuted'>            shouldUnwrapNativeToken: false,</span>
 346 |     | <span class='unexecuted'>            executionFee: _executionFee,</span>
 347 |     | <span class='unexecuted'>            callbackGasLimit: orderAgent.callbackGasLimit()</span>
 348 |     | <span class='neutral'>        });</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='unexecuted'>        return GMX_ROUTER.createWithdrawal(params);</span>
 351 |     | <span class='neutral'>    }</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='unexecuted'>    function _depositMarketTokensAsCollateral() internal {</span>
 354 |     | <span class='unexecuted'>        uint256 received = IERC20(market).balanceOf(address(this));</span>
 355 |     | <span class='unexecuted'>        market.safeTransfer(address(degenBox), received);</span>
 356 |     | <span class='unexecuted'>        (, uint256 share) = degenBox.deposit(IERC20(market), address(degenBox), cauldron, received, 0);</span>
 357 |     | <span class='unexecuted'>        ICauldronV4(cauldron).addCollateral(user, true, share);</span>
 358 |     | <span class='unexecuted'>        ICauldronV4GmxV2(cauldron).closeOrder(user);</span>
 359 |     | <span class='neutral'>    }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='unexecuted'>    function afterDepositExecution(</span>
 362 |     | <span class='neutral'>        bytes32 /*key*/,</span>
 363 |     | <span class='neutral'>        IGmxV2Deposit.Props memory deposit,</span>
 364 |     | <span class='neutral'>        IGmxV2EventUtils.EventLogData memory /*eventData*/</span>
 365 |     | <span class='neutral'>    ) external override onlyDepositHandler {</span>
 366 |     | <span class='neutral'>        // verify that the deposit was from this address</span>
 367 |     | <span class='unexecuted'>        if (deposit.addresses.account != address(this)) {</span>
 368 |     | <span class='unexecuted'>            revert ErrWrongUser();</span>
 369 |     | <span class='neutral'>        }</span>
 370 |     | <span class='unexecuted'>        _depositMarketTokensAsCollateral();</span>
 371 |     | <span class='neutral'>    }</span>
 372 |     | <span class='neutral'></span>
 373 |     | <span class='unexecuted'>    function afterWithdrawalCancellation(</span>
 374 |     | <span class='neutral'>        bytes32 /*key*/,</span>
 375 |     | <span class='neutral'>        IGmxV2Withdrawal.Props memory withdrawal,</span>
 376 |     | <span class='neutral'>        IGmxV2EventUtils.EventLogData memory /*eventData*/</span>
 377 |     | <span class='neutral'>    ) external override onlyWithdrawalHandler {</span>
 378 |     | <span class='neutral'>        // verify that the withdrawal was from this address</span>
 379 |     | <span class='neutral'>        if (withdrawal.addresses.account != address(this)) {</span>
 380 |     | <span class='neutral'>            revert ErrWrongUser();</span>
 381 |     | <span class='neutral'>        }</span>
 382 |     | <span class='neutral'>        _depositMarketTokensAsCollateral();</span>
 383 |     | <span class='neutral'>    }</span>
 384 |     | <span class='neutral'></span>
 385 |     | <span class='unexecuted'>    function afterDepositCancellation(</span>
 386 |     | <span class='neutral'>        bytes32 key,</span>
 387 |     | <span class='neutral'>        IGmxV2Deposit.Props memory deposit,</span>
 388 |     | <span class='neutral'>        IGmxV2EventUtils.EventLogData memory eventData</span>
 389 |     | <span class='neutral'>    ) external override {}</span>
 390 |     | <span class='neutral'></span>
 391 |     | <span class='unexecuted'>    function afterWithdrawalExecution(</span>
 392 |     | <span class='neutral'>        bytes32 key,</span>
 393 |     | <span class='neutral'>        IGmxV2Withdrawal.Props memory withdrawal,</span>
 394 |     | <span class='neutral'>        IGmxV2EventUtils.EventLogData memory eventData</span>
 395 |     | <span class='neutral'>    ) external override {}</span>
 396 |     | <span class='neutral'>}</span>
 397 |     | <span class='neutral'></span>
 398 |     | <span class='unexecuted'>contract GmxV2CauldronOrderAgent is IGmCauldronOrderAgent, OperatableV2 {</span>
 399 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
 400 |     | <span class='neutral'></span>
 401 |     | <span class='neutral'>    event LogSetOracle(address indexed market, IOracle indexed oracle);</span>
 402 |     | <span class='neutral'>    event LogOrderCreated(address indexed order, address indexed user, GmRouterOrderParams params);</span>
 403 |     | <span class='neutral'>    event LogCallbackGasLimit(uint256 previous, uint256 current);</span>
 404 |     | <span class='neutral'></span>
 405 |     | <span class='neutral'>    error ErrInvalidParams();</span>
 406 |     | <span class='neutral'></span>
 407 |     | <span class='unexecuted'>    address public immutable orderImplementation;</span>
 408 |     | <span class='unexecuted'>    IBentoBoxV1 public immutable degenBox;</span>
 409 |     | <span class='unexecuted'>    mapping(address =&gt; IOracle) public oracles;</span>
 410 |     | <span class='neutral'></span>
 411 |     | <span class='unexecuted'>    uint256 public callbackGasLimit = 1_000_000;</span>
 412 |     | <span class='neutral'></span>
 413 |     | <span class='unexecuted'>    constructor(IBentoBoxV1 _degenBox, address _orderImplementation, address _owner) OperatableV2(_owner) {</span>
 414 |     | <span class='unexecuted'>        degenBox = _degenBox;</span>
 415 |     | <span class='unexecuted'>        orderImplementation = _orderImplementation;</span>
 416 |     | <span class='neutral'>    }</span>
 417 |     | <span class='neutral'></span>
 418 |     | <span class='unexecuted'>    function setCallbackGasLimit(uint256 _callbackGasLimit) external onlyOwner {</span>
 419 |     | <span class='unexecuted'>        emit LogCallbackGasLimit(callbackGasLimit, _callbackGasLimit);</span>
 420 |     | <span class='unexecuted'>        callbackGasLimit = _callbackGasLimit;</span>
 421 |     | <span class='neutral'>    }</span>
 422 |     | <span class='neutral'></span>
 423 |     | <span class='unexecuted'>    function setOracle(address market, IOracle oracle) external onlyOwner {</span>
 424 |     | <span class='unexecuted'>        oracles[market] = oracle;</span>
 425 |     | <span class='unexecuted'>        emit LogSetOracle(market, oracle);</span>
 426 |     | <span class='neutral'>    }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='unexecuted'>    function createOrder(address user, GmRouterOrderParams memory params) external payable override onlyOperators returns (address order) {</span>
 429 |     | <span class='unexecuted'>        order = LibClone.clone(orderImplementation);</span>
 430 |     | <span class='unexecuted'>        degenBox.withdraw(IERC20(params.inputToken), address(this), address(order), params.inputAmount, 0);</span>
 431 |     | <span class='unexecuted'>        IGmRouterOrder(order).init{value: msg.value}(msg.sender, user, params);</span>
 432 |     | <span class='neutral'></span>
 433 |     | <span class='unexecuted'>        emit LogOrderCreated(order, user, params);</span>
 434 |     | <span class='neutral'>    }</span>
 435 |     | <span class='neutral'>}</span>
 436 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/LiquidationHelper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20, ERC20} from &quot;BoringSolidity/ERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import {CauldronLib} from &quot;libraries/CauldronLib.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
   7 |     | <span class='neutral'>import {ICauldronV2} from &quot;interfaces/ICauldronV2.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ICauldronV3} from &quot;interfaces/ICauldronV3.sol&quot;;</span>
   9 |     | <span class='neutral'>import {ICauldronV4} from &quot;interfaces/ICauldronV4.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/// @title LiquidationHelper</span>
  12 |     | <span class='neutral'>/// @notice Helper contract to liquidate accounts using max borrow amount or a part of it.</span>
  13 |     | <span class='neutral'>/// The required MiM is transferred from the liquidator to the BentoBox in case there&#39;s not enough balance</span>
  14 |     | <span class='neutral'>/// inside the user degenbox to cover the liquidation.</span>
  15 |     | <span class='unexecuted'>contract LiquidationHelper {</span>
  16 |     | <span class='neutral'>    error ErrInvalidCauldronVersion(uint8 cauldronVersion);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    ERC20 public mim;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    constructor(ERC20 _mim) payable {</span>
  21 |     | <span class='unexecuted'>        mim = _mim;</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>    function isLiquidatable(ICauldronV2 cauldron, address account) public view returns (bool) {</span>
  25 |     | <span class='unexecuted'>        return !CauldronLib.isSolvent(cauldron, account);</span>
  26 |     | <span class='neutral'>    }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    function previewMaxLiquidation(</span>
  29 |     | <span class='neutral'>        ICauldronV2 cauldron,</span>
  30 |     | <span class='neutral'>        address account</span>
  31 |     | <span class='unexecuted'>    ) external view returns (bool liquidatable, uint256 requiredMIMAmount, uint256 adjustedBorrowPart, uint256 returnedCollateralAmount) {</span>
  32 |     | <span class='unexecuted'>        adjustedBorrowPart = cauldron.userBorrowPart(account);</span>
  33 |     | <span class='unexecuted'>        (liquidatable, requiredMIMAmount, adjustedBorrowPart, returnedCollateralAmount) = previewLiquidation(</span>
  34 |     | <span class='unexecuted'>            cauldron,</span>
  35 |     | <span class='unexecuted'>            account,</span>
  36 |     | <span class='unexecuted'>            adjustedBorrowPart</span>
  37 |     | <span class='neutral'>        );</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>    function previewLiquidation(</span>
  41 |     | <span class='neutral'>        ICauldronV2 cauldron,</span>
  42 |     | <span class='neutral'>        address account,</span>
  43 |     | <span class='neutral'>        uint256 borrowPart</span>
  44 |     | <span class='unexecuted'>    ) public view returns (bool liquidatable, uint256 requiredMIMAmount, uint256 adjustedBorrowPart, uint256 returnedCollateralAmount) {</span>
  45 |     | <span class='unexecuted'>        liquidatable = isLiquidatable(cauldron, account);</span>
  46 |     | <span class='unexecuted'>        (returnedCollateralAmount, adjustedBorrowPart, requiredMIMAmount) = CauldronLib.getLiquidationCollateralAndBorrowAmount(</span>
  47 |     | <span class='unexecuted'>            ICauldronV2(cauldron),</span>
  48 |     | <span class='unexecuted'>            account,</span>
  49 |     | <span class='unexecuted'>            borrowPart</span>
  50 |     | <span class='neutral'>        );</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /// @notice Liquidate an account using max borrow amount</span>
  54 |     | <span class='unexecuted'>    function liquidateMax(</span>
  55 |     | <span class='neutral'>        address cauldron,</span>
  56 |     | <span class='neutral'>        address account,</span>
  57 |     | <span class='neutral'>        uint8 cauldronVersion</span>
  58 |     | <span class='unexecuted'>    ) external returns (uint256 collateralAmount, uint256 adjustedBorrowPart, uint256 requiredMimAmount) {</span>
  59 |     | <span class='unexecuted'>        return liquidateMaxTo(cauldron, account, msg.sender, cauldronVersion);</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /// @notice Liquidate an account using max borrow amount and send the collateral to a different address</span>
  63 |     | <span class='unexecuted'>    function liquidateMaxTo(</span>
  64 |     | <span class='neutral'>        address cauldron,</span>
  65 |     | <span class='neutral'>        address account,</span>
  66 |     | <span class='neutral'>        address recipient,</span>
  67 |     | <span class='neutral'>        uint8 cauldronVersion</span>
  68 |     | <span class='unexecuted'>    ) public returns (uint256 collateralAmount, uint256 adjustedBorrowPart, uint256 requiredMimAmount) {</span>
  69 |     | <span class='unexecuted'>        uint256 borrowPart = ICauldronV2(cauldron).userBorrowPart(account);</span>
  70 |     | <span class='unexecuted'>        return liquidateTo(cauldron, account, recipient, borrowPart, cauldronVersion);</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    /// @notice Liquidate an account using a part of the borrow amount</span>
  74 |     | <span class='unexecuted'>    function liquidate(</span>
  75 |     | <span class='neutral'>        address cauldron,</span>
  76 |     | <span class='neutral'>        address account,</span>
  77 |     | <span class='neutral'>        uint256 borrowPart,</span>
  78 |     | <span class='neutral'>        uint8 cauldronVersion</span>
  79 |     | <span class='unexecuted'>    ) external returns (uint256 collateralAmount, uint256 adjustedBorrowPart, uint256 requiredMimAmount) {</span>
  80 |     | <span class='unexecuted'>        return liquidateTo(cauldron, account, msg.sender, borrowPart, cauldronVersion);</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /// @notice Liquidate an account using a part of the borrow amount and send the collateral to a different address</span>
  84 |     | <span class='unexecuted'>    function liquidateTo(</span>
  85 |     | <span class='neutral'>        address cauldron,</span>
  86 |     | <span class='neutral'>        address account,</span>
  87 |     | <span class='neutral'>        address recipient,</span>
  88 |     | <span class='neutral'>        uint256 borrowPart,</span>
  89 |     | <span class='neutral'>        uint8 cauldronVersion</span>
  90 |     | <span class='unexecuted'>    ) public returns (uint256 collateralAmount, uint256 adjustedBorrowPart, uint256 requiredMimAmount) {</span>
  91 |     | <span class='unexecuted'>        (collateralAmount, adjustedBorrowPart, requiredMimAmount) = CauldronLib.getLiquidationCollateralAndBorrowAmount(</span>
  92 |     | <span class='unexecuted'>            ICauldronV2(cauldron),</span>
  93 |     | <span class='unexecuted'>            account,</span>
  94 |     | <span class='unexecuted'>            borrowPart</span>
  95 |     | <span class='neutral'>        );</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>        IBentoBoxV1 box = IBentoBoxV1(ICauldronV2(cauldron).bentoBox());</span>
  98 |     | <span class='unexecuted'>        uint256 shareMIMBefore = _transferRequiredMIMToCauldronDegenBox(box, requiredMimAmount);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>        address masterContract = address(ICauldronV2(cauldron).masterContract());</span>
 101 |     | <span class='unexecuted'>        box.setMasterContractApproval(address(this), masterContract, true, 0, 0, 0);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>        _liquidate(cauldron, account, adjustedBorrowPart, cauldronVersion);</span>
 104 |     | <span class='unexecuted'>        box.setMasterContractApproval(address(this), masterContract, false, 0, 0, 0);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>        // withdraw/refund any MiM left and withdraw collateral to wallet</span>
 107 |     | <span class='unexecuted'>        box.withdraw(mim, address(this), msg.sender, 0, box.balanceOf(mim, address(this)) - shareMIMBefore);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        {</span>
 110 |     | <span class='unexecuted'>            IERC20 collateral = ICauldronV2(cauldron).collateral();</span>
 111 |     | <span class='unexecuted'>            box.withdraw(collateral, address(this), recipient, 0, box.balanceOf(collateral, address(this)));</span>
 112 |     | <span class='neutral'>        }</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>    function _liquidate(address cauldron, address account, uint256 borrowPart, uint8 cauldronVersion) internal {</span>
 116 |     | <span class='unexecuted'>        address[] memory users = new address[](1);</span>
 117 |     | <span class='unexecuted'>        users[0] = account;</span>
 118 |     | <span class='unexecuted'>        uint256[] memory maxBorrowParts = new uint256[](1);</span>
 119 |     | <span class='unexecuted'>        maxBorrowParts[0] = borrowPart;</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>        if (cauldronVersion &lt;= 2) {</span>
 122 |     | <span class='unexecuted'>            ICauldronV2(cauldron).liquidate(users, maxBorrowParts, address(this), address(0));</span>
 123 |     | <span class='unexecuted'>        } else if (cauldronVersion &gt;= 3) {</span>
 124 |     | <span class='unexecuted'>            ICauldronV3(cauldron).liquidate(users, maxBorrowParts, address(this), address(0), new bytes(0));</span>
 125 |     | <span class='neutral'>        } else {</span>
 126 |     | <span class='unexecuted'>            revert ErrInvalidCauldronVersion(cauldronVersion);</span>
 127 |     | <span class='neutral'>        }</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /// @notice Transfer MiM from the liquidator to the BentoBox</span>
 131 |     | <span class='unexecuted'>    function _transferRequiredMIMToCauldronDegenBox(IBentoBoxV1 box, uint256 amount) internal returns (uint256 shareMIMBefore) {</span>
 132 |     | <span class='unexecuted'>        shareMIMBefore = box.balanceOf(mim, address(this));</span>
 133 |     | <span class='unexecuted'>        mim.transferFrom(msg.sender, address(box), amount);</span>
 134 |     | <span class='unexecuted'>        box.deposit(mim, address(box), address(this), amount, 0);</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'>}</span>
 137 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/LzMulticallSenderReceiver.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {LzNonblockingApp} from &quot;mixins/LzNonblockingApp.sol&quot;;</span>
  5 |     | <span class='neutral'>import {OperatableV3} from &quot;mixins/OperatableV3.sol&quot;;</span>
  6 |     | <span class='neutral'>import {Address} from &quot;openzeppelin-contracts/utils/Address.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/// @notice A contract that sends and receive calls to and from other chains.</span>
  9 |     | <span class='unexecuted'>contract LzMulticallSenderReceiver is LzNonblockingApp, OperatableV3 {</span>
 10 |     | <span class='neutral'>    struct Call {</span>
 11 |     | <span class='neutral'>        address to;</span>
 12 |     | <span class='neutral'>        uint256 value;</span>
 13 |     | <span class='neutral'>        bytes data;</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    event LogSent(uint16 indexed _chainId, Call[] calls);</span>
 17 |     | <span class='neutral'>    event LogReceived(uint16 indexed _srcChainId, Call[] calls);</span>
 18 |     | <span class='neutral'>    event LogNonceExpired(uint16 indexed _chainId, uint64 indexed _nonce);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    error ErrArrayLengthMismatch();</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    mapping(uint16 chainid =&gt; uint64 nonce) public noncePerChain;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    constructor(address _lzEndpoint, address _owner) LzNonblockingApp(_lzEndpoint, _owner) {}</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    function send(uint16 _chainId, Call[] memory _calls) external payable onlyOperators {</span>
 27 |     | <span class='unexecuted'>        _lzSend(_chainId, abi.encode(_calls), payable(msg.sender), address(0), bytes(&quot;&quot;), msg.value);</span>
 28 |     | <span class='unexecuted'>        emit LogSent(_chainId, _calls);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function multisend(uint16[] calldata _chainIds, Call[][] memory _calls, uint256[] memory _nativeFees) external payable onlyOperators {</span>
 32 |     | <span class='unexecuted'>        if (_chainIds.length != _calls.length) {</span>
 33 |     | <span class='unexecuted'>            revert ErrArrayLengthMismatch();</span>
 34 |     | <span class='neutral'>        }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _calls.length; ) {</span>
 37 |     | <span class='unexecuted'>            _lzSend(_chainIds[i], abi.encode(_calls[i]), payable(msg.sender), address(0), bytes(&quot;&quot;), _nativeFees[i]);</span>
 38 |     | <span class='unexecuted'>            emit LogSent(_chainIds[i], _calls[i]);</span>
 39 |     | <span class='neutral'>            unchecked {</span>
 40 |     | <span class='unexecuted'>                ++i;</span>
 41 |     | <span class='neutral'>            }</span>
 42 |     | <span class='neutral'>        }</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='unexecuted'>    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory, uint64 nonce, bytes memory _payload, bool) internal override {</span>
 46 |     | <span class='unexecuted'>        if (nonce &lt; noncePerChain[_srcChainId]) {</span>
 47 |     | <span class='unexecuted'>            emit LogNonceExpired(_srcChainId, nonce);</span>
 48 |     | <span class='unexecuted'>            return;</span>
 49 |     | <span class='neutral'>        }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>        Call[] memory _calls = abi.decode(_payload, (Call[]));</span>
 52 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _calls.length; ) {</span>
 53 |     | <span class='unexecuted'>            Address.functionCallWithValue(_calls[i].to, _calls[i].data, _calls[i].value);</span>
 54 |     | <span class='neutral'>            unchecked {</span>
 55 |     | <span class='unexecuted'>                ++i;</span>
 56 |     | <span class='neutral'>            }</span>
 57 |     | <span class='neutral'>        }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>        emit LogReceived(_srcChainId, _calls);</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='unexecuted'>    function isOwner(address _account) internal view override returns (bool) {</span>
 63 |     | <span class='unexecuted'>        return _account == owner;</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'>}</span>
 66 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/LzOFTV2FeeHandler.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {OperatableV2} from &quot;mixins/OperatableV2.sol&quot;;</span>
   5 |     | <span class='neutral'>import {ILzFeeHandler, ILzOFTV2} from &quot;interfaces/ILayerZero.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>contract LzOFTV2FeeHandler is OperatableV2, ILzFeeHandler {</span>
   9 |     | <span class='neutral'>    event LogFeeWithdrawn(address to, uint256 amount);</span>
  10 |     | <span class='neutral'>    event LogFixedNativeFeeChanged(uint256 previous, uint256 current);</span>
  11 |     | <span class='neutral'>    event LogOracleImplementationChange(IAggregator indexed previous, IAggregator indexed current);</span>
  12 |     | <span class='neutral'>    event LogQuoteTypeChanged(QuoteType previous, QuoteType current);</span>
  13 |     | <span class='neutral'>    event LogFeeToChanged(address indexed previous, address indexed current);</span>
  14 |     | <span class='neutral'>    event LogUsdFeeChanged(uint256 previous, uint256 current);</span>
  15 |     | <span class='neutral'>    event LogFeeCollected(uint256 amount);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    error ErrInvalidQuoteType(QuoteType);</span>
  18 |     | <span class='neutral'>    error ErrWithdrawFailed();</span>
  19 |     | <span class='neutral'>    error ErrValueTooLowToCoverFees(uint256);</span>
  20 |     | <span class='neutral'>    error ErrUnauthorizedSender();</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    modifier onlyFromOFT() {</span>
  23 |     | <span class='neutral'>        if (msg.sender != address(oft)) {</span>
  24 |     | <span class='neutral'>            revert ErrUnauthorizedSender();</span>
  25 |     | <span class='neutral'>        }</span>
  26 |     | <span class='neutral'>        _;</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    uint256 public constant DEFAULT_USD_FEE = 1e18;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    ILzOFTV2 public immutable oft;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>    address public feeTo;</span>
  34 |     | <span class='unexecuted'>    IAggregator public aggregator;</span>
  35 |     | <span class='unexecuted'>    uint256 public fixedNativeFee;</span>
  36 |     | <span class='unexecuted'>    uint256 public usdFee;</span>
  37 |     | <span class='unexecuted'>    QuoteType public quoteType = QuoteType.Oracle;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    constructor(</span>
  40 |     | <span class='neutral'>        address _owner,</span>
  41 |     | <span class='neutral'>        uint256 _fixedNativeFee,</span>
  42 |     | <span class='neutral'>        address _oft,</span>
  43 |     | <span class='neutral'>        address _aggregator,</span>
  44 |     | <span class='neutral'>        address _feeTo,</span>
  45 |     | <span class='neutral'>        uint8 _quoteType</span>
  46 |     | <span class='neutral'>    ) OperatableV2(_owner) {</span>
  47 |     | <span class='unexecuted'>        fixedNativeFee = _fixedNativeFee;</span>
  48 |     | <span class='unexecuted'>        oft = ILzOFTV2(_oft);</span>
  49 |     | <span class='unexecuted'>        aggregator = IAggregator(_aggregator);</span>
  50 |     | <span class='unexecuted'>        feeTo = _feeTo;</span>
  51 |     | <span class='unexecuted'>        quoteType = QuoteType(_quoteType);</span>
  52 |     | <span class='unexecuted'>        usdFee = DEFAULT_USD_FEE;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    receive() external payable {</span>
  56 |     | <span class='unexecuted'>        emit LogFeeCollected(msg.value);</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /************************************************************************</span>
  60 |     | <span class='neutral'>     * Public</span>
  61 |     | <span class='neutral'>     ************************************************************************/</span>
  62 |     | <span class='unexecuted'>    function withdrawFees() external {</span>
  63 |     | <span class='unexecuted'>        uint256 balance = address(this).balance;</span>
  64 |     | <span class='unexecuted'>        (bool success, ) = feeTo.call{value: balance}(&quot;&quot;);</span>
  65 |     | <span class='unexecuted'>        if (!success) revert ErrWithdrawFailed();</span>
  66 |     | <span class='unexecuted'>        emit LogFeeWithdrawn(feeTo, balance);</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /************************************************************************</span>
  70 |     | <span class='neutral'>     * Operations</span>
  71 |     | <span class='neutral'>     ************************************************************************/</span>
  72 |     | <span class='unexecuted'>    function setFixedNativeFee(uint256 _fixedNativeFee) external onlyOperators {</span>
  73 |     | <span class='unexecuted'>        emit LogFixedNativeFeeChanged(fixedNativeFee, _fixedNativeFee);</span>
  74 |     | <span class='unexecuted'>        fixedNativeFee = _fixedNativeFee;</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>    function setAggregator(IAggregator _aggregator) external onlyOperators {</span>
  78 |     | <span class='unexecuted'>        emit LogOracleImplementationChange(aggregator, _aggregator);</span>
  79 |     | <span class='unexecuted'>        aggregator = _aggregator;</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>    function setUsdFee(uint256 _usdFee) external onlyOperators {</span>
  83 |     | <span class='unexecuted'>        emit LogUsdFeeChanged(usdFee, _usdFee);</span>
  84 |     | <span class='unexecuted'>        usdFee = _usdFee;</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>    function setQuoteType(QuoteType _quoteType) external onlyOperators {</span>
  88 |     | <span class='unexecuted'>        if (_quoteType &gt; QuoteType.Fixed) {</span>
  89 |     | <span class='unexecuted'>            revert ErrInvalidQuoteType(_quoteType);</span>
  90 |     | <span class='neutral'>        }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>        emit LogQuoteTypeChanged(quoteType, _quoteType);</span>
  93 |     | <span class='unexecuted'>        quoteType = _quoteType;</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    /************************************************************************</span>
  97 |     | <span class='neutral'>     * Owners</span>
  98 |     | <span class='neutral'>     ************************************************************************/</span>
  99 |     | <span class='unexecuted'>    function setFeeTo(address _feeTo) external onlyOwner {</span>
 100 |     | <span class='unexecuted'>        emit LogFeeToChanged(feeTo, _feeTo);</span>
 101 |     | <span class='unexecuted'>        feeTo = _feeTo;</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /************************************************************************</span>
 105 |     | <span class='neutral'>     * Views</span>
 106 |     | <span class='neutral'>     ************************************************************************/</span>
 107 |     | <span class='unexecuted'>    function getFee() public view override returns (uint256 nativeFee) {</span>
 108 |     | <span class='unexecuted'>        if (quoteType == QuoteType.Oracle) {</span>
 109 |     | <span class='unexecuted'>            nativeFee = ((10 ** aggregator.decimals()) * usdFee) / uint256(aggregator.latestAnswer());</span>
 110 |     | <span class='unexecuted'>        } else if (quoteType == QuoteType.Fixed) {</span>
 111 |     | <span class='unexecuted'>            nativeFee = fixedNativeFee;</span>
 112 |     | <span class='neutral'>        }</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'>}</span>
 115 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/MSpellStaking.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// Inspired by Stable Joe Staking which in turn is derived from the SushiSwap MasterChef contract</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   5 |     | <span class='neutral'>import {BoringOwnable} from &quot;BoringSolidity/BoringOwnable.sol&quot;;</span>
   6 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solmate/utils/SafeTransferLib.sol&quot;;</span>
   7 |     | <span class='neutral'>import {ERC20} from &quot;solmate/tokens/ERC20.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/**</span>
  10 |     | <span class='neutral'> * @title Magic Spell Staking</span>
  11 |     | <span class='neutral'> * @author 0xMerlin</span>
  12 |     | <span class='neutral'> */</span>
  13 |     | <span class='unexecuted'>contract MSpellStaking is BoringOwnable {</span>
  14 |     | <span class='neutral'>    using SafeTransferLib for ERC20;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    /// @notice Info of each user</span>
  17 |     | <span class='neutral'>    struct UserInfo {</span>
  18 |     | <span class='neutral'>        uint128 amount;</span>
  19 |     | <span class='neutral'>        uint128 rewardDebt;</span>
  20 |     | <span class='neutral'>        uint128 lastAdded;</span>
  21 |     | <span class='neutral'>        /**</span>
  22 |     | <span class='neutral'>         * @notice We do some fancy math here. Basically, any point in time, the amount of JOEs</span>
  23 |     | <span class='neutral'>         * entitled to a user but is pending to be distributed is:</span>
  24 |     | <span class='neutral'>         *</span>
  25 |     | <span class='neutral'>         *   pending reward = (user.amount * accRewardPerShare) - user.rewardDebt[token]</span>
  26 |     | <span class='neutral'>         *</span>
  27 |     | <span class='neutral'>         * Whenever a user deposits or withdraws SPELL. Here&#39;s what happens:</span>
  28 |     | <span class='neutral'>         *   1. accRewardPerShare (and `lastRewardBalance`) gets updated</span>
  29 |     | <span class='neutral'>         *   2. User receives the pending reward sent to his/her address</span>
  30 |     | <span class='neutral'>         *   3. User&#39;s `amount` gets updated</span>
  31 |     | <span class='neutral'>         *   4. User&#39;s `rewardDebt[token]` gets updated</span>
  32 |     | <span class='neutral'>         */</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    ERC20 public immutable spell;</span>
  36 |     | <span class='neutral'>    /// @notice Array of tokens that users can claim</span>
  37 |     | <span class='unexecuted'>    ERC20 public immutable mim;</span>
  38 |     | <span class='neutral'>    /// @notice Last reward balance of `token`</span>
  39 |     | <span class='unexecuted'>    uint256 public lastRewardBalance;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /// @notice amount of time that the position is locked for.</span>
  42 |     | <span class='unexecuted'>    uint256 private constant LOCK_TIME = 24 hours;</span>
  43 |     | <span class='unexecuted'>    bool public toggleLockup;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /// @notice Accumulated `token` rewards per share, scaled to `ACC_REWARD_PER_SHARE_PRECISION`</span>
  46 |     | <span class='unexecuted'>    uint256 public accRewardPerShare;</span>
  47 |     | <span class='neutral'>    /// @notice The precision of `accRewardPerShare`</span>
  48 |     | <span class='unexecuted'>    uint256 public constant ACC_REWARD_PER_SHARE_PRECISION = 1e24;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /// @dev Info of each user that stakes SPELL</span>
  51 |     | <span class='unexecuted'>    mapping(address =&gt; UserInfo) public userInfo;</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /// @notice Emitted when a user deposits SPELL</span>
  54 |     | <span class='neutral'>    event Deposit(address indexed user, uint256 amount);</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /// @notice Emitted when a user withdraws SPELL</span>
  57 |     | <span class='neutral'>    event Withdraw(address indexed user, uint256 amount);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /// @notice Emitted when a user claims reward</span>
  60 |     | <span class='neutral'>    event ClaimReward(address indexed user, uint256 amount);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /// @notice Emitted when a user emergency withdraws its SPELL</span>
  63 |     | <span class='neutral'>    event EmergencyWithdraw(address indexed user, uint256 amount);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /**</span>
  66 |     | <span class='neutral'>     * @notice Initialize a new mSpellStaking contract</span>
  67 |     | <span class='neutral'>     * @dev This contract needs to receive an ERC20 `_rewardToken` in order to distribute them</span>
  68 |     | <span class='neutral'>     * (with MoneyMaker in our case)</span>
  69 |     | <span class='neutral'>     * @param _mim The address of the MIM token</span>
  70 |     | <span class='neutral'>     * @param _spell The address of the SPELL token</span>
  71 |     | <span class='neutral'>     */</span>
  72 |     | <span class='unexecuted'>    constructor(ERC20 _mim, ERC20 _spell) {</span>
  73 |     | <span class='unexecuted'>        require(address(_mim) != address(0), &quot;mSpellStaking: reward token can&#39;t be address(0)&quot;);</span>
  74 |     | <span class='unexecuted'>        require(address(_spell) != address(0), &quot;mSpellStaking: spell can&#39;t be address(0)&quot;);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>        spell = _spell;</span>
  77 |     | <span class='unexecuted'>        toggleLockup = true;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>        mim = _mim;</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    /**</span>
  83 |     | <span class='neutral'>     * @notice Deposit SPELL for reward token allocation</span>
  84 |     | <span class='neutral'>     * @param _amount The amount of SPELL to deposit</span>
  85 |     | <span class='neutral'>     */</span>
  86 |     | <span class='unexecuted'>    function deposit(uint256 _amount) external {</span>
  87 |     | <span class='unexecuted'>        UserInfo storage user = userInfo[msg.sender];</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>        uint256 _previousAmount = user.amount;</span>
  90 |     | <span class='unexecuted'>        uint256 _newAmount = user.amount + _amount;</span>
  91 |     | <span class='unexecuted'>        user.amount = uint128(_newAmount);</span>
  92 |     | <span class='unexecuted'>        user.lastAdded = uint128(block.timestamp);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        updateReward();</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>        uint256 _previousRewardDebt = user.rewardDebt;</span>
  97 |     | <span class='unexecuted'>        user.rewardDebt = uint128((_newAmount * accRewardPerShare) / ACC_REWARD_PER_SHARE_PRECISION);</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>        if (_previousAmount != 0) {</span>
 100 |     | <span class='unexecuted'>            uint256 _pending = (_previousAmount * accRewardPerShare) / ACC_REWARD_PER_SHARE_PRECISION - _previousRewardDebt;</span>
 101 |     | <span class='unexecuted'>            if (_pending != 0) {</span>
 102 |     | <span class='unexecuted'>                safeTokenTransfer(mim, msg.sender, _pending);</span>
 103 |     | <span class='unexecuted'>                emit ClaimReward(msg.sender, _pending);</span>
 104 |     | <span class='neutral'>            }</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>        spell.safeTransferFrom(msg.sender, address(this), _amount);</span>
 108 |     | <span class='unexecuted'>        emit Deposit(msg.sender, _amount);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /**</span>
 112 |     | <span class='neutral'>     * @notice View function to see pending reward token on frontend</span>
 113 |     | <span class='neutral'>     * @param _user The address of the user</span>
 114 |     | <span class='neutral'>     * @return `_user`&#39;s pending reward token</span>
 115 |     | <span class='neutral'>     */</span>
 116 |     | <span class='unexecuted'>    function pendingReward(address _user) external view returns (uint256) {</span>
 117 |     | <span class='unexecuted'>        UserInfo storage user = userInfo[_user];</span>
 118 |     | <span class='unexecuted'>        uint256 _totalSpell = spell.balanceOf(address(this));</span>
 119 |     | <span class='unexecuted'>        uint256 _accRewardTokenPerShare = accRewardPerShare;</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>        uint256 _rewardBalance = mim.balanceOf(address(this));</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>        if (_rewardBalance != lastRewardBalance &amp;&amp; _totalSpell != 0) {</span>
 124 |     | <span class='unexecuted'>            uint256 _accruedReward = _rewardBalance - lastRewardBalance;</span>
 125 |     | <span class='unexecuted'>            _accRewardTokenPerShare = _accRewardTokenPerShare + (_accruedReward * ACC_REWARD_PER_SHARE_PRECISION) / _totalSpell;</span>
 126 |     | <span class='neutral'>        }</span>
 127 |     | <span class='unexecuted'>        return (user.amount * _accRewardTokenPerShare) / ACC_REWARD_PER_SHARE_PRECISION - user.rewardDebt;</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /**</span>
 131 |     | <span class='neutral'>     * @notice Withdraw SPELL and harvest the rewards</span>
 132 |     | <span class='neutral'>     * @param _amount The amount of SPELL to withdraw</span>
 133 |     | <span class='neutral'>     */</span>
 134 |     | <span class='unexecuted'>    function withdraw(uint256 _amount) external {</span>
 135 |     | <span class='unexecuted'>        UserInfo storage user = userInfo[msg.sender];</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='unexecuted'>        require(!toggleLockup || user.lastAdded + LOCK_TIME &lt; block.timestamp, &quot;mSpell: Wait for LockUp&quot;);</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>        uint256 _previousAmount = user.amount;</span>
 140 |     | <span class='unexecuted'>        uint256 _newAmount = user.amount - _amount;</span>
 141 |     | <span class='unexecuted'>        user.amount = uint128(_newAmount);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>        updateReward();</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='unexecuted'>        uint256 _pending = (_previousAmount * accRewardPerShare) / ACC_REWARD_PER_SHARE_PRECISION - user.rewardDebt;</span>
 146 |     | <span class='unexecuted'>        user.rewardDebt = uint128((_newAmount * accRewardPerShare) / ACC_REWARD_PER_SHARE_PRECISION);</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='unexecuted'>        if (_pending != 0) {</span>
 149 |     | <span class='unexecuted'>            safeTokenTransfer(mim, msg.sender, _pending);</span>
 150 |     | <span class='unexecuted'>            emit ClaimReward(msg.sender, _pending);</span>
 151 |     | <span class='neutral'>        }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>        spell.safeTransfer(msg.sender, _amount);</span>
 154 |     | <span class='unexecuted'>        emit Withdraw(msg.sender, _amount);</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    /**</span>
 158 |     | <span class='neutral'>     * @notice Withdraw without caring about rewards. EMERGENCY ONLY</span>
 159 |     | <span class='neutral'>     */</span>
 160 |     | <span class='unexecuted'>    function emergencyWithdraw() external {</span>
 161 |     | <span class='unexecuted'>        UserInfo storage user = userInfo[msg.sender];</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='unexecuted'>        require(!toggleLockup || user.lastAdded + LOCK_TIME &lt; block.timestamp, &quot;mSpell: Wait for LockUp&quot;);</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='unexecuted'>        uint256 _amount = user.amount;</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>        user.amount = 0;</span>
 168 |     | <span class='unexecuted'>        user.rewardDebt = 0;</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>        spell.safeTransfer(msg.sender, _amount);</span>
 171 |     | <span class='unexecuted'>        emit EmergencyWithdraw(msg.sender, _amount);</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    /**</span>
 175 |     | <span class='neutral'>     * @notice Update reward variables</span>
 176 |     | <span class='neutral'>     * @dev Needs to be called before any deposit or withdrawal</span>
 177 |     | <span class='neutral'>     */</span>
 178 |     | <span class='unexecuted'>    function updateReward() public {</span>
 179 |     | <span class='unexecuted'>        uint256 _rewardBalance = mim.balanceOf(address(this));</span>
 180 |     | <span class='unexecuted'>        uint256 _totalSpell = spell.balanceOf(address(this));</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>        // Did mSpellStaking receive any token</span>
 183 |     | <span class='unexecuted'>        if (_rewardBalance == lastRewardBalance || _totalSpell == 0) {</span>
 184 |     | <span class='unexecuted'>            return;</span>
 185 |     | <span class='neutral'>        }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='unexecuted'>        uint256 _accruedReward = _rewardBalance - lastRewardBalance;</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='unexecuted'>        accRewardPerShare = accRewardPerShare + (_accruedReward * ACC_REWARD_PER_SHARE_PRECISION) / _totalSpell;</span>
 190 |     | <span class='unexecuted'>        lastRewardBalance = _rewardBalance;</span>
 191 |     | <span class='neutral'>    }</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>    /**</span>
 194 |     | <span class='neutral'>     * @notice Safe token transfer function, just in case if rounding error</span>
 195 |     | <span class='neutral'>     * causes pool to not have enough reward tokens</span>
 196 |     | <span class='neutral'>     * @param _token The address of then token to transfer</span>
 197 |     | <span class='neutral'>     * @param _to The address that will receive `_amount` `rewardToken`</span>
 198 |     | <span class='neutral'>     * @param _amount The amount to send to `_to`</span>
 199 |     | <span class='neutral'>     */</span>
 200 |     | <span class='unexecuted'>    function safeTokenTransfer(ERC20 _token, address _to, uint256 _amount) internal {</span>
 201 |     | <span class='unexecuted'>        uint256 _rewardBalance = _token.balanceOf(address(this));</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='unexecuted'>        if (_amount &gt; _rewardBalance) {</span>
 204 |     | <span class='unexecuted'>            lastRewardBalance = lastRewardBalance - _rewardBalance;</span>
 205 |     | <span class='unexecuted'>            _token.safeTransfer(_to, _rewardBalance);</span>
 206 |     | <span class='neutral'>        } else {</span>
 207 |     | <span class='unexecuted'>            lastRewardBalance = lastRewardBalance - _amount;</span>
 208 |     | <span class='unexecuted'>            _token.safeTransfer(_to, _amount);</span>
 209 |     | <span class='neutral'>        }</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /**</span>
 213 |     | <span class='neutral'>     * @notice Allows to enable and disable the lockup</span>
 214 |     | <span class='neutral'>     * @param status The new lockup status</span>
 215 |     | <span class='neutral'>     */</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='unexecuted'>    function toggleLockUp(bool status) external onlyOwner {</span>
 218 |     | <span class='unexecuted'>        toggleLockup = status;</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'>}</span>
 221 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/MagicCurveLpHarvestor.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import {Rebase} from &quot;BoringSolidity/libraries/BoringRebase.sol&quot;;</span>
   7 |     | <span class='neutral'>import {SafeApproveLib} from &quot;libraries/SafeApproveLib.sol&quot;;</span>
   8 |     | <span class='neutral'>import {MathLib} from &quot;libraries/MathLib.sol&quot;;</span>
   9 |     | <span class='neutral'>import {Operatable} from &quot;mixins/Operatable.sol&quot;;</span>
  10 |     | <span class='neutral'>import {FeeCollectable} from &quot;mixins/FeeCollectable.sol&quot;;</span>
  11 |     | <span class='neutral'>import {IMagicCurveLpRewardHandler} from &quot;interfaces/IMagicCurveLpRewardHandler.sol&quot;;</span>
  12 |     | <span class='neutral'>import {IERC4626} from &quot;interfaces/IERC4626.sol&quot;;</span>
  13 |     | <span class='neutral'>import {ICurveRewardGauge} from &quot;interfaces/ICurveRewardGauge.sol&quot;;</span>
  14 |     | <span class='neutral'>import {ICurvePool} from &quot;interfaces/ICurvePool.sol&quot;;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>/// @notice Contract to harvest rewards from the staking contract and distribute them to the vault</span>
  17 |     | <span class='unexecuted'>contract MagicCurveLpHarvestor is Operatable, FeeCollectable {</span>
  18 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
  19 |     | <span class='neutral'>    using SafeApproveLib for IERC20;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    error ErrSwapFailed();</span>
  22 |     | <span class='neutral'>    event LogFeeParametersChanged(address indexed feeCollector, uint16 feeAmount);</span>
  23 |     | <span class='neutral'>    event LogExchangeRouterChanged(address indexed previous, address indexed current);</span>
  24 |     | <span class='neutral'>    event LogHarvest(uint256 total, uint256 amount, uint256 fee);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /// @notice Vault to harvest rewards from and compound</span>
  27 |     | <span class='unexecuted'>    IERC4626 public immutable vault;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    /// @notice Reward token to harvest</span>
  30 |     | <span class='unexecuted'>    IERC20 public immutable rewardToken;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /// @notice Number of coins in the pool</span>
  33 |     | <span class='unexecuted'>    uint8 public immutable poolNumCoins;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /// @notice Index of the token to one side liquidity to the pool</span>
  36 |     | <span class='unexecuted'>    uint8 public immutable poolTokenInIndex;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /// @notice Exchange router to swap rewards</span>
  39 |     | <span class='unexecuted'>    address public exchangeRouter;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /// @notice Last time the harvest happened</span>
  42 |     | <span class='unexecuted'>    uint64 public lastExecution;</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /// @param _rewardToken Reward token to harvest</span>
  45 |     | <span class='unexecuted'>    constructor(IERC20 _rewardToken, uint8 _poolNumCoins, uint8 _poolTokenInIndex, IERC4626 _vault) {</span>
  46 |     | <span class='unexecuted'>        rewardToken = _rewardToken;</span>
  47 |     | <span class='unexecuted'>        poolNumCoins = _poolNumCoins;</span>
  48 |     | <span class='unexecuted'>        poolTokenInIndex = _poolTokenInIndex;</span>
  49 |     | <span class='unexecuted'>        vault = _vault;</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /// @notice Returns true when the caller is the fee operator</span>
  53 |     | <span class='unexecuted'>    function isFeeOperator(address account) public view override returns (bool) {</span>
  54 |     | <span class='unexecuted'>        return account == owner;</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    /// @notice Returns the number of rewards amount from the staking contract</span>
  58 |     | <span class='unexecuted'>    function claimable() public view returns (uint256) {</span>
  59 |     | <span class='unexecuted'>        ICurveRewardGauge staking = IMagicCurveLpRewardHandler(address(vault)).staking();</span>
  60 |     | <span class='unexecuted'>        return staking.claimable_reward(address(vault), address(rewardToken));</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /// @notice Returns the total amount of rewards in the contract (including the staking contract)</span>
  64 |     | <span class='unexecuted'>    function totalRewardsBalanceAfterClaiming() external view returns (uint256) {</span>
  65 |     | <span class='unexecuted'>        return claimable() + rewardToken.balanceOf(address(this));</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /// @notice Harvests rewards from the staking contract and distributes them to the vault</span>
  69 |     | <span class='neutral'>    /// @param minLp Minimum amount of LP tokens to mint otherwise revert</span>
  70 |     | <span class='neutral'>    /// @param tokenIn Token to swap rewards to and used to mint LP tokens</span>
  71 |     | <span class='neutral'>    /// @param maxAmountIn Maximum amount of tokenIn to swap</span>
  72 |     | <span class='neutral'>    /// @param swapData exchange router data for the swap</span>
  73 |     | <span class='unexecuted'>    function run(uint256 minLp, IERC20 tokenIn, uint256 maxAmountIn, bytes memory swapData) external onlyOperators {</span>
  74 |     | <span class='unexecuted'>        IMagicCurveLpRewardHandler(address(vault)).harvest(address(this));</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        // wKAVA -&gt; USDT</span>
  77 |     | <span class='unexecuted'>        (bool success, ) = exchangeRouter.call(swapData);</span>
  78 |     | <span class='unexecuted'>        if (!success) {</span>
  79 |     | <span class='unexecuted'>            revert ErrSwapFailed();</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='unexecuted'>        uint256 amountIn = MathLib.min(tokenIn.balanceOf(address(this)), maxAmountIn);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        if (amountIn &gt; 0) {</span>
  84 |     | <span class='unexecuted'>            _compoundFromToken(tokenIn, amountIn, minLp);</span>
  85 |     | <span class='neutral'>        }</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    /// @notice Harvests rewards from the staking contract and distributes them to the vault</span>
  89 |     | <span class='unexecuted'>    function compoundFromToken(IERC20 tokenIn, uint256 amount, uint256 minLp) external onlyOperators {</span>
  90 |     | <span class='unexecuted'>        _compoundFromToken(tokenIn, amount, minLp);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /// @notice Changes the allowance of the reward token to the staking contract</span>
  94 |     | <span class='unexecuted'>    function setLiquidityPoolAllowance(address pool, IERC20 token, uint256 amount) external onlyOwner {</span>
  95 |     | <span class='unexecuted'>        token.approve(pool, amount);</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /// @notice Changes the allowance of the LLP tokens to the vault for `distributeRewards`</span>
  99 |     | <span class='unexecuted'>    function setVaultAssetAllowance(uint256 amount) external onlyOwner {</span>
 100 |     | <span class='unexecuted'>        IERC20 asset = vault.asset();</span>
 101 |     | <span class='unexecuted'>        asset.approve(address(vault), amount);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /// @notice Changes the exchange router to swap the rewards to</span>
 105 |     | <span class='unexecuted'>    function setExchangeRouter(address _exchangeRouter) external onlyOwner {</span>
 106 |     | <span class='unexecuted'>        if (exchangeRouter != address(0)) {</span>
 107 |     | <span class='unexecuted'>            rewardToken.approve(exchangeRouter, 0);</span>
 108 |     | <span class='neutral'>        }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>        emit LogExchangeRouterChanged(exchangeRouter, _exchangeRouter);</span>
 111 |     | <span class='unexecuted'>        exchangeRouter = _exchangeRouter;</span>
 112 |     | <span class='unexecuted'>        rewardToken.approve(_exchangeRouter, type(uint256).max);</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>    function _compoundFromToken(</span>
 116 |     | <span class='neutral'>        IERC20 tokenIn,</span>
 117 |     | <span class='neutral'>        uint256 amountIn,</span>
 118 |     | <span class='neutral'>        uint256 minLp</span>
 119 |     | <span class='unexecuted'>    ) private returns (uint256 totalAmount, uint256 assetAmount, uint256 feeAmount) {</span>
 120 |     | <span class='unexecuted'>        IERC20 asset = vault.asset();</span>
 121 |     | <span class='unexecuted'>        uint balanceLpBefore = asset.balanceOf(address(this));</span>
 122 |     | <span class='unexecuted'>        tokenIn.safeApprove(address(asset), amountIn);</span>
 123 |     | <span class='unexecuted'>        ICurvePool pool = ICurvePool(address(asset));</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>        if (poolNumCoins == 2) {</span>
 126 |     | <span class='unexecuted'>            uint256[2] memory amounts = [uint256(0), uint256(0)];</span>
 127 |     | <span class='unexecuted'>            amounts[poolTokenInIndex] = amountIn;</span>
 128 |     | <span class='unexecuted'>            pool.add_liquidity(amounts, minLp);</span>
 129 |     | <span class='unexecuted'>        } else if (poolNumCoins == 3) {</span>
 130 |     | <span class='unexecuted'>            uint256[3] memory amounts = [uint256(0), uint256(0), uint256(0)];</span>
 131 |     | <span class='unexecuted'>            amounts[poolTokenInIndex] = amountIn;</span>
 132 |     | <span class='unexecuted'>            pool.add_liquidity(amounts, minLp);</span>
 133 |     | <span class='unexecuted'>        } else if (poolNumCoins == 4) {</span>
 134 |     | <span class='unexecuted'>            uint256[4] memory amounts = [uint256(0), uint256(0), uint256(0), uint256(0)];</span>
 135 |     | <span class='unexecuted'>            amounts[poolTokenInIndex] = amountIn;</span>
 136 |     | <span class='unexecuted'>            pool.add_liquidity(amounts, minLp);</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>        totalAmount = asset.balanceOf(address(this)) - balanceLpBefore;</span>
 140 |     | <span class='unexecuted'>        (assetAmount, feeAmount) = calculateFees(totalAmount);</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='unexecuted'>        if (feeAmount &gt; 0) {</span>
 143 |     | <span class='unexecuted'>            asset.safeTransfer(feeCollector, feeAmount);</span>
 144 |     | <span class='neutral'>        }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>        IMagicCurveLpRewardHandler(address(vault)).distributeRewards(assetAmount);</span>
 147 |     | <span class='unexecuted'>        lastExecution = uint64(block.timestamp);</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='unexecuted'>        emit LogHarvest(totalAmount, assetAmount, feeAmount);</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'>}</span>
 152 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/MagicCurveLpRewardHandler.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20, BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {MagicCurveLpData} from &quot;tokens/MagicCurveLp.sol&quot;;</span>
  6 |     | <span class='neutral'>import {ICurveRewardGauge} from &quot;interfaces/ICurveRewardGauge.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IMagicCurveLpRewardHandler} from &quot;interfaces/IMagicCurveLpRewardHandler.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/// @dev in case of V2, if adding new variable create MagicCurveLpRewardHandlerDataV2 that inherits</span>
 10 |     | <span class='neutral'>/// from MagicCurveLpRewardHandlerDataV1</span>
 11 |     | <span class='unexecuted'>contract MagicCurveLpRewardHandlerDataV1 is MagicCurveLpData {</span>
 12 |     | <span class='neutral'>    ICurveRewardGauge _staking;</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>/// @dev When making a new version, never change existing variables, always add after</span>
 16 |     | <span class='neutral'>/// the existing one. Ex: Inherit from MagicCurveLpRewardHandlerDataV2 in case of a V2 version.</span>
 17 |     | <span class='unexecuted'>contract MagicCurveLpRewardHandler is MagicCurveLpRewardHandlerDataV1, IMagicCurveLpRewardHandler {</span>
 18 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    event LogStakingChanged(ICurveRewardGauge indexed previousStaking, ICurveRewardGauge indexed currentStaking);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    ////////////////////////////////////////////////////////////////////////////////</span>
 23 |     | <span class='neutral'>    /// @dev Avoid adding storage variable in this contract.</span>
 24 |     | <span class='neutral'>    /// Use MagicCurveLpRewardHandlerData instead.</span>
 25 |     | <span class='neutral'>    ////////////////////////////////////////////////////////////////////////////////</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    /// @notice harvests rewards from the staking contract and distributes them to the vault</span>
 28 |     | <span class='neutral'>    /// @param to Address to send the rewards to</span>
 29 |     | <span class='unexecuted'>    function harvest(address to) external override onlyOperators {</span>
 30 |     | <span class='unexecuted'>        _staking.claim_rewards(address(this), to);</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    /// @notice distributes rewards to the staking contract</span>
 34 |     | <span class='neutral'>    /// @param amount Amount of rewards to distribute</span>
 35 |     | <span class='unexecuted'>    function distributeRewards(uint256 amount) external override onlyOperators {</span>
 36 |     | <span class='unexecuted'>        _asset.transferFrom(msg.sender, address(this), amount);</span>
 37 |     | <span class='unexecuted'>        _staking.deposit(amount, address(this), false);</span>
 38 |     | <span class='unexecuted'>        _totalAssets += amount;</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /// @notice Skims excess assets from the staking contract and current contract balance</span>
 42 |     | <span class='unexecuted'>    function skimAssets() external override onlyOwner returns (uint256 excessStakedAmount, uint256 excessLpAmount) {</span>
 43 |     | <span class='unexecuted'>        uint256 stakedAmount = _staking.balanceOf(address(this));</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='unexecuted'>        excessStakedAmount = stakedAmount - _totalAssets;</span>
 46 |     | <span class='unexecuted'>        excessLpAmount = _asset.balanceOf(address(this));</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>        _staking.withdraw(excessStakedAmount);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='unexecuted'>        uint total = _asset.balanceOf(address(this));</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='unexecuted'>        if (total &gt; 0) {</span>
 53 |     | <span class='unexecuted'>            _asset.transfer(msg.sender, total);</span>
 54 |     | <span class='neutral'>        }</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    /// @notice Sets the staking contract and pid and approves the staking contract to spend the asset</span>
 58 |     | <span class='neutral'>    /// @param __staking Staking contract</span>
 59 |     | <span class='unexecuted'>    function setStaking(ICurveRewardGauge __staking) external override onlyOwner {</span>
 60 |     | <span class='unexecuted'>        emit LogStakingChanged(_staking, __staking);</span>
 61 |     | <span class='unexecuted'>        _staking = __staking;</span>
 62 |     | <span class='unexecuted'>        _asset.approve(address(__staking), type(uint256).max);</span>
 63 |     | <span class='neutral'>    }</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='neutral'>    /// @notice Returns the staking contract and pid</span>
 66 |     | <span class='unexecuted'>    function staking() external view override returns (ICurveRewardGauge) {</span>
 67 |     | <span class='unexecuted'>        return _staking;</span>
 68 |     | <span class='neutral'>    }</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>    ////////////////////////////////////////////////////////////////////////////////</span>
 71 |     | <span class='neutral'>    // Private Delegate Functions</span>
 72 |     | <span class='neutral'>    // Only allowed to be called by the MagicCurveLp contract</span>
 73 |     | <span class='neutral'>    ////////////////////////////////////////////////////////////////////////////////</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='neutral'>    /// @notice Stakes the asset in the staking contract</span>
 76 |     | <span class='unexecuted'>    function stakeAsset(uint256 amount) external override {</span>
 77 |     | <span class='unexecuted'>        _staking.deposit(amount, address(this), false);</span>
 78 |     | <span class='neutral'>    }</span>
 79 |     | <span class='neutral'></span>
 80 |     | <span class='neutral'>    /// @notice Unstakes the asset in the staking contract</span>
 81 |     | <span class='unexecuted'>    function unstakeAsset(uint256 amount) external override {</span>
 82 |     | <span class='unexecuted'>        _staking.withdraw(amount);</span>
 83 |     | <span class='neutral'>    }</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='neutral'>    /// @notice Private functions are not meant to be called by the fallback function directly</span>
 86 |     | <span class='neutral'>    /// as they would compromise the state of the contract.</span>
 87 |     | <span class='unexecuted'>    function isPrivateDelegateFunction(bytes4 sig) external pure returns (bool) {</span>
 88 |     | <span class='unexecuted'>        return sig == this.stakeAsset.selector || sig == this.unstakeAsset.selector;</span>
 89 |     | <span class='neutral'>    }</span>
 90 |     | <span class='neutral'>}</span>
 91 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/MagicGlpHarvestor.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import {BoringOwnable} from &quot;BoringSolidity/BoringOwnable.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Operatable} from &quot;mixins/Operatable.sol&quot;;</span>
   8 |     | <span class='neutral'>import {IMagicGlpRewardHandler} from &quot;interfaces/IMagicGlpRewardHandler.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IGmxGlpRewardRouter, IGmxRewardRouterV2, IGmxRewardTracker} from &quot;interfaces/IGmxV1.sol&quot;;</span>
  10 |     | <span class='neutral'>import {IWETHAlike} from &quot;interfaces/IWETH.sol&quot;;</span>
  11 |     | <span class='neutral'>import {IERC4626} from &quot;interfaces/IERC4626.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>/// @dev Glp harvester version that swap the reward to USDC to mint glp</span>
  14 |     | <span class='neutral'>/// and transfer them back in GmxGlpVault token for auto compounding</span>
  15 |     | <span class='unexecuted'>contract MagicGlpHarvestor is Operatable {</span>
  16 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
  17 |     | <span class='neutral'>    using BoringERC20 for IWETHAlike;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    error ErrInvalidFeePercent();</span>
  20 |     | <span class='neutral'>    error ErrNotRewardToken();</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    event LogFeeParametersChanged(address indexed feeCollector, uint16 feeAmount);</span>
  23 |     | <span class='neutral'>    event LogRewardRouterV2Changed(IGmxRewardRouterV2 indexed, IGmxRewardRouterV2 indexed);</span>
  24 |     | <span class='neutral'>    event LogHarvest(uint256 total, uint256 amount, uint256 fee);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>    uint256 public constant BIPS = 10_000;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    IMagicGlpRewardHandler public immutable vault;</span>
  29 |     | <span class='unexecuted'>    IERC20 public immutable asset;</span>
  30 |     | <span class='unexecuted'>    IWETHAlike public immutable rewardToken;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>    IGmxRewardRouterV2 public rewardRouterV2;</span>
  33 |     | <span class='unexecuted'>    IGmxGlpRewardRouter public glpRewardRouter;</span>
  34 |     | <span class='unexecuted'>    uint64 public lastExecution;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    address public feeCollector;</span>
  37 |     | <span class='unexecuted'>    uint16 public feePercentBips;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    bool public useDistributeRewardsFeature;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>    constructor(</span>
  42 |     | <span class='neutral'>        IWETHAlike _rewardToken,</span>
  43 |     | <span class='neutral'>        IGmxRewardRouterV2 _rewardRouterV2,</span>
  44 |     | <span class='neutral'>        IGmxGlpRewardRouter _glpRewardRouter,</span>
  45 |     | <span class='neutral'>        IMagicGlpRewardHandler _vault,</span>
  46 |     | <span class='neutral'>        bool _useDistributeRewardsFeature</span>
  47 |     | <span class='neutral'>    ) {</span>
  48 |     | <span class='unexecuted'>        rewardToken = _rewardToken;</span>
  49 |     | <span class='unexecuted'>        rewardRouterV2 = _rewardRouterV2;</span>
  50 |     | <span class='unexecuted'>        glpRewardRouter = _glpRewardRouter;</span>
  51 |     | <span class='unexecuted'>        vault = _vault;</span>
  52 |     | <span class='unexecuted'>        useDistributeRewardsFeature = _useDistributeRewardsFeature;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>        asset = IERC4626(address(vault)).asset();</span>
  55 |     | <span class='unexecuted'>        asset.approve(address(_vault), type(uint256).max);</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    // Only accept native reward token from rewardToken.withdraw calls</span>
  59 |     | <span class='neutral'>    receive() external payable virtual {</span>
  60 |     | <span class='unexecuted'>        if (msg.sender != address(rewardToken)) {</span>
  61 |     | <span class='unexecuted'>            revert ErrNotRewardToken();</span>
  62 |     | <span class='neutral'>        }</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function claimable() external view returns (uint256) {</span>
  66 |     | <span class='unexecuted'>        return</span>
  67 |     | <span class='unexecuted'>            IGmxRewardTracker(rewardRouterV2.feeGmxTracker()).claimable(address(vault)) +</span>
  68 |     | <span class='unexecuted'>            IGmxRewardTracker(rewardRouterV2.feeGlpTracker()).claimable(address(vault));</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /// @dev if deploying a new version of this contract, add `+ address(this).balance` as well.</span>
  72 |     | <span class='neutral'>    /// keeping it as is to match what is currently onchain.</span>
  73 |     | <span class='unexecuted'>    function totalRewardsBalanceAfterClaiming() external view returns (uint256) {</span>
  74 |     | <span class='neutral'>        return</span>
  75 |     | <span class='unexecuted'>            rewardToken.balanceOf(address(vault)) +</span>
  76 |     | <span class='unexecuted'>            rewardToken.balanceOf(address(this)) +</span>
  77 |     | <span class='unexecuted'>            IGmxRewardTracker(rewardRouterV2.feeGmxTracker()).claimable(address(vault)) +</span>
  78 |     | <span class='unexecuted'>            IGmxRewardTracker(rewardRouterV2.feeGlpTracker()).claimable(address(vault));</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>    function run(uint256 minGlp, uint256 rewardAmount) external onlyOperators {</span>
  82 |     | <span class='unexecuted'>        vault.harvest();</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>        rewardToken.safeTransferFrom(address(vault), address(this), rewardToken.balanceOf(address(vault)));</span>
  85 |     | <span class='unexecuted'>        rewardToken.withdraw(rewardToken.balanceOf(address(this)));</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>        if (rewardAmount &gt; address(this).balance) {</span>
  88 |     | <span class='unexecuted'>            rewardAmount = address(this).balance;</span>
  89 |     | <span class='neutral'>        }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>        uint256 total = glpRewardRouter.mintAndStakeGlpETH{value: rewardAmount}(0, minGlp);</span>
  92 |     | <span class='unexecuted'>        uint256 assetAmount = total;</span>
  93 |     | <span class='unexecuted'>        uint256 feeAmount = (total * feePercentBips) / BIPS;</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>        if (feeAmount &gt; 0) {</span>
  96 |     | <span class='unexecuted'>            assetAmount -= feeAmount;</span>
  97 |     | <span class='unexecuted'>            asset.safeTransfer(feeCollector, feeAmount);</span>
  98 |     | <span class='neutral'>        }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>        if (useDistributeRewardsFeature) {</span>
 101 |     | <span class='unexecuted'>            vault.distributeRewards(assetAmount);</span>
 102 |     | <span class='neutral'>        } else {</span>
 103 |     | <span class='unexecuted'>            asset.safeTransfer(address(vault), assetAmount);</span>
 104 |     | <span class='neutral'>        }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>        lastExecution = uint64(block.timestamp);</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>        emit LogHarvest(total, assetAmount, feeAmount);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>    function setRewardRouterV2(IGmxRewardRouterV2 _rewardRouterV2) external onlyOwner {</span>
 112 |     | <span class='unexecuted'>        emit LogRewardRouterV2Changed(rewardRouterV2, _rewardRouterV2);</span>
 113 |     | <span class='unexecuted'>        rewardRouterV2 = _rewardRouterV2;</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>    function setFeeParameters(address _feeCollector, uint16 _feePercentBips) external onlyOwner {</span>
 117 |     | <span class='unexecuted'>        if (feePercentBips &gt; BIPS) {</span>
 118 |     | <span class='unexecuted'>            revert ErrInvalidFeePercent();</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>        feeCollector = _feeCollector;</span>
 122 |     | <span class='unexecuted'>        feePercentBips = _feePercentBips;</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>        emit LogFeeParametersChanged(_feeCollector, _feePercentBips);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'>}</span>
 127 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/MagicGlpRewardHandler.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20, BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import {BoringOwnable} from &quot;BoringSolidity/BoringOwnable.sol&quot;;</span>
   6 |     | <span class='neutral'>import {MagicGlpData} from &quot;tokens/MagicGlp.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IGmxGlpManager, IGmxRewardRouterV2, IGmxStakedGlp, IGmxVester} from &quot;interfaces/IGmxV1.sol&quot;;</span>
   8 |     | <span class='neutral'>import {IMagicGlpRewardHandler} from &quot;interfaces/IMagicGlpRewardHandler.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/// @dev in case of V2, if adding new variable create MagicGlpRewardHandlerDataV2 that inherits</span>
  11 |     | <span class='neutral'>/// from MagicGlpRewardHandlerDataV1</span>
  12 |     | <span class='unexecuted'>contract MagicGlpRewardHandlerDataV1 is MagicGlpData {</span>
  13 |     | <span class='neutral'>    /// @dev V1 variables, do not change.</span>
  14 |     | <span class='unexecuted'>    IGmxRewardRouterV2 public rewardRouter;</span>
  15 |     | <span class='neutral'>}</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>/// @dev When making a new version, never change existing variables, always add after</span>
  18 |     | <span class='neutral'>/// the existing one. Ex: Inherit from GmxGlpVaultRewardHandlerDataV2 in case of a V2 version.</span>
  19 |     | <span class='unexecuted'>contract MagicGlpRewardHandler is MagicGlpRewardHandlerDataV1, IMagicGlpRewardHandler {</span>
  20 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    event LogRewardRouterChanged(IGmxRewardRouterV2 indexed previous, IGmxRewardRouterV2 indexed current);</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    ////////////////////////////////////////////////////////////////////////////////</span>
  25 |     | <span class='neutral'>    /// @dev Avoid adding storage variable here</span>
  26 |     | <span class='neutral'>    /// Should use GmxGlpVaultData instead.</span>
  27 |     | <span class='neutral'>    ////////////////////////////////////////////////////////////////////////////////</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    function harvest() external onlyStrategyExecutor {</span>
  30 |     | <span class='unexecuted'>        rewardRouter.handleRewards({</span>
  31 |     | <span class='neutral'>            shouldClaimGmx: true,</span>
  32 |     | <span class='neutral'>            shouldStakeGmx: true,</span>
  33 |     | <span class='neutral'>            shouldClaimEsGmx: true,</span>
  34 |     | <span class='neutral'>            shouldStakeEsGmx: true,</span>
  35 |     | <span class='neutral'>            shouldStakeMultiplierPoints: true,</span>
  36 |     | <span class='neutral'>            shouldClaimWeth: true,</span>
  37 |     | <span class='neutral'>            shouldConvertWethToEth: false</span>
  38 |     | <span class='neutral'>        });</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>    function distributeRewards(uint256 amount) external onlyStrategyExecutor {</span>
  42 |     | <span class='unexecuted'>        _asset.transferFrom(msg.sender, address(this), amount);</span>
  43 |     | <span class='unexecuted'>        _totalAssets += amount;</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>    function skimAssets() external onlyOwner returns (uint256 amount) {</span>
  47 |     | <span class='unexecuted'>        amount = _asset.balanceOf(address(this)) - _totalAssets;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>        if (amount &gt; 0) {</span>
  50 |     | <span class='unexecuted'>            _asset.transfer(msg.sender, amount);</span>
  51 |     | <span class='neutral'>        }</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>    function setRewardRouter(IGmxRewardRouterV2 _rewardRouter) external onlyOwner {</span>
  55 |     | <span class='unexecuted'>        emit LogRewardRouterChanged(rewardRouter, _rewardRouter);</span>
  56 |     | <span class='unexecuted'>        rewardRouter = _rewardRouter;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>    function setTokenAllowance(IERC20 token, address spender, uint256 amount) external onlyOwner {</span>
  60 |     | <span class='unexecuted'>        token.approve(spender, amount);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    ///////////////////////////////////////////////////////////////////////</span>
  64 |     | <span class='neutral'>    // esGMX Vesting Handling</span>
  65 |     | <span class='neutral'>    // Adapted from RageTrade contract code</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /// @notice unstakes and vest protocol esGmx to convert it to Gmx</span>
  68 |     | <span class='unexecuted'>    function unstakeGmx(uint256 amount, uint256 amountToTransferToSender, address recipient) external onlyOwner {</span>
  69 |     | <span class='unexecuted'>        IERC20 gmx = IERC20(rewardRouter.gmx());</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>        if (amount &gt; 0) {</span>
  72 |     | <span class='unexecuted'>            rewardRouter.unstakeGmx(amount);</span>
  73 |     | <span class='neutral'>        }</span>
  74 |     | <span class='unexecuted'>        if (amountToTransferToSender &gt; 0) {</span>
  75 |     | <span class='unexecuted'>            uint256 gmxAmount = gmx.balanceOf(address(this));</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>            if (amountToTransferToSender &lt; gmxAmount) {</span>
  78 |     | <span class='unexecuted'>                gmxAmount = amountToTransferToSender;</span>
  79 |     | <span class='neutral'>            }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>            gmx.safeTransfer(recipient, gmxAmount);</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /// @notice unstakes and vest protocol esGmx to convert it to Gmx</span>
  86 |     | <span class='unexecuted'>    function unstakeEsGmxAndVest(uint256 amount, uint256 glpVesterDepositAmount, uint256 gmxVesterDepositAmount) external onlyOwner {</span>
  87 |     | <span class='unexecuted'>        if (amount &gt; 0) {</span>
  88 |     | <span class='unexecuted'>            rewardRouter.unstakeEsGmx(amount);</span>
  89 |     | <span class='neutral'>        }</span>
  90 |     | <span class='unexecuted'>        if (glpVesterDepositAmount &gt; 0) {</span>
  91 |     | <span class='unexecuted'>            IGmxVester(rewardRouter.glpVester()).deposit(glpVesterDepositAmount);</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='unexecuted'>        if (gmxVesterDepositAmount &gt; 0) {</span>
  94 |     | <span class='unexecuted'>            IGmxVester(rewardRouter.gmxVester()).deposit(gmxVesterDepositAmount);</span>
  95 |     | <span class='neutral'>        }</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /// @notice claims vested gmx tokens (i.e. stops vesting esGmx so that the relevant glp amount is unlocked)</span>
  99 |     | <span class='neutral'>    /// This will withdraw and unreserve all tokens as well as pause vesting. esGMX tokens that have been converted</span>
 100 |     | <span class='neutral'>    /// to GMX will remain as GMX tokens.</span>
 101 |     | <span class='unexecuted'>    function withdrawFromVesting(bool withdrawFromGlpVester, bool withdrawFromGmxVester, bool stake) external onlyOwner {</span>
 102 |     | <span class='unexecuted'>        if (withdrawFromGlpVester) {</span>
 103 |     | <span class='unexecuted'>            IGmxVester(rewardRouter.glpVester()).withdraw();</span>
 104 |     | <span class='neutral'>        }</span>
 105 |     | <span class='unexecuted'>        if (withdrawFromGmxVester) {</span>
 106 |     | <span class='unexecuted'>            IGmxVester(rewardRouter.gmxVester()).withdraw();</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        if (stake) {</span>
 110 |     | <span class='unexecuted'>            uint256 esGmxWithdrawn = IERC20(rewardRouter.esGmx()).balanceOf(address(this));</span>
 111 |     | <span class='unexecuted'>            rewardRouter.stakeEsGmx(esGmxWithdrawn);</span>
 112 |     | <span class='neutral'>        }</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    /// @notice claims vested gmx tokens and optionnaly stake or transfer to feeRecipient</span>
 116 |     | <span class='neutral'>    /// @dev vested esGmx gets converted to GMX every second, so whatever amount is vested gets claimed</span>
 117 |     | <span class='unexecuted'>    function claimVestedGmx(bool withdrawFromGlpVester, bool withdrawFromGmxVester, bool stake, bool transferToOwner) external onlyOwner {</span>
 118 |     | <span class='unexecuted'>        IERC20 gmx = IERC20(rewardRouter.gmx());</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>        if (withdrawFromGlpVester) {</span>
 121 |     | <span class='unexecuted'>            IGmxVester(rewardRouter.glpVester()).claim();</span>
 122 |     | <span class='neutral'>        }</span>
 123 |     | <span class='unexecuted'>        if (withdrawFromGmxVester) {</span>
 124 |     | <span class='unexecuted'>            IGmxVester(rewardRouter.gmxVester()).claim();</span>
 125 |     | <span class='neutral'>        }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>        uint256 gmxAmount = gmx.balanceOf(address(this));</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>        if (stake) {</span>
 130 |     | <span class='unexecuted'>            gmx.approve(address(rewardRouter.stakedGmxTracker()), gmxAmount);</span>
 131 |     | <span class='unexecuted'>            rewardRouter.stakeGmx(gmxAmount);</span>
 132 |     | <span class='unexecuted'>        } else if (transferToOwner) {</span>
 133 |     | <span class='unexecuted'>            gmx.safeTransfer(owner, gmxAmount);</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'>}</span>
 137 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/MasterContractConfigurationRegistry.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Owned} from &quot;solmate/auth/Owned.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ICauldronV1} from &quot;interfaces/ICauldronV1.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>struct MasterContractConfiguration {</span>
  8 |     | <span class='neutral'>    uint24 collaterizationRate;</span>
  9 |     | <span class='neutral'>    uint24 liquidationMultiplier;</span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>contract MasterContractConfigurationRegistry is Owned {</span>
 13 |     | <span class='neutral'>    error ErrInvalidConfigration();</span>
 14 |     | <span class='neutral'>    error ErrInvalidMasterContract(ICauldronV1 masterContract);</span>
 15 |     | <span class='neutral'>    error ErrLengthMismatch();</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    mapping(ICauldronV1 =&gt; MasterContractConfiguration) public configurations;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    constructor(address owner_) Owned(owner_) {}</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    function setConfigurations(</span>
 22 |     | <span class='neutral'>        ICauldronV1[] calldata masterContracts_,</span>
 23 |     | <span class='neutral'>        MasterContractConfiguration[] calldata configurations_</span>
 24 |     | <span class='neutral'>    ) external onlyOwner {</span>
 25 |     | <span class='unexecuted'>        if (masterContracts_.length != configurations_.length) {</span>
 26 |     | <span class='unexecuted'>            revert ErrLengthMismatch();</span>
 27 |     | <span class='neutral'>        }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; masterContracts_.length; ++i) {</span>
 30 |     | <span class='unexecuted'>            ICauldronV1 masterContract = masterContracts_[i];</span>
 31 |     | <span class='unexecuted'>            MasterContractConfiguration calldata configuration = configurations_[i];</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='unexecuted'>            if (address(masterContract) == address(0)) {</span>
 34 |     | <span class='unexecuted'>                revert ErrInvalidMasterContract(masterContract);</span>
 35 |     | <span class='neutral'>            }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>            if (configuration.collaterizationRate == 0 || configuration.liquidationMultiplier == 0) {</span>
 38 |     | <span class='unexecuted'>                revert ErrInvalidConfigration();</span>
 39 |     | <span class='neutral'>            }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='unexecuted'>            configurations[masterContract] = configuration;</span>
 42 |     | <span class='neutral'>        }</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='unexecuted'>    function removeConfigurations(ICauldronV1[] calldata masterContracts_) external onlyOwner {</span>
 46 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; masterContracts_.length; ++i) {</span>
 47 |     | <span class='unexecuted'>            ICauldronV1 masterContract = masterContracts_[i];</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='unexecuted'>            if (address(masterContract) == address(0)) {</span>
 50 |     | <span class='unexecuted'>                revert ErrInvalidMasterContract(masterContract);</span>
 51 |     | <span class='neutral'>            }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='unexecuted'>            delete configurations[masterContract];</span>
 54 |     | <span class='neutral'>        }</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'>}</span>
 57 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/OracleUpdater.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ICauldronV1} from &quot;interfaces/ICauldronV1.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ICauldronV2} from &quot;interfaces/ICauldronV2.sol&quot;;</span>
  6 |     | <span class='neutral'>import {CauldronRegistry} from &quot;periphery/CauldronRegistry.sol&quot;;</span>
  7 |     | <span class='neutral'>import {MasterContractConfigurationRegistry} from &quot;periphery/MasterContractConfigurationRegistry.sol&quot;;</span>
  8 |     | <span class='neutral'>import {Owned} from &quot;solmate/auth/Owned.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>interface IOracleUpdater {</span>
 11 |     | <span class='neutral'>    function updateCauldrons(ICauldronV1[] memory cauldrons_) external;</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>interface IGelatoChecker {</span>
 15 |     | <span class='neutral'>    function checker() external view returns (bool canExec, bytes memory execPayload);</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>contract OracleUpdater is IOracleUpdater, IGelatoChecker {</span>
 19 |     | <span class='neutral'>    uint256 private constant EXCHANGERATE_PRECISION = 1e18;</span>
 20 |     | <span class='unexecuted'>    uint256 private constant COLLATERIZATION_RATE_PRECISION = 1e5;</span>
 21 |     | <span class='unexecuted'>    uint256 private constant LIQUIDATION_MULTIPLIER_PRECISION = 1e5;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    CauldronRegistry cauldronRegistry;</span>
 24 |     | <span class='neutral'>    MasterContractConfigurationRegistry masterContractConfigurationRegistry;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    constructor(CauldronRegistry cauldronRegistry_, MasterContractConfigurationRegistry masterContractConfigurationRegistry_) {</span>
 27 |     | <span class='unexecuted'>        cauldronRegistry = cauldronRegistry_;</span>
 28 |     | <span class='unexecuted'>        masterContractConfigurationRegistry = masterContractConfigurationRegistry_;</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function updateCauldrons(ICauldronV1[] calldata cauldrons_) external override {</span>
 32 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; cauldrons_.length; ++i) {</span>
 33 |     | <span class='unexecuted'>            cauldrons_[i].updateExchangeRate();</span>
 34 |     | <span class='neutral'>        }</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function checker() external view override returns (bool canExec, bytes memory execPayload) {</span>
 38 |     | <span class='unexecuted'>        canExec = false;</span>
 39 |     | <span class='unexecuted'>        uint256 len;</span>
 40 |     | <span class='unexecuted'>        uint256 cauldronsLength = cauldronRegistry.cauldronsLength();</span>
 41 |     | <span class='unexecuted'>        bool[] memory isToBeUpdated = new bool[](cauldronsLength);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; cauldronsLength; ++i) {</span>
 44 |     | <span class='unexecuted'>            ICauldronV1 cauldron = cauldronRegistry.cauldrons(i);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>            (uint256 collaterizationRate, uint256 liquidationMultiplier) = masterContractConfigurationRegistry.configurations(</span>
 47 |     | <span class='unexecuted'>                cauldron.masterContract()</span>
 48 |     | <span class='neutral'>            );</span>
 49 |     | <span class='unexecuted'>            if (collaterizationRate == 0) {</span>
 50 |     | <span class='neutral'>                // Not registered --- assume V2 plus</span>
 51 |     | <span class='unexecuted'>                collaterizationRate = ICauldronV2(address(cauldron)).COLLATERIZATION_RATE();</span>
 52 |     | <span class='unexecuted'>                liquidationMultiplier = ICauldronV2(address(cauldron)).LIQUIDATION_MULTIPLIER();</span>
 53 |     | <span class='neutral'>            }</span>
 54 |     | <span class='unexecuted'>            uint256 collateralizationDelta = COLLATERIZATION_RATE_PRECISION - collaterizationRate;</span>
 55 |     | <span class='unexecuted'>            uint256 liquidationDelta = liquidationMultiplier - LIQUIDATION_MULTIPLIER_PRECISION;</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='unexecuted'>            (, uint256 currentRate) = cauldron.oracle().peek(cauldron.oracleData());</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>            uint256 staleRate = cauldron.exchangeRate();</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='neutral'>            // Effectively staleRate * (1 - LTV)</span>
 62 |     | <span class='unexecuted'>            uint256 collaterizationBuffer = (staleRate * collateralizationDelta) / COLLATERIZATION_RATE_PRECISION;</span>
 63 |     | <span class='neutral'>            // Effectively staleRate * (liquidationMultiplier - 1)</span>
 64 |     | <span class='unexecuted'>            uint256 liquidationBuffer = (staleRate * liquidationDelta) / LIQUIDATION_MULTIPLIER_PRECISION;</span>
 65 |     | <span class='unexecuted'>            if (staleRate + collaterizationBuffer - liquidationBuffer &lt; currentRate) {</span>
 66 |     | <span class='unexecuted'>                canExec = true;</span>
 67 |     | <span class='unexecuted'>                isToBeUpdated[i] = true;</span>
 68 |     | <span class='neutral'>                unchecked {</span>
 69 |     | <span class='unexecuted'>                    len++;</span>
 70 |     | <span class='neutral'>                }</span>
 71 |     | <span class='neutral'>            }</span>
 72 |     | <span class='neutral'>        }</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='unexecuted'>        ICauldronV1[] memory toBeUpdated = new ICauldronV1[](len);</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; cauldronsLength; ++i) {</span>
 77 |     | <span class='unexecuted'>            if (isToBeUpdated[i]) {</span>
 78 |     | <span class='unexecuted'>                toBeUpdated[toBeUpdated.length - len] = cauldronRegistry.cauldrons(i);</span>
 79 |     | <span class='neutral'>                unchecked {</span>
 80 |     | <span class='unexecuted'>                    --len;</span>
 81 |     | <span class='neutral'>                }</span>
 82 |     | <span class='neutral'>            }</span>
 83 |     | <span class='neutral'>        }</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='unexecuted'>        execPayload = abi.encodeCall(IOracleUpdater.updateCauldrons, (toBeUpdated));</span>
 86 |     | <span class='neutral'>    }</span>
 87 |     | <span class='neutral'>}</span>
 88 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/RepayHelper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ERC20} from &quot;BoringSolidity/ERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import {RebaseLibrary, Rebase} from &quot;BoringSolidity/libraries/BoringRebase.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BoringERC20, IERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Operatable} from &quot;mixins/Operatable.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ICauldronV4} from &quot;interfaces/ICauldronV4.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>contract RepayHelper {</span>
  12 |     | <span class='neutral'>    using RebaseLibrary for Rebase;</span>
  13 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>    IERC20 public immutable magicInternetMoney;</span>
  16 |     | <span class='unexecuted'>    address public constant multisig = 0x5f0DeE98360d8200b20812e174d139A1a633EDd2;</span>
  17 |     | <span class='unexecuted'>    address public constant safe = 0xDF2C270f610Dc35d8fFDA5B453E74db5471E126B;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    error ErrNotAllowed();</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    event LogTotalRepaid(ICauldronV4 indexed cauldron, uint256 amount);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    modifier onlySafe() {</span>
  24 |     | <span class='unexecuted'>        if (msg.sender != safe) {</span>
  25 |     | <span class='unexecuted'>            revert ErrNotAllowed();</span>
  26 |     | <span class='neutral'>        }</span>
  27 |     | <span class='neutral'>        _;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    modifier onlyMultisig() {</span>
  31 |     | <span class='unexecuted'>        if (msg.sender != multisig) {</span>
  32 |     | <span class='unexecuted'>            revert ErrNotAllowed();</span>
  33 |     | <span class='neutral'>        }</span>
  34 |     | <span class='neutral'>        _;</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>    constructor(IERC20 magicInternetMoney_) {</span>
  38 |     | <span class='unexecuted'>        magicInternetMoney = magicInternetMoney_;</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /// @notice Repays a loan.</span>
  42 |     | <span class='neutral'>    /// @param to Address of the user this payment should go.</span>
  43 |     | <span class='neutral'>    /// @param cauldron cauldron on which it is repaid</span>
  44 |     | <span class='neutral'>    /// @param amount The amount to repay.</span>
  45 |     | <span class='neutral'>    /// @return part The total part repayed.</span>
  46 |     | <span class='unexecuted'>    function repayAmount(address to, ICauldronV4 cauldron, uint256 amount) public onlySafe returns (uint256 part) {</span>
  47 |     | <span class='unexecuted'>        cauldron.accrue();</span>
  48 |     | <span class='unexecuted'>        Rebase memory totalBorrow = cauldron.totalBorrow();</span>
  49 |     | <span class='unexecuted'>        part = totalBorrow.toBase(amount - 1, true);</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>        cauldron.repay(to, true, part);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /// @notice Repays multiple loans completely</span>
  55 |     | <span class='neutral'>    /// @param to Address of the users this payment should go.</span>
  56 |     | <span class='neutral'>    /// @param cauldron cauldron on which it is repaid</span>
  57 |     | <span class='unexecuted'>    function repayTotal(address[] calldata to, ICauldronV4 cauldron) external onlySafe returns (uint256 amount) {</span>
  58 |     | <span class='unexecuted'>        cauldron.accrue();</span>
  59 |     | <span class='unexecuted'>        Rebase memory totalBorrow = cauldron.totalBorrow();</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>        uint totalPart;</span>
  62 |     | <span class='unexecuted'>        for (uint i; i &lt; to.length; i++) {</span>
  63 |     | <span class='unexecuted'>            totalPart += cauldron.userBorrowPart(to[i]);</span>
  64 |     | <span class='neutral'>        }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>        amount = totalBorrow.toElastic(totalPart + 1e6, true);</span>
  67 |     | <span class='unexecuted'>        IBentoBoxV1 bentoBox = IBentoBoxV1(address(cauldron.bentoBox()));</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>        magicInternetMoney.safeTransferFrom(safe, address(bentoBox), amount);</span>
  70 |     | <span class='unexecuted'>        bentoBox.deposit(magicInternetMoney, address(bentoBox), address(bentoBox), amount, 0);</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>        for (uint i; i &lt; to.length; i++) {</span>
  73 |     | <span class='unexecuted'>            cauldron.repay(to[i], true, cauldron.userBorrowPart(to[i]));</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>        emit LogTotalRepaid(cauldron, amount);</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    /// @notice Repays multiple loans completely</span>
  80 |     | <span class='neutral'>    /// @param to Address of the users this payment should go.</span>
  81 |     | <span class='neutral'>    /// @param cauldron cauldron on which it is repaid</span>
  82 |     | <span class='unexecuted'>    function repayTotalMultisig(address[] calldata to, ICauldronV4 cauldron) external onlyMultisig returns (uint256 amount) {</span>
  83 |     | <span class='unexecuted'>        cauldron.accrue();</span>
  84 |     | <span class='unexecuted'>        Rebase memory totalBorrow = cauldron.totalBorrow();</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>        uint totalPart;</span>
  87 |     | <span class='unexecuted'>        for (uint i; i &lt; to.length; i++) {</span>
  88 |     | <span class='unexecuted'>            totalPart += cauldron.userBorrowPart(to[i]);</span>
  89 |     | <span class='neutral'>        }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>        amount = totalBorrow.toElastic(totalPart + 1e6, true);</span>
  92 |     | <span class='unexecuted'>        IBentoBoxV1 bentoBox = IBentoBoxV1(address(cauldron.bentoBox()));</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        magicInternetMoney.safeTransferFrom(multisig, address(bentoBox), amount);</span>
  95 |     | <span class='unexecuted'>        bentoBox.deposit(magicInternetMoney, address(bentoBox), address(bentoBox), amount, 0);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>        for (uint i; i &lt; to.length; i++) {</span>
  98 |     | <span class='unexecuted'>            cauldron.repay(to[i], true, cauldron.userBorrowPart(to[i]));</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>        emit LogTotalRepaid(cauldron, amount);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'>}</span>
 104 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/SpellStakingRewardDistributor.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>/// solhint-disable not-rely-on-time</span>
   3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import {ERC20} from &quot;BoringSolidity/ERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
   8 |     | <span class='neutral'>import {OperatableV2} from &quot;mixins/OperatableV2.sol&quot;;</span>
   9 |     | <span class='neutral'>import {ILzReceiver, ILzApp, ILzOFTV2, ILzCommonOFT} from &quot;interfaces/ILayerZero.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/// @notice Responsible of distributing MIM rewards.</span>
  12 |     | <span class='neutral'>/// Mainnet Only</span>
  13 |     | <span class='unexecuted'>contract SpellStakingRewardDistributor is OperatableV2 {</span>
  14 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    event LogSetOperator(address indexed operator, bool status);</span>
  17 |     | <span class='neutral'>    event LogDistribute(Distribution indexed distribution);</span>
  18 |     | <span class='neutral'>    error ErrNotEnoughNativeTokenToCoverFee();</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    struct Distribution {</span>
  21 |     | <span class='neutral'>        // slot 0</span>
  22 |     | <span class='neutral'>        address recipient;</span>
  23 |     | <span class='neutral'>        uint80 gas; // lz  gas limit</span>
  24 |     | <span class='neutral'>        uint16 lzChainId; // lz chain id</span>
  25 |     | <span class='neutral'>        // slot 1</span>
  26 |     | <span class='neutral'>        uint128 fee; // lz fee</span>
  27 |     | <span class='neutral'>        uint128 amount;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>    ERC20 public constant MIM = ERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);</span>
  31 |     | <span class='unexecuted'>    ILzOFTV2 public constant OFT = ILzOFTV2(0x439a5f0f5E8d149DDA9a0Ca367D4a8e4D6f83C10);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>    constructor(address _owner) OperatableV2(_owner) {</span>
  34 |     | <span class='unexecuted'>        MIM.approve(address(OFT), type(uint256).max);</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    receive() external payable {}</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    function estimateBridgingFee(uint256 amount, uint16 lzChainId, address recipient) external view returns (uint256 fee, uint256 gas) {</span>
  40 |     | <span class='unexecuted'>        gas = ILzApp(address(OFT)).minDstGasLookup(lzChainId, 0 /* packet type for sendFrom */);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>        (fee, ) = OFT.estimateSendFee(</span>
  43 |     | <span class='unexecuted'>            lzChainId,</span>
  44 |     | <span class='unexecuted'>            bytes32(uint256(uint160(recipient))),</span>
  45 |     | <span class='unexecuted'>            amount,</span>
  46 |     | <span class='neutral'>            false,</span>
  47 |     | <span class='unexecuted'>            abi.encodePacked(uint16(1), uint256(gas))</span>
  48 |     | <span class='neutral'>        );</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>    function distribute(Distribution[] calldata distributions) external onlyOperators {</span>
  52 |     | <span class='unexecuted'>        uint256 length = distributions.length;</span>
  53 |     | <span class='unexecuted'>        for (uint256 i = 0; length &gt; i; ) {</span>
  54 |     | <span class='unexecuted'>            Distribution memory distribution = distributions[i];</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>            if (distribution.fee &gt; 0) {</span>
  57 |     | <span class='neutral'>                // optionnal check for convenience</span>
  58 |     | <span class='neutral'>                // check if there is enough native token to cover the bridging fees</span>
  59 |     | <span class='unexecuted'>                if (distribution.fee &gt; address(this).balance) {</span>
  60 |     | <span class='unexecuted'>                    revert ErrNotEnoughNativeTokenToCoverFee();</span>
  61 |     | <span class='neutral'>                }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>                ILzCommonOFT.LzCallParams memory lzCallParams = ILzCommonOFT.LzCallParams({</span>
  64 |     | <span class='unexecuted'>                    refundAddress: payable(address(this)),</span>
  65 |     | <span class='neutral'>                    zroPaymentAddress: address(0),</span>
  66 |     | <span class='unexecuted'>                    adapterParams: abi.encodePacked(uint16(1), uint256(distribution.gas))</span>
  67 |     | <span class='neutral'>                });</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>                OFT.sendFrom{value: distribution.fee}(</span>
  70 |     | <span class='unexecuted'>                    address(this),</span>
  71 |     | <span class='unexecuted'>                    uint16(distribution.lzChainId),</span>
  72 |     | <span class='unexecuted'>                    bytes32(uint256(uint160(distribution.recipient))),</span>
  73 |     | <span class='unexecuted'>                    distribution.amount,</span>
  74 |     | <span class='unexecuted'>                    lzCallParams</span>
  75 |     | <span class='neutral'>                );</span>
  76 |     | <span class='neutral'>            } else {</span>
  77 |     | <span class='unexecuted'>                MIM.transfer(distribution.recipient, distribution.amount);</span>
  78 |     | <span class='neutral'>            }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>            emit LogDistribute(distribution);</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>            unchecked {</span>
  83 |     | <span class='unexecuted'>                ++i;</span>
  84 |     | <span class='neutral'>            }</span>
  85 |     | <span class='neutral'>        }</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    ////////////////////////////////////////////////////////</span>
  89 |     | <span class='neutral'>    // Emergency Functions</span>
  90 |     | <span class='neutral'>    ////////////////////////////////////////////////////////</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>    function rescueTokens(IERC20 token, address to, uint256 amount) external onlyOwner {</span>
  93 |     | <span class='unexecuted'>        token.safeTransfer(to, amount);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>    function execute(address to, uint256 value, bytes calldata data) external onlyOwner returns (bool success, bytes memory result) {</span>
  97 |     | <span class='neutral'>        // solhint-disable-next-line avoid-low-level-calls</span>
  98 |     | <span class='unexecuted'>        (success, result) = to.call{value: value}(data);</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'>}</span>
 101 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/StargateLPMIMPool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BoringOwnable} from &quot;BoringSolidity/BoringOwnable.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Address} from &quot;openzeppelin-contracts/utils/Address.sol&quot;;</span>
   8 |     | <span class='neutral'>import {SafeApproveLib} from &quot;libraries/SafeApproveLib.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IStargatePool, IStargateRouter} from &quot;interfaces/IStargate.sol&quot;;</span>
  10 |     | <span class='neutral'>import {IOracle} from &quot;interfaces/IOracle.sol&quot;;</span>
  11 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>contract StargateLPMIMPool is BoringOwnable {</span>
  14 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
  15 |     | <span class='neutral'>    using SafeApproveLib for IERC20;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    error ErrSwapFailed();</span>
  18 |     | <span class='neutral'>    error ErrUnauthorizedRedeemer(address);</span>
  19 |     | <span class='neutral'>    error ErrUnauthorizedExecutor(address);</span>
  20 |     | <span class='neutral'>    error ErrInvalidToken(address);</span>
  21 |     | <span class='neutral'>    error ErrInvalidFee(uint256);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    event AllowedRedeemerChanged(address redeemer, bool allowed);</span>
  24 |     | <span class='neutral'>    event AllowedExecutorChanged(address redeemer, bool allowed);</span>
  25 |     | <span class='neutral'>    event Swap(address from, IStargatePool tokenIn, uint256 amountIn, uint256 amountOut, address recipient);</span>
  26 |     | <span class='neutral'>    event PoolChanged(IStargatePool lp, uint16 poolId, IOracle oracle);</span>
  27 |     | <span class='neutral'>    event FeeChanged(uint256 previousFeeBps, uint256 feeBps);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    struct PoolInfo {</span>
  30 |     | <span class='neutral'>        uint16 poolId; // 16 bits</span>
  31 |     | <span class='neutral'>        IOracle oracle; // 160 bits</span>
  32 |     | <span class='neutral'>        uint80 oracleDecimalsMultipler; // 80 bits</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    IERC20 public immutable mim;</span>
  36 |     | <span class='unexecuted'>    IAggregator public immutable mimOracle;</span>
  37 |     | <span class='unexecuted'>    IStargateRouter public immutable stargateRouter;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    uint256 public feeBps;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>    mapping(IStargatePool =&gt; PoolInfo) public pools;</span>
  42 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public allowedRedeemers;</span>
  43 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public allowedExecutors;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    modifier onlyAllowedRedeemers() {</span>
  46 |     | <span class='unexecuted'>        if (!allowedRedeemers[msg.sender]) {</span>
  47 |     | <span class='unexecuted'>            revert ErrUnauthorizedRedeemer(msg.sender);</span>
  48 |     | <span class='neutral'>        }</span>
  49 |     | <span class='neutral'>        _;</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    modifier onlyAllowedExecutors() {</span>
  53 |     | <span class='unexecuted'>        if (!allowedExecutors[msg.sender]) {</span>
  54 |     | <span class='unexecuted'>            revert ErrUnauthorizedExecutor(msg.sender);</span>
  55 |     | <span class='neutral'>        }</span>
  56 |     | <span class='neutral'>        _;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>    constructor(IERC20 _mim, IAggregator _mimOracle, IStargateRouter _stargateRouter) {</span>
  60 |     | <span class='unexecuted'>        feeBps = 20;</span>
  61 |     | <span class='unexecuted'>        mim = _mim;</span>
  62 |     | <span class='unexecuted'>        mimOracle = _mimOracle;</span>
  63 |     | <span class='unexecuted'>        stargateRouter = _stargateRouter;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>    function swapForMim(IStargatePool tokenIn, uint256 amountIn, address recipient) external onlyAllowedRedeemers returns (uint256) {</span>
  67 |     | <span class='unexecuted'>        if (address(pools[tokenIn].oracle) == address(0)) {</span>
  68 |     | <span class='unexecuted'>            revert ErrInvalidToken(address(tokenIn));</span>
  69 |     | <span class='neutral'>        }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>        uint256 amount = getMimAmountOut(tokenIn, amountIn);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        IERC20(address(tokenIn)).safeTransferFrom(msg.sender, address(this), amountIn);</span>
  74 |     | <span class='unexecuted'>        mim.safeTransfer(recipient, amount);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>        emit Swap(msg.sender, tokenIn, amountIn, amount, recipient);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>        return amount;</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>    function getMimAmountOut(IStargatePool tokenIn, uint256 amountIn) public view returns (uint256) {</span>
  82 |     | <span class='unexecuted'>        if (address(pools[tokenIn].oracle) == address(0)) {</span>
  83 |     | <span class='unexecuted'>            revert ErrInvalidToken(address(tokenIn));</span>
  84 |     | <span class='neutral'>        }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>        uint256 mimUsd = uint256(mimOracle.latestAnswer()); // 8 decimals</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        /// @dev for oracleDecimalsMultipler = 14 and tokenIn is 6 decimals -&gt; amountOut is 6 decimals</span>
  89 |     | <span class='unexecuted'>        uint256 amount = ((amountIn * 10 ** pools[tokenIn].oracleDecimalsMultipler) / pools[tokenIn].oracle.peekSpot(&quot;&quot;)) / mimUsd;</span>
  90 |     | <span class='unexecuted'>        return amount - ((amount * feeBps) / 10_000);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /*** Admin Functions ***/</span>
  94 |     | <span class='unexecuted'>    function setAllowedRedeemer(address redeemer, bool allowed) external onlyOwner {</span>
  95 |     | <span class='unexecuted'>        allowedRedeemers[redeemer] = allowed;</span>
  96 |     | <span class='unexecuted'>        emit AllowedRedeemerChanged(redeemer, allowed);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>    function setAllowedExecutor(address executor, bool allowed) external onlyOwner {</span>
 100 |     | <span class='unexecuted'>        allowedExecutors[executor] = allowed;</span>
 101 |     | <span class='unexecuted'>        emit AllowedExecutorChanged(executor, allowed);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>    function setFee(uint256 _feeBps) external onlyOwner {</span>
 105 |     | <span class='unexecuted'>        if (_feeBps &gt; 10_000) {</span>
 106 |     | <span class='unexecuted'>            revert ErrInvalidFee(_feeBps);</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='unexecuted'>        emit FeeChanged(feeBps, _feeBps);</span>
 109 |     | <span class='unexecuted'>        feeBps = _feeBps;</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>    function setPool(IStargatePool lp, uint16 poolId, IOracle oracle, uint80 oracleDecimalsMultipler) external onlyOwner {</span>
 113 |     | <span class='unexecuted'>        pools[lp] = PoolInfo({poolId: poolId, oracle: oracle, oracleDecimalsMultipler: oracleDecimalsMultipler});</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>        IERC20(address(lp)).safeApprove(address(stargateRouter), type(uint256).max);</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>        emit PoolChanged(lp, poolId, oracle);</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>    function getMaximumInstantRedeemable(IStargatePool lp) public view returns (uint256 max) {</span>
 121 |     | <span class='unexecuted'>        uint256 totalLiquidity = lp.totalLiquidity();</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>        if (totalLiquidity &gt; 0) {</span>
 124 |     | <span class='unexecuted'>            uint256 amountSD = lp.deltaCredit();</span>
 125 |     | <span class='unexecuted'>            max = (amountSD * lp.totalSupply()) / totalLiquidity;</span>
 126 |     | <span class='neutral'>        }</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /// @param dstChainId the chainId to remove liquidity</span>
 130 |     | <span class='neutral'>    /// @param srcPoolId the source poolId</span>
 131 |     | <span class='neutral'>    /// @param dstPoolId the destination poolId</span>
 132 |     | <span class='neutral'>    /// @param amount quantity of LP tokens to redeem</span>
 133 |     | <span class='neutral'>    /// @param txParams adpater parameters</span>
 134 |     | <span class='neutral'>    /// https://layerzero.gitbook.io/docs/technical-reference/mainnet/supported-chain-ids</span>
 135 |     | <span class='unexecuted'>    function redeemLocal(</span>
 136 |     | <span class='neutral'>        uint16 dstChainId,</span>
 137 |     | <span class='neutral'>        uint256 srcPoolId,</span>
 138 |     | <span class='neutral'>        uint256 dstPoolId,</span>
 139 |     | <span class='neutral'>        uint256 amount,</span>
 140 |     | <span class='neutral'>        IStargateRouter.lzTxObj memory txParams</span>
 141 |     | <span class='neutral'>    ) external payable onlyAllowedExecutors {</span>
 142 |     | <span class='unexecuted'>        stargateRouter.redeemLocal{value: msg.value}(</span>
 143 |     | <span class='unexecuted'>            dstChainId,</span>
 144 |     | <span class='unexecuted'>            srcPoolId,</span>
 145 |     | <span class='unexecuted'>            dstPoolId,</span>
 146 |     | <span class='unexecuted'>            payable(msg.sender),</span>
 147 |     | <span class='unexecuted'>            amount,</span>
 148 |     | <span class='unexecuted'>            abi.encodePacked(address(this)),</span>
 149 |     | <span class='unexecuted'>            txParams</span>
 150 |     | <span class='neutral'>        );</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>    function instantRedeemLocalMax(IStargatePool lp) external onlyAllowedExecutors {</span>
 154 |     | <span class='unexecuted'>        PoolInfo memory info = pools[lp];</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>        uint256 amount = IERC20(address(lp)).balanceOf(address(this));</span>
 157 |     | <span class='unexecuted'>        uint256 max = getMaximumInstantRedeemable(lp);</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>        stargateRouter.instantRedeemLocal(info.poolId, amount &gt; max ? max : amount, address(this));</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='unexecuted'>    function instantRedeemLocal(IStargatePool lp, uint256 amount) external onlyAllowedExecutors {</span>
 163 |     | <span class='unexecuted'>        PoolInfo memory info = pools[lp];</span>
 164 |     | <span class='unexecuted'>        stargateRouter.instantRedeemLocal(info.poolId, amount, address(this));</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /// @dev Swap internal tokens using an aggregator, for example, 1inch, 0x.</span>
 168 |     | <span class='unexecuted'>    function swapOnAggregator(address aggreagtorRouter, IERC20 tokenIn, bytes calldata data) external onlyAllowedExecutors {</span>
 169 |     | <span class='unexecuted'>        tokenIn.safeApprove(aggreagtorRouter, type(uint256).max);</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>        // solhint-disable-next-line avoid-low-level-calls</span>
 172 |     | <span class='unexecuted'>        (bool success, ) = aggreagtorRouter.call(data);</span>
 173 |     | <span class='unexecuted'>        if (!success) {</span>
 174 |     | <span class='unexecuted'>            revert ErrSwapFailed();</span>
 175 |     | <span class='neutral'>        }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='unexecuted'>        tokenIn.safeApprove(aggreagtorRouter, 0);</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    /*** Emergency Functions ***/</span>
 181 |     | <span class='unexecuted'>    function execute(address to, uint256 value, bytes calldata data) external onlyOwner returns (bool, bytes memory) {</span>
 182 |     | <span class='neutral'>        // solhint-disable-next-line avoid-low-level-calls</span>
 183 |     | <span class='unexecuted'>        (bool success, bytes memory result) = to.call{value: value}(data);</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>        return (success, result);</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='unexecuted'>    function rescueTokens(IERC20 token, address to, uint256 amount) external onlyOwner {</span>
 189 |     | <span class='unexecuted'>        token.safeTransfer(to, amount);</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'>}</span>
 192 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/StrategyExecutor.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Address} from &quot;openzeppelin-contracts/utils/Address.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BaseStrategy} from &quot;strategies/BaseStrategy.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  8 |     | <span class='neutral'>import {OperatableV2} from &quot;mixins/OperatableV2.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>contract StrategyExecutor is OperatableV2 {</span>
 11 |     | <span class='neutral'>    using Address for address;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    uint256 public constant BIPS = 10_000;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    mapping(BaseStrategy =&gt; uint64) public lastExecution;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    constructor(address _owner) OperatableV2(_owner) {}</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function _run(</span>
 20 |     | <span class='neutral'>        BaseStrategy strategy,</span>
 21 |     | <span class='neutral'>        uint256 maxBentoBoxAmountIncreaseInBips,</span>
 22 |     | <span class='neutral'>        uint256 maxBentoBoxChangeAmountInBips,</span>
 23 |     | <span class='neutral'>        address[] calldata callees,</span>
 24 |     | <span class='neutral'>        bytes[] calldata data,</span>
 25 |     | <span class='neutral'>        bool postRebalanceEnabled</span>
 26 |     | <span class='neutral'>    ) private {</span>
 27 |     | <span class='unexecuted'>        IBentoBoxV1 bentoBox = strategy.bentoBox();</span>
 28 |     | <span class='unexecuted'>        IERC20 strategyToken = strategy.strategyToken();</span>
 29 |     | <span class='unexecuted'>        uint128 totals = bentoBox.totals(strategyToken).elastic;</span>
 30 |     | <span class='unexecuted'>        uint256 maxBalance = totals + ((totals * BIPS) / maxBentoBoxAmountIncreaseInBips);</span>
 31 |     | <span class='unexecuted'>        uint256 maxChangeAmount = (maxBalance * maxBentoBoxChangeAmountInBips) / BIPS;</span>
 32 |     | <span class='unexecuted'>        strategy.safeHarvest(maxBalance, true, maxChangeAmount, false);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; data.length; i++) {</span>
 35 |     | <span class='unexecuted'>            callees[i].functionCall(data[i], &quot;call failed&quot;);</span>
 36 |     | <span class='neutral'>        }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>        // useful when the previous function calls adds back strategy token to rebalance</span>
 39 |     | <span class='unexecuted'>        if (postRebalanceEnabled) {</span>
 40 |     | <span class='unexecuted'>            strategy.safeHarvest(maxBalance, true, 0, false);</span>
 41 |     | <span class='neutral'>        }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>        lastExecution[strategy] = uint64(block.timestamp);</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>    function runMultiple(</span>
 47 |     | <span class='neutral'>        BaseStrategy[] calldata strategy,</span>
 48 |     | <span class='neutral'>        uint256[] calldata maxBentoBoxAmountIncreaseInBips,</span>
 49 |     | <span class='neutral'>        uint256[] calldata maxBentoBoxChangeAmountInBips,</span>
 50 |     | <span class='neutral'>        address[][] calldata callees,</span>
 51 |     | <span class='neutral'>        bytes[][] calldata data,</span>
 52 |     | <span class='neutral'>        bool[] calldata postRebalanceEnabled</span>
 53 |     | <span class='neutral'>    ) external onlyOperators {</span>
 54 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; strategy.length; i++) {</span>
 55 |     | <span class='unexecuted'>            _run(</span>
 56 |     | <span class='unexecuted'>                strategy[i],</span>
 57 |     | <span class='unexecuted'>                maxBentoBoxAmountIncreaseInBips[i],</span>
 58 |     | <span class='unexecuted'>                maxBentoBoxChangeAmountInBips[i],</span>
 59 |     | <span class='unexecuted'>                callees[i],</span>
 60 |     | <span class='unexecuted'>                data[i],</span>
 61 |     | <span class='unexecuted'>                postRebalanceEnabled[i]</span>
 62 |     | <span class='neutral'>            );</span>
 63 |     | <span class='neutral'>        }</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='unexecuted'>    function run(</span>
 67 |     | <span class='neutral'>        BaseStrategy strategy,</span>
 68 |     | <span class='neutral'>        uint256 maxBentoBoxAmountIncreaseInBips,</span>
 69 |     | <span class='neutral'>        uint256 maxBentoBoxChangeAmountInBips,</span>
 70 |     | <span class='neutral'>        address[] calldata callees,</span>
 71 |     | <span class='neutral'>        bytes[] calldata calls,</span>
 72 |     | <span class='neutral'>        bool postRebalanceEnabled</span>
 73 |     | <span class='neutral'>    ) external onlyOperators {</span>
 74 |     | <span class='unexecuted'>        _run(strategy, maxBentoBoxAmountIncreaseInBips, maxBentoBoxChangeAmountInBips, callees, calls, postRebalanceEnabled);</span>
 75 |     | <span class='neutral'>    }</span>
 76 |     | <span class='neutral'>}</span>
 77 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/TriCryptoUpdator.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Operatable} from &quot;mixins/Operatable.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IAggregator} from &quot;interfaces/IAggregator.sol&quot;;</span>
  8 |     | <span class='neutral'>import {SafeApproveLib} from &quot;libraries/SafeApproveLib.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>interface ITriCryptoWithExchange {</span>
 11 |     | <span class='neutral'>    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function last_prices(uint256 i) external view returns (uint256);</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>contract TriCryptoUpdator is Operatable {</span>
 17 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 18 |     | <span class='neutral'>    using SafeApproveLib for IERC20;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    address public tricrypto = 0xD51a44d3FaE010294C616388b506AcdA1bfAAE46;</span>
 21 |     | <span class='unexecuted'>    IAggregator private WETH_ORACLE = IAggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);</span>
 22 |     | <span class='unexecuted'>    IAggregator private BTC_ORACLE = IAggregator(0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    uint256 private constant TRADE_AMOUNT = 1e5;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    IERC20 constant USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);</span>
 27 |     | <span class='unexecuted'>    IERC20 constant WBTC = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);</span>
 28 |     | <span class='unexecuted'>    IERC20 constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>    constructor() {</span>
 31 |     | <span class='unexecuted'>        USDT.safeApprove(tricrypto, type(uint256).max);</span>
 32 |     | <span class='unexecuted'>        WETH.safeApprove(tricrypto, type(uint256).max);</span>
 33 |     | <span class='unexecuted'>        WBTC.safeApprove(tricrypto, type(uint256).max);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>    function trade() external onlyOperators {</span>
 37 |     | <span class='unexecuted'>        ITriCryptoWithExchange(tricrypto).exchange(0, 1, TRADE_AMOUNT, 0);</span>
 38 |     | <span class='unexecuted'>        ITriCryptoWithExchange(tricrypto).exchange(1, 2, WBTC.balanceOf(address(this)), 0);</span>
 39 |     | <span class='unexecuted'>        ITriCryptoWithExchange(tricrypto).exchange(2, 0, WETH.balanceOf(address(this)), 0);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='unexecuted'>    function checker() external view returns (bool canExec, bytes memory execPayload) {</span>
 43 |     | <span class='unexecuted'>        canExec = false;</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='unexecuted'>        uint256 chainLinkPriceBtc = uint256(BTC_ORACLE.latestAnswer());</span>
 46 |     | <span class='unexecuted'>        uint256 chainLinkPriceEth = uint256(WETH_ORACLE.latestAnswer());</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>        uint256 curvePriceBTC = ITriCryptoWithExchange(tricrypto).last_prices(0) / 1e12;</span>
 49 |     | <span class='unexecuted'>        uint256 curvePriceETH = ITriCryptoWithExchange(tricrypto).last_prices(1) / 1e12;</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>        if (</span>
 52 |     | <span class='unexecuted'>            curvePriceETH * 95 &gt; chainLinkPriceEth ||</span>
 53 |     | <span class='unexecuted'>            curvePriceETH * 105 &lt; chainLinkPriceEth ||</span>
 54 |     | <span class='unexecuted'>            curvePriceBTC * 95 &gt; chainLinkPriceBtc ||</span>
 55 |     | <span class='unexecuted'>            curvePriceBTC * 105 &lt; chainLinkPriceBtc</span>
 56 |     | <span class='neutral'>        ) {</span>
 57 |     | <span class='unexecuted'>            canExec = true;</span>
 58 |     | <span class='neutral'>        }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='unexecuted'>        execPayload = abi.encodeCall(TriCryptoUpdator.trade, ());</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'>}</span>
 63 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/precrime/BaseOFTV2View.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {ILzBaseOFTV2, ILzApp, ILzEndpoint, IOFTV2View} from &quot;interfaces/ILayerZero.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BytesLib} from &quot;libraries/BytesLib.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IERC20, BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>abstract contract BaseOFTV2View is IOFTV2View {</span>
 10 |     | <span class='neutral'>    error ErrNotTrustedRemote();</span>
 11 |     | <span class='neutral'>    error ErrInvalidPathLength();</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    using BytesLib for bytes;</span>
 14 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    ILzApp public immutable oft;</span>
 17 |     | <span class='unexecuted'>    IERC20 public immutable token;</span>
 18 |     | <span class='unexecuted'>    ILzEndpoint public immutable endpoint;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /// @notice Local decimals to shared decimals rate</span>
 21 |     | <span class='unexecuted'>    uint public immutable ld2sdRate;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    constructor(address _oft) {</span>
 24 |     | <span class='unexecuted'>        oft = ILzApp(_oft);</span>
 25 |     | <span class='unexecuted'>        token = IERC20(address(ILzBaseOFTV2(_oft).innerToken()));</span>
 26 |     | <span class='unexecuted'>        endpoint = ILzApp(_oft).lzEndpoint();</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>        uint8 decimals = token.safeDecimals();</span>
 29 |     | <span class='unexecuted'>        uint8 sharedDecimals = ILzBaseOFTV2(_oft).sharedDecimals();</span>
 30 |     | <span class='unexecuted'>        ld2sdRate = 10 ** (decimals - sharedDecimals);</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='unexecuted'>    function _decodePayload(bytes memory _payload) internal view returns (uint) {</span>
 34 |     | <span class='unexecuted'>        uint64 amountSD = _payload.toUint64(33);</span>
 35 |     | <span class='unexecuted'>        return amountSD * ld2sdRate;</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='unexecuted'>    function getInboundNonce(uint16 _srcChainId) external view virtual returns (uint64) {</span>
 39 |     | <span class='unexecuted'>        bytes memory path = oft.trustedRemoteLookup(_srcChainId);</span>
 40 |     | <span class='unexecuted'>        return endpoint.getInboundNonce(_srcChainId, path);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>    function _isPacketFromTrustedRemote(uint16 _srcChainId, bytes32 _srcAddress) internal view returns (bool) {</span>
 44 |     | <span class='unexecuted'>        bytes memory path = oft.trustedRemoteLookup(_srcChainId);</span>
 45 |     | <span class='unexecuted'>        uint pathLength = path.length;</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>        // EVM - EVM path length 40 (address + address)</span>
 48 |     | <span class='neutral'>        // EVM - non-EVM path length 52 (bytes32 + address)</span>
 49 |     | <span class='unexecuted'>        if (pathLength != 40 &amp;&amp; pathLength != 52) {</span>
 50 |     | <span class='unexecuted'>            revert ErrInvalidPathLength();</span>
 51 |     | <span class='neutral'>        }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>        // path format: remote + local</span>
 54 |     | <span class='unexecuted'>        path = path.slice(0, pathLength - 20);</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='unexecuted'>        uint remoteAddressLength = path.length;</span>
 57 |     | <span class='unexecuted'>        uint mask = (2 ** (remoteAddressLength * 8)) - 1;</span>
 58 |     | <span class='neutral'>        bytes32 remoteUaAddress;</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>        assembly {</span>
 61 |     | <span class='unexecuted'>            remoteUaAddress := and(mload(add(path, remoteAddressLength)), mask)</span>
 62 |     | <span class='neutral'>        }</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='unexecuted'>        return remoteUaAddress == _srcAddress;</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='neutral'>    function lzReceive(</span>
 68 |     | <span class='neutral'>        uint16 _srcChainId,</span>
 69 |     | <span class='neutral'>        bytes32 _scrAddress,</span>
 70 |     | <span class='neutral'>        bytes memory _payload,</span>
 71 |     | <span class='neutral'>        uint _totalSupply</span>
 72 |     | <span class='neutral'>    ) external view virtual returns (uint);</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>    function getCurrentState() external view virtual returns (uint);</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>    function isProxy() external view virtual returns (bool);</span>
 77 |     | <span class='neutral'>}</span>
 78 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/precrime/IndirectOFTV2View.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {BaseOFTV2View} from &quot;periphery/precrime/BaseOFTV2View.sol&quot;;</span>
  6 |     | <span class='neutral'>import {LzProxyOFTV2} from &quot;tokens/LzProxyOFTV2.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>contract IndirectOFTV2View is BaseOFTV2View {</span>
  9 |     | <span class='unexecuted'>    constructor(address _oft) BaseOFTV2View(_oft) {}</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    function lzReceive(</span>
 12 |     | <span class='neutral'>        uint16 _srcChainId,</span>
 13 |     | <span class='neutral'>        bytes32 _scrAddress,</span>
 14 |     | <span class='neutral'>        bytes memory _payload,</span>
 15 |     | <span class='neutral'>        uint _totalSupply</span>
 16 |     | <span class='unexecuted'>    ) external view override returns (uint) {</span>
 17 |     | <span class='unexecuted'>        if (!_isPacketFromTrustedRemote(_srcChainId, _scrAddress)) {</span>
 18 |     | <span class='unexecuted'>            revert ErrNotTrustedRemote();</span>
 19 |     | <span class='neutral'>        }</span>
 20 |     | <span class='neutral'>    </span>
 21 |     | <span class='unexecuted'>        uint amount = _decodePayload(_payload);</span>
 22 |     | <span class='unexecuted'>        return _totalSupply + amount;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>    function isProxy() external pure override returns (bool) {</span>
 26 |     | <span class='neutral'>        return false;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>    function getCurrentState() external view override returns (uint) {</span>
 30 |     | <span class='unexecuted'>        return token.totalSupply();</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'>}</span>
 33 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/precrime/PreCrimeView.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IOFTV2View, IPreCrimeView} from &quot;interfaces/ILayerZero.sol&quot;;</span>
   5 |     | <span class='neutral'>import {Owned} from &quot;solmate/auth/Owned.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='unexecuted'>contract PreCrimeView is IPreCrimeView, Owned {</span>
   8 |     | <span class='neutral'>    error ErrInvalidSize();</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>    uint16 public constant CONFIG_VERSION = 1;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    //---------------- error code ----------------------</span>
  13 |     | <span class='neutral'>    // --- UA scope code ---</span>
  14 |     | <span class='unexecuted'>    uint16 public constant CODE_SUCCESS = 0; // success</span>
  15 |     | <span class='unexecuted'>    uint16 public constant CODE_PRECRIME_FAILURE = 1; // !!! crimes found</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    // --- protocol scope error code ---</span>
  18 |     | <span class='neutral'>    // simualte</span>
  19 |     | <span class='unexecuted'>    uint16 public constant CODE_PACKETS_OVERSIZE = 2; // packets number bigger then max size</span>
  20 |     | <span class='unexecuted'>    uint16 public constant CODE_PACKETS_UNSORTED = 3; // packets are unsorted, need backfill and keep order</span>
  21 |     | <span class='neutral'>    // precrime</span>
  22 |     | <span class='unexecuted'>    uint16 public constant CODE_MISS_SIMULATE_RESULT = 4; // miss simulation result</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    /**</span>
  25 |     | <span class='neutral'>     * @dev 10000 - 20000 is for view mode, 20000 - 30000 is for precrime inherit mode</span>
  26 |     | <span class='neutral'>     */</span>
  27 |     | <span class='unexecuted'>    uint16 public constant PRECRIME_VERSION = 10001;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    /// @notice a view for OFTV2 or ProxyOFTV2</span>
  30 |     | <span class='unexecuted'>    IOFTV2View public immutable oftView;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>    uint16 public localChainId;</span>
  33 |     | <span class='unexecuted'>    uint16[] public remoteChainIds;</span>
  34 |     | <span class='unexecuted'>    bytes32[] public remotePrecrimeAddresses;</span>
  35 |     | <span class='unexecuted'>    uint64 public maxBatchSize;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>    constructor(address _owner, uint16 _localChainId, address _oftView, uint64 _maxSize) Owned(_owner) {</span>
  38 |     | <span class='unexecuted'>        localChainId = _localChainId;</span>
  39 |     | <span class='unexecuted'>        oftView = IOFTV2View(_oftView);</span>
  40 |     | <span class='unexecuted'>        maxBatchSize = _maxSize;</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>    function setRemotePrecrimeAddresses(uint16[] memory _remoteChainIds, bytes32[] memory _remotePrecrimeAddresses) public onlyOwner {</span>
  44 |     | <span class='unexecuted'>        if (_remoteChainIds.length != _remotePrecrimeAddresses.length) {</span>
  45 |     | <span class='unexecuted'>            revert ErrInvalidSize();</span>
  46 |     | <span class='neutral'>        }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>        remoteChainIds = _remoteChainIds;</span>
  49 |     | <span class='unexecuted'>        remotePrecrimeAddresses = _remotePrecrimeAddresses;</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>    function setMaxBatchSize(uint64 _maxSize) public onlyOwner {</span>
  53 |     | <span class='unexecuted'>        maxBatchSize = _maxSize;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev get precrime config,</span>
  58 |     | <span class='neutral'>     * @param _packets packets</span>
  59 |     | <span class='neutral'>     * @return configation bytes</span>
  60 |     | <span class='neutral'>     */</span>
  61 |     | <span class='unexecuted'>    function getConfig(Packet[] calldata _packets) external view virtual override returns (bytes memory) {</span>
  62 |     | <span class='unexecuted'>        (uint16[] memory remoteChains, bytes32[] memory remoteAddresses) = _remotePrecrimeAddress(_packets);</span>
  63 |     | <span class='unexecuted'>        return</span>
  64 |     | <span class='unexecuted'>            abi.encodePacked(</span>
  65 |     | <span class='neutral'>                CONFIG_VERSION,</span>
  66 |     | <span class='neutral'>                //---- max packets size for simulate batch ---</span>
  67 |     | <span class='unexecuted'>                _maxBatchSize(),</span>
  68 |     | <span class='neutral'>                //------------- remote precrimes -------------</span>
  69 |     | <span class='unexecuted'>                remoteChains.length,</span>
  70 |     | <span class='unexecuted'>                remoteChains,</span>
  71 |     | <span class='unexecuted'>                remoteAddresses</span>
  72 |     | <span class='neutral'>            );</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /**</span>
  76 |     | <span class='neutral'>     * @dev</span>
  77 |     | <span class='neutral'>     * @param _simulation all simulation results from difference chains</span>
  78 |     | <span class='neutral'>     * @return code     precrime result code; check out the error code definition</span>
  79 |     | <span class='neutral'>     * @return reason   error reason</span>
  80 |     | <span class='neutral'>     */</span>
  81 |     | <span class='unexecuted'>    function precrime(</span>
  82 |     | <span class='neutral'>        Packet[] calldata _packets,</span>
  83 |     | <span class='neutral'>        bytes[] calldata _simulation</span>
  84 |     | <span class='unexecuted'>    ) external view override returns (uint16 code, bytes memory reason) {</span>
  85 |     | <span class='unexecuted'>        bytes[] memory originSimulateResult = new bytes[](_simulation.length);</span>
  86 |     | <span class='unexecuted'>        uint16[] memory chainIds = new uint16[](_simulation.length);</span>
  87 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _simulation.length; i++) {</span>
  88 |     | <span class='unexecuted'>            (uint16 chainId, bytes memory simulateResult) = abi.decode(_simulation[i], (uint16, bytes));</span>
  89 |     | <span class='unexecuted'>            chainIds[i] = chainId;</span>
  90 |     | <span class='unexecuted'>            originSimulateResult[i] = simulateResult;</span>
  91 |     | <span class='neutral'>        }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>        (code, reason) = _checkResultsCompleteness(_packets, chainIds);</span>
  94 |     | <span class='unexecuted'>        if (code != CODE_SUCCESS) {</span>
  95 |     | <span class='unexecuted'>            return (code, reason);</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='unexecuted'>        (code, reason) = _precrime(originSimulateResult);</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /**</span>
 102 |     | <span class='neutral'>     * @dev simulate run cross chain packets and get a simulation result for precrime later</span>
 103 |     | <span class='neutral'>     * @param _packets packets, the packets item should group by srcChainId, srcAddress, then sort by nonce</span>
 104 |     | <span class='neutral'>     * @return code   simulation result code; see the error code defination</span>
 105 |     | <span class='neutral'>     * @return data the result is use for precrime params</span>
 106 |     | <span class='neutral'>     */</span>
 107 |     | <span class='unexecuted'>    function simulate(Packet[] calldata _packets) external view override returns (uint16 code, bytes memory data) {</span>
 108 |     | <span class='neutral'>        // params check</span>
 109 |     | <span class='unexecuted'>        (code, data) = _checkPacketsMaxSizeAndNonceOrder(_packets);</span>
 110 |     | <span class='unexecuted'>        if (code != CODE_SUCCESS) {</span>
 111 |     | <span class='unexecuted'>            return (code, data);</span>
 112 |     | <span class='neutral'>        }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>        (code, data) = _simulate(_packets);</span>
 115 |     | <span class='unexecuted'>        if (code == CODE_SUCCESS) {</span>
 116 |     | <span class='unexecuted'>            data = abi.encode(localChainId, data); // add localChainId to the header</span>
 117 |     | <span class='neutral'>        }</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>    function version() external pure override returns (uint16) {</span>
 121 |     | <span class='neutral'>        return PRECRIME_VERSION;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>    function _checkPacketsMaxSizeAndNonceOrder(Packet[] calldata _packets) internal view returns (uint16 code, bytes memory reason) {</span>
 125 |     | <span class='unexecuted'>        uint64 maxSize = _maxBatchSize();</span>
 126 |     | <span class='unexecuted'>        if (_packets.length &gt; maxSize) {</span>
 127 |     | <span class='unexecuted'>            return (CODE_PACKETS_OVERSIZE, abi.encodePacked(&quot;packets size exceed limited&quot;));</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>        // check packets nonce, sequence order</span>
 131 |     | <span class='neutral'>        // packets should group by srcChainId and srcAddress, then sort by nonce ascending</span>
 132 |     | <span class='unexecuted'>        if (_packets.length &gt; 0) {</span>
 133 |     | <span class='unexecuted'>            uint16 srcChainId;</span>
 134 |     | <span class='neutral'>            bytes32 srcAddress;</span>
 135 |     | <span class='neutral'>            uint64 nonce;</span>
 136 |     | <span class='unexecuted'>            for (uint256 i = 0; i &lt; _packets.length; i++) {</span>
 137 |     | <span class='unexecuted'>                Packet memory packet = _packets[i];</span>
 138 |     | <span class='neutral'>                // start from a new chain packet or a new source UA</span>
 139 |     | <span class='unexecuted'>                if (packet.srcChainId != srcChainId || packet.srcAddress != srcAddress) {</span>
 140 |     | <span class='unexecuted'>                    srcChainId = packet.srcChainId;</span>
 141 |     | <span class='unexecuted'>                    srcAddress = packet.srcAddress;</span>
 142 |     | <span class='unexecuted'>                    nonce = packet.nonce;</span>
 143 |     | <span class='unexecuted'>                    uint64 nextInboundNonce = _getInboundNonce(packet) + 1;</span>
 144 |     | <span class='neutral'>                    // the first packet&#39;s nonce must equal to dst InboundNonce+1</span>
 145 |     | <span class='unexecuted'>                    if (nonce != nextInboundNonce) {</span>
 146 |     | <span class='unexecuted'>                        return (CODE_PACKETS_UNSORTED, abi.encodePacked(&quot;skipped inboundNonce forbidden&quot;));</span>
 147 |     | <span class='neutral'>                    }</span>
 148 |     | <span class='neutral'>                } else {</span>
 149 |     | <span class='neutral'>                    // the following packet&#39;s nonce add 1 in order</span>
 150 |     | <span class='unexecuted'>                    if (packet.nonce != ++nonce) {</span>
 151 |     | <span class='unexecuted'>                        return (CODE_PACKETS_UNSORTED, abi.encodePacked(&quot;unsorted packets&quot;));</span>
 152 |     | <span class='neutral'>                    }</span>
 153 |     | <span class='neutral'>                }</span>
 154 |     | <span class='neutral'>            }</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='unexecuted'>        return (CODE_SUCCESS, &quot;&quot;);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>    function _checkResultsCompleteness(</span>
 160 |     | <span class='neutral'>        Packet[] calldata _packets,</span>
 161 |     | <span class='neutral'>        uint16[] memory _resultChainIds</span>
 162 |     | <span class='unexecuted'>    ) internal view returns (uint16 code, bytes memory reason) {</span>
 163 |     | <span class='neutral'>        // check if all remote result included</span>
 164 |     | <span class='unexecuted'>        if (_packets.length &gt; 0) {</span>
 165 |     | <span class='unexecuted'>            (uint16[] memory remoteChains, ) = _remotePrecrimeAddress(_packets);</span>
 166 |     | <span class='unexecuted'>            for (uint256 i = 0; i &lt; remoteChains.length; i++) {</span>
 167 |     | <span class='unexecuted'>                bool resultChainIdChecked;</span>
 168 |     | <span class='unexecuted'>                for (uint256 j = 0; j &lt; _resultChainIds.length; j++) {</span>
 169 |     | <span class='unexecuted'>                    if (_resultChainIds[j] == remoteChains[i]) {</span>
 170 |     | <span class='unexecuted'>                        resultChainIdChecked = true;</span>
 171 |     | <span class='unexecuted'>                        break;</span>
 172 |     | <span class='neutral'>                    }</span>
 173 |     | <span class='neutral'>                }</span>
 174 |     | <span class='unexecuted'>                if (!resultChainIdChecked) {</span>
 175 |     | <span class='unexecuted'>                    return (CODE_MISS_SIMULATE_RESULT, &quot;missing remote simulation result&quot;);</span>
 176 |     | <span class='neutral'>                }</span>
 177 |     | <span class='neutral'>            }</span>
 178 |     | <span class='neutral'>        }</span>
 179 |     | <span class='neutral'>        // check if local result included</span>
 180 |     | <span class='unexecuted'>        bool localChainIdResultChecked;</span>
 181 |     | <span class='unexecuted'>        for (uint256 j = 0; j &lt; _resultChainIds.length; j++) {</span>
 182 |     | <span class='unexecuted'>            if (_resultChainIds[j] == localChainId) {</span>
 183 |     | <span class='unexecuted'>                localChainIdResultChecked = true;</span>
 184 |     | <span class='unexecuted'>                break;</span>
 185 |     | <span class='neutral'>            }</span>
 186 |     | <span class='neutral'>        }</span>
 187 |     | <span class='unexecuted'>        if (!localChainIdResultChecked) {</span>
 188 |     | <span class='unexecuted'>            return (CODE_MISS_SIMULATE_RESULT, &quot;missing local simulation result&quot;);</span>
 189 |     | <span class='neutral'>        }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='unexecuted'>        return (CODE_SUCCESS, &quot;&quot;);</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    /**</span>
 195 |     | <span class='neutral'>     * @dev UA execute the logic by _packets, and return simulation result for precrime. would revert state after returned result.</span>
 196 |     | <span class='neutral'>     * @param _packets packets</span>
 197 |     | <span class='neutral'>     * @return code</span>
 198 |     | <span class='neutral'>     * @return result</span>
 199 |     | <span class='neutral'>     */</span>
 200 |     | <span class='unexecuted'>    function _simulate(Packet[] calldata _packets) internal view returns (uint16, bytes memory) {</span>
 201 |     | <span class='unexecuted'>        uint totalSupply = oftView.getCurrentState();</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; _packets.length; i++) {</span>
 204 |     | <span class='unexecuted'>            Packet memory packet = _packets[i];</span>
 205 |     | <span class='unexecuted'>            totalSupply = oftView.lzReceive(packet.srcChainId, packet.srcAddress, packet.payload, totalSupply);</span>
 206 |     | <span class='neutral'>        }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='unexecuted'>        return (CODE_SUCCESS, abi.encode(SimulationResult({chainTotalSupply: totalSupply, isProxy: oftView.isProxy()})));</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    /**</span>
 212 |     | <span class='neutral'>     * @dev</span>
 213 |     | <span class='neutral'>     * @param _simulation all simulation results from difference chains</span>
 214 |     | <span class='neutral'>     * @return code     precrime result code; check out the error code defination</span>
 215 |     | <span class='neutral'>     * @return reason   error reason</span>
 216 |     | <span class='neutral'>     */</span>
 217 |     | <span class='unexecuted'>    function _precrime(bytes[] memory _simulation) internal pure returns (uint16 code, bytes memory reason) {</span>
 218 |     | <span class='unexecuted'>        uint totalLocked = 0;</span>
 219 |     | <span class='unexecuted'>        uint totalMinted = 0;</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; _simulation.length; i++) {</span>
 222 |     | <span class='unexecuted'>            SimulationResult memory result = abi.decode(_simulation[i], (SimulationResult));</span>
 223 |     | <span class='unexecuted'>            if (result.isProxy) {</span>
 224 |     | <span class='unexecuted'>                if (totalLocked &gt; 0) {</span>
 225 |     | <span class='unexecuted'>                    return (CODE_PRECRIME_FAILURE, &quot;more than one proxy simulation&quot;);</span>
 226 |     | <span class='neutral'>                }</span>
 227 |     | <span class='unexecuted'>                totalLocked = result.chainTotalSupply;</span>
 228 |     | <span class='neutral'>            } else {</span>
 229 |     | <span class='unexecuted'>                totalMinted += result.chainTotalSupply;</span>
 230 |     | <span class='neutral'>            }</span>
 231 |     | <span class='neutral'>        }</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='unexecuted'>        if (totalMinted &gt; totalLocked) {</span>
 234 |     | <span class='unexecuted'>            return (CODE_PRECRIME_FAILURE, &quot;total minted &gt; total locked&quot;);</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='unexecuted'>        return (CODE_SUCCESS, &quot;&quot;);</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>    /**</span>
 241 |     | <span class='neutral'>     * @dev Always returns all remote chain ids and precrime addresses</span>
 242 |     | <span class='neutral'>     */</span>
 243 |     | <span class='unexecuted'>    function _remotePrecrimeAddress(</span>
 244 |     | <span class='neutral'>        Packet[] calldata</span>
 245 |     | <span class='unexecuted'>    ) internal view returns (uint16[] memory chainIds, bytes32[] memory precrimeAddresses) {</span>
 246 |     | <span class='unexecuted'>        return (remoteChainIds, remotePrecrimeAddresses);</span>
 247 |     | <span class='neutral'>    }</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='neutral'>    /**</span>
 250 |     | <span class='neutral'>     * @dev max batch size for simulate</span>
 251 |     | <span class='neutral'>     */</span>
 252 |     | <span class='unexecuted'>    function _maxBatchSize() internal view virtual returns (uint64) {</span>
 253 |     | <span class='unexecuted'>        return maxBatchSize;</span>
 254 |     | <span class='neutral'>    }</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>    /**</span>
 257 |     | <span class='neutral'>     * get srcChain &amp; srcAddress InboundNonce by packet</span>
 258 |     | <span class='neutral'>     */</span>
 259 |     | <span class='unexecuted'>    function _getInboundNonce(Packet memory _packet) internal view returns (uint64) {</span>
 260 |     | <span class='unexecuted'>        return oftView.getInboundNonce(_packet.srcChainId);</span>
 261 |     | <span class='neutral'>    }</span>
 262 |     | <span class='neutral'>}</span>
 263 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/precrime/ProxyOFTV2View.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {BaseOFTV2View} from &quot;periphery/precrime/BaseOFTV2View.sol&quot;;</span>
  6 |     | <span class='neutral'>import {LzProxyOFTV2} from &quot;tokens/LzProxyOFTV2.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>contract ProxyOFTV2View is BaseOFTV2View {</span>
  9 |     | <span class='neutral'>    error ErrTransferAmountExceedsLockedAmount();</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    constructor(address _oft) BaseOFTV2View(_oft) {}</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    function lzReceive(</span>
 14 |     | <span class='neutral'>        uint16 _srcChainId,</span>
 15 |     | <span class='neutral'>        bytes32 _scrAddress,</span>
 16 |     | <span class='neutral'>        bytes memory _payload,</span>
 17 |     | <span class='neutral'>        uint _totalSupply // totalSupply is the locked amount inside ProxyOFTV2</span>
 18 |     | <span class='unexecuted'>    ) external view override returns (uint) {</span>
 19 |     | <span class='unexecuted'>        if(!_isPacketFromTrustedRemote(_srcChainId, _scrAddress)) {</span>
 20 |     | <span class='unexecuted'>            revert ErrNotTrustedRemote();</span>
 21 |     | <span class='neutral'>        }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>        uint amount = _decodePayload(_payload);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>        if (amount &gt; _totalSupply) {</span>
 26 |     | <span class='unexecuted'>            revert ErrTransferAmountExceedsLockedAmount();</span>
 27 |     | <span class='neutral'>        }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>        return _totalSupply - amount;</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    function isProxy() external pure override returns (bool) {</span>
 33 |     | <span class='unexecuted'>        return true;</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>    function getCurrentState() external view override returns (uint) {</span>
 37 |     | <span class='unexecuted'>        return LzProxyOFTV2(address(oft)).innerToken().balanceOf(address(oft));</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'>}</span>
 40 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/staking/LockingMultiRewards.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {OperatableV2} from &quot;mixins/OperatableV2.sol&quot;;</span>
   5 |     | <span class='neutral'>import {Pausable} from &quot;openzeppelin-contracts/security/Pausable.sol&quot;;</span>
   6 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solady/utils/SafeTransferLib.sol&quot;;</span>
   7 |     | <span class='neutral'>import {MathLib} from &quot;libraries/MathLib.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/// @notice A staking contract that distributes multiple rewards to stakers.</span>
  10 |     | <span class='neutral'>/// Stakers can lock their tokens for a period of time to get a boost on their rewards.</span>
  11 |     | <span class='neutral'>/// @author Based from Curve Finance&#39;s MultiRewards contract https://github.com/curvefi/multi-rewards/blob/master/contracts/MultiRewards.sol</span>
  12 |     | <span class='neutral'>/// @author Based from Ellipsis Finance&#39;s EpsStaker https://github.com/ellipsis-finance/ellipsis/blob/master/contracts/EpsStaker.sol</span>
  13 |     | <span class='neutral'>/// @author Based from Convex Finance&#39;s CvxLockerV2 https://github.com/convex-eth/platform/blob/main/contracts/contracts/CvxLockerV2.sol</span>
  14 |     | <span class='unexecuted'>contract LockingMultiRewards is OperatableV2, Pausable {</span>
  15 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    event LogRewardAdded(uint256 reward);</span>
  18 |     | <span class='neutral'>    event LogStaked(address indexed user, uint256 amount);</span>
  19 |     | <span class='neutral'>    event LogLocked(address indexed user, uint256 amount, uint256 unlockTime, uint256 lockCount);</span>
  20 |     | <span class='neutral'>    event LogUnlocked(address indexed user, uint256 amount, uint256 index);</span>
  21 |     | <span class='neutral'>    event LogLockIndexChanged(address indexed user, uint256 fromIndex, uint256 toIndex);</span>
  22 |     | <span class='neutral'>    event LogWithdrawn(address indexed user, uint256 amount);</span>
  23 |     | <span class='neutral'>    event LogRewardLockCreated(address indexed user, uint256 unlockTime);</span>
  24 |     | <span class='neutral'>    event LogRewardLocked(address indexed user, address indexed rewardsToken, uint256 reward);</span>
  25 |     | <span class='neutral'>    event LogRewardPaid(address indexed user, address indexed rewardsToken, uint256 reward);</span>
  26 |     | <span class='neutral'>    event LogRewardsDurationUpdated(address token, uint256 newDuration);</span>
  27 |     | <span class='neutral'>    event LogRecovered(address token, uint256 amount);</span>
  28 |     | <span class='neutral'>    event LogSetMinLockAmount(uint256 previous, uint256 current);</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    error ErrZeroAmount();</span>
  31 |     | <span class='neutral'>    error ErrRewardAlreadyExists();</span>
  32 |     | <span class='neutral'>    error ErrInvalidTokenAddress();</span>
  33 |     | <span class='neutral'>    error ErrMaxUserLocksExceeded();</span>
  34 |     | <span class='neutral'>    error ErrNotExpired();</span>
  35 |     | <span class='neutral'>    error ErrInvalidUser();</span>
  36 |     | <span class='neutral'>    error ErrLockAmountTooSmall();</span>
  37 |     | <span class='neutral'>    error ErrLengthMismatch();</span>
  38 |     | <span class='neutral'>    error ErrNoLocks();</span>
  39 |     | <span class='neutral'>    error ErrLockNotExpired();</span>
  40 |     | <span class='neutral'>    error ErrMaxRewardsExceeded();</span>
  41 |     | <span class='neutral'>    error ErrSkimmingTooMuch();</span>
  42 |     | <span class='neutral'>    error ErrInvalidLockIndex();</span>
  43 |     | <span class='neutral'>    error ErrNotEnoughReward();</span>
  44 |     | <span class='neutral'>    error ErrInvalidDurationRatio();</span>
  45 |     | <span class='neutral'>    error ErrInvalidBoostMultiplier();</span>
  46 |     | <span class='neutral'>    error ErrInvalidLockDuration();</span>
  47 |     | <span class='neutral'>    error ErrInvalidRewardDuration();</span>
  48 |     | <span class='neutral'>    error ErrInsufficientRemainingTime();</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    struct Reward {</span>
  51 |     | <span class='neutral'>        uint256 periodFinish;</span>
  52 |     | <span class='neutral'>        uint256 rewardRate;</span>
  53 |     | <span class='neutral'>        uint256 rewardPerTokenStored;</span>
  54 |     | <span class='neutral'>        bool exists;</span>
  55 |     | <span class='neutral'>        uint248 lastUpdateTime;</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    struct Balances {</span>
  59 |     | <span class='neutral'>        uint256 unlocked;</span>
  60 |     | <span class='neutral'>        uint256 locked;</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    struct LockedBalance {</span>
  64 |     | <span class='neutral'>        uint256 amount;</span>
  65 |     | <span class='neutral'>        uint256 unlockTime;</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    struct RewardLockItem {</span>
  69 |     | <span class='neutral'>        address token;</span>
  70 |     | <span class='neutral'>        uint256 amount;</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    struct RewardLock {</span>
  74 |     | <span class='neutral'>        RewardLockItem[] items;</span>
  75 |     | <span class='neutral'>        uint256 unlockTime;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>    uint256 internal constant BIPS = 10_000;</span>
  79 |     | <span class='neutral'>    uint256 internal constant MAX_NUM_REWARDS = 5;</span>
  80 |     | <span class='unexecuted'>    uint256 internal constant MIN_LOCK_DURATION = 1 weeks;</span>
  81 |     | <span class='unexecuted'>    uint256 internal constant MIN_REWARDS_DURATION = 1 days;</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>    uint256 public immutable maxLocks;</span>
  84 |     | <span class='unexecuted'>    uint256 public immutable lockingBoostMultiplerInBips;</span>
  85 |     | <span class='unexecuted'>    uint256 public immutable rewardsDuration;</span>
  86 |     | <span class='unexecuted'>    uint256 public immutable lockDuration;</span>
  87 |     | <span class='unexecuted'>    address public immutable stakingToken;</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    mapping(address token =&gt; Reward info) internal _rewardData;</span>
  90 |     | <span class='neutral'>    mapping(address user =&gt; Balances balances) internal _balances;</span>
  91 |     | <span class='neutral'>    mapping(address user =&gt; LockedBalance[] locks) internal _userLocks;</span>
  92 |     | <span class='neutral'>    mapping(address user =&gt; RewardLock rewardLock) internal _userRewardLock;</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>    mapping(address user =&gt; mapping(address token =&gt; uint256 amount)) public userRewardPerTokenPaid;</span>
  95 |     | <span class='unexecuted'>    mapping(address user =&gt; mapping(address token =&gt; uint256 amount)) public rewards;</span>
  96 |     | <span class='unexecuted'>    mapping(address user =&gt; uint256 index) public lastLockIndex;</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='unexecuted'>    address[] public rewardTokens;</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>    uint256 public lockedSupply; // all locked boosted deposits</span>
 101 |     | <span class='unexecuted'>    uint256 public unlockedSupply; // all unlocked unboosted deposits</span>
 102 |     | <span class='unexecuted'>    uint256 public minLockAmount; // minimum amount allowed to lock</span>
 103 |     | <span class='unexecuted'>    uint256 public stakingTokenBalance; // total staking token balance</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    ///</span>
 106 |     | <span class='neutral'>    /// @dev Constructor</span>
 107 |     | <span class='neutral'>    /// @param _stakingToken The token that is being staked</span>
 108 |     | <span class='neutral'>    /// @param _owner The owner of the contract</span>
 109 |     | <span class='neutral'>    /// @param _lockingBoostMultiplerInBips The multiplier for the locking boost. 30000 means if you stake 100, you get 300 locked</span>
 110 |     | <span class='neutral'>    /// @param _rewardsDuration The duration of the rewards period in seconds, should be 7 days by default.</span>
 111 |     | <span class='neutral'>    /// @param _lockDuration The duration of the lock period in seconds, should be 13 weeks by default.</span>
 112 |     | <span class='unexecuted'>    constructor(</span>
 113 |     | <span class='neutral'>        address _stakingToken,</span>
 114 |     | <span class='neutral'>        uint256 _lockingBoostMultiplerInBips,</span>
 115 |     | <span class='neutral'>        uint256 _rewardsDuration,</span>
 116 |     | <span class='neutral'>        uint256 _lockDuration,</span>
 117 |     | <span class='neutral'>        address _owner</span>
 118 |     | <span class='neutral'>    ) OperatableV2(_owner) {</span>
 119 |     | <span class='unexecuted'>        if (_lockingBoostMultiplerInBips &lt;= BIPS) {</span>
 120 |     | <span class='unexecuted'>            revert ErrInvalidBoostMultiplier();</span>
 121 |     | <span class='neutral'>        }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>        if (_lockDuration &lt; MIN_LOCK_DURATION) {</span>
 124 |     | <span class='unexecuted'>            revert ErrInvalidLockDuration();</span>
 125 |     | <span class='neutral'>        }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>        if (_rewardsDuration &lt; MIN_REWARDS_DURATION) {</span>
 128 |     | <span class='unexecuted'>            revert ErrInvalidRewardDuration();</span>
 129 |     | <span class='neutral'>        }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>        if (_lockDuration % _rewardsDuration != 0) {</span>
 132 |     | <span class='unexecuted'>            revert ErrInvalidDurationRatio();</span>
 133 |     | <span class='neutral'>        }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='unexecuted'>        stakingToken = _stakingToken;</span>
 136 |     | <span class='unexecuted'>        lockingBoostMultiplerInBips = _lockingBoostMultiplerInBips;</span>
 137 |     | <span class='unexecuted'>        rewardsDuration = _rewardsDuration;</span>
 138 |     | <span class='unexecuted'>        lockDuration = _lockDuration;</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>        // kocks are combined into the same `rewardsDuration` epoch. So, if</span>
 141 |     | <span class='neutral'>        // a user stake with locking every `rewardsDuration` this should reach the</span>
 142 |     | <span class='neutral'>        // maximum number of possible simultaneous because the first lock gets expired,</span>
 143 |     | <span class='neutral'>        // freeing up a slot.</span>
 144 |     | <span class='unexecuted'>        maxLocks = _lockDuration / _rewardsDuration;</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /// @notice Stakes the given amount of tokens for the given user.</span>
 148 |     | <span class='neutral'>    /// @param amount The amount of tokens to stake</span>
 149 |     | <span class='neutral'>    /// @param lock_ If true, the tokens will be locked for the lock duration for a reward boost</span>
 150 |     | <span class='unexecuted'>    function stake(uint256 amount, bool lock_) public whenNotPaused {</span>
 151 |     | <span class='unexecuted'>        _stakeFor(msg.sender, amount, lock_);</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    /// @notice Locks an existing unlocked balance.</span>
 155 |     | <span class='unexecuted'>    function lock(uint256 amount) public whenNotPaused {</span>
 156 |     | <span class='unexecuted'>        if (amount == 0) {</span>
 157 |     | <span class='unexecuted'>            revert ErrZeroAmount();</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>        _updateRewardsForUser(msg.sender);</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='unexecuted'>        _balances[msg.sender].unlocked -= amount;</span>
 163 |     | <span class='unexecuted'>        unlockedSupply -= amount;</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='unexecuted'>        _createLock(msg.sender, amount);</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    /// @notice Withdraws the given amount of unlocked tokens for the given user.</span>
 169 |     | <span class='neutral'>    /// @param amount The amount of unlocked tokens to withdraw</span>
 170 |     | <span class='unexecuted'>    function withdraw(uint256 amount) public virtual {</span>
 171 |     | <span class='unexecuted'>        if (amount == 0) {</span>
 172 |     | <span class='unexecuted'>            revert ErrZeroAmount();</span>
 173 |     | <span class='neutral'>        }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='unexecuted'>        _updateRewardsForUser(msg.sender);</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='unexecuted'>        _balances[msg.sender].unlocked -= amount;</span>
 178 |     | <span class='unexecuted'>        unlockedSupply -= amount;</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='unexecuted'>        stakingToken.safeTransfer(msg.sender, amount);</span>
 181 |     | <span class='unexecuted'>        stakingTokenBalance -= amount;</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='unexecuted'>        emit LogWithdrawn(msg.sender, amount);</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='unexecuted'>    function withdrawWithRewards(uint256 amount) public virtual {</span>
 187 |     | <span class='unexecuted'>        withdraw(amount);</span>
 188 |     | <span class='unexecuted'>        _getRewards(msg.sender);</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='unexecuted'>    function getRewards() public virtual {</span>
 192 |     | <span class='unexecuted'>        _updateRewardsForUser(msg.sender);</span>
 193 |     | <span class='unexecuted'>        _getRewards(msg.sender);</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 197 |     | <span class='neutral'>    /// VIEWS</span>
 198 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 199 |     | <span class='unexecuted'>    function rewardData(address token) external view returns (Reward memory) {</span>
 200 |     | <span class='unexecuted'>        return _rewardData[token];</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='unexecuted'>    function rewardsForDuration(address rewardToken) external view returns (uint256) {</span>
 204 |     | <span class='unexecuted'>        return _rewardData[rewardToken].rewardRate * rewardsDuration;</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='unexecuted'>    function rewardTokensLength() external view returns (uint256) {</span>
 208 |     | <span class='unexecuted'>        return rewardTokens.length;</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='unexecuted'>    function balances(address user) external view returns (Balances memory) {</span>
 212 |     | <span class='unexecuted'>        return _balances[user];</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='unexecuted'>    function userRewardLock(address user) external view returns (RewardLock memory) {</span>
 216 |     | <span class='unexecuted'>        return _userRewardLock[user];</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='unexecuted'>    function userLocks(address user) external view returns (LockedBalance[] memory) {</span>
 220 |     | <span class='unexecuted'>        return _userLocks[user];</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='unexecuted'>    function userLocksLength(address user) external view returns (uint256) {</span>
 224 |     | <span class='unexecuted'>        return _userLocks[user].length;</span>
 225 |     | <span class='neutral'>    }</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='unexecuted'>    function locked(address user) external view returns (uint256) {</span>
 228 |     | <span class='unexecuted'>        return _balances[user].locked;</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='unexecuted'>    function unlocked(address user) external view returns (uint256) {</span>
 232 |     | <span class='unexecuted'>        return _balances[user].unlocked;</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='unexecuted'>    function totalSupply() public view returns (uint256) {</span>
 236 |     | <span class='unexecuted'>        return unlockedSupply + ((lockedSupply * lockingBoostMultiplerInBips) / BIPS);</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='unexecuted'>    function balanceOf(address user) public view returns (uint256) {</span>
 240 |     | <span class='unexecuted'>        Balances storage bal = _balances[user];</span>
 241 |     | <span class='unexecuted'>        return bal.unlocked + ((bal.locked * lockingBoostMultiplerInBips) / BIPS);</span>
 242 |     | <span class='neutral'>    }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    /// @dev Calculates when the next unlock event will occur given the current epoch.</span>
 245 |     | <span class='neutral'>    /// It ensures that the unlock timing coincides with the intervals at which rewards are distributed.</span>
 246 |     | <span class='neutral'>    /// If the current time is within an ongoing reward interval, the function establishes the</span>
 247 |     | <span class='neutral'>    /// unlock period to begin at the next epoch.</span>
 248 |     | <span class='neutral'>    /// So, if you stake at week 1 + 4 days, you will be able to unlock at the end of week 14.</span>
 249 |     | <span class='neutral'>    // |    week -1   |    week 1    |    week 2    |      ...     |    week 13   |    week 14   |</span>
 250 |     | <span class='neutral'>    // |--------------|--------------|--------------|--------------|--------------|--------------|</span>
 251 |     | <span class='neutral'>    // |                   ^ block.timestamp                                      |</span>
 252 |     | <span class='neutral'>    // |                             ^ lock starts (adjusted)                                    ^ unlock ends (nextUnlockTime)</span>
 253 |     | <span class='unexecuted'>    function nextUnlockTime() public view returns (uint256) {</span>
 254 |     | <span class='unexecuted'>        return nextEpoch() + lockDuration;</span>
 255 |     | <span class='neutral'>    }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='unexecuted'>    function epoch() public view returns (uint256) {</span>
 258 |     | <span class='unexecuted'>        return (block.timestamp / rewardsDuration) * rewardsDuration;</span>
 259 |     | <span class='neutral'>    }</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='unexecuted'>    function nextEpoch() public view returns (uint256) {</span>
 262 |     | <span class='unexecuted'>        return epoch() + rewardsDuration;</span>
 263 |     | <span class='neutral'>    }</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='unexecuted'>    function remainingEpochTime() public view returns (uint256) {</span>
 266 |     | <span class='unexecuted'>        return nextEpoch() - block.timestamp;</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='unexecuted'>    function lastTimeRewardApplicable(address rewardToken) public view returns (uint256) {</span>
 270 |     | <span class='unexecuted'>        return MathLib.min(block.timestamp, _rewardData[rewardToken].periodFinish);</span>
 271 |     | <span class='neutral'>    }</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='unexecuted'>    function rewardPerToken(address rewardToken) public view returns (uint256) {</span>
 274 |     | <span class='unexecuted'>        return _rewardPerToken(rewardToken, lastTimeRewardApplicable(rewardToken), totalSupply());</span>
 275 |     | <span class='neutral'>    }</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>    function _rewardPerToken(address rewardToken, uint256 lastTimeRewardApplicable_, uint256 totalSupply_) public view returns (uint256) {</span>
 278 |     | <span class='unexecuted'>        if (totalSupply_ == 0) {</span>
 279 |     | <span class='unexecuted'>            return _rewardData[rewardToken].rewardPerTokenStored;</span>
 280 |     | <span class='neutral'>        }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='unexecuted'>        uint256 timeElapsed = lastTimeRewardApplicable_ - _rewardData[rewardToken].lastUpdateTime;</span>
 283 |     | <span class='unexecuted'>        uint256 pendingRewardsPerToken = (timeElapsed * _rewardData[rewardToken].rewardRate * 1e18) / totalSupply_;</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='unexecuted'>        return _rewardData[rewardToken].rewardPerTokenStored + pendingRewardsPerToken;</span>
 286 |     | <span class='neutral'>    }</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='unexecuted'>    function earned(address user, address rewardToken) public view returns (uint256) {</span>
 289 |     | <span class='unexecuted'>        return _earned(user, balanceOf(user), rewardToken, rewardPerToken(rewardToken));</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='unexecuted'>    function _earned(address user, uint256 balance_, address rewardToken, uint256 rewardPerToken_) internal view returns (uint256) {</span>
 293 |     | <span class='unexecuted'>        uint256 pendingUserRewardsPerToken = rewardPerToken_ - userRewardPerTokenPaid[user][rewardToken];</span>
 294 |     | <span class='unexecuted'>        return ((balance_ * pendingUserRewardsPerToken) / 1e18) + rewards[user][rewardToken];</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 298 |     | <span class='neutral'>    /// ADMIN</span>
 299 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 300 |     | <span class='unexecuted'>    function addReward(address rewardToken) public virtual onlyOwner {</span>
 301 |     | <span class='unexecuted'>        _addReward(rewardToken);</span>
 302 |     | <span class='neutral'>    }</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='unexecuted'>    function setMinLockAmount(uint256 _minLockAmount) external onlyOwner {</span>
 305 |     | <span class='unexecuted'>        emit LogSetMinLockAmount(minLockAmount, _minLockAmount);</span>
 306 |     | <span class='unexecuted'>        minLockAmount = _minLockAmount;</span>
 307 |     | <span class='neutral'>    }</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='neutral'>    /// @notice This function can recover any token except for the staking token beyond the balance necessary for rewards.</span>
 310 |     | <span class='neutral'>    /// WARNING: Use this function with caution to ensure it does not affect the reward mechanism.</span>
 311 |     | <span class='unexecuted'>    function recover(address tokenAddress, uint256 tokenAmount) external onlyOwner {</span>
 312 |     | <span class='neutral'>        // In case it&#39;s the staking token, allow to skim the excess</span>
 313 |     | <span class='unexecuted'>        if (tokenAddress == stakingToken &amp;&amp; tokenAmount &gt; stakingToken.balanceOf(address(this)) - stakingTokenBalance) {</span>
 314 |     | <span class='unexecuted'>            revert ErrSkimmingTooMuch();</span>
 315 |     | <span class='neutral'>        }</span>
 316 |     | <span class='neutral'></span>
 317 |     | <span class='unexecuted'>        tokenAddress.safeTransfer(owner, tokenAmount);</span>
 318 |     | <span class='unexecuted'>        emit LogRecovered(tokenAddress, tokenAmount);</span>
 319 |     | <span class='neutral'>    }</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 322 |     | <span class='neutral'>    /// EMERGENCY FUNCTIONS</span>
 323 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 324 |     | <span class='unexecuted'>    function pause() external onlyOwner {</span>
 325 |     | <span class='unexecuted'>        _pause();</span>
 326 |     | <span class='neutral'>    }</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='unexecuted'>    function unpause() external onlyOwner {</span>
 329 |     | <span class='unexecuted'>        _unpause();</span>
 330 |     | <span class='neutral'>    }</span>
 331 |     | <span class='neutral'></span>
 332 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 333 |     | <span class='neutral'>    /// OPERATORS</span>
 334 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 335 |     | <span class='neutral'>    </span>
 336 |     | <span class='unexecuted'>    function stakeFor(address account, uint256 amount, bool lock_) external onlyOperators {</span>
 337 |     | <span class='unexecuted'>        _stakeFor(account, amount, lock_);</span>
 338 |     | <span class='neutral'>    }</span>
 339 |     | <span class='neutral'>    </span>
 340 |     | <span class='neutral'>    /// @notice Distribute new rewards to the stakers</span>
 341 |     | <span class='neutral'>    /// @param rewardToken The address of the reward token</span>
 342 |     | <span class='neutral'>    /// @param amount The amount of reward tokens to distribute</span>
 343 |     | <span class='neutral'>    /// @param minRemainingTime The minimum remaining time for the current reward period</span>
 344 |     | <span class='neutral'>    /// Used to avoid distributing rewards on a lower period than the expected one.</span>
 345 |     | <span class='neutral'>    /// Example: If the reward period is 7 days, and there are 2 days left, `minRemainingTime` higher than</span>
 346 |     | <span class='neutral'>    /// 2 days will revert the transaction.</span>
 347 |     | <span class='neutral'>    /// To ignore this check, set `minRemainingTime` to 0.</span>
 348 |     | <span class='unexecuted'>    function notifyRewardAmount(address rewardToken, uint256 amount, uint minRemainingTime) public onlyOperators {</span>
 349 |     | <span class='unexecuted'>        if (!_rewardData[rewardToken].exists) {</span>
 350 |     | <span class='unexecuted'>            revert ErrInvalidTokenAddress();</span>
 351 |     | <span class='neutral'>        }</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='unexecuted'>        _updateRewards();</span>
 354 |     | <span class='unexecuted'>        rewardToken.safeTransferFrom(msg.sender, address(this), amount);</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='unexecuted'>        Reward storage reward = _rewardData[rewardToken];</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='unexecuted'>        uint256 _nextEpoch = nextEpoch();</span>
 359 |     | <span class='unexecuted'>        uint256 _remainingRewardTime = _nextEpoch - block.timestamp;</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='unexecuted'>        if (_remainingRewardTime &lt; minRemainingTime) {</span>
 362 |     | <span class='unexecuted'>            revert ErrInsufficientRemainingTime();</span>
 363 |     | <span class='neutral'>        }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>        // Take the remainder of the current rewards and add it to the amount for the next period</span>
 366 |     | <span class='unexecuted'>        if (block.timestamp &lt; reward.periodFinish) {</span>
 367 |     | <span class='unexecuted'>            amount += _remainingRewardTime * reward.rewardRate;</span>
 368 |     | <span class='neutral'>        }</span>
 369 |     | <span class='neutral'></span>
 370 |     | <span class='neutral'>        // avoid `rewardRate` being 0</span>
 371 |     | <span class='unexecuted'>        if (amount &lt; _remainingRewardTime) {</span>
 372 |     | <span class='unexecuted'>            revert ErrNotEnoughReward();</span>
 373 |     | <span class='neutral'>        }</span>
 374 |     | <span class='neutral'></span>
 375 |     | <span class='unexecuted'>        reward.rewardRate = amount / _remainingRewardTime;</span>
 376 |     | <span class='unexecuted'>        reward.lastUpdateTime = uint248(block.timestamp);</span>
 377 |     | <span class='unexecuted'>        reward.periodFinish = _nextEpoch;</span>
 378 |     | <span class='neutral'></span>
 379 |     | <span class='unexecuted'>        emit LogRewardAdded(amount);</span>
 380 |     | <span class='neutral'>    }</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='neutral'>    /// @notice Updates the balances of the given user and lock indexes</span>
 383 |     | <span class='neutral'>    // Should be called once a `rewardDuration` (for example, every week)</span>
 384 |     | <span class='unexecuted'>    function processExpiredLocks(address[] memory users, uint256[] calldata lockIndexes) external onlyOperators {</span>
 385 |     | <span class='unexecuted'>        if (users.length != lockIndexes.length) {</span>
 386 |     | <span class='unexecuted'>            revert ErrLengthMismatch();</span>
 387 |     | <span class='neutral'>        }</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='unexecuted'>        _updateRewardsForUsers(users);</span>
 390 |     | <span class='neutral'></span>
 391 |     | <span class='neutral'>        // Release all expired users&#39; locks</span>
 392 |     | <span class='unexecuted'>        for (uint256 i; i &lt; users.length; ) {</span>
 393 |     | <span class='unexecuted'>            address user = users[i];</span>
 394 |     | <span class='unexecuted'>            Balances storage bal = _balances[user];</span>
 395 |     | <span class='unexecuted'>            LockedBalance[] storage locks = _userLocks[user];</span>
 396 |     | <span class='neutral'></span>
 397 |     | <span class='unexecuted'>            if (locks.length == 0) {</span>
 398 |     | <span class='unexecuted'>                revert ErrNoLocks();</span>
 399 |     | <span class='neutral'>            }</span>
 400 |     | <span class='neutral'></span>
 401 |     | <span class='unexecuted'>            uint256 index = lockIndexes[i];</span>
 402 |     | <span class='neutral'></span>
 403 |     | <span class='neutral'>            // Prevents processing `lastLockIndex` out of order</span>
 404 |     | <span class='unexecuted'>            if (index == lastLockIndex[user] &amp;&amp; locks.length &gt; 1) {</span>
 405 |     | <span class='unexecuted'>                revert ErrInvalidLockIndex();</span>
 406 |     | <span class='neutral'>            }</span>
 407 |     | <span class='neutral'></span>
 408 |     | <span class='neutral'>            // prohibit releasing non-expired locks</span>
 409 |     | <span class='unexecuted'>            if (locks[index].unlockTime &gt; block.timestamp) {</span>
 410 |     | <span class='unexecuted'>                revert ErrLockNotExpired();</span>
 411 |     | <span class='neutral'>            }</span>
 412 |     | <span class='neutral'></span>
 413 |     | <span class='unexecuted'>            uint256 amount = locks[index].amount;</span>
 414 |     | <span class='unexecuted'>            uint256 lastIndex = locks.length - 1;</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>            /// Last lock index changed place with the one we just swapped.</span>
 417 |     | <span class='unexecuted'>            if (lastLockIndex[user] == lastIndex) {</span>
 418 |     | <span class='unexecuted'>                lastLockIndex[user] = index;</span>
 419 |     | <span class='neutral'>            }</span>
 420 |     | <span class='neutral'></span>
 421 |     | <span class='unexecuted'>            if (index != lastIndex) {</span>
 422 |     | <span class='unexecuted'>                locks[index] = locks[lastIndex];</span>
 423 |     | <span class='unexecuted'>                emit LogLockIndexChanged(user, lastIndex, index);</span>
 424 |     | <span class='neutral'>            }</span>
 425 |     | <span class='neutral'></span>
 426 |     | <span class='unexecuted'>            locks.pop();</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='unexecuted'>            unlockedSupply += amount;</span>
 429 |     | <span class='unexecuted'>            lockedSupply -= amount;</span>
 430 |     | <span class='neutral'></span>
 431 |     | <span class='unexecuted'>            bal.unlocked += amount;</span>
 432 |     | <span class='unexecuted'>            bal.locked -= amount;</span>
 433 |     | <span class='neutral'></span>
 434 |     | <span class='unexecuted'>            emit LogUnlocked(user, amount, index);</span>
 435 |     | <span class='neutral'></span>
 436 |     | <span class='neutral'>            unchecked {</span>
 437 |     | <span class='unexecuted'>                ++i;</span>
 438 |     | <span class='neutral'>            }</span>
 439 |     | <span class='neutral'>        }</span>
 440 |     | <span class='neutral'>    }</span>
 441 |     | <span class='neutral'></span>
 442 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 443 |     | <span class='neutral'>    /// INTERNALS</span>
 444 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 445 |     | <span class='unexecuted'>    function _stakeFor(address account, uint256 amount, bool lock_) internal {</span>
 446 |     | <span class='unexecuted'>        if (amount == 0) {</span>
 447 |     | <span class='unexecuted'>            revert ErrZeroAmount();</span>
 448 |     | <span class='neutral'>        }</span>
 449 |     | <span class='neutral'></span>
 450 |     | <span class='neutral'>        // This staking contract isn&#39;t using balanceOf, so it&#39;s safe to transfer immediately</span>
 451 |     | <span class='unexecuted'>        stakingToken.safeTransferFrom(msg.sender, address(this), amount);</span>
 452 |     | <span class='unexecuted'>        stakingTokenBalance += amount;</span>
 453 |     | <span class='neutral'></span>
 454 |     | <span class='unexecuted'>        _updateRewardsForUser(account);</span>
 455 |     | <span class='neutral'></span>
 456 |     | <span class='unexecuted'>        if (lock_) {</span>
 457 |     | <span class='unexecuted'>            _createLock(account, amount);</span>
 458 |     | <span class='neutral'>        } else {</span>
 459 |     | <span class='unexecuted'>            _balances[account].unlocked += amount;</span>
 460 |     | <span class='unexecuted'>            unlockedSupply += amount;</span>
 461 |     | <span class='neutral'></span>
 462 |     | <span class='unexecuted'>            emit LogStaked(account, amount);</span>
 463 |     | <span class='neutral'>        }</span>
 464 |     | <span class='neutral'>    }</span>
 465 |     | <span class='neutral'></span>
 466 |     | <span class='unexecuted'>    function _addReward(address rewardToken) internal {</span>
 467 |     | <span class='unexecuted'>        if (rewardToken == address(0)) {</span>
 468 |     | <span class='unexecuted'>            revert ErrInvalidTokenAddress();</span>
 469 |     | <span class='neutral'>        }</span>
 470 |     | <span class='neutral'></span>
 471 |     | <span class='unexecuted'>        if (_rewardData[rewardToken].exists) {</span>
 472 |     | <span class='unexecuted'>            revert ErrRewardAlreadyExists();</span>
 473 |     | <span class='neutral'>        }</span>
 474 |     | <span class='neutral'></span>
 475 |     | <span class='unexecuted'>        if (rewardTokens.length == MAX_NUM_REWARDS) {</span>
 476 |     | <span class='unexecuted'>            revert ErrMaxRewardsExceeded();</span>
 477 |     | <span class='neutral'>        }</span>
 478 |     | <span class='neutral'></span>
 479 |     | <span class='unexecuted'>        rewardTokens.push(rewardToken);</span>
 480 |     | <span class='unexecuted'>        _rewardData[rewardToken].exists = true;</span>
 481 |     | <span class='neutral'>    }</span>
 482 |     | <span class='neutral'></span>
 483 |     | <span class='unexecuted'>    function _createLock(address user, uint256 amount) internal {</span>
 484 |     | <span class='unexecuted'>        Balances storage bal = _balances[user];</span>
 485 |     | <span class='unexecuted'>        uint256 _nextUnlockTime = nextUnlockTime();</span>
 486 |     | <span class='unexecuted'>        uint256 _lastLockIndex = lastLockIndex[user];</span>
 487 |     | <span class='unexecuted'>        uint256 lockCount = _userLocks[user].length;</span>
 488 |     | <span class='neutral'></span>
 489 |     | <span class='unexecuted'>        bal.locked += amount;</span>
 490 |     | <span class='unexecuted'>        lockedSupply += amount;</span>
 491 |     | <span class='neutral'></span>
 492 |     | <span class='neutral'>        // Add to current lock if it&#39;s the same unlock time or the first one</span>
 493 |     | <span class='neutral'>        // userLocks is sorted by unlockTime, so the last lock is the most recent one</span>
 494 |     | <span class='unexecuted'>        if (lockCount == 0 || _userLocks[user][_lastLockIndex].unlockTime &lt; _nextUnlockTime) {</span>
 495 |     | <span class='neutral'>            // Limit the number of locks per user to avoid too much gas costs per user</span>
 496 |     | <span class='neutral'>            // when looping through the locks</span>
 497 |     | <span class='unexecuted'>            if (lockCount == maxLocks) {</span>
 498 |     | <span class='unexecuted'>                revert ErrMaxUserLocksExceeded();</span>
 499 |     | <span class='neutral'>            }</span>
 500 |     | <span class='neutral'></span>
 501 |     | <span class='unexecuted'>            if (amount &lt; minLockAmount) {</span>
 502 |     | <span class='unexecuted'>                revert ErrLockAmountTooSmall();</span>
 503 |     | <span class='neutral'>            }</span>
 504 |     | <span class='neutral'></span>
 505 |     | <span class='unexecuted'>            _userLocks[user].push(LockedBalance({amount: amount, unlockTime: _nextUnlockTime}));</span>
 506 |     | <span class='unexecuted'>            lastLockIndex[user] = lockCount;</span>
 507 |     | <span class='neutral'></span>
 508 |     | <span class='neutral'>            unchecked {</span>
 509 |     | <span class='unexecuted'>                ++lockCount;</span>
 510 |     | <span class='neutral'>            }</span>
 511 |     | <span class='neutral'>        }</span>
 512 |     | <span class='neutral'>        /// It&#39;s the same reward period, so we just add the amount to the current lock</span>
 513 |     | <span class='neutral'>        else {</span>
 514 |     | <span class='unexecuted'>            _userLocks[user][_lastLockIndex].amount += amount;</span>
 515 |     | <span class='neutral'>        }</span>
 516 |     | <span class='neutral'></span>
 517 |     | <span class='unexecuted'>        emit LogLocked(user, amount, _nextUnlockTime, lockCount);</span>
 518 |     | <span class='neutral'>    }</span>
 519 |     | <span class='neutral'></span>
 520 |     | <span class='neutral'>    /// @dev Update the global accumulated rewards from the last update to this point,</span>
 521 |     | <span class='neutral'>    /// in relation with the `totalSupply`</span>
 522 |     | <span class='neutral'>    ///</span>
 523 |     | <span class='neutral'>    /// The idea is to allow everyone that are currently part of that supply to get their allocated</span>
 524 |     | <span class='neutral'>    /// reward share.</span>
 525 |     | <span class='neutral'>    ///</span>
 526 |     | <span class='neutral'>    /// Each user&#39;s reward share is taking in account when `rewards[user][token] = _earned(...)`</span>
 527 |     | <span class='neutral'>    /// is called. And only updated when a user is interacting with `stake`, `lock`, `withdraw`</span>
 528 |     | <span class='neutral'>    /// or `getRewards`.</span>
 529 |     | <span class='neutral'>    ///</span>
 530 |     | <span class='neutral'>    /// Otherwise, if it&#39;s yet-to-be-updated, it&#39;s going to get considered as part of the pending</span>
 531 |     | <span class='neutral'>    /// yet-to-receive rewards in the `earned` function.</span>
 532 |     | <span class='unexecuted'>    function _updateRewardsGlobal(address token_, uint256 totalSupply_) internal returns (uint256 rewardPerToken_) {</span>
 533 |     | <span class='unexecuted'>        uint256 lastTimeRewardApplicable_ = lastTimeRewardApplicable(token_);</span>
 534 |     | <span class='unexecuted'>        rewardPerToken_ = _rewardPerToken(token_, lastTimeRewardApplicable_, totalSupply_);</span>
 535 |     | <span class='neutral'></span>
 536 |     | <span class='unexecuted'>        _rewardData[token_].rewardPerTokenStored = rewardPerToken_;</span>
 537 |     | <span class='unexecuted'>        _rewardData[token_].lastUpdateTime = uint248(lastTimeRewardApplicable_); // safe to cast as this will never overflow</span>
 538 |     | <span class='neutral'>    }</span>
 539 |     | <span class='neutral'></span>
 540 |     | <span class='unexecuted'>    function _udpateUserRewards(address user_, uint256 balance_, address token_, uint256 rewardPerToken_) internal {</span>
 541 |     | <span class='unexecuted'>        rewards[user_][token_] = _earned(user_, balance_, token_, rewardPerToken_);</span>
 542 |     | <span class='unexecuted'>        userRewardPerTokenPaid[user_][token_] = rewardPerToken_;</span>
 543 |     | <span class='neutral'>    }</span>
 544 |     | <span class='neutral'></span>
 545 |     | <span class='neutral'>    /// @dev Simplest version of updating rewards. Mainly used by `notifyRewardAmount`.</span>
 546 |     | <span class='neutral'>    /// where we don&#39;t need to update any particular user but the global state for</span>
 547 |     | <span class='neutral'>    /// each reward tokens only.</span>
 548 |     | <span class='unexecuted'>    function _updateRewards() internal {</span>
 549 |     | <span class='unexecuted'>        uint256 totalSupply_ = totalSupply();</span>
 550 |     | <span class='neutral'></span>
 551 |     | <span class='unexecuted'>        for (uint256 i; i &lt; rewardTokens.length; ) {</span>
 552 |     | <span class='unexecuted'>            _updateRewardsGlobal(rewardTokens[i], totalSupply_);</span>
 553 |     | <span class='neutral'>            unchecked {</span>
 554 |     | <span class='unexecuted'>                ++i;</span>
 555 |     | <span class='neutral'>            }</span>
 556 |     | <span class='neutral'>        }</span>
 557 |     | <span class='neutral'>    }</span>
 558 |     | <span class='neutral'></span>
 559 |     | <span class='neutral'>    /// @dev More gas efficient version of `_updateRewards` when we</span>
 560 |     | <span class='neutral'>    /// only need to update the rewards for a single user.</span>
 561 |     | <span class='unexecuted'>    function _updateRewardsForUser(address user) internal {</span>
 562 |     | <span class='unexecuted'>        uint256 balance = balanceOf(user);</span>
 563 |     | <span class='unexecuted'>        uint256 totalSupply_ = totalSupply();</span>
 564 |     | <span class='neutral'></span>
 565 |     | <span class='unexecuted'>        for (uint256 i; i &lt; rewardTokens.length; ) {</span>
 566 |     | <span class='unexecuted'>            address token = rewardTokens[i];</span>
 567 |     | <span class='unexecuted'>            _udpateUserRewards(user, balance, token, _updateRewardsGlobal(token, totalSupply_));</span>
 568 |     | <span class='neutral'></span>
 569 |     | <span class='neutral'>            unchecked {</span>
 570 |     | <span class='unexecuted'>                ++i;</span>
 571 |     | <span class='neutral'>            }</span>
 572 |     | <span class='neutral'>        }</span>
 573 |     | <span class='neutral'>    }</span>
 574 |     | <span class='neutral'></span>
 575 |     | <span class='neutral'>    /// @dev `_updateRewardsForUser` for multiple users.</span>
 576 |     | <span class='unexecuted'>    function _updateRewardsForUsers(address[] memory users) internal {</span>
 577 |     | <span class='unexecuted'>        uint256 totalSupply_ = totalSupply();</span>
 578 |     | <span class='neutral'></span>
 579 |     | <span class='unexecuted'>        for (uint256 i; i &lt; rewardTokens.length; ) {</span>
 580 |     | <span class='unexecuted'>            address token = rewardTokens[i];</span>
 581 |     | <span class='unexecuted'>            uint256 rewardPerToken_ = _updateRewardsGlobal(token, totalSupply_);</span>
 582 |     | <span class='neutral'></span>
 583 |     | <span class='neutral'>            // Record each user&#39;s rewards</span>
 584 |     | <span class='unexecuted'>            for (uint256 j; j &lt; users.length; ) {</span>
 585 |     | <span class='unexecuted'>                address user = users[j];</span>
 586 |     | <span class='unexecuted'>                _udpateUserRewards(user, balanceOf(user), token, rewardPerToken_);</span>
 587 |     | <span class='neutral'></span>
 588 |     | <span class='neutral'>                unchecked {</span>
 589 |     | <span class='unexecuted'>                    ++j;</span>
 590 |     | <span class='neutral'>                }</span>
 591 |     | <span class='neutral'>            }</span>
 592 |     | <span class='neutral'></span>
 593 |     | <span class='neutral'>            unchecked {</span>
 594 |     | <span class='unexecuted'>                ++i;</span>
 595 |     | <span class='neutral'>            }</span>
 596 |     | <span class='neutral'>        }</span>
 597 |     | <span class='neutral'>    }</span>
 598 |     | <span class='neutral'></span>
 599 |     | <span class='neutral'>    /// @notice Claim unlocked rewards or create a new reward lock that</span>
 600 |     | <span class='neutral'>    // makes them available the next epoch</span>
 601 |     | <span class='unexecuted'>    function _getRewards(address user) internal {</span>
 602 |     | <span class='unexecuted'>        RewardLock storage _rewardLock = _userRewardLock[user];</span>
 603 |     | <span class='neutral'></span>
 604 |     | <span class='neutral'>        // first ever lock is always expired because `unlockTime` is 0</span>
 605 |     | <span class='neutral'>        // unlock time is aligned to epoch</span>
 606 |     | <span class='unexecuted'>        bool expired = _rewardLock.unlockTime &lt;= block.timestamp;</span>
 607 |     | <span class='neutral'></span>
 608 |     | <span class='neutral'>        // cache the length here since the loop will be modifying the array</span>
 609 |     | <span class='unexecuted'>        uint256 rewardItemLength = _rewardLock.items.length;</span>
 610 |     | <span class='neutral'></span>
 611 |     | <span class='neutral'>        // expired lock</span>
 612 |     | <span class='neutral'>        // existing lock items will be reused</span>
 613 |     | <span class='unexecuted'>        if (expired) {</span>
 614 |     | <span class='unexecuted'>            _rewardLock.unlockTime = nextEpoch();</span>
 615 |     | <span class='unexecuted'>            emit LogRewardLockCreated(user, _rewardLock.unlockTime);</span>
 616 |     | <span class='neutral'>        }</span>
 617 |     | <span class='neutral'></span>
 618 |     | <span class='unexecuted'>        for (uint256 i; i &lt; rewardTokens.length; ) {</span>
 619 |     | <span class='unexecuted'>            address rewardToken = rewardTokens[i];</span>
 620 |     | <span class='unexecuted'>            uint256 rewardAmount = rewards[user][rewardToken];</span>
 621 |     | <span class='neutral'></span>
 622 |     | <span class='neutral'>            // in all scenario, reset the reward amount immediately</span>
 623 |     | <span class='unexecuted'>            rewards[user][rewardToken] = 0;</span>
 624 |     | <span class='neutral'></span>
 625 |     | <span class='neutral'>            // don&#39;t assume the rewardTokens array is always the same length as the items array</span>
 626 |     | <span class='neutral'>            // as new reward tokens can be added by the owner</span>
 627 |     | <span class='unexecuted'>            if (i &lt; rewardItemLength) {</span>
 628 |     | <span class='unexecuted'>                RewardLockItem storage item = _rewardLock.items[i];</span>
 629 |     | <span class='neutral'></span>
 630 |     | <span class='neutral'>                // expired lock, claim existing unlocked rewards if any</span>
 631 |     | <span class='unexecuted'>                if (expired) {</span>
 632 |     | <span class='unexecuted'>                    uint256 amount = item.amount;</span>
 633 |     | <span class='neutral'></span>
 634 |     | <span class='neutral'>                    // since this current lock is expired and that item index</span>
 635 |     | <span class='neutral'>                    // matches the reward index, override the current amount</span>
 636 |     | <span class='neutral'>                    // with the new locked amount.</span>
 637 |     | <span class='unexecuted'>                    item.amount = rewardAmount;</span>
 638 |     | <span class='neutral'></span>
 639 |     | <span class='neutral'>                    // use cached amount</span>
 640 |     | <span class='unexecuted'>                    if (amount &gt; 0) {</span>
 641 |     | <span class='unexecuted'>                        rewardToken.safeTransfer(user, amount);</span>
 642 |     | <span class='unexecuted'>                        emit LogRewardPaid(user, rewardToken, amount);</span>
 643 |     | <span class='neutral'>                    }</span>
 644 |     | <span class='neutral'>                } else {</span>
 645 |     | <span class='neutral'>                    // not expired, just add to the existing lock</span>
 646 |     | <span class='unexecuted'>                    item.amount += rewardAmount;</span>
 647 |     | <span class='neutral'>                }</span>
 648 |     | <span class='neutral'>            }</span>
 649 |     | <span class='neutral'>            // new reward token, create a new lock item</span>
 650 |     | <span class='neutral'>            // could mean it&#39;s adding to an existing lock or creating a new one</span>
 651 |     | <span class='neutral'>            else {</span>
 652 |     | <span class='unexecuted'>                _userRewardLock[user].items.push(RewardLockItem({token: rewardToken, amount: rewardAmount}));</span>
 653 |     | <span class='neutral'>            }</span>
 654 |     | <span class='neutral'></span>
 655 |     | <span class='unexecuted'>            emit LogRewardLocked(user, rewardToken, rewardAmount);</span>
 656 |     | <span class='neutral'></span>
 657 |     | <span class='neutral'>            unchecked {</span>
 658 |     | <span class='unexecuted'>                ++i;</span>
 659 |     | <span class='neutral'>            }</span>
 660 |     | <span class='neutral'>        }</span>
 661 |     | <span class='neutral'>    }</span>
 662 |     | <span class='neutral'>}</span>
 663 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/staking/MultiRewards.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {OperatableV2} from &quot;mixins/OperatableV2.sol&quot;;</span>
   5 |     | <span class='neutral'>import {Pausable} from &quot;openzeppelin-contracts/security/Pausable.sol&quot;;</span>
   6 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solady/utils/SafeTransferLib.sol&quot;;</span>
   7 |     | <span class='neutral'>import {MathLib} from &quot;libraries/MathLib.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/// @notice A staking contract that distributes multiple rewards to stakers.</span>
  10 |     | <span class='neutral'>/// @author Modified from Curve Finance&#39;s MultiRewards contract</span>
  11 |     | <span class='neutral'>/// https://github.com/curvefi/multi-rewards/blob/master/contracts/MultiRewards.sol</span>
  12 |     | <span class='unexecuted'>contract MultiRewards is OperatableV2, Pausable {</span>
  13 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    event LogRewardAdded(uint256 reward);</span>
  16 |     | <span class='neutral'>    event LogStaked(address indexed user, uint256 amount);</span>
  17 |     | <span class='neutral'>    event LogWithdrawn(address indexed user, uint256 amount);</span>
  18 |     | <span class='neutral'>    event LogRewardPaid(address indexed user, address indexed rewardsToken, uint256 reward);</span>
  19 |     | <span class='neutral'>    event LogRewardsDurationUpdated(address token, uint256 newDuration);</span>
  20 |     | <span class='neutral'>    event LogRecovered(address token, uint256 amount);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    error ErrZeroAmount();</span>
  23 |     | <span class='neutral'>    error ErrZeroDuration();</span>
  24 |     | <span class='neutral'>    error ErrRewardAlreadyAdded();</span>
  25 |     | <span class='neutral'>    error ErrRewardPeriodStillActive();</span>
  26 |     | <span class='neutral'>    error ErrInvalidTokenAddress();</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    struct Reward {</span>
  29 |     | <span class='neutral'>        uint256 rewardsDuration;</span>
  30 |     | <span class='neutral'>        uint256 periodFinish;</span>
  31 |     | <span class='neutral'>        uint256 rewardRate;</span>
  32 |     | <span class='neutral'>        uint256 lastUpdateTime;</span>
  33 |     | <span class='neutral'>        uint256 rewardPerTokenStored;</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    address public immutable stakingToken;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    mapping(address token =&gt; Reward info) private _rewardData;</span>
  39 |     | <span class='unexecuted'>    mapping(address user =&gt; uint256 amount) public balanceOf;</span>
  40 |     | <span class='unexecuted'>    mapping(address user =&gt; mapping(address token =&gt; uint256 amount)) public userRewardPerTokenPaid;</span>
  41 |     | <span class='unexecuted'>    mapping(address user =&gt; mapping(address token =&gt; uint256 amount)) public rewards;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>    address[] public rewardTokens;</span>
  44 |     | <span class='unexecuted'>    uint256 public totalSupply;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>    constructor(address _stakingToken, address _owner) OperatableV2(_owner) {</span>
  47 |     | <span class='unexecuted'>        stakingToken = _stakingToken;</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>    function stake(uint256 amount) public virtual whenNotPaused {</span>
  51 |     | <span class='unexecuted'>        if (amount == 0) {</span>
  52 |     | <span class='unexecuted'>            revert ErrZeroAmount();</span>
  53 |     | <span class='neutral'>        }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>        _updateRewards(msg.sender);</span>
  56 |     | <span class='unexecuted'>        totalSupply += amount;</span>
  57 |     | <span class='unexecuted'>        balanceOf[msg.sender] += amount;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>        stakingToken.safeTransferFrom(msg.sender, address(this), amount);</span>
  60 |     | <span class='unexecuted'>        emit LogStaked(msg.sender, amount);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>    function withdraw(uint256 amount) public virtual {</span>
  64 |     | <span class='unexecuted'>        if (amount == 0) {</span>
  65 |     | <span class='unexecuted'>            revert ErrZeroAmount();</span>
  66 |     | <span class='neutral'>        }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>        _updateRewards(msg.sender);</span>
  69 |     | <span class='unexecuted'>        totalSupply -= amount;</span>
  70 |     | <span class='unexecuted'>        balanceOf[msg.sender] -= amount;</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>        stakingToken.safeTransfer(msg.sender, amount);</span>
  73 |     | <span class='unexecuted'>        emit LogWithdrawn(msg.sender, amount);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>    function getRewards() public virtual {</span>
  77 |     | <span class='unexecuted'>        _updateRewards(msg.sender);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>        for (uint256 i; i &lt; rewardTokens.length; ) {</span>
  80 |     | <span class='unexecuted'>            address rewardToken = rewardTokens[i];</span>
  81 |     | <span class='unexecuted'>            uint256 reward = rewards[msg.sender][rewardToken];</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>            if (reward &gt; 0) {</span>
  84 |     | <span class='unexecuted'>                rewards[msg.sender][rewardToken] = 0;</span>
  85 |     | <span class='unexecuted'>                rewardToken.safeTransfer(msg.sender, reward);</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>                emit LogRewardPaid(msg.sender, rewardToken, reward);</span>
  88 |     | <span class='neutral'>            }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>            unchecked {</span>
  91 |     | <span class='unexecuted'>                ++i;</span>
  92 |     | <span class='neutral'>            }</span>
  93 |     | <span class='neutral'>        }</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>    function exit() public virtual {</span>
  97 |     | <span class='unexecuted'>        withdraw(balanceOf[msg.sender]);</span>
  98 |     | <span class='unexecuted'>        getRewards();</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 102 |     | <span class='neutral'>    /// VIEWS</span>
 103 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 104 |     | <span class='unexecuted'>    function rewardData(address token) external view returns (Reward memory) {</span>
 105 |     | <span class='unexecuted'>        return _rewardData[token];</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>    function lastTimeRewardApplicable(address rewardToken) public view returns (uint256) {</span>
 109 |     | <span class='unexecuted'>        return MathLib.min(block.timestamp, _rewardData[rewardToken].periodFinish);</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>    function rewardPerToken(address rewardToken) public view returns (uint256) {</span>
 113 |     | <span class='unexecuted'>        if (totalSupply == 0) {</span>
 114 |     | <span class='unexecuted'>            return _rewardData[rewardToken].rewardPerTokenStored;</span>
 115 |     | <span class='neutral'>        }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>        uint256 timeElapsed = lastTimeRewardApplicable(rewardToken) - _rewardData[rewardToken].lastUpdateTime;</span>
 118 |     | <span class='unexecuted'>        uint256 pendingRewardsPerToken = (timeElapsed * _rewardData[rewardToken].rewardRate * 1e18) / totalSupply;</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>        return _rewardData[rewardToken].rewardPerTokenStored + pendingRewardsPerToken;</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>    function earned(address user, address rewardToken) public view returns (uint256) {</span>
 124 |     | <span class='unexecuted'>        uint256 pendingUserRewardsPerToken = rewardPerToken(rewardToken) - userRewardPerTokenPaid[user][rewardToken];</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>        return ((balanceOf[user] * pendingUserRewardsPerToken) / 1e18) + rewards[user][rewardToken];</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>    function getRewardForDuration(address rewardToken) external view returns (uint256) {</span>
 130 |     | <span class='unexecuted'>        return _rewardData[rewardToken].rewardRate * _rewardData[rewardToken].rewardsDuration;</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>    function getRewardTokenLength() external view returns (uint256) {</span>
 134 |     | <span class='unexecuted'>        return rewardTokens.length;</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='unexecuted'>    function isSupportedReward(address rewardToken) external view returns (bool) {</span>
 138 |     | <span class='unexecuted'>        return _rewardData[rewardToken].rewardsDuration != 0;</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 142 |     | <span class='neutral'>    /// ADMIN</span>
 143 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 144 |     | <span class='unexecuted'>    function addReward(address rewardToken, uint256 _rewardsDuration) public onlyOwner {</span>
 145 |     | <span class='unexecuted'>        if (rewardToken == address(0)) {</span>
 146 |     | <span class='unexecuted'>            revert ErrInvalidTokenAddress();</span>
 147 |     | <span class='neutral'>        }</span>
 148 |     | <span class='unexecuted'>        if (_rewardData[rewardToken].rewardsDuration != 0) {</span>
 149 |     | <span class='unexecuted'>            revert ErrRewardAlreadyAdded();</span>
 150 |     | <span class='neutral'>        }</span>
 151 |     | <span class='unexecuted'>        if (_rewardsDuration == 0) {</span>
 152 |     | <span class='unexecuted'>            revert ErrZeroDuration();</span>
 153 |     | <span class='neutral'>        }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>        rewardTokens.push(rewardToken);</span>
 156 |     | <span class='unexecuted'>        _rewardData[rewardToken].rewardsDuration = _rewardsDuration;</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>    function setRewardsDuration(address rewardToken, uint256 _rewardsDuration) external onlyOwner {</span>
 160 |     | <span class='unexecuted'>        if (block.timestamp &lt;= _rewardData[rewardToken].periodFinish) {</span>
 161 |     | <span class='unexecuted'>            revert ErrRewardPeriodStillActive();</span>
 162 |     | <span class='neutral'>        }</span>
 163 |     | <span class='unexecuted'>        if (_rewardsDuration == 0) {</span>
 164 |     | <span class='unexecuted'>            revert ErrZeroDuration();</span>
 165 |     | <span class='neutral'>        }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='unexecuted'>        _rewardData[rewardToken].rewardsDuration = _rewardsDuration;</span>
 168 |     | <span class='unexecuted'>        emit LogRewardsDurationUpdated(rewardToken, _rewardData[rewardToken].rewardsDuration);</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>    function recover(address tokenAddress, uint256 tokenAmount) external onlyOwner {</span>
 172 |     | <span class='unexecuted'>        if (tokenAddress == stakingToken) {</span>
 173 |     | <span class='unexecuted'>            revert ErrInvalidTokenAddress();</span>
 174 |     | <span class='neutral'>        }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='unexecuted'>        tokenAddress.safeTransfer(owner, tokenAmount);</span>
 177 |     | <span class='unexecuted'>        emit LogRecovered(tokenAddress, tokenAmount);</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='unexecuted'>    function pause() external onlyOwner {</span>
 181 |     | <span class='unexecuted'>        _pause();</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='unexecuted'>    function unpause() external onlyOwner {</span>
 185 |     | <span class='unexecuted'>        _unpause();</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 189 |     | <span class='neutral'>    /// OPERATORS</span>
 190 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 191 |     | <span class='unexecuted'>    function notifyRewardAmount(address rewardToken, uint256 amount) external onlyOperators {</span>
 192 |     | <span class='unexecuted'>        if (_rewardData[rewardToken].rewardsDuration == 0) {</span>
 193 |     | <span class='unexecuted'>            revert ErrInvalidTokenAddress();</span>
 194 |     | <span class='neutral'>        }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='unexecuted'>        _updateRewards(address(0));</span>
 197 |     | <span class='unexecuted'>        rewardToken.safeTransferFrom(msg.sender, address(this), amount);</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>        // Take the remainder of the current rewards and add it to the amount for the next period</span>
 200 |     | <span class='unexecuted'>        if (block.timestamp &lt; _rewardData[rewardToken].periodFinish) {</span>
 201 |     | <span class='unexecuted'>            amount += (_rewardData[rewardToken].periodFinish - block.timestamp) * _rewardData[rewardToken].rewardRate;</span>
 202 |     | <span class='neutral'>        }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='unexecuted'>        _rewardData[rewardToken].rewardRate = amount / _rewardData[rewardToken].rewardsDuration;</span>
 205 |     | <span class='unexecuted'>        _rewardData[rewardToken].lastUpdateTime = block.timestamp;</span>
 206 |     | <span class='unexecuted'>        _rewardData[rewardToken].periodFinish = block.timestamp + _rewardData[rewardToken].rewardsDuration;</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='unexecuted'>        emit LogRewardAdded(amount);</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 212 |     | <span class='neutral'>    /// INTERNALS</span>
 213 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 214 |     | <span class='unexecuted'>    function _updateRewards(address user) internal {</span>
 215 |     | <span class='unexecuted'>        for (uint256 i; i &lt; rewardTokens.length; ) {</span>
 216 |     | <span class='unexecuted'>            address token = rewardTokens[i];</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='unexecuted'>            _rewardData[token].rewardPerTokenStored = rewardPerToken(token);</span>
 219 |     | <span class='unexecuted'>            _rewardData[token].lastUpdateTime = lastTimeRewardApplicable(token);</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='unexecuted'>            if (user != address(0)) {</span>
 222 |     | <span class='unexecuted'>                rewards[user][token] = earned(user, token);</span>
 223 |     | <span class='unexecuted'>                userRewardPerTokenPaid[user][token] = _rewardData[token].rewardPerTokenStored;</span>
 224 |     | <span class='neutral'>            }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>            unchecked {</span>
 227 |     | <span class='unexecuted'>                ++i;</span>
 228 |     | <span class='neutral'>            }</span>
 229 |     | <span class='neutral'>        }</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'>}</span>
 232 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/staking/PrivateMultiRewardsStaking.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {OperatableV2} from &quot;mixins/OperatableV2.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Pausable} from &quot;openzeppelin-contracts/security/Pausable.sol&quot;;</span>
  6 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solady/utils/SafeTransferLib.sol&quot;;</span>
  7 |     | <span class='neutral'>import {MathLib} from &quot;libraries/MathLib.sol&quot;;</span>
  8 |     | <span class='neutral'>import {MultiRewards} from &quot;staking/MultiRewards.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>/// @notice Permissioned version of MultiRewards</span>
 11 |     | <span class='unexecuted'>contract PrivateMultiRewardsStaking is MultiRewards {</span>
 12 |     | <span class='neutral'>    event LogAuthorizedChanged(address indexed, bool);</span>
 13 |     | <span class='neutral'>    error ErrNotAuthorized();</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public authorized;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    modifier onlyAuthorized() {</span>
 18 |     | <span class='unexecuted'>        if (!authorized[msg.sender]) {</span>
 19 |     | <span class='unexecuted'>            revert ErrNotAuthorized();</span>
 20 |     | <span class='neutral'>        }</span>
 21 |     | <span class='neutral'>        _;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    constructor(address _stakingToken, address _owner) MultiRewards(_stakingToken, _owner) {}</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    function stake(uint256 amount) public override onlyAuthorized {</span>
 27 |     | <span class='unexecuted'>        super.stake(amount);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>    function withdraw(uint256 amount) public override onlyAuthorized {</span>
 31 |     | <span class='unexecuted'>        super.withdraw(amount);</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>    function getRewards() public override onlyAuthorized {</span>
 35 |     | <span class='unexecuted'>        super.getRewards();</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='unexecuted'>    function exit() public override onlyAuthorized {</span>
 39 |     | <span class='unexecuted'>        super.exit();</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 43 |     | <span class='neutral'>    /// ADMIN</span>
 44 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 45 |     | <span class='unexecuted'>    function setAuthorized(address account, bool status) external onlyOwner {</span>
 46 |     | <span class='unexecuted'>        authorized[account] = status;</span>
 47 |     | <span class='unexecuted'>        emit LogAuthorizedChanged(account, status);</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'>}</span>
 50 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/strategies/BaseStrategy.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {BoringOwnable} from &quot;BoringSolidity/BoringOwnable.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
   8 |     | <span class='neutral'>import {IStrategy} from &quot;interfaces/IStrategy.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>abstract contract BaseStrategy is IStrategy, BoringOwnable {</span>
  12 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>    IERC20 public immutable strategyToken;</span>
  15 |     | <span class='unexecuted'>    IBentoBoxV1 public immutable bentoBox;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>    bool public exited; /// @dev After bentobox &#39;exits&#39; the strategy harvest, skim and withdraw functions can no loner be called</span>
  18 |     | <span class='unexecuted'>    uint256 public maxBentoBoxBalance; /// @dev Slippage protection when calling harvest</span>
  19 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public strategyExecutors; /// @dev EOAs that can execute safeHarvest</span>
  20 |     | <span class='neutral'>    event LogSetStrategyExecutor(address indexed executor, bool allowed);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /** @param _strategyToken Address of the underlying token the strategy invests.</span>
  23 |     | <span class='neutral'>        @param _bentoBox BentoBox address.</span>
  24 |     | <span class='neutral'>    */</span>
  25 |     | <span class='neutral'>    constructor(IERC20 _strategyToken, IBentoBoxV1 _bentoBox) {</span>
  26 |     | <span class='unexecuted'>        strategyToken = _strategyToken;</span>
  27 |     | <span class='unexecuted'>        bentoBox = _bentoBox;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    //** Strategy implementation: override the following functions: */</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /// @notice Invests the underlying asset.</span>
  33 |     | <span class='neutral'>    /// @param amount The amount of tokens to invest.</span>
  34 |     | <span class='neutral'>    /// @dev Assume the contract&#39;s balance is greater than the amount</span>
  35 |     | <span class='neutral'>    function _skim(uint256 amount) internal virtual {}</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    /// @notice Harvest any profits made and transfer them to address(this) or report a loss</span>
  38 |     | <span class='neutral'>    /// @param balance The amount of tokens that have been invested.</span>
  39 |     | <span class='neutral'>    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.</span>
  40 |     | <span class='neutral'>    /// @dev amountAdded can be left at 0 when reporting profits (gas savings).</span>
  41 |     | <span class='neutral'>    /// amountAdded should not reflect any rewards or tokens the strategy received.</span>
  42 |     | <span class='neutral'>    /// Calcualte the amount added based on what the current deposit is worth.</span>
  43 |     | <span class='neutral'>    /// (The Base Strategy harvest function accounts for rewards).</span>
  44 |     | <span class='neutral'>    function _harvest(uint256 balance) internal virtual returns (int256 amountAdded) {}</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    /// @dev Withdraw the requested amount of the underlying tokens to address(this).</span>
  47 |     | <span class='neutral'>    /// @param amount The requested amount we want to withdraw.</span>
  48 |     | <span class='neutral'>    function _withdraw(uint256 amount) internal virtual {}</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /// @notice Withdraw the maximum available amount of the invested assets to address(this).</span>
  51 |     | <span class='neutral'>    /// @dev This shouldn&#39;t revert (use try catch).</span>
  52 |     | <span class='neutral'>    function _exit() internal virtual {}</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /// @notice Claim any rewards reward tokens and optionally sell them for the underlying token.</span>
  55 |     | <span class='neutral'>    /// @dev Doesn&#39;t need to be implemented if we don&#39;t expect any rewards.</span>
  56 |     | <span class='neutral'>    function _harvestRewards() internal virtual {}</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    //** End strategy implementation */</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    modifier isActive() {</span>
  61 |     | <span class='unexecuted'>        require(!exited, &quot;BentoBox Strategy: exited&quot;);</span>
  62 |     | <span class='neutral'>        _;</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    modifier onlyBentoBox() {</span>
  66 |     | <span class='unexecuted'>        require(msg.sender == address(bentoBox), &quot;BentoBox Strategy: only BentoBox&quot;);</span>
  67 |     | <span class='unexecuted'>        _;</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    modifier onlyExecutor() {</span>
  71 |     | <span class='unexecuted'>        require(msg.sender == owner || strategyExecutors[msg.sender], &quot;BentoBox Strategy: only Executors&quot;);</span>
  72 |     | <span class='neutral'>        _;</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>    function setStrategyExecutor(address executor, bool value) external onlyOwner {</span>
  76 |     | <span class='unexecuted'>        strategyExecutors[executor] = value;</span>
  77 |     | <span class='unexecuted'>        emit LogSetStrategyExecutor(executor, value);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    /// @inheritdoc IStrategy</span>
  81 |     | <span class='unexecuted'>    function skim(uint256 amount) external virtual override {</span>
  82 |     | <span class='unexecuted'>        _skim(amount);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /// @notice Harvest profits while preventing a sandwich attack exploit.</span>
  86 |     | <span class='neutral'>    /// @param maxBalance The maximum balance of the underlying token that is allowed to be in BentoBox.</span>
  87 |     | <span class='neutral'>    /// @param rebalance Whether BentoBox should rebalance the strategy assets to acheive it&#39;s target allocation.</span>
  88 |     | <span class='neutral'>    /// @param maxChangeAmount When rebalancing - the maximum amount that will be deposited to or withdrawn from a strategy to BentoBox.</span>
  89 |     | <span class='neutral'>    /// @param harvestRewards If we want to claim any accrued reward tokens</span>
  90 |     | <span class='neutral'>    /// @dev maxBalance can be set to 0 to keep the previous value.</span>
  91 |     | <span class='neutral'>    /// @dev maxChangeAmount can be set to 0 to allow for full rebalancing.</span>
  92 |     | <span class='unexecuted'>    function safeHarvest(uint256 maxBalance, bool rebalance, uint256 maxChangeAmount, bool harvestRewards) external onlyExecutor {</span>
  93 |     | <span class='unexecuted'>        _safeHarvest(maxBalance, rebalance, maxChangeAmount, harvestRewards);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>    function _safeHarvest(uint256 maxBalance, bool rebalance, uint256 maxChangeAmount, bool harvestRewards) internal {</span>
  97 |     | <span class='neutral'>        if (harvestRewards) {</span>
  98 |     | <span class='neutral'>            _harvestRewards();</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>        if (maxBalance &gt; 0) {</span>
 102 |     | <span class='unexecuted'>            maxBentoBoxBalance = maxBalance;</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='unexecuted'>        IBentoBoxV1(bentoBox).harvest(strategyToken, rebalance, maxChangeAmount);</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /** @inheritdoc IStrategy</span>
 109 |     | <span class='neutral'>    @dev Only BentoBox can call harvest on this strategy.</span>
 110 |     | <span class='neutral'>    @dev Ensures that (1) the caller was this contract (called through the safeHarvest function)</span>
 111 |     | <span class='neutral'>        and (2) that we are not being frontrun by a large BentoBox deposit when harvesting profits. */</span>
 112 |     | <span class='unexecuted'>    function harvest(uint256 balance, address sender) external virtual override isActive onlyBentoBox returns (int256) {</span>
 113 |     | <span class='neutral'>        /** @dev Don&#39;t revert if conditions aren&#39;t met in order to allow</span>
 114 |     | <span class='neutral'>            BentoBox to continiue execution as it might need to do a rebalance. */</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>        if (sender == address(this) &amp;&amp; IBentoBoxV1(bentoBox).totals(strategyToken).elastic &lt;= maxBentoBoxBalance &amp;&amp; balance &gt; 0) {</span>
 117 |     | <span class='unexecuted'>            int256 amount = _harvest(balance);</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>            /** @dev Since harvesting of rewards is accounted for seperately we might also have</span>
 120 |     | <span class='neutral'>            some underlying tokens in the contract that the _harvest call doesn&#39;t report. </span>
 121 |     | <span class='neutral'>            E.g. reward tokens that have been sold into the underlying tokens which are now sitting in the contract.</span>
 122 |     | <span class='neutral'>            Meaning the amount returned by the internal _harvest function isn&#39;t necessary the final profit/loss amount */</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>            uint256 contractBalance = strategyToken.balanceOf(address(this));</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>            if (amount &gt;= 0) {</span>
 127 |     | <span class='neutral'>                // _harvest reported a profit</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>                if (contractBalance &gt; 0) {</span>
 130 |     | <span class='unexecuted'>                    strategyToken.safeTransfer(address(bentoBox), contractBalance);</span>
 131 |     | <span class='neutral'>                }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>                return int256(contractBalance);</span>
 134 |     | <span class='unexecuted'>            } else if (contractBalance &gt; 0) {</span>
 135 |     | <span class='neutral'>                // _harvest reported a loss but we have some tokens sitting in the contract</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='unexecuted'>                int256 diff = amount + int256(contractBalance);</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>                if (diff &gt; 0) {</span>
 140 |     | <span class='neutral'>                    // we still made some profit</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>                    /// @dev send the profit to BentoBox and reinvest the rest</span>
 143 |     | <span class='unexecuted'>                    strategyToken.safeTransfer(address(bentoBox), uint256(diff));</span>
 144 |     | <span class='unexecuted'>                    _skim(uint256(-amount));</span>
 145 |     | <span class='neutral'>                } else {</span>
 146 |     | <span class='neutral'>                    // we made a loss but we have some tokens we can reinvest</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='unexecuted'>                    _skim(contractBalance);</span>
 149 |     | <span class='neutral'>                }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>                return diff;</span>
 152 |     | <span class='neutral'>            } else {</span>
 153 |     | <span class='neutral'>                // we made a loss</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>                return amount;</span>
 156 |     | <span class='neutral'>            }</span>
 157 |     | <span class='neutral'>        }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>        return int256(0);</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    /// @inheritdoc IStrategy</span>
 163 |     | <span class='unexecuted'>    function withdraw(uint256 amount) external virtual override isActive onlyBentoBox returns (uint256 actualAmount) {</span>
 164 |     | <span class='unexecuted'>        _withdraw(amount);</span>
 165 |     | <span class='neutral'>        /// @dev Make sure we send and report the exact same amount of tokens by using balanceOf.</span>
 166 |     | <span class='unexecuted'>        actualAmount = strategyToken.balanceOf(address(this));</span>
 167 |     | <span class='unexecuted'>        strategyToken.safeTransfer(address(bentoBox), actualAmount);</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    /// @inheritdoc IStrategy</span>
 171 |     | <span class='neutral'>    /// @dev do not use isActive modifier here; allow bentobox to call strategy.exit() multiple times</span>
 172 |     | <span class='unexecuted'>    function exit(uint256 balance) external virtual override onlyBentoBox returns (int256 amountAdded) {</span>
 173 |     | <span class='unexecuted'>        _exit();</span>
 174 |     | <span class='neutral'>        /// @dev Check balance of token on the contract.</span>
 175 |     | <span class='unexecuted'>        uint256 actualBalance = strategyToken.balanceOf(address(this));</span>
 176 |     | <span class='neutral'>        /// @dev Calculate tokens added (or lost).</span>
 177 |     | <span class='unexecuted'>        amountAdded = int256(actualBalance) - int256(balance);</span>
 178 |     | <span class='neutral'>        /// @dev Transfer all tokens to bentoBox.</span>
 179 |     | <span class='unexecuted'>        strategyToken.safeTransfer(address(bentoBox), actualBalance);</span>
 180 |     | <span class='neutral'>        /// @dev Flag as exited, allowing the owner to manually deal with any amounts available later.</span>
 181 |     | <span class='unexecuted'>        exited = true;</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    /** @dev After exited, the owner can perform ANY call. This is to rescue any funds that didn&#39;t</span>
 185 |     | <span class='neutral'>        get released during exit or got earned afterwards due to vesting or airdrops, etc. */</span>
 186 |     | <span class='unexecuted'>    function afterExit(address to, uint256 value, bytes memory data) public onlyOwner returns (bool success) {</span>
 187 |     | <span class='unexecuted'>        require(exited, &quot;BentoBox Strategy: not exited&quot;);</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>        // solhint-disable-next-line avoid-low-level-calls</span>
 190 |     | <span class='unexecuted'>        (success, ) = to.call{value: value}(data);</span>
 191 |     | <span class='neutral'>    }</span>
 192 |     | <span class='neutral'>}</span>
 193 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/strategies/GmStrategy.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Address} from &quot;openzeppelin-contracts/utils/Address.sol&quot;;</span>
   5 |     | <span class='neutral'>import {BaseStrategy} from &quot;./BaseStrategy.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
   8 |     | <span class='neutral'>import {FeeCollectable} from &quot;mixins/FeeCollectable.sol&quot;;</span>
   9 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solady/utils/SafeTransferLib.sol&quot;;</span>
  10 |     | <span class='neutral'>import {IGmxV2Deposit, IGmxV2ExchangeRouter, IGmxReader, IGmxV2EventUtils, IGmxDataStore, IGmxV2DepositHandler, IGmxV2DepositCallbackReceiver, IGmxV2Market} from &quot;interfaces/IGmxV2.sol&quot;;</span>
  11 |     | <span class='neutral'>import {IMultiRewardsStaking} from &quot;interfaces/IMultiRewardsStaking.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>contract GmStrategy is BaseStrategy, FeeCollectable, IGmxV2DepositCallbackReceiver {</span>
  14 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    error ErrInsufficientAmountOut();</span>
  17 |     | <span class='neutral'>    error ErrExecuteDepositsDisabled();</span>
  18 |     | <span class='neutral'>    error ErrWrongUser();</span>
  19 |     | <span class='neutral'>    error ErrUnauthorized();</span>
  20 |     | <span class='neutral'>    error ErrInvalidToken();</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    event LogCallbackGasLimitChanged(uint256 previous, uint256 current);</span>
  23 |     | <span class='neutral'>    event LogExchangeChanged(address indexed previous, address indexed current);</span>
  24 |     | <span class='neutral'>    event LogMarketMinted(uint256 total, uint256 strategyAmount, uint256 feeAmount);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>    bytes32 public constant EXECUTE_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(&quot;EXECUTE_DEPOSIT_FEATURE_DISABLED&quot;));</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    IGmxV2ExchangeRouter public immutable GMX_ROUTER;</span>
  29 |     | <span class='unexecuted'>    IGmxReader public immutable GMX_READER;</span>
  30 |     | <span class='unexecuted'>    IGmxDataStore public immutable DATASTORE;</span>
  31 |     | <span class='unexecuted'>    address public immutable DEPOSIT_VAULT;</span>
  32 |     | <span class='unexecuted'>    address public immutable SYNTHETICS_ROUTER;</span>
  33 |     | <span class='unexecuted'>    address public immutable REFUND_TO;</span>
  34 |     | <span class='unexecuted'>    address public immutable LONG_TOKEN;</span>
  35 |     | <span class='unexecuted'>    address public immutable SHORT_TOKEN;</span>
  36 |     | <span class='unexecuted'>    IMultiRewardsStaking public immutable STAKING;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    address public exchange;</span>
  39 |     | <span class='unexecuted'>    uint256 public callbackGasLimit = 2_000_000;</span>
  40 |     | <span class='unexecuted'>    bytes32 public orderKey;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @dev Keep in memory the max balance once the GMX tokens are deposited</span>
  43 |     | <span class='neutral'>    uint256 private maxBalance;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    modifier onlyDepositHandler() {</span>
  46 |     | <span class='neutral'>        if (msg.sender != address(GMX_ROUTER.depositHandler())) {</span>
  47 |     | <span class='neutral'>            revert ErrUnauthorized();</span>
  48 |     | <span class='neutral'>        }</span>
  49 |     | <span class='neutral'>        _;</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>    receive() external payable virtual {</span>
  53 |     | <span class='unexecuted'>        (bool success, ) = REFUND_TO.call{value: msg.value}(&quot;&quot;);</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>        // ignore failures</span>
  56 |     | <span class='unexecuted'>        if (!success) {</span>
  57 |     | <span class='unexecuted'>            return;</span>
  58 |     | <span class='neutral'>        }</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>    constructor(</span>
  62 |     | <span class='neutral'>        address _strategyToken,</span>
  63 |     | <span class='neutral'>        IBentoBoxV1 _degenBox,</span>
  64 |     | <span class='neutral'>        IGmxV2ExchangeRouter _gmxRouter,</span>
  65 |     | <span class='neutral'>        IGmxReader _gmxReader,</span>
  66 |     | <span class='neutral'>        address _syntheticsRouter,</span>
  67 |     | <span class='neutral'>        address _refundTo,</span>
  68 |     | <span class='neutral'>        address _staking</span>
  69 |     | <span class='unexecuted'>    ) BaseStrategy(IERC20(_strategyToken), _degenBox) {</span>
  70 |     | <span class='unexecuted'>        assert(IMultiRewardsStaking(_staking).stakingToken() == _strategyToken);</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>        feeBips = 200; // 2%</span>
  73 |     | <span class='unexecuted'>        feeCollector = msg.sender;</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>        GMX_ROUTER = _gmxRouter;</span>
  76 |     | <span class='unexecuted'>        GMX_READER = _gmxReader;</span>
  77 |     | <span class='unexecuted'>        SYNTHETICS_ROUTER = _syntheticsRouter;</span>
  78 |     | <span class='unexecuted'>        DATASTORE = IGmxDataStore(_gmxRouter.dataStore());</span>
  79 |     | <span class='unexecuted'>        DEPOSIT_VAULT = IGmxV2DepositHandler(_gmxRouter.depositHandler()).depositVault();</span>
  80 |     | <span class='unexecuted'>        REFUND_TO = _refundTo;</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        IGmxV2Market.Props memory props = GMX_READER.getMarket(address(DATASTORE), _strategyToken);</span>
  83 |     | <span class='unexecuted'>        LONG_TOKEN = props.longToken;</span>
  84 |     | <span class='unexecuted'>        SHORT_TOKEN = props.shortToken;</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>        STAKING = IMultiRewardsStaking(_staking);</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>        _strategyToken.safeApprove(address(_staking), type(uint256).max);</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
  92 |     | <span class='neutral'>    /// EXECUTORS</span>
  93 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /// @param _rewardToken Reward token from the staking contract</span>
  96 |     | <span class='neutral'>    /// @param _marketInputToken Same as _rewardToken when _swapData is empty,</span>
  97 |     | <span class='neutral'>    /// otherwise the token to use as market token input</span>
  98 |     | <span class='unexecuted'>    function run(</span>
  99 |     | <span class='neutral'>        address _rewardToken,</span>
 100 |     | <span class='neutral'>        address _marketInputToken,</span>
 101 |     | <span class='neutral'>        uint256 _marketMinOut,</span>
 102 |     | <span class='neutral'>        uint256 _executionFee,</span>
 103 |     | <span class='neutral'>        bytes memory _swapData,</span>
 104 |     | <span class='neutral'>        uint256 _maxBentoBoxAmountIncreaseInBips,</span>
 105 |     | <span class='neutral'>        uint256 _maxBentoBoxChangeAmountInBips</span>
 106 |     | <span class='unexecuted'>    ) external payable onlyExecutor {</span>
 107 |     | <span class='unexecuted'>        uint128 totals = bentoBox.totals(strategyToken).elastic;</span>
 108 |     | <span class='unexecuted'>        maxBalance = totals + ((totals * BIPS) / _maxBentoBoxAmountIncreaseInBips);</span>
 109 |     | <span class='unexecuted'>        uint256 maxChangeAmount = (maxBalance * _maxBentoBoxChangeAmountInBips) / BIPS;</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        _safeHarvest(maxBalance, true, maxChangeAmount, false);</span>
 112 |     | <span class='unexecuted'>        _mintMarketTokens(_rewardToken, _marketInputToken, _marketMinOut, _executionFee, _swapData);</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 116 |     | <span class='neutral'>    /// GMX CALLBACKS</span>
 117 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 118 |     | <span class='unexecuted'>    function afterDepositExecution(bytes32, IGmxV2Deposit.Props memory deposit, IGmxV2EventUtils.EventLogData memory) external override {</span>
 119 |     | <span class='neutral'>        // verify that the deposit was from this address</span>
 120 |     | <span class='unexecuted'>        if (deposit.addresses.account != address(this)) {</span>
 121 |     | <span class='unexecuted'>            revert ErrWrongUser();</span>
 122 |     | <span class='neutral'>        }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>        uint256 total = strategyToken.balanceOf(address(this));</span>
 125 |     | <span class='unexecuted'>        (uint256 amountOut, uint256 feeAmount) = calculateFees(total);</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>        address(strategyToken).safeTransfer(feeCollector, feeAmount);</span>
 128 |     | <span class='unexecuted'>        emit LogMarketMinted(total, amountOut, feeAmount);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>        _safeHarvest(maxBalance, true, 0, false);</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>    function afterDepositCancellation(</span>
 134 |     | <span class='neutral'>        bytes32 key,</span>
 135 |     | <span class='neutral'>        IGmxV2Deposit.Props memory deposit,</span>
 136 |     | <span class='neutral'>        IGmxV2EventUtils.EventLogData memory eventData</span>
 137 |     | <span class='neutral'>    ) external override {}</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 140 |     | <span class='neutral'>    /// ADMIN</span>
 141 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 142 |     | <span class='unexecuted'>    function cancelOrder() external onlyOwner {</span>
 143 |     | <span class='unexecuted'>        GMX_ROUTER.cancelDeposit(orderKey);</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>    function setTokenApproval(address _token, address _to, uint256 _amount) external onlyOwner {</span>
 147 |     | <span class='unexecuted'>        _token.safeApprove(_to, _amount);</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='unexecuted'>    function setCallbackGasLimit(uint256 _callbackGasLimit) external onlyOwner {</span>
 151 |     | <span class='unexecuted'>        emit LogCallbackGasLimitChanged(callbackGasLimit, _callbackGasLimit);</span>
 152 |     | <span class='unexecuted'>        callbackGasLimit = _callbackGasLimit;</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>    function setExchange(address _exchange) external onlyOwner {</span>
 156 |     | <span class='unexecuted'>        emit LogExchangeChanged(exchange, _exchange);</span>
 157 |     | <span class='unexecuted'>        exchange = _exchange;</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>    function rescueToken(address _token, uint256 _amount, address _to) external onlyOwner {</span>
 161 |     | <span class='unexecuted'>        if (_token == address(strategyToken)) {</span>
 162 |     | <span class='unexecuted'>            revert ErrInvalidToken();</span>
 163 |     | <span class='neutral'>        }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='unexecuted'>        _token.safeTransfer(_to, _amount);</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 169 |     | <span class='neutral'>    /// VIEWS</span>
 170 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 171 |     | <span class='unexecuted'>    function isFeeOperator(address account) public view override returns (bool) {</span>
 172 |     | <span class='unexecuted'>        return account == owner;</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='unexecuted'>    function isDepositExecutionDisabled() public view returns (bool) {</span>
 176 |     | <span class='unexecuted'>        bytes32 depositExecutionDisabledKey = keccak256(abi.encode(EXECUTE_DEPOSIT_FEATURE_DISABLED, GMX_ROUTER.depositHandler()));</span>
 177 |     | <span class='unexecuted'>        return DATASTORE.getBool(depositExecutionDisabledKey);</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 181 |     | <span class='neutral'>    /// INTERNALS</span>
 182 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////////////////////////</span>
 183 |     | <span class='unexecuted'>    function _mintMarketTokens(</span>
 184 |     | <span class='neutral'>        address _rewardToken,</span>
 185 |     | <span class='neutral'>        address _marketInputToken,</span>
 186 |     | <span class='neutral'>        uint256 _marketMinOut,</span>
 187 |     | <span class='neutral'>        uint256 _executionFee,</span>
 188 |     | <span class='neutral'>        bytes memory _swapData</span>
 189 |     | <span class='neutral'>    ) internal {</span>
 190 |     | <span class='unexecuted'>        if (isDepositExecutionDisabled()) {</span>
 191 |     | <span class='unexecuted'>            revert ErrExecuteDepositsDisabled();</span>
 192 |     | <span class='neutral'>        }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>        // only allow rize staking rewards</span>
 195 |     | <span class='unexecuted'>        if (!STAKING.isSupportedReward(_rewardToken)) {</span>
 196 |     | <span class='unexecuted'>            revert ErrInvalidToken();</span>
 197 |     | <span class='neutral'>        }</span>
 198 |     | <span class='neutral'>    </span>
 199 |     | <span class='unexecuted'>        if (_swapData.length &gt; 0) {</span>
 200 |     | <span class='unexecuted'>            Address.functionCall(exchange, _swapData);</span>
 201 |     | <span class='neutral'>        }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='unexecuted'>        GMX_ROUTER.sendWnt{value: _executionFee}(address(DEPOSIT_VAULT), _executionFee);</span>
 204 |     | <span class='unexecuted'>        GMX_ROUTER.sendTokens(_marketInputToken, address(DEPOSIT_VAULT), _marketInputToken.balanceOf(address(this)));</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='unexecuted'>        address[] memory emptyPath = new address[](0);</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='unexecuted'>        IGmxV2Deposit.CreateDepositParams memory params = IGmxV2Deposit.CreateDepositParams({</span>
 209 |     | <span class='unexecuted'>            receiver: address(this),</span>
 210 |     | <span class='neutral'>            callbackContract: address(this),</span>
 211 |     | <span class='neutral'>            uiFeeReceiver: address(0),</span>
 212 |     | <span class='unexecuted'>            market: address(strategyToken),</span>
 213 |     | <span class='unexecuted'>            initialLongToken: LONG_TOKEN,</span>
 214 |     | <span class='unexecuted'>            initialShortToken: SHORT_TOKEN,</span>
 215 |     | <span class='neutral'>            longTokenSwapPath: emptyPath,</span>
 216 |     | <span class='neutral'>            shortTokenSwapPath: emptyPath,</span>
 217 |     | <span class='neutral'>            minMarketTokens: _marketMinOut,</span>
 218 |     | <span class='neutral'>            shouldUnwrapNativeToken: false,</span>
 219 |     | <span class='neutral'>            executionFee: _executionFee,</span>
 220 |     | <span class='unexecuted'>            callbackGasLimit: callbackGasLimit</span>
 221 |     | <span class='neutral'>        });</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='unexecuted'>        orderKey = GMX_ROUTER.createDeposit(params);</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='unexecuted'>    function _skim(uint256 amount) internal override {</span>
 227 |     | <span class='unexecuted'>        STAKING.stake(amount);</span>
 228 |     | <span class='unexecuted'>        STAKING.getRewards();</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='unexecuted'>    function _harvest(uint256) internal override returns (int256) {</span>
 232 |     | <span class='unexecuted'>        STAKING.getRewards();</span>
 233 |     | <span class='unexecuted'>        return int256(0);</span>
 234 |     | <span class='neutral'>    }</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='unexecuted'>    function _withdraw(uint256 amount) internal override {</span>
 237 |     | <span class='unexecuted'>        STAKING.withdraw(amount);</span>
 238 |     | <span class='neutral'>        STAKING.getRewards();</span>
 239 |     | <span class='neutral'>    }</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='unexecuted'>    function _exit() internal override {</span>
 242 |     | <span class='unexecuted'>        STAKING.exit();</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'>}</span>
 245 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/strategies/MasterChefLPStrategy.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
   5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {UniswapV2Library, UniswapV2OneSided} from &quot;libraries/UniswapV2Lib.sol&quot;;</span>
   8 |     | <span class='neutral'>import {IUniswapV2Pair, IUniswapV2Router01} from &quot;interfaces/IUniswapV2.sol&quot;;</span>
   9 |     | <span class='neutral'>import {BaseStrategy} from &quot;./BaseStrategy.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>interface IMasterChef {</span>
  12 |     | <span class='neutral'>    function deposit(uint256 _pid, uint256 _amount) external;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    function withdraw(uint256 _pid, uint256 _amount) external;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    function userInfo(uint256 _pid, address user) external view returns (uint256 amount, uint256 rewardDebt);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    function emergencyWithdraw(uint256 _pid) external;</span>
  19 |     | <span class='neutral'>}</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>contract MasterChefLPStrategy is BaseStrategy {</span>
  22 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    error InvalidFeePercent();</span>
  25 |     | <span class='neutral'>    error InsupportedToken(address token);</span>
  26 |     | <span class='neutral'>    event LpMinted(uint256 total, uint256 strategyAmount, uint256 feeAmount);</span>
  27 |     | <span class='neutral'>    event RewardTokenUpdated(address token, bool enabled);</span>
  28 |     | <span class='neutral'>    event FeeChanged(uint256 previousFee, uint256 newFee, address previousFeeCollector, address newFeeCollector);</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>    IMasterChef public immutable masterchef;</span>
  31 |     | <span class='unexecuted'>    IUniswapV2Router01 public immutable router;</span>
  32 |     | <span class='unexecuted'>    uint256 public immutable pid;</span>
  33 |     | <span class='unexecuted'>    address public immutable token0;</span>
  34 |     | <span class='unexecuted'>    address public immutable token1;</span>
  35 |     | <span class='neutral'>    bytes32 internal immutable pairCodeHash;</span>
  36 |     | <span class='unexecuted'>    address public immutable factory;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    struct RewardTokenInfo {</span>
  39 |     | <span class='neutral'>        bool enabled;</span>
  40 |     | <span class='neutral'>        // When true, the _rewardToken will be swapped to the pair&#39;s token0 for one-sided liquidity providing, otherwise, the pair&#39;s token1.</span>
  41 |     | <span class='neutral'>        bool usePairToken0;</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='unexecuted'>    mapping(address =&gt; RewardTokenInfo) public rewardTokensInfo;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>    address public feeCollector;</span>
  47 |     | <span class='unexecuted'>    uint8 public feePercent;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    constructor(</span>
  50 |     | <span class='neutral'>        IERC20 _strategyToken,</span>
  51 |     | <span class='neutral'>        IBentoBoxV1 _bentoBox,</span>
  52 |     | <span class='neutral'>        address _factory,</span>
  53 |     | <span class='neutral'>        IMasterChef _masterchef,</span>
  54 |     | <span class='neutral'>        uint256 _pid,</span>
  55 |     | <span class='neutral'>        IUniswapV2Router01 _router,</span>
  56 |     | <span class='neutral'>        bytes32 _pairCodeHash</span>
  57 |     | <span class='unexecuted'>    ) BaseStrategy(_strategyToken, _bentoBox) {</span>
  58 |     | <span class='unexecuted'>        factory = _factory;</span>
  59 |     | <span class='unexecuted'>        masterchef = _masterchef;</span>
  60 |     | <span class='unexecuted'>        pid = _pid;</span>
  61 |     | <span class='unexecuted'>        router = _router;</span>
  62 |     | <span class='unexecuted'>        pairCodeHash = _pairCodeHash;</span>
  63 |     | <span class='unexecuted'>        feeCollector = msg.sender;</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>        address _token0 = IUniswapV2Pair(address(_strategyToken)).token0();</span>
  66 |     | <span class='unexecuted'>        address _token1 = IUniswapV2Pair(address(_strategyToken)).token1();</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>        IERC20(_token0).approve(address(_router), type(uint256).max);</span>
  69 |     | <span class='unexecuted'>        IERC20(_token1).approve(address(_router), type(uint256).max);</span>
  70 |     | <span class='unexecuted'>        IERC20(_strategyToken).approve(address(_masterchef), type(uint256).max);</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>        token0 = _token0;</span>
  73 |     | <span class='unexecuted'>        token1 = _token1;</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    /// @param token The reward token to add</span>
  77 |     | <span class='neutral'>    /// @param usePairToken0 When true, the _rewardToken will be swapped to the pair&#39;s token0 for one-sided liquidity</span>
  78 |     | <span class='neutral'>    /// providing, otherwise, the pair&#39;s token1.</span>
  79 |     | <span class='unexecuted'>    function setRewardTokenInfo(address token, bool usePairToken0, bool enabled) external onlyOwner {</span>
  80 |     | <span class='unexecuted'>        rewardTokensInfo[token] = RewardTokenInfo(enabled, usePairToken0);</span>
  81 |     | <span class='unexecuted'>        emit RewardTokenUpdated(token, enabled);</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>    function _skim(uint256 amount) internal virtual override {</span>
  85 |     | <span class='unexecuted'>        masterchef.deposit(pid, amount);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>    function _harvest(uint256) internal virtual override returns (int256) {</span>
  89 |     | <span class='unexecuted'>        masterchef.withdraw(pid, 0);</span>
  90 |     | <span class='unexecuted'>        return int256(0);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>    function _withdraw(uint256 amount) internal virtual override {</span>
  94 |     | <span class='unexecuted'>        masterchef.withdraw(pid, amount);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>    function _exit() internal virtual override {</span>
  98 |     | <span class='unexecuted'>        masterchef.emergencyWithdraw(pid);</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>    function _swapRewards(address tokenIn, address tokenOut) private returns (uint256 amountOut) {</span>
 102 |     | <span class='unexecuted'>        uint256 amountIn = IERC20(tokenIn).balanceOf(address(this));</span>
 103 |     | <span class='unexecuted'>        IUniswapV2Pair pair = IUniswapV2Pair(address(UniswapV2Library.pairFor(factory, tokenIn, tokenOut, pairCodeHash)));</span>
 104 |     | <span class='unexecuted'>        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();</span>
 105 |     | <span class='unexecuted'>        IERC20(tokenIn).safeTransfer(address(pair), amountIn);</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>        if (tokenIn == pair.token0()) {</span>
 108 |     | <span class='unexecuted'>            amountOut = UniswapV2Library.getAmountOut(amountIn, reserve0, reserve1);</span>
 109 |     | <span class='unexecuted'>            pair.swap(0, amountOut, address(this), &quot;&quot;);</span>
 110 |     | <span class='neutral'>        } else {</span>
 111 |     | <span class='unexecuted'>            amountOut = UniswapV2Library.getAmountOut(amountIn, reserve1, reserve0);</span>
 112 |     | <span class='unexecuted'>            pair.swap(amountOut, 0, address(this), &quot;&quot;);</span>
 113 |     | <span class='neutral'>        }</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    /// @notice Swap some tokens in the contract for the underlying and deposits them to address(this)</span>
 117 |     | <span class='unexecuted'>    function swapToLP(uint256 amountOutMin, address rewardToken) public onlyExecutor returns (uint256 amountOut) {</span>
 118 |     | <span class='unexecuted'>        RewardTokenInfo memory info = rewardTokensInfo[rewardToken];</span>
 119 |     | <span class='unexecuted'>        if (!info.enabled) {</span>
 120 |     | <span class='unexecuted'>            revert InsupportedToken(rewardToken);</span>
 121 |     | <span class='neutral'>        }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>        address pairInputToken = info.usePairToken0 ? token0 : token1;</span>
 124 |     | <span class='unexecuted'>        uint256 tokenInAmount = _swapRewards(rewardToken, pairInputToken);</span>
 125 |     | <span class='unexecuted'>        uint256 amountStrategyLpBefore = strategyToken.balanceOf(address(this));</span>
 126 |     | <span class='unexecuted'>        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(address(strategyToken)).getReserves();</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>        UniswapV2OneSided.AddLiquidityFromSingleTokenParams memory _addLiquidityFromSingleTokenParams = UniswapV2OneSided</span>
 129 |     | <span class='neutral'>            .AddLiquidityFromSingleTokenParams(</span>
 130 |     | <span class='unexecuted'>                router,</span>
 131 |     | <span class='unexecuted'>                IUniswapV2Pair(address(strategyToken)),</span>
 132 |     | <span class='unexecuted'>                token0,</span>
 133 |     | <span class='unexecuted'>                token1,</span>
 134 |     | <span class='unexecuted'>                reserve0,</span>
 135 |     | <span class='unexecuted'>                reserve1,</span>
 136 |     | <span class='unexecuted'>                pairInputToken,</span>
 137 |     | <span class='unexecuted'>                tokenInAmount,</span>
 138 |     | <span class='unexecuted'>                address(this)</span>
 139 |     | <span class='neutral'>            );</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='unexecuted'>        UniswapV2OneSided.addLiquidityFromSingleToken(_addLiquidityFromSingleTokenParams);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>        uint256 total = IERC20(strategyToken).balanceOf(address(this)) - amountStrategyLpBefore;</span>
 144 |     | <span class='unexecuted'>        require(total &gt;= amountOutMin, &quot;InsufficientAmountOut&quot;);</span>
 145 |     | <span class='unexecuted'>        uint256 feeAmount = (total * feePercent) / 100;</span>
 146 |     | <span class='unexecuted'>        if (feeAmount &gt; 0) {</span>
 147 |     | <span class='unexecuted'>            amountOut = total - feeAmount;</span>
 148 |     | <span class='unexecuted'>            IERC20(strategyToken).safeTransfer(feeCollector, feeAmount);</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>        emit LpMinted(total, amountOut, feeAmount);</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>    function setFeeParameters(address _feeCollector, uint8 _feePercent) external onlyOwner {</span>
 155 |     | <span class='unexecuted'>        if (feePercent &gt; 100) {</span>
 156 |     | <span class='unexecuted'>            revert InvalidFeePercent();</span>
 157 |     | <span class='neutral'>        }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>        uint256 previousFee = feePercent;</span>
 160 |     | <span class='unexecuted'>        address previousFeeCollector = feeCollector;</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='unexecuted'>        feeCollector = _feeCollector;</span>
 163 |     | <span class='unexecuted'>        feePercent = _feePercent;</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='unexecuted'>        emit FeeChanged(previousFee, _feePercent, previousFeeCollector, _feeCollector);</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'>}</span>
 168 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/strategies/NegativeInterestStrategy.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
   5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {BaseStrategy} from &quot;./BaseStrategy.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='unexecuted'>contract NegativeInterestStrategy is BaseStrategy {</span>
  10 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    error InsupportedToken();</span>
  13 |     | <span class='neutral'>    error InvalidInterestRate();</span>
  14 |     | <span class='neutral'>    error SwapFailed();</span>
  15 |     | <span class='neutral'>    error InsufficientAmountOut();</span>
  16 |     | <span class='neutral'>    error InvalidFeeTo();</span>
  17 |     | <span class='neutral'>    error InvalidMaxInterestPerSecond();</span>
  18 |     | <span class='neutral'>    error InvalidLerpParameters();</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    event LogAccrue(uint256 accruedAmount);</span>
  21 |     | <span class='neutral'>    event LogInterestChanged(uint64 interestPerSecond);</span>
  22 |     | <span class='neutral'>    event LogInterestWithLerpChanged(uint64 startInterestPerSecond, uint64 targetInterestPerSecond, uint64 duration);</span>
  23 |     | <span class='neutral'>    event LogMaxStrategyExecutorInterestPerSecondChanged(uint256 previous, uint256 current);</span>
  24 |     | <span class='neutral'>    event FeeToChanged(address previous, address current);</span>
  25 |     | <span class='neutral'>    event SwapperChanged(address previous, address current);</span>
  26 |     | <span class='neutral'>    event Swap(uint256 amountIn, uint256 amountOut);</span>
  27 |     | <span class='neutral'>    event SwapTokenOutEnabled(IERC20 token, bool enabled);</span>
  28 |     | <span class='neutral'>    event SwapAndWithdrawFee(uint256 amountIn, uint256 amountOut, IERC20 tokenOut);</span>
  29 |     | <span class='neutral'>    event WithdrawFee(uint256 amount);</span>
  30 |     | <span class='neutral'>    event EmergencyExitEnabled(bool enabled);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>    uint256 private constant WAD = 1e18;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    // Interest linear interpolation to destination in a given time</span>
  35 |     | <span class='neutral'>    // ex: 1% -&gt; 13% in 30 days.</span>
  36 |     | <span class='neutral'>    struct InterestLerp {</span>
  37 |     | <span class='neutral'>        uint64 startTime;</span>
  38 |     | <span class='neutral'>        uint64 startInterestPerSecond;</span>
  39 |     | <span class='neutral'>        uint64 targetInterestPerSecond;</span>
  40 |     | <span class='neutral'>        uint64 duration;</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    // slot grouping</span>
  44 |     | <span class='unexecuted'>    uint128 public pendingFeeEarned;</span>
  45 |     | <span class='unexecuted'>    uint128 public pendingFeeEarnedAdjustement;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    // slot grouping</span>
  48 |     | <span class='unexecuted'>    uint64 public lastAccrued;</span>
  49 |     | <span class='unexecuted'>    uint64 public interestPerSecond;</span>
  50 |     | <span class='unexecuted'>    bool public emergencyExitEnabled;</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>    address public feeTo;</span>
  53 |     | <span class='unexecuted'>    address public swapper;</span>
  54 |     | <span class='unexecuted'>    uint256 public principal;</span>
  55 |     | <span class='unexecuted'>    mapping(IERC20 =&gt; bool) public swapTokenOutEnabled;</span>
  56 |     | <span class='unexecuted'>    InterestLerp public interestLerp;</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /// @dev This is the maximum interest per second that a strategy executor can set.</span>
  59 |     | <span class='neutral'>    uint256 maxStrategyExecutorInterestPerSecond;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>    constructor(IERC20 _strategyToken, IERC20 _mim, IBentoBoxV1 _bentoBox, address _feeTo) BaseStrategy(_strategyToken, _bentoBox) {</span>
  62 |     | <span class='unexecuted'>        feeTo = _feeTo;</span>
  63 |     | <span class='unexecuted'>        swapTokenOutEnabled[_mim] = true;</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>        maxStrategyExecutorInterestPerSecond = getInterestPerSecond(1_000_000); // 1_000%</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>        emit LogMaxStrategyExecutorInterestPerSecondChanged(0, maxStrategyExecutorInterestPerSecond);</span>
  68 |     | <span class='unexecuted'>        emit FeeToChanged(address(0), _feeTo);</span>
  69 |     | <span class='unexecuted'>        emit SwapTokenOutEnabled(_mim, true);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>    function setMaxStrategyExecutorInterestPerSecond(uint256 _maxStrategyExecutorInterestPerSecond) public onlyOwner {</span>
  73 |     | <span class='unexecuted'>        emit LogMaxStrategyExecutorInterestPerSecondChanged(maxStrategyExecutorInterestPerSecond, _maxStrategyExecutorInterestPerSecond);</span>
  74 |     | <span class='unexecuted'>        maxStrategyExecutorInterestPerSecond = _maxStrategyExecutorInterestPerSecond;</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /// @dev example: 200 is 2% interests</span>
  78 |     | <span class='unexecuted'>    function getInterestPerSecond(uint256 yearlyInterestBips) public pure returns (uint64 interestsPerSecond) {</span>
  79 |     | <span class='unexecuted'>        return uint64((yearlyInterestBips * 316880878) / 100); // 316880878 is the precomputed integral part of 1e18 / (36525 * 3600 * 24)</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>    function getYearlyInterestBips() external view returns (uint256) {</span>
  83 |     | <span class='unexecuted'>        return (interestPerSecond * 100) / 316880878;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>    function _updateInterestPerSecond() private {</span>
  87 |     | <span class='unexecuted'>        if (interestLerp.duration == 0) {</span>
  88 |     | <span class='neutral'>            return;</span>
  89 |     | <span class='neutral'>        }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        /// @dev Adapted from https://github.com/makerdao/dss-lerp/blob/master/src/Lerp.sol</span>
  92 |     | <span class='unexecuted'>        if (block.timestamp &lt; interestLerp.startTime + interestLerp.duration) {</span>
  93 |     | <span class='unexecuted'>            uint256 t = ((block.timestamp - interestLerp.startTime) * WAD) / interestLerp.duration;</span>
  94 |     | <span class='unexecuted'>            interestPerSecond = uint64(</span>
  95 |     | <span class='unexecuted'>                (interestLerp.targetInterestPerSecond * t) /</span>
  96 |     | <span class='neutral'>                    WAD +</span>
  97 |     | <span class='unexecuted'>                    interestLerp.startInterestPerSecond -</span>
  98 |     | <span class='unexecuted'>                    (interestLerp.startInterestPerSecond * t) /</span>
  99 |     | <span class='neutral'>                    WAD</span>
 100 |     | <span class='neutral'>            );</span>
 101 |     | <span class='neutral'>        } else {</span>
 102 |     | <span class='unexecuted'>            interestPerSecond = interestLerp.targetInterestPerSecond;</span>
 103 |     | <span class='unexecuted'>            interestLerp.duration = 0;</span>
 104 |     | <span class='neutral'>        }</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>    function skim(uint256) external override isActive onlyBentoBox {</span>
 108 |     | <span class='unexecuted'>        principal = availableAmount();</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /// @dev accrue interest and report loss</span>
 112 |     | <span class='neutral'>    /// The interest linear interpolation used here is very basic: the more this function is called the smoother</span>
 113 |     | <span class='neutral'>    /// the interpolation.</span>
 114 |     | <span class='neutral'>    /// Meaning that if we&#39;re ramping from 1% to 13% in 30 days and that harvest is called only once on</span>
 115 |     | <span class='neutral'>    /// the 15th day, 1% interest will be used for these 15 days and then the next harvest will be around 7%.</span>
 116 |     | <span class='neutral'>    /// If we are calling it daily it will smoothly increase by steps of 0.4% (12% / 30 days)</span>
 117 |     | <span class='unexecuted'>    function harvest(uint256 balance, address sender) external virtual override isActive onlyBentoBox returns (int256) {</span>
 118 |     | <span class='unexecuted'>        if (sender == address(this) &amp;&amp; balance &gt; 0) {</span>
 119 |     | <span class='unexecuted'>            uint256 accrued = _accrue();</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>            // add the potential accrued interest collected from changing the interest rate, since</span>
 122 |     | <span class='neutral'>            // this didn&#39;t harvest &amp; reported loss yet.</span>
 123 |     | <span class='unexecuted'>            accrued += pendingFeeEarnedAdjustement;</span>
 124 |     | <span class='unexecuted'>            pendingFeeEarnedAdjustement = 0;</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>            return -int256(accrued);</span>
 127 |     | <span class='neutral'>        }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>        return int256(0);</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='unexecuted'>    function withdraw(uint256 amount) external override isActive onlyBentoBox returns (uint256 actualAmount) {</span>
 133 |     | <span class='unexecuted'>        uint256 maxAvailableAmount = availableAmount();</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='unexecuted'>        if (maxAvailableAmount &gt; 0) {</span>
 136 |     | <span class='unexecuted'>            actualAmount = amount &gt; maxAvailableAmount ? maxAvailableAmount : amount;</span>
 137 |     | <span class='unexecuted'>            maxAvailableAmount -= actualAmount;</span>
 138 |     | <span class='unexecuted'>            strategyToken.safeTransfer(address(bentoBox), actualAmount);</span>
 139 |     | <span class='neutral'>        }</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='unexecuted'>        principal = availableAmount();</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>    function exit(uint256 amount) external override onlyBentoBox returns (int256 amountAdded) {</span>
 145 |     | <span class='neutral'>        // in case something wrong happen, we can exit and use `afterExit` once we&#39;ve exited.</span>
 146 |     | <span class='unexecuted'>        if (emergencyExitEnabled) {</span>
 147 |     | <span class='unexecuted'>            exited = true;</span>
 148 |     | <span class='neutral'>            return int256(0);</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>        _accrue();</span>
 152 |     | <span class='unexecuted'>        uint256 maxAvailableAmount = availableAmount();</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>        if (maxAvailableAmount &gt; 0) {</span>
 155 |     | <span class='unexecuted'>            uint256 actualAmount = amount &gt; maxAvailableAmount ? maxAvailableAmount : amount;</span>
 156 |     | <span class='unexecuted'>            amountAdded = int256(actualAmount) - int256(amount);</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='unexecuted'>            if (actualAmount &gt; 0) {</span>
 159 |     | <span class='unexecuted'>                strategyToken.safeTransfer(address(bentoBox), actualAmount);</span>
 160 |     | <span class='neutral'>            }</span>
 161 |     | <span class='neutral'>        }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='unexecuted'>        principal = 0;</span>
 164 |     | <span class='unexecuted'>        exited = true;</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='unexecuted'>    function availableAmount() public view returns (uint256 amount) {</span>
 168 |     | <span class='unexecuted'>        uint256 balance = strategyToken.balanceOf(address(this));</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>        if (balance &gt; pendingFeeEarned) {</span>
 171 |     | <span class='unexecuted'>            amount = balance - pendingFeeEarned;</span>
 172 |     | <span class='neutral'>        }</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='unexecuted'>    function withdrawFees() external onlyExecutor returns (uint256) {</span>
 176 |     | <span class='unexecuted'>        IERC20(strategyToken).safeTransfer(feeTo, pendingFeeEarned);</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>        emit WithdrawFee(pendingFeeEarned);</span>
 179 |     | <span class='unexecuted'>        pendingFeeEarned = 0;</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>        return pendingFeeEarned;</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='unexecuted'>    function swapAndwithdrawFees(uint256 amountOutMin, IERC20 tokenOut, bytes calldata data) external onlyExecutor returns (uint256) {</span>
 185 |     | <span class='unexecuted'>        if (!swapTokenOutEnabled[tokenOut]) {</span>
 186 |     | <span class='unexecuted'>            revert InsupportedToken();</span>
 187 |     | <span class='neutral'>        }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='unexecuted'>        uint256 amountInBefore = IERC20(strategyToken).balanceOf(address(this));</span>
 190 |     | <span class='unexecuted'>        uint256 amountOutBefore = tokenOut.balanceOf(address(this));</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='unexecuted'>        (bool success, ) = swapper.call(data);</span>
 193 |     | <span class='unexecuted'>        if (!success) {</span>
 194 |     | <span class='unexecuted'>            revert SwapFailed();</span>
 195 |     | <span class='neutral'>        }</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='unexecuted'>        uint256 amountOut = tokenOut.balanceOf(address(this)) - amountOutBefore;</span>
 198 |     | <span class='unexecuted'>        if (amountOut &lt; amountOutMin) {</span>
 199 |     | <span class='unexecuted'>            revert InsufficientAmountOut();</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>        uint256 amountIn = amountInBefore - IERC20(strategyToken).balanceOf(address(this));</span>
 203 |     | <span class='unexecuted'>        pendingFeeEarned -= uint128(amountIn);</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='unexecuted'>        tokenOut.safeTransfer(feeTo, amountOut);</span>
 206 |     | <span class='unexecuted'>        emit SwapAndWithdrawFee(amountIn, amountOut, tokenOut);</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='unexecuted'>        return amountOut;</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='unexecuted'>    function _accrue() private returns (uint128 interest) {</span>
 212 |     | <span class='unexecuted'>        if (lastAccrued == 0) {</span>
 213 |     | <span class='neutral'>            // we want to start accruing interests as soon as there&#39;s a deposited amount.</span>
 214 |     | <span class='unexecuted'>            if (principal &gt; 0) {</span>
 215 |     | <span class='unexecuted'>                lastAccrued = uint64(block.timestamp);</span>
 216 |     | <span class='neutral'>            }</span>
 217 |     | <span class='unexecuted'>            return 0;</span>
 218 |     | <span class='neutral'>        }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>        // Number of seconds since accrue was called</span>
 221 |     | <span class='unexecuted'>        uint256 elapsedTime = block.timestamp - lastAccrued;</span>
 222 |     | <span class='unexecuted'>        if (elapsedTime == 0) {</span>
 223 |     | <span class='unexecuted'>            return 0;</span>
 224 |     | <span class='neutral'>        }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='unexecuted'>        lastAccrued = uint64(block.timestamp);</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='unexecuted'>        if (principal == 0) {</span>
 229 |     | <span class='unexecuted'>            return 0;</span>
 230 |     | <span class='neutral'>        }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='neutral'>        // Accrue interest</span>
 233 |     | <span class='unexecuted'>        interest = uint128((principal * interestPerSecond * elapsedTime) / 1e18);</span>
 234 |     | <span class='unexecuted'>        pendingFeeEarned += interest;</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='unexecuted'>        _updateInterestPerSecond();</span>
 237 |     | <span class='unexecuted'>        emit LogAccrue(interest);</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='unexecuted'>    function setFeeTo(address _feeTo) external onlyOwner {</span>
 241 |     | <span class='unexecuted'>        if (_feeTo == address(0)) {</span>
 242 |     | <span class='unexecuted'>            revert InvalidFeeTo();</span>
 243 |     | <span class='neutral'>        }</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='unexecuted'>        emit FeeToChanged(feeTo, _feeTo);</span>
 246 |     | <span class='unexecuted'>        feeTo = _feeTo;</span>
 247 |     | <span class='neutral'>    }</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='unexecuted'>    function setSwapper(address _swapper) external onlyOwner {</span>
 250 |     | <span class='unexecuted'>        if (swapper != address(0)) {</span>
 251 |     | <span class='unexecuted'>            strategyToken.approve(swapper, 0);</span>
 252 |     | <span class='neutral'>        }</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='unexecuted'>        strategyToken.approve(_swapper, type(uint256).max);</span>
 255 |     | <span class='unexecuted'>        emit SwapperChanged(swapper, _swapper);</span>
 256 |     | <span class='unexecuted'>        swapper = _swapper;</span>
 257 |     | <span class='neutral'>    }</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='unexecuted'>    function setSwapTokenOutEnabled(IERC20 token, bool enabled) external onlyOwner {</span>
 260 |     | <span class='unexecuted'>        swapTokenOutEnabled[token] = enabled;</span>
 261 |     | <span class='unexecuted'>        emit SwapTokenOutEnabled(token, enabled);</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='unexecuted'>    function setInterest(uint256 yearlyInterestBips) public onlyExecutor {</span>
 265 |     | <span class='unexecuted'>        _setInterestPerSecond(getInterestPerSecond(yearlyInterestBips));</span>
 266 |     | <span class='neutral'>    }</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='unexecuted'>    function setInterestWithLerp(uint64 startYearlyInterestBips, uint64 targetYearlyInterestBips, uint64 duration) public onlyExecutor {</span>
 269 |     | <span class='unexecuted'>        _setInterestPerSecondWithLerp(</span>
 270 |     | <span class='unexecuted'>            getInterestPerSecond(startYearlyInterestBips),</span>
 271 |     | <span class='unexecuted'>            getInterestPerSecond(targetYearlyInterestBips),</span>
 272 |     | <span class='unexecuted'>            duration</span>
 273 |     | <span class='neutral'>        );</span>
 274 |     | <span class='neutral'>    }</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='unexecuted'>    function setInterestPerSecond(uint64 _interestPerSecond) public onlyExecutor {</span>
 277 |     | <span class='unexecuted'>        _setInterestPerSecond(_interestPerSecond);</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='unexecuted'>    function setInterestPerSecondWithLerp(</span>
 281 |     | <span class='neutral'>        uint64 startInterestPerSecond,</span>
 282 |     | <span class='neutral'>        uint64 targetInterestPerSecond,</span>
 283 |     | <span class='neutral'>        uint64 duration</span>
 284 |     | <span class='neutral'>    ) public onlyExecutor {</span>
 285 |     | <span class='unexecuted'>        _setInterestPerSecondWithLerp(startInterestPerSecond, targetInterestPerSecond, duration);</span>
 286 |     | <span class='neutral'>    }</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='unexecuted'>    function _setInterestPerSecond(uint64 _interestPerSecond) private {</span>
 289 |     | <span class='unexecuted'>        if (owner != msg.sender) {</span>
 290 |     | <span class='unexecuted'>            if (_interestPerSecond &gt; maxStrategyExecutorInterestPerSecond) {</span>
 291 |     | <span class='unexecuted'>                revert InvalidMaxInterestPerSecond();</span>
 292 |     | <span class='neutral'>            }</span>
 293 |     | <span class='neutral'>        }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='unexecuted'>        pendingFeeEarnedAdjustement += _accrue();</span>
 296 |     | <span class='unexecuted'>        interestPerSecond = _interestPerSecond;</span>
 297 |     | <span class='unexecuted'>        interestLerp.duration = 0;</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='unexecuted'>        emit LogInterestChanged(interestPerSecond);</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='unexecuted'>    function _setInterestPerSecondWithLerp(uint64 startInterestPerSecond, uint64 targetInterestPerSecond, uint64 duration) private {</span>
 303 |     | <span class='unexecuted'>        if (owner != msg.sender) {</span>
 304 |     | <span class='unexecuted'>            if (</span>
 305 |     | <span class='unexecuted'>                startInterestPerSecond &gt; maxStrategyExecutorInterestPerSecond ||</span>
 306 |     | <span class='unexecuted'>                targetInterestPerSecond &gt; maxStrategyExecutorInterestPerSecond</span>
 307 |     | <span class='neutral'>            ) {</span>
 308 |     | <span class='unexecuted'>                revert InvalidMaxInterestPerSecond();</span>
 309 |     | <span class='neutral'>            }</span>
 310 |     | <span class='neutral'>        }</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='unexecuted'>        if (duration == 0 || duration &gt; 365 days || targetInterestPerSecond &lt;= startInterestPerSecond) {</span>
 313 |     | <span class='unexecuted'>            revert InvalidLerpParameters();</span>
 314 |     | <span class='neutral'>        }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='unexecuted'>        pendingFeeEarnedAdjustement += _accrue();</span>
 317 |     | <span class='unexecuted'>        interestPerSecond = startInterestPerSecond;</span>
 318 |     | <span class='unexecuted'>        interestLerp.duration = duration;</span>
 319 |     | <span class='unexecuted'>        interestLerp.startTime = uint64(block.timestamp);</span>
 320 |     | <span class='unexecuted'>        interestLerp.startInterestPerSecond = startInterestPerSecond;</span>
 321 |     | <span class='unexecuted'>        interestLerp.targetInterestPerSecond = targetInterestPerSecond;</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='unexecuted'>        emit LogInterestWithLerpChanged(startInterestPerSecond, targetInterestPerSecond, duration);</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='unexecuted'>    function setEmergencyExitEnabled(bool _emergencyExitEnabled) external onlyOwner {</span>
 327 |     | <span class='unexecuted'>        emergencyExitEnabled = _emergencyExitEnabled;</span>
 328 |     | <span class='unexecuted'>        emit EmergencyExitEnabled(_emergencyExitEnabled);</span>
 329 |     | <span class='neutral'>    }</span>
 330 |     | <span class='neutral'>}</span>
 331 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/strategies/StargateLPStrategy.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import {Address} from &quot;openzeppelin-contracts/utils/Address.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BaseStrategy} from &quot;./BaseStrategy.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
   8 |     | <span class='neutral'>import {IStargateLPStaking, IStargatePool, IStargateRouter} from &quot;interfaces/IStargate.sol&quot;;</span>
   9 |     | <span class='neutral'>import {FeeCollectable} from &quot;mixins/FeeCollectable.sol&quot;;</span>
  10 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solady/utils/SafeTransferLib.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>contract StargateLPStrategy is BaseStrategy, FeeCollectable {</span>
  13 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    error ErrInsufficientAmountOut();</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    event LogLpMinted(uint256 total, uint256 strategyAmount, uint256 feeAmount);</span>
  18 |     | <span class='neutral'>    event LogStargateSwapperChanged(address oldSwapper, address newSwapper);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    IStargateLPStaking public immutable staking;</span>
  21 |     | <span class='unexecuted'>    IStargateRouter public immutable router;</span>
  22 |     | <span class='unexecuted'>    address public immutable rewardToken;</span>
  23 |     | <span class='unexecuted'>    address public immutable underlyingToken;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    uint256 public immutable poolId;</span>
  26 |     | <span class='unexecuted'>    uint256 public immutable pid;</span>
  27 |     | <span class='unexecuted'>    address public stargateSwapper;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    constructor(</span>
  30 |     | <span class='neutral'>        IStargatePool _strategyToken,</span>
  31 |     | <span class='neutral'>        IBentoBoxV1 _bentoBox,</span>
  32 |     | <span class='neutral'>        IStargateRouter _router,</span>
  33 |     | <span class='neutral'>        IStargateLPStaking _staking,</span>
  34 |     | <span class='neutral'>        address _rewardToken,</span>
  35 |     | <span class='neutral'>        uint256 _pid</span>
  36 |     | <span class='unexecuted'>    ) BaseStrategy(IERC20(address(_strategyToken)), _bentoBox) {</span>
  37 |     | <span class='unexecuted'>        router = _router;</span>
  38 |     | <span class='unexecuted'>        staking = _staking;</span>
  39 |     | <span class='unexecuted'>        rewardToken = _rewardToken;</span>
  40 |     | <span class='unexecuted'>        pid = _pid;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>        poolId = IStargatePool(address(_strategyToken)).poolId();</span>
  43 |     | <span class='unexecuted'>        address _underlyingToken = IStargatePool(address(_strategyToken)).token();</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>        feeBips = 150; // 1.5%</span>
  46 |     | <span class='unexecuted'>        feeCollector = msg.sender;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>        IERC20(_underlyingToken).approve(address(_router), type(uint256).max);</span>
  49 |     | <span class='unexecuted'>        underlyingToken = _underlyingToken;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>        IERC20(address(_strategyToken)).approve(address(_staking), type(uint256).max);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>    function _skim(uint256 amount) internal override {</span>
  55 |     | <span class='unexecuted'>        staking.deposit(pid, amount);</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>    function _harvest(uint256) internal override returns (int256) {</span>
  59 |     | <span class='unexecuted'>        staking.withdraw(pid, 0);</span>
  60 |     | <span class='unexecuted'>        return int256(0);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>    function _withdraw(uint256 amount) internal override {</span>
  64 |     | <span class='unexecuted'>        staking.withdraw(pid, amount);</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>    function _exit() internal override {</span>
  68 |     | <span class='unexecuted'>        staking.emergencyWithdraw(pid);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>    function swapToLP(uint256 amountOutMin, bytes calldata data) public onlyExecutor returns (uint256 amountOut) {</span>
  72 |     | <span class='neutral'>        // Current Stargate LP Amount</span>
  73 |     | <span class='unexecuted'>        uint256 amountStrategyLpBefore = IERC20(strategyToken).balanceOf(address(this));</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>        // rewardToken -&gt; Pool underlying Token (USDT, USDC...)</span>
  76 |     | <span class='unexecuted'>        Address.functionCall(stargateSwapper, data);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>        // Pool underlying Token in this contract</span>
  79 |     | <span class='unexecuted'>        uint256 underlyingTokenAmount = underlyingToken.balanceOf(address(this));</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>        // Underlying Token -&gt; Stargate Pool LP</span>
  82 |     | <span class='unexecuted'>        router.addLiquidity(poolId, underlyingTokenAmount, address(this));</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>        uint256 total = IERC20(strategyToken).balanceOf(address(this)) - amountStrategyLpBefore;</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>        if (total &lt; amountOutMin) {</span>
  87 |     | <span class='unexecuted'>            revert ErrInsufficientAmountOut();</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>        uint256 feeAmount;</span>
  91 |     | <span class='unexecuted'>        (amountOut, feeAmount) = calculateFees(total);</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>        address(strategyToken).safeTransfer(feeCollector, feeAmount);</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>        emit LogLpMinted(total, amountOut, feeAmount);</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='unexecuted'>    function setStargateSwapper(address _stargateSwapper) external onlyOwner {</span>
  99 |     | <span class='unexecuted'>        address previousStargateSwapper = address(stargateSwapper);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>        if (previousStargateSwapper != address(0)) {</span>
 102 |     | <span class='unexecuted'>            rewardToken.safeApprove(previousStargateSwapper, 0);</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='unexecuted'>        stargateSwapper = _stargateSwapper;</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>        if (_stargateSwapper != address(0)) {</span>
 108 |     | <span class='unexecuted'>            rewardToken.safeApprove(_stargateSwapper, type(uint256).max);</span>
 109 |     | <span class='neutral'>        }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        emit LogStargateSwapperChanged(previousStargateSwapper, _stargateSwapper);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>    function isFeeOperator(address account) public view override returns (bool) {</span>
 115 |     | <span class='unexecuted'>        return account == owner;</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'>}</span>
 118 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/ConvexWrapperLevSwapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solady/utils/SafeTransferLib.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  8 |     | <span class='neutral'>import {CurveLevSwapper} from &quot;swappers/CurveLevSwapper.sol&quot;;</span>
  9 |     | <span class='neutral'>import {IConvexWrapper} from &quot;interfaces/IConvexWrapper.sol&quot;;</span>
 10 |     | <span class='neutral'>import {CurvePoolInterfaceType} from &quot;interfaces/ICurvePool.sol&quot;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>contract ConvexWrapperLevSwapper is CurveLevSwapper {</span>
 13 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    IConvexWrapper public immutable wrapper;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    constructor(</span>
 18 |     | <span class='neutral'>        IBentoBoxV1 _bentoBox,</span>
 19 |     | <span class='neutral'>        IConvexWrapper _wrapper,</span>
 20 |     | <span class='neutral'>        address _mim,</span>
 21 |     | <span class='neutral'>        CurvePoolInterfaceType _curvePoolInterfaceType,</span>
 22 |     | <span class='neutral'>        address _curvePool,</span>
 23 |     | <span class='neutral'>        address _curvePoolDepositor /* Optional Curve Deposit Zapper */,</span>
 24 |     | <span class='neutral'>        address[] memory _poolTokens,</span>
 25 |     | <span class='neutral'>        address _zeroXExchangeProxy</span>
 26 |     | <span class='neutral'>    )</span>
 27 |     | <span class='neutral'>        CurveLevSwapper(</span>
 28 |     | <span class='unexecuted'>            _bentoBox,</span>
 29 |     | <span class='unexecuted'>            _wrapper.curveToken(),</span>
 30 |     | <span class='unexecuted'>            _mim,</span>
 31 |     | <span class='unexecuted'>            _curvePoolInterfaceType,</span>
 32 |     | <span class='unexecuted'>            _curvePool,</span>
 33 |     | <span class='unexecuted'>            _curvePoolDepositor,</span>
 34 |     | <span class='unexecuted'>            _poolTokens,</span>
 35 |     | <span class='unexecuted'>            _zeroXExchangeProxy</span>
 36 |     | <span class='neutral'>        )</span>
 37 |     | <span class='neutral'>    {</span>
 38 |     | <span class='unexecuted'>        wrapper = _wrapper;</span>
 39 |     | <span class='unexecuted'>        curveToken.safeApprove(address(_wrapper), type(uint256).max);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='unexecuted'>    function depositInBentoBox(uint256 amount, address recipient) internal override returns (uint256 shareReturned) {</span>
 43 |     | <span class='neutral'>        // CurveLP -&gt; Convex Wrapper LP</span>
 44 |     | <span class='unexecuted'>        wrapper.deposit(amount, address(bentoBox));</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>        (, shareReturned) = bentoBox.deposit(IERC20(address(wrapper)), address(bentoBox), recipient, amount, 0);</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'>}</span>
 49 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/ConvexWrapperSwapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solady/utils/SafeTransferLib.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import {CurveSwapper} from &quot;swappers/CurveSwapper.sol&quot;;</span>
  8 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  9 |     | <span class='neutral'>import {IConvexWrapper} from &quot;interfaces/IConvexWrapper.sol&quot;;</span>
 10 |     | <span class='neutral'>import {CurvePoolInterfaceType} from &quot;interfaces/ICurvePool.sol&quot;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>contract ConvexWrapperSwapper is CurveSwapper {</span>
 13 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    IConvexWrapper public immutable wrapper;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    constructor(</span>
 18 |     | <span class='neutral'>        IBentoBoxV1 _bentoBox,</span>
 19 |     | <span class='neutral'>        IConvexWrapper _wrapper,</span>
 20 |     | <span class='neutral'>        address _mim,</span>
 21 |     | <span class='neutral'>        CurvePoolInterfaceType _curvePoolInterfaceType,</span>
 22 |     | <span class='neutral'>        address _curvePool,</span>
 23 |     | <span class='neutral'>        address _curvePoolDepositor /* Optional Curve Deposit Zapper */,</span>
 24 |     | <span class='neutral'>        address[] memory _poolTokens,</span>
 25 |     | <span class='neutral'>        address _zeroXExchangeProxy</span>
 26 |     | <span class='neutral'>    )</span>
 27 |     | <span class='neutral'>        CurveSwapper(</span>
 28 |     | <span class='unexecuted'>            _bentoBox,</span>
 29 |     | <span class='unexecuted'>            _wrapper.curveToken(),</span>
 30 |     | <span class='unexecuted'>            _mim,</span>
 31 |     | <span class='unexecuted'>            _curvePoolInterfaceType,</span>
 32 |     | <span class='unexecuted'>            _curvePool,</span>
 33 |     | <span class='unexecuted'>            _curvePoolDepositor,</span>
 34 |     | <span class='unexecuted'>            _poolTokens,</span>
 35 |     | <span class='unexecuted'>            _zeroXExchangeProxy</span>
 36 |     | <span class='neutral'>        )</span>
 37 |     | <span class='neutral'>    {</span>
 38 |     | <span class='unexecuted'>        wrapper = _wrapper;</span>
 39 |     | <span class='unexecuted'>        if (_curvePoolDepositor != address(0)) {</span>
 40 |     | <span class='unexecuted'>            address curveToken = wrapper.curveToken();</span>
 41 |     | <span class='unexecuted'>            curveToken.safeApprove(_curvePoolDepositor, type(uint256).max);</span>
 42 |     | <span class='neutral'>        }</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='unexecuted'>    function withdrawFromBentoBox(uint256 shareFrom) internal override returns (uint256 amount) {</span>
 46 |     | <span class='unexecuted'>        (amount, ) = bentoBox.withdraw(IERC20(address(wrapper)), address(this), address(this), 0, shareFrom);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>        // ConvexWrapper -&gt; CurveLP token</span>
 49 |     | <span class='unexecuted'>        wrapper.withdrawAndUnwrap(amount);</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'>}</span>
 52 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/CurveLevSwapper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
   3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solady/utils/SafeTransferLib.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ILevSwapperV2} from &quot;interfaces/ILevSwapperV2.sol&quot;;</span>
   9 |     | <span class='neutral'>import {ICurvePool, CurvePoolInterfaceType, ICurve3PoolZapper} from &quot;interfaces/ICurvePool.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>contract CurveLevSwapper is ILevSwapperV2 {</span>
  12 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    error ErrSwapFailed();</span>
  15 |     | <span class='neutral'>    error ErrUnsupportedCurvePool();</span>
  16 |     | <span class='neutral'>    error ErrUnsupportedCurvePoolLength();</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    IBentoBoxV1 public immutable bentoBox;</span>
  19 |     | <span class='unexecuted'>    address public immutable curveToken;</span>
  20 |     | <span class='unexecuted'>    address public immutable mim;</span>
  21 |     | <span class='unexecuted'>    CurvePoolInterfaceType public immutable curvePoolInterfaceType;</span>
  22 |     | <span class='unexecuted'>    address public immutable zeroXExchangeProxy;</span>
  23 |     | <span class='unexecuted'>    address public immutable curvePool;</span>
  24 |     | <span class='unexecuted'>    address public immutable curvePoolDepositor;</span>
  25 |     | <span class='unexecuted'>    uint256 public immutable curvePoolCoinsLength;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>    constructor(</span>
  28 |     | <span class='neutral'>        IBentoBoxV1 _bentoBox,</span>
  29 |     | <span class='neutral'>        address _curveToken,</span>
  30 |     | <span class='neutral'>        address _mim,</span>
  31 |     | <span class='neutral'>        CurvePoolInterfaceType _curvePoolInterfaceType,</span>
  32 |     | <span class='neutral'>        address _curvePool,</span>
  33 |     | <span class='neutral'>        address _curvePoolDepositor /* Optional Curve Deposit Zapper */,</span>
  34 |     | <span class='neutral'>        address[] memory _poolTokens,</span>
  35 |     | <span class='neutral'>        address _zeroXExchangeProxy</span>
  36 |     | <span class='unexecuted'>    ) {</span>
  37 |     | <span class='unexecuted'>        bentoBox = _bentoBox;</span>
  38 |     | <span class='unexecuted'>        curveToken = _curveToken;</span>
  39 |     | <span class='unexecuted'>        mim = _mim;</span>
  40 |     | <span class='unexecuted'>        zeroXExchangeProxy = _zeroXExchangeProxy;</span>
  41 |     | <span class='unexecuted'>        curvePoolCoinsLength = _poolTokens.length;</span>
  42 |     | <span class='unexecuted'>        curvePoolInterfaceType = _curvePoolInterfaceType;</span>
  43 |     | <span class='unexecuted'>        curvePool = _curvePool;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>        _mim.safeApprove(_zeroXExchangeProxy, type(uint256).max);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>        address depositor = _curvePool;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>        if (_curvePoolDepositor != address(0)) {</span>
  50 |     | <span class='unexecuted'>            depositor = _curvePoolDepositor;</span>
  51 |     | <span class='neutral'>        }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _poolTokens.length; i++) {</span>
  54 |     | <span class='unexecuted'>            _poolTokens[i].safeApprove(address(depositor), type(uint256).max);</span>
  55 |     | <span class='neutral'>        }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>        curvePoolDepositor = depositor;</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>    function depositInBentoBox(uint256 amount, address recipient) internal virtual returns (uint256 shareReturned) {</span>
  61 |     | <span class='unexecuted'>        (, shareReturned) = bentoBox.deposit(IERC20(curveToken), address(bentoBox), recipient, amount, 0);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /// @inheritdoc ILevSwapperV2</span>
  65 |     | <span class='unexecuted'>    function swap(</span>
  66 |     | <span class='neutral'>        address recipient,</span>
  67 |     | <span class='neutral'>        uint256 shareToMin,</span>
  68 |     | <span class='neutral'>        uint256 shareFrom,</span>
  69 |     | <span class='neutral'>        bytes calldata data</span>
  70 |     | <span class='unexecuted'>    ) external override returns (uint256 extraShare, uint256 shareReturned) {</span>
  71 |     | <span class='unexecuted'>        (address underlyingToken, uint256 poolIndex, bytes memory swapData) = abi.decode(data, (address, uint256, bytes));</span>
  72 |     | <span class='unexecuted'>        bentoBox.withdraw(IERC20(mim), address(this), address(this), 0, shareFrom);</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>        // Optional MIM -&gt; Asset</span>
  75 |     | <span class='unexecuted'>        if (swapData.length != 0) {</span>
  76 |     | <span class='unexecuted'>            (bool success, ) = zeroXExchangeProxy.call(swapData);</span>
  77 |     | <span class='unexecuted'>            if (!success) {</span>
  78 |     | <span class='unexecuted'>                revert ErrSwapFailed();</span>
  79 |     | <span class='neutral'>            }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>            // Refund remaining underlying balance to the recipient</span>
  82 |     | <span class='unexecuted'>            mim.safeTransfer(recipient, mim.balanceOf(address(this)));</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>        // Asset -&gt; Curve LP</span>
  86 |     | <span class='unexecuted'>        if (curvePoolInterfaceType == CurvePoolInterfaceType.ICURVE_3POOL_ZAPPER) {</span>
  87 |     | <span class='unexecuted'>            _addLiquidityUsing3PoolZapper(underlyingToken, poolIndex);</span>
  88 |     | <span class='unexecuted'>        } else if (</span>
  89 |     | <span class='unexecuted'>            curvePoolInterfaceType == CurvePoolInterfaceType.ICURVE_POOL ||</span>
  90 |     | <span class='unexecuted'>            curvePoolInterfaceType == CurvePoolInterfaceType.IFACTORY_POOL ||</span>
  91 |     | <span class='unexecuted'>            curvePoolInterfaceType == CurvePoolInterfaceType.ITRICRYPTO_POOL</span>
  92 |     | <span class='neutral'>        ) {</span>
  93 |     | <span class='unexecuted'>            _addLiquidityCurvePool(underlyingToken, poolIndex);</span>
  94 |     | <span class='neutral'>        } else {</span>
  95 |     | <span class='unexecuted'>            revert ErrUnsupportedCurvePool();</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='unexecuted'>        uint256 _amount = curveToken.balanceOf(address(this));</span>
  99 |     | <span class='unexecuted'>        shareReturned = depositInBentoBox(_amount, recipient);</span>
 100 |     | <span class='unexecuted'>        extraShare = shareReturned - shareToMin;</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>    function _addLiquidityUsing3PoolZapper(address underlyingToken, uint256 poolIndex) internal {</span>
 104 |     | <span class='unexecuted'>        uint256[4] memory amounts;</span>
 105 |     | <span class='unexecuted'>        amounts[poolIndex] = underlyingToken.balanceOf(address(this));</span>
 106 |     | <span class='unexecuted'>        ICurve3PoolZapper(curvePoolDepositor).add_liquidity(curvePool, amounts, 0);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>    function _addLiquidityCurvePool(address underlyingToken, uint256 poolIndex) internal {</span>
 110 |     | <span class='unexecuted'>        if (curvePoolCoinsLength == 2) {</span>
 111 |     | <span class='unexecuted'>            uint256[2] memory amounts;</span>
 112 |     | <span class='unexecuted'>            amounts[poolIndex] = underlyingToken.balanceOf(address(this));</span>
 113 |     | <span class='unexecuted'>            ICurvePool(curvePoolDepositor).add_liquidity(amounts, 0);</span>
 114 |     | <span class='unexecuted'>        } else if (curvePoolCoinsLength == 3) {</span>
 115 |     | <span class='unexecuted'>            uint256[3] memory amounts;</span>
 116 |     | <span class='unexecuted'>            amounts[poolIndex] = underlyingToken.balanceOf(address(this));</span>
 117 |     | <span class='unexecuted'>            ICurvePool(curvePoolDepositor).add_liquidity(amounts, 0);</span>
 118 |     | <span class='unexecuted'>        } else if (curvePoolCoinsLength == 4) {</span>
 119 |     | <span class='unexecuted'>            uint256[4] memory amounts;</span>
 120 |     | <span class='unexecuted'>            amounts[poolIndex] = underlyingToken.balanceOf(address(this));</span>
 121 |     | <span class='unexecuted'>            ICurvePool(curvePoolDepositor).add_liquidity(amounts, 0);</span>
 122 |     | <span class='neutral'>        } else {</span>
 123 |     | <span class='unexecuted'>            revert ErrUnsupportedCurvePoolLength();</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'>}</span>
 127 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/CurveSwapper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
   3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solady/utils/SafeTransferLib.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ISwapperV2} from &quot;interfaces/ISwapperV2.sol&quot;;</span>
   9 |     | <span class='neutral'>import {ICurvePool, CurvePoolInterfaceType, ITriCrypto, ICurve3PoolZapper, IFactoryPool} from &quot;interfaces/ICurvePool.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>contract CurveSwapper is ISwapperV2 {</span>
  12 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    error ErrSwapFailed();</span>
  15 |     | <span class='neutral'>    error ErrTokenNotSupported();</span>
  16 |     | <span class='neutral'>    error ErrUnsupportedCurvePool();</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    CurvePoolInterfaceType public immutable curvePoolInterfaceType;</span>
  19 |     | <span class='unexecuted'>    IBentoBoxV1 public immutable bentoBox;</span>
  20 |     | <span class='unexecuted'>    address public immutable curveToken;</span>
  21 |     | <span class='unexecuted'>    address public immutable mim;</span>
  22 |     | <span class='unexecuted'>    address public immutable exchange;</span>
  23 |     | <span class='unexecuted'>    address public immutable curvePool;</span>
  24 |     | <span class='unexecuted'>    address public immutable curvePoolDepositor;</span>
  25 |     | <span class='unexecuted'>    uint256 public immutable curvePoolCoinsLength;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>    constructor(</span>
  28 |     | <span class='neutral'>        IBentoBoxV1 _bentoBox,</span>
  29 |     | <span class='neutral'>        address _curveToken,</span>
  30 |     | <span class='neutral'>        address _mim,</span>
  31 |     | <span class='neutral'>        CurvePoolInterfaceType _curvePoolInterfaceType,</span>
  32 |     | <span class='neutral'>        address _curvePool,</span>
  33 |     | <span class='neutral'>        address _curvePoolDepositor /* Optional Curve Deposit Zapper */,</span>
  34 |     | <span class='neutral'>        address[] memory _poolTokens,</span>
  35 |     | <span class='neutral'>        address _exchange</span>
  36 |     | <span class='unexecuted'>    ) {</span>
  37 |     | <span class='unexecuted'>        bentoBox = _bentoBox;</span>
  38 |     | <span class='unexecuted'>        curveToken = _curveToken;</span>
  39 |     | <span class='unexecuted'>        mim = _mim;</span>
  40 |     | <span class='unexecuted'>        curvePoolInterfaceType = _curvePoolInterfaceType;</span>
  41 |     | <span class='unexecuted'>        curvePool = _curvePool;</span>
  42 |     | <span class='unexecuted'>        exchange = _exchange;</span>
  43 |     | <span class='unexecuted'>        curvePoolCoinsLength = _poolTokens.length;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>        address depositor = _curvePool;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>        if (_curvePoolDepositor != address(0)) {</span>
  48 |     | <span class='unexecuted'>            depositor = _curvePoolDepositor;</span>
  49 |     | <span class='neutral'>        }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>        curvePoolDepositor = depositor;</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _poolTokens.length; i++) {</span>
  54 |     | <span class='unexecuted'>            _poolTokens[i].safeApprove(_exchange, type(uint256).max);</span>
  55 |     | <span class='neutral'>        }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>        mim.safeApprove(address(_bentoBox), type(uint256).max);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>    function withdrawFromBentoBox(uint256 shareFrom) internal virtual returns (uint256 amount) {</span>
  61 |     | <span class='unexecuted'>        (amount, ) = bentoBox.withdraw(IERC20(curveToken), address(this), address(this), 0, shareFrom);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /// @inheritdoc ISwapperV2</span>
  65 |     | <span class='unexecuted'>    function swap(</span>
  66 |     | <span class='neutral'>        address,</span>
  67 |     | <span class='neutral'>        address,</span>
  68 |     | <span class='neutral'>        address recipient,</span>
  69 |     | <span class='neutral'>        uint256 shareToMin,</span>
  70 |     | <span class='neutral'>        uint256 shareFrom,</span>
  71 |     | <span class='neutral'>        bytes calldata data</span>
  72 |     | <span class='unexecuted'>    ) public override returns (uint256 extraShare, uint256 shareReturned) {</span>
  73 |     | <span class='unexecuted'>        (uint256 poolIndex, bytes memory swapData) = abi.decode(data, (uint256, bytes));</span>
  74 |     | <span class='unexecuted'>        uint256 amount = withdrawFromBentoBox(shareFrom);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        // CurveLP token -&gt; underlyingToken</span>
  77 |     | <span class='unexecuted'>        if (curvePoolInterfaceType == CurvePoolInterfaceType.ICURVE_POOL) {</span>
  78 |     | <span class='unexecuted'>            ICurvePool(curvePoolDepositor).remove_liquidity_one_coin(amount, int128(uint128(poolIndex)), uint256(0));</span>
  79 |     | <span class='unexecuted'>        } else if (curvePoolInterfaceType == CurvePoolInterfaceType.ICURVE_3POOL_ZAPPER) {</span>
  80 |     | <span class='unexecuted'>            ICurve3PoolZapper(curvePoolDepositor).remove_liquidity_one_coin(curvePool, amount, int128(uint128(poolIndex)), uint256(0));</span>
  81 |     | <span class='unexecuted'>        } else if (curvePoolInterfaceType == CurvePoolInterfaceType.IFACTORY_POOL) {</span>
  82 |     | <span class='unexecuted'>            IFactoryPool(curvePoolDepositor).remove_liquidity_one_coin(amount, poolIndex, uint256(0));</span>
  83 |     | <span class='unexecuted'>        } else if (curvePoolInterfaceType == CurvePoolInterfaceType.ITRICRYPTO_POOL) {</span>
  84 |     | <span class='unexecuted'>            ITriCrypto(curvePoolDepositor).remove_liquidity_one_coin(amount, poolIndex, uint256(0));</span>
  85 |     | <span class='neutral'>        } else {</span>
  86 |     | <span class='unexecuted'>            revert ErrUnsupportedCurvePool();</span>
  87 |     | <span class='neutral'>        }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        // Optional underlyingToken -&gt; MIM</span>
  90 |     | <span class='unexecuted'>        if (swapData.length != 0) {</span>
  91 |     | <span class='unexecuted'>            (bool success, ) = exchange.call(swapData);</span>
  92 |     | <span class='unexecuted'>            if (!success) {</span>
  93 |     | <span class='unexecuted'>                revert ErrSwapFailed();</span>
  94 |     | <span class='neutral'>            }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>            // Refund remaining underlying balance to the recipient</span>
  97 |     | <span class='unexecuted'>            address underlyingToken = ICurvePool(curvePool).coins(poolIndex);</span>
  98 |     | <span class='unexecuted'>            underlyingToken.safeTransfer(recipient, underlyingToken.balanceOf(address(this)));</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>        (, shareReturned) = bentoBox.deposit(IERC20(mim), address(this), recipient, mim.balanceOf(address(this)), 0);</span>
 102 |     | <span class='unexecuted'>        extraShare = shareReturned - shareToMin;</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'>}</span>
 105 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/ERC4626LevSwapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import {SafeApproveLib} from &quot;libraries/SafeApproveLib.sol&quot;;</span>
  8 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  9 |     | <span class='neutral'>import {ILevSwapperV2} from &quot;interfaces/ILevSwapperV2.sol&quot;;</span>
 10 |     | <span class='neutral'>import {IERC4626} from &quot;interfaces/IERC4626.sol&quot;;</span>
 11 |     | <span class='neutral'>import {IGmxGlpRewardRouter, IGmxVault} from &quot;interfaces/IGmxV1.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>contract ERC4626LevSwapper is ILevSwapperV2 {</span>
 14 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 15 |     | <span class='neutral'>    using SafeApproveLib for IERC20;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    error ErrSwapFailed();</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    IBentoBoxV1 public immutable bentoBox;</span>
 20 |     | <span class='unexecuted'>    IERC20 public immutable mim;</span>
 21 |     | <span class='unexecuted'>    IERC20 public immutable token;</span>
 22 |     | <span class='unexecuted'>    IERC4626 public immutable vault;</span>
 23 |     | <span class='unexecuted'>    address public immutable zeroXExchangeProxy;</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>    constructor(IBentoBoxV1 _bentoBox, IERC4626 _vault, IERC20 _mim, address _zeroXExchangeProxy) {</span>
 26 |     | <span class='unexecuted'>        bentoBox = _bentoBox;</span>
 27 |     | <span class='unexecuted'>        vault = _vault;</span>
 28 |     | <span class='unexecuted'>        mim = _mim;</span>
 29 |     | <span class='unexecuted'>        zeroXExchangeProxy = _zeroXExchangeProxy;</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>        IERC20 _token = _vault.asset();</span>
 32 |     | <span class='unexecuted'>        token = _token;</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>        _token.approve(address(_vault), type(uint256).max);</span>
 35 |     | <span class='unexecuted'>        _mim.approve(_zeroXExchangeProxy, type(uint256).max);</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    /// @inheritdoc ILevSwapperV2</span>
 39 |     | <span class='unexecuted'>    function swap(</span>
 40 |     | <span class='neutral'>        address recipient,</span>
 41 |     | <span class='neutral'>        uint256 shareToMin,</span>
 42 |     | <span class='neutral'>        uint256 shareFrom,</span>
 43 |     | <span class='neutral'>        bytes calldata swapData</span>
 44 |     | <span class='unexecuted'>    ) external override returns (uint256 extraShare, uint256 shareReturned) {</span>
 45 |     | <span class='unexecuted'>        bentoBox.withdraw(mim, address(this), address(this), 0, shareFrom);</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>        // MIM -&gt; Asset</span>
 48 |     | <span class='unexecuted'>        (bool success, ) = zeroXExchangeProxy.call(swapData);</span>
 49 |     | <span class='unexecuted'>        if (!success) {</span>
 50 |     | <span class='unexecuted'>            revert ErrSwapFailed();</span>
 51 |     | <span class='neutral'>        }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='unexecuted'>        uint256 _amount = token.balanceOf(address(this));</span>
 54 |     | <span class='unexecuted'>        _amount = vault.deposit(_amount, address(bentoBox));</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='unexecuted'>        (, shareReturned) = bentoBox.deposit(IERC20(address(vault)), address(bentoBox), recipient, _amount, 0);</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='unexecuted'>        extraShare = shareReturned - shareToMin;</span>
 59 |     | <span class='neutral'>    }</span>
 60 |     | <span class='neutral'>}</span>
 61 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/ERC4626Swapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import {SafeApproveLib} from &quot;libraries/SafeApproveLib.sol&quot;;</span>
  8 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  9 |     | <span class='neutral'>import {ISwapperV2} from &quot;interfaces/ISwapperV2.sol&quot;;</span>
 10 |     | <span class='neutral'>import {IGmxGlpRewardRouter, IGmxVault} from &quot;interfaces/IGmxV1.sol&quot;;</span>
 11 |     | <span class='neutral'>import {IERC4626} from &quot;interfaces/IERC4626.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>contract ERC4626Swapper is ISwapperV2 {</span>
 14 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 15 |     | <span class='neutral'>    using SafeApproveLib for IERC20;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    error ErrSwapFailed();</span>
 18 |     | <span class='neutral'>    error ErrTokenNotSupported(IERC20);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    IBentoBoxV1 public immutable bentoBox;</span>
 21 |     | <span class='unexecuted'>    IERC4626 public immutable vault;</span>
 22 |     | <span class='unexecuted'>    IERC20 public immutable mim;</span>
 23 |     | <span class='unexecuted'>    IERC20 public immutable asset;</span>
 24 |     | <span class='unexecuted'>    address public immutable zeroXExchangeProxy;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    constructor(IBentoBoxV1 _bentoBox, IERC4626 _vault, IERC20 _mim, address _zeroXExchangeProxy) {</span>
 27 |     | <span class='unexecuted'>        bentoBox = _bentoBox;</span>
 28 |     | <span class='unexecuted'>        vault = _vault;</span>
 29 |     | <span class='unexecuted'>        mim = _mim;</span>
 30 |     | <span class='unexecuted'>        zeroXExchangeProxy = _zeroXExchangeProxy;</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>        IERC20 _asset = _vault.asset();</span>
 33 |     | <span class='unexecuted'>        asset = _asset;</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>        _asset.safeApprove(_zeroXExchangeProxy, type(uint256).max);</span>
 36 |     | <span class='unexecuted'>        mim.approve(address(_bentoBox), type(uint256).max);</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /// @inheritdoc ISwapperV2</span>
 40 |     | <span class='unexecuted'>    function swap(</span>
 41 |     | <span class='neutral'>        address,</span>
 42 |     | <span class='neutral'>        address,</span>
 43 |     | <span class='neutral'>        address recipient,</span>
 44 |     | <span class='neutral'>        uint256 shareToMin,</span>
 45 |     | <span class='neutral'>        uint256 shareFrom,</span>
 46 |     | <span class='neutral'>        bytes calldata swapData</span>
 47 |     | <span class='unexecuted'>    ) public override returns (uint256 extraShare, uint256 shareReturned) {</span>
 48 |     | <span class='unexecuted'>        (uint256 amount, ) = bentoBox.withdraw(IERC20(address(vault)), address(this), address(this), 0, shareFrom);</span>
 49 |     | <span class='unexecuted'>        amount = IERC4626(address(vault)).redeem(amount, address(this), address(this));</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>        // Asset -&gt; MIM</span>
 52 |     | <span class='unexecuted'>        (bool success, ) = zeroXExchangeProxy.call(swapData);</span>
 53 |     | <span class='unexecuted'>        if (!success) {</span>
 54 |     | <span class='unexecuted'>            revert ErrSwapFailed();</span>
 55 |     | <span class='neutral'>        }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='unexecuted'>        (, shareReturned) = bentoBox.deposit(mim, address(this), recipient, mim.balanceOf(address(this)), 0);</span>
 58 |     | <span class='unexecuted'>        extraShare = shareReturned - shareToMin;</span>
 59 |     | <span class='neutral'>    }</span>
 60 |     | <span class='neutral'>}</span>
 61 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/MagicCurveLpLevSwapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import {SafeApproveLib} from &quot;libraries/SafeApproveLib.sol&quot;;</span>
  8 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  9 |     | <span class='neutral'>import {CurveLevSwapper} from &quot;swappers/CurveLevSwapper.sol&quot;;</span>
 10 |     | <span class='neutral'>import {IERC4626} from &quot;interfaces/IERC4626.sol&quot;;</span>
 11 |     | <span class='neutral'>import {ICurvePool, CurvePoolInterfaceType} from &quot;interfaces/ICurvePool.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>contract MagicCurveLpLevSwapper is CurveLevSwapper {</span>
 14 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 15 |     | <span class='neutral'>    using SafeApproveLib for IERC20;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    IERC4626 public immutable vault;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    constructor(</span>
 20 |     | <span class='neutral'>        IBentoBoxV1 _bentoBox,</span>
 21 |     | <span class='neutral'>        IERC4626 _vault,</span>
 22 |     | <span class='neutral'>        address _mim,</span>
 23 |     | <span class='neutral'>        CurvePoolInterfaceType _curvePoolInterfaceType,</span>
 24 |     | <span class='neutral'>        address _curvePool,CurvePoolInterfaceType,</span>
 25 |     | <span class='neutral'>        address _curvePoolDepositor /* Optional Curve Deposit Zapper */,</span>
 26 |     | <span class='neutral'>        address[] memory _poolTokens,</span>
 27 |     | <span class='neutral'>        address _exchange</span>
 28 |     | <span class='neutral'>    )</span>
 29 |     | <span class='neutral'>        CurveLevSwapper(</span>
 30 |     | <span class='unexecuted'>            _bentoBox,</span>
 31 |     | <span class='unexecuted'>            address(_vault.asset()),</span>
 32 |     | <span class='unexecuted'>            _mim,</span>
 33 |     | <span class='unexecuted'>            _curvePoolInterfaceType,</span>
 34 |     | <span class='unexecuted'>            _curvePool,</span>
 35 |     | <span class='unexecuted'>            _curvePoolDepositor,</span>
 36 |     | <span class='unexecuted'>            _poolTokens,</span>
 37 |     | <span class='unexecuted'>            _exchange</span>
 38 |     | <span class='neutral'>        )</span>
 39 |     | <span class='neutral'>    {</span>
 40 |     | <span class='unexecuted'>        vault = _vault;</span>
 41 |     | <span class='unexecuted'>        IERC20(curveToken).safeApprove(address(_vault), type(uint256).max);</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='unexecuted'>    function depositInBentoBox(uint256 amount, address recipient) internal override returns (uint256 shareReturned) {</span>
 45 |     | <span class='neutral'>        // CurveLP -&gt; MagicCurveLP</span>
 46 |     | <span class='unexecuted'>        amount = vault.deposit(amount, address(bentoBox));</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>        (, shareReturned) = bentoBox.deposit(IERC20(address(vault)), address(bentoBox), recipient, amount, 0);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'>}</span>
 51 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/MagicCurveLpSwapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import {CurveSwapper} from &quot;swappers/CurveSwapper.sol&quot;;</span>
  8 |     | <span class='neutral'>import {SafeApproveLib} from &quot;libraries/SafeApproveLib.sol&quot;;</span>
  9 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
 10 |     | <span class='neutral'>import {IERC4626} from &quot;interfaces/IERC4626.sol&quot;;</span>
 11 |     | <span class='neutral'>import {ICurvePool, CurvePoolInterfaceType} from &quot;interfaces/ICurvePool.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>contract MagicCurveLpSwapper is CurveSwapper {</span>
 14 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 15 |     | <span class='neutral'>    using SafeApproveLib for IERC20;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    IERC4626 public immutable vault;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    constructor(</span>
 20 |     | <span class='neutral'>        IBentoBoxV1 _bentoBox,</span>
 21 |     | <span class='neutral'>        IERC4626 _vault,</span>
 22 |     | <span class='neutral'>        address _mim,</span>
 23 |     | <span class='neutral'>        CurvePoolInterfaceType _curvePoolInterfaceType,</span>
 24 |     | <span class='neutral'>        address _curvePool,</span>
 25 |     | <span class='neutral'>        address _curvePoolDepositor /* Optional Curve Deposit Zapper */,</span>
 26 |     | <span class='neutral'>        address[] memory _poolTokens,</span>
 27 |     | <span class='neutral'>        address _exchange</span>
 28 |     | <span class='neutral'>    )</span>
 29 |     | <span class='neutral'>        CurveSwapper(</span>
 30 |     | <span class='unexecuted'>            _bentoBox,</span>
 31 |     | <span class='unexecuted'>            address(_vault.asset()),</span>
 32 |     | <span class='unexecuted'>            _mim,</span>
 33 |     | <span class='unexecuted'>            _curvePoolInterfaceType,</span>
 34 |     | <span class='unexecuted'>            _curvePool,</span>
 35 |     | <span class='unexecuted'>            _curvePoolDepositor,</span>
 36 |     | <span class='unexecuted'>            _poolTokens,</span>
 37 |     | <span class='unexecuted'>            _exchange</span>
 38 |     | <span class='neutral'>        )</span>
 39 |     | <span class='neutral'>    {</span>
 40 |     | <span class='unexecuted'>        vault = _vault;</span>
 41 |     | <span class='unexecuted'>        if (_curvePoolDepositor != address(0)) {</span>
 42 |     | <span class='unexecuted'>            IERC20 curveToken = _vault.asset();</span>
 43 |     | <span class='unexecuted'>            curveToken.safeApprove(_curvePoolDepositor, type(uint256).max);</span>
 44 |     | <span class='neutral'>        }</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>    function withdrawFromBentoBox(uint256 shareFrom) internal override returns (uint256 amount) {</span>
 48 |     | <span class='unexecuted'>        (amount, ) = bentoBox.withdraw(IERC20(address(vault)), address(this), address(this), 0, shareFrom);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>        // MagicCurveLP -&gt; CurveLP</span>
 51 |     | <span class='unexecuted'>        amount = vault.redeem(amount, address(this), address(this));</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'>}</span>
 54 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/MagicGlpLevSwapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import {SafeApproveLib} from &quot;libraries/SafeApproveLib.sol&quot;;</span>
  8 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  9 |     | <span class='neutral'>import {ILevSwapperV2} from &quot;interfaces/ILevSwapperV2.sol&quot;;</span>
 10 |     | <span class='neutral'>import {IERC4626} from &quot;interfaces/IERC4626.sol&quot;;</span>
 11 |     | <span class='neutral'>import {IGmxGlpRewardRouter, IGmxVault} from &quot;interfaces/IGmxV1.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>contract MagicGlpLevSwapper is ILevSwapperV2 {</span>
 14 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 15 |     | <span class='neutral'>    using SafeApproveLib for IERC20;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    error ErrSwapFailed();</span>
 18 |     | <span class='neutral'>    error ErrTokenNotSupported(IERC20);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    IBentoBoxV1 public immutable bentoBox;</span>
 21 |     | <span class='unexecuted'>    IERC20 public immutable mim;</span>
 22 |     | <span class='unexecuted'>    IERC20 public immutable magicGLP;</span>
 23 |     | <span class='unexecuted'>    IGmxGlpRewardRouter public immutable glpRewardRouter;</span>
 24 |     | <span class='unexecuted'>    IERC20 public immutable sGLP;</span>
 25 |     | <span class='unexecuted'>    address public immutable zeroXExchangeProxy;</span>
 26 |     | <span class='unexecuted'>    IGmxVault public immutable gmxVault;</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>    constructor(</span>
 29 |     | <span class='neutral'>        IBentoBoxV1 _bentoBox,</span>
 30 |     | <span class='neutral'>        IGmxVault _gmxVault,</span>
 31 |     | <span class='neutral'>        IERC20 _magicGLP,</span>
 32 |     | <span class='neutral'>        IERC20 _mim,</span>
 33 |     | <span class='neutral'>        IERC20 _sGLP,</span>
 34 |     | <span class='neutral'>        address glpManager,</span>
 35 |     | <span class='neutral'>        IGmxGlpRewardRouter _glpRewardRouter,</span>
 36 |     | <span class='neutral'>        address _zeroXExchangeProxy</span>
 37 |     | <span class='unexecuted'>    ) {</span>
 38 |     | <span class='unexecuted'>        bentoBox = _bentoBox;</span>
 39 |     | <span class='unexecuted'>        gmxVault = _gmxVault;</span>
 40 |     | <span class='unexecuted'>        magicGLP = _magicGLP;</span>
 41 |     | <span class='unexecuted'>        mim = _mim;</span>
 42 |     | <span class='unexecuted'>        sGLP = _sGLP;</span>
 43 |     | <span class='unexecuted'>        glpRewardRouter = _glpRewardRouter;</span>
 44 |     | <span class='unexecuted'>        zeroXExchangeProxy = _zeroXExchangeProxy;</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>        uint256 len = _gmxVault.allWhitelistedTokensLength();</span>
 47 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; len; i++) {</span>
 48 |     | <span class='unexecuted'>            IERC20 token = IERC20(_gmxVault.allWhitelistedTokens(i));</span>
 49 |     | <span class='unexecuted'>            if (token == mim) continue;</span>
 50 |     | <span class='unexecuted'>            token.safeApprove(glpManager, type(uint256).max);</span>
 51 |     | <span class='neutral'>        }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='unexecuted'>        _sGLP.approve(address(_magicGLP), type(uint256).max);</span>
 54 |     | <span class='unexecuted'>        _mim.approve(_zeroXExchangeProxy, type(uint256).max);</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    /// @inheritdoc ILevSwapperV2</span>
 58 |     | <span class='unexecuted'>    function swap(</span>
 59 |     | <span class='neutral'>        address recipient,</span>
 60 |     | <span class='neutral'>        uint256 shareToMin,</span>
 61 |     | <span class='neutral'>        uint256 shareFrom,</span>
 62 |     | <span class='neutral'>        bytes calldata data</span>
 63 |     | <span class='unexecuted'>    ) external override returns (uint256 extraShare, uint256 shareReturned) {</span>
 64 |     | <span class='unexecuted'>        (bytes memory swapData, IERC20 token) = abi.decode(data, (bytes, IERC20));</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='unexecuted'>        bentoBox.withdraw(mim, address(this), address(this), 0, shareFrom);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>        // MIM -&gt; Token</span>
 69 |     | <span class='unexecuted'>        (bool success, ) = zeroXExchangeProxy.call(swapData);</span>
 70 |     | <span class='unexecuted'>        if (!success) {</span>
 71 |     | <span class='unexecuted'>            revert ErrSwapFailed();</span>
 72 |     | <span class='neutral'>        }</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='unexecuted'>        uint256 _amount = token.balanceOf(address(this));</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='unexecuted'>        _amount = glpRewardRouter.mintAndStakeGlp(address(token), _amount, 0, 0);</span>
 77 |     | <span class='unexecuted'>        _amount = IERC4626(address(magicGLP)).deposit(_amount, address(bentoBox));</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='unexecuted'>        (, shareReturned) = bentoBox.deposit(magicGLP, address(bentoBox), recipient, _amount, 0);</span>
 80 |     | <span class='neutral'></span>
 81 |     | <span class='unexecuted'>        extraShare = shareReturned - shareToMin;</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'>}</span>
 84 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/MagicGlpSwapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import {SafeApproveLib} from &quot;libraries/SafeApproveLib.sol&quot;;</span>
  8 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  9 |     | <span class='neutral'>import {ISwapperV2} from &quot;interfaces/ISwapperV2.sol&quot;;</span>
 10 |     | <span class='neutral'>import {IGmxGlpRewardRouter, IGmxVault} from &quot;interfaces/IGmxV1.sol&quot;;</span>
 11 |     | <span class='neutral'>import {IERC4626} from &quot;interfaces/IERC4626.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>contract MagicGlpSwapper is ISwapperV2 {</span>
 14 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 15 |     | <span class='neutral'>    using SafeApproveLib for IERC20;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    error ErrSwapFailed();</span>
 18 |     | <span class='neutral'>    error ErrTokenNotSupported(IERC20);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    IBentoBoxV1 public immutable bentoBox;</span>
 21 |     | <span class='unexecuted'>    IERC20 public immutable magicGlp;</span>
 22 |     | <span class='unexecuted'>    IERC20 public immutable mim;</span>
 23 |     | <span class='unexecuted'>    IERC20 public immutable sGLP;</span>
 24 |     | <span class='unexecuted'>    IGmxGlpRewardRouter public immutable glpRewardRouter;</span>
 25 |     | <span class='unexecuted'>    address public immutable zeroXExchangeProxy;</span>
 26 |     | <span class='unexecuted'>    IGmxVault public immutable gmxVault;</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>    constructor(</span>
 29 |     | <span class='neutral'>        IBentoBoxV1 _bentoBox,</span>
 30 |     | <span class='neutral'>        IGmxVault _gmxVault,</span>
 31 |     | <span class='neutral'>        IERC20 _magicGlp,</span>
 32 |     | <span class='neutral'>        IERC20 _mim,</span>
 33 |     | <span class='neutral'>        IERC20 _sGLP,</span>
 34 |     | <span class='neutral'>        IGmxGlpRewardRouter _glpRewardRouter,</span>
 35 |     | <span class='neutral'>        address _zeroXExchangeProxy</span>
 36 |     | <span class='unexecuted'>    ) {</span>
 37 |     | <span class='unexecuted'>        bentoBox = _bentoBox;</span>
 38 |     | <span class='unexecuted'>        gmxVault = _gmxVault;</span>
 39 |     | <span class='unexecuted'>        magicGlp = _magicGlp;</span>
 40 |     | <span class='unexecuted'>        mim = _mim;</span>
 41 |     | <span class='unexecuted'>        sGLP = _sGLP;</span>
 42 |     | <span class='unexecuted'>        glpRewardRouter = _glpRewardRouter;</span>
 43 |     | <span class='unexecuted'>        zeroXExchangeProxy = _zeroXExchangeProxy;</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='unexecuted'>        uint256 len = _gmxVault.allWhitelistedTokensLength();</span>
 46 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; len; i++) {</span>
 47 |     | <span class='unexecuted'>            IERC20 token = IERC20(_gmxVault.allWhitelistedTokens(i));</span>
 48 |     | <span class='unexecuted'>            if (token == mim) continue;</span>
 49 |     | <span class='unexecuted'>            token.safeApprove(_zeroXExchangeProxy, type(uint256).max);</span>
 50 |     | <span class='neutral'>        }</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='unexecuted'>        mim.approve(address(_bentoBox), type(uint256).max);</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    /// @inheritdoc ISwapperV2</span>
 56 |     | <span class='unexecuted'>    function swap(</span>
 57 |     | <span class='neutral'>        address,</span>
 58 |     | <span class='neutral'>        address,</span>
 59 |     | <span class='neutral'>        address recipient,</span>
 60 |     | <span class='neutral'>        uint256 shareToMin,</span>
 61 |     | <span class='neutral'>        uint256 shareFrom,</span>
 62 |     | <span class='neutral'>        bytes calldata data</span>
 63 |     | <span class='unexecuted'>    ) public override returns (uint256 extraShare, uint256 shareReturned) {</span>
 64 |     | <span class='unexecuted'>        (bytes memory swapData, IERC20 token) = abi.decode(data, (bytes, IERC20));</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='unexecuted'>        (uint256 amount, ) = bentoBox.withdraw(IERC20(address(magicGlp)), address(this), address(this), 0, shareFrom);</span>
 67 |     | <span class='unexecuted'>        amount = IERC4626(address(magicGlp)).redeem(amount, address(this), address(this));</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='unexecuted'>        glpRewardRouter.unstakeAndRedeemGlp(address(token), amount, 0, address(this));</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='neutral'>        // Token -&gt; MIM</span>
 72 |     | <span class='unexecuted'>        (bool success, ) = zeroXExchangeProxy.call(swapData);</span>
 73 |     | <span class='unexecuted'>        if (!success) {</span>
 74 |     | <span class='unexecuted'>            revert ErrSwapFailed();</span>
 75 |     | <span class='neutral'>        }</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='neutral'>        // we can expect dust from both gmx and 0x</span>
 78 |     | <span class='unexecuted'>        token.safeTransfer(recipient, token.balanceOf(address(this)));</span>
 79 |     | <span class='neutral'></span>
 80 |     | <span class='unexecuted'>        (, shareReturned) = bentoBox.deposit(mim, address(this), recipient, mim.balanceOf(address(this)), 0);</span>
 81 |     | <span class='unexecuted'>        extraShare = shareReturned - shareToMin;</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'>}</span>
 84 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/StargateCurveSwapper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BoringOwnable} from &quot;BoringSolidity/BoringOwnable.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Address} from &quot;openzeppelin-contracts/utils/Address.sol&quot;;</span>
   8 |     | <span class='neutral'>import {SafeApproveLib} from &quot;libraries/SafeApproveLib.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IStargatePool, IStargateRouter} from &quot;interfaces/IStargate.sol&quot;;</span>
  10 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  11 |     | <span class='neutral'>import {ISwapperV1} from &quot;interfaces/ISwapperV1.sol&quot;;</span>
  12 |     | <span class='neutral'>import {ICurvePool} from &quot;interfaces/ICurvePool.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>interface IStargateLpMimPool {</span>
  15 |     | <span class='neutral'>    function swapForMim(IStargatePool tokenIn, uint256 amountIn, address recipient) external returns (uint256);</span>
  16 |     | <span class='neutral'>}</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>/// @notice Liquidation Swapper for Stargate LP using Curve</span>
  19 |     | <span class='unexecuted'>contract StargateCurveSwapper is ISwapperV1, BoringOwnable {</span>
  20 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
  21 |     | <span class='neutral'>    using SafeApproveLib for IERC20;</span>
  22 |     | <span class='neutral'>    using Address for address;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    event MimPoolChanged(IStargateLpMimPool previousPool, IStargateLpMimPool pool);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>    IBentoBoxV1 public immutable degenBox;</span>
  27 |     | <span class='unexecuted'>    IStargatePool public immutable pool;</span>
  28 |     | <span class='unexecuted'>    IStargateRouter public immutable stargateRouter;</span>
  29 |     | <span class='unexecuted'>    ICurvePool public immutable curvePool;</span>
  30 |     | <span class='unexecuted'>    int128 public immutable curvePoolI;</span>
  31 |     | <span class='unexecuted'>    int128 public immutable curvePoolJ;</span>
  32 |     | <span class='unexecuted'>    uint16 public immutable poolId;</span>
  33 |     | <span class='unexecuted'>    IERC20 public immutable underlyingPoolToken;</span>
  34 |     | <span class='unexecuted'>    IERC20 public immutable mim;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    IStargateLpMimPool public mimPool;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    constructor(</span>
  39 |     | <span class='neutral'>        IBentoBoxV1 _degenBox,</span>
  40 |     | <span class='neutral'>        IStargatePool _pool,</span>
  41 |     | <span class='neutral'>        uint16 _poolId,</span>
  42 |     | <span class='neutral'>        IStargateRouter _stargateRouter,</span>
  43 |     | <span class='neutral'>        ICurvePool _curvePool,</span>
  44 |     | <span class='neutral'>        int128 _curvePoolI,</span>
  45 |     | <span class='neutral'>        int128 _curvePoolJ</span>
  46 |     | <span class='neutral'>    ) {</span>
  47 |     | <span class='unexecuted'>        degenBox = _degenBox;</span>
  48 |     | <span class='unexecuted'>        pool = _pool;</span>
  49 |     | <span class='unexecuted'>        poolId = _poolId;</span>
  50 |     | <span class='unexecuted'>        stargateRouter = _stargateRouter;</span>
  51 |     | <span class='unexecuted'>        curvePool = _curvePool;</span>
  52 |     | <span class='unexecuted'>        curvePoolI = _curvePoolI;</span>
  53 |     | <span class='unexecuted'>        curvePoolJ = _curvePoolJ;</span>
  54 |     | <span class='unexecuted'>        mim = IERC20(_curvePool.coins(uint128(_curvePoolJ)));</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>        underlyingPoolToken = IERC20(_pool.token());</span>
  57 |     | <span class='unexecuted'>        underlyingPoolToken.safeApprove(address(_curvePool), type(uint256).max);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>    function setMimPool(IStargateLpMimPool _mimPool) external onlyOwner {</span>
  61 |     | <span class='unexecuted'>        if (address(mimPool) != address(0)) {</span>
  62 |     | <span class='unexecuted'>            IERC20(address(pool)).safeApprove(address(_mimPool), 0);</span>
  63 |     | <span class='neutral'>        }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>        if (address(_mimPool) != address(0)) {</span>
  66 |     | <span class='unexecuted'>            IERC20(address(pool)).safeApprove(address(_mimPool), type(uint256).max);</span>
  67 |     | <span class='neutral'>        }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>        emit MimPoolChanged(mimPool, _mimPool);</span>
  70 |     | <span class='unexecuted'>        mimPool = _mimPool;</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    /// @inheritdoc ISwapperV1</span>
  74 |     | <span class='unexecuted'>    function swap(</span>
  75 |     | <span class='neutral'>        address,</span>
  76 |     | <span class='neutral'>        address,</span>
  77 |     | <span class='neutral'>        address recipient,</span>
  78 |     | <span class='neutral'>        uint256 shareToMin,</span>
  79 |     | <span class='neutral'>        uint256 shareFrom</span>
  80 |     | <span class='unexecuted'>    ) public override returns (uint256 extraShare, uint256 shareReturned) {</span>
  81 |     | <span class='unexecuted'>        degenBox.withdraw(IERC20(address(pool)), address(this), address(this), 0, shareFrom);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>        // use the full balance so it&#39;s easier to check if everything has been redeemed.</span>
  84 |     | <span class='unexecuted'>        uint256 amount = IERC20(address(pool)).balanceOf(address(this));</span>
  85 |     | <span class='unexecuted'>        uint256 mimAmount;</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        // Stargate Pool LP -&gt; Underlying Token</span>
  88 |     | <span class='unexecuted'>        stargateRouter.instantRedeemLocal(poolId, amount, address(this));</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>        // Use mim pool to swap the remaining lp</span>
  91 |     | <span class='unexecuted'>        if (address(mimPool) != address(0)) {</span>
  92 |     | <span class='neutral'>            // Remaining lp amount</span>
  93 |     | <span class='unexecuted'>            amount = IERC20(address(pool)).balanceOf(address(this));</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>            if (amount &gt; 0) {</span>
  96 |     | <span class='unexecuted'>                mimAmount += mimPool.swapForMim(pool, amount, address(degenBox));</span>
  97 |     | <span class='neutral'>            }</span>
  98 |     | <span class='neutral'>        } else {</span>
  99 |     | <span class='unexecuted'>            require(IERC20(address(pool)).balanceOf(address(this)) == 0, &quot;Cannot fully redeem&quot;);</span>
 100 |     | <span class='neutral'>        }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>        // Stargate Pool Underlying Token -&gt; MIM</span>
 103 |     | <span class='unexecuted'>        mimAmount += curvePool.exchange_underlying(</span>
 104 |     | <span class='unexecuted'>            curvePoolI,</span>
 105 |     | <span class='unexecuted'>            curvePoolJ,</span>
 106 |     | <span class='unexecuted'>            underlyingPoolToken.balanceOf(address(this)),</span>
 107 |     | <span class='unexecuted'>            0,</span>
 108 |     | <span class='unexecuted'>            address(degenBox)</span>
 109 |     | <span class='neutral'>        );</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        (, shareReturned) = degenBox.deposit(mim, address(degenBox), recipient, mimAmount, 0);</span>
 112 |     | <span class='unexecuted'>        extraShare = shareReturned - shareToMin;</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'>}</span>
 115 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/StargateLPLevSwapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IUniswapV2Pair} from &quot;interfaces/IUniswapV2.sol&quot;;</span>
  8 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  9 |     | <span class='neutral'>import {ILevSwapperV2} from &quot;interfaces/ILevSwapperV2.sol&quot;;</span>
 10 |     | <span class='neutral'>import {IStargatePool, IStargateRouter} from &quot;interfaces/IStargate.sol&quot;;</span>
 11 |     | <span class='neutral'>import {SafeApproveLib} from &quot;libraries/SafeApproveLib.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>/// @notice LP leverage swapper for Stargate LP using Matcha/0x aggregator</span>
 14 |     | <span class='unexecuted'>contract StargateLPLevSwapper is ILevSwapperV2 {</span>
 15 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 16 |     | <span class='neutral'>    using SafeApproveLib for IERC20;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    error ErrSwapFailed();</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    IBentoBoxV1 public immutable bentoBox;</span>
 21 |     | <span class='unexecuted'>    IStargatePool public immutable pool;</span>
 22 |     | <span class='unexecuted'>    IERC20 public immutable mim;</span>
 23 |     | <span class='unexecuted'>    IERC20 public immutable underlyingToken;</span>
 24 |     | <span class='unexecuted'>    IStargateRouter public immutable stargateRouter;</span>
 25 |     | <span class='unexecuted'>    address public immutable zeroXExchangeProxy;</span>
 26 |     | <span class='unexecuted'>    uint256 public immutable poolId;</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>    constructor(</span>
 29 |     | <span class='neutral'>        IBentoBoxV1 _bentoBox,</span>
 30 |     | <span class='neutral'>        IStargatePool _pool,</span>
 31 |     | <span class='neutral'>        uint256 _poolId,</span>
 32 |     | <span class='neutral'>        IStargateRouter _stargateRouter,</span>
 33 |     | <span class='neutral'>        IERC20 _mim,</span>
 34 |     | <span class='neutral'>        address _zeroXExchangeProxy</span>
 35 |     | <span class='unexecuted'>    ) {</span>
 36 |     | <span class='unexecuted'>        bentoBox = _bentoBox;</span>
 37 |     | <span class='unexecuted'>        pool = _pool;</span>
 38 |     | <span class='unexecuted'>        poolId = _poolId;</span>
 39 |     | <span class='unexecuted'>        mim = _mim;</span>
 40 |     | <span class='unexecuted'>        stargateRouter = _stargateRouter;</span>
 41 |     | <span class='unexecuted'>        zeroXExchangeProxy = _zeroXExchangeProxy;</span>
 42 |     | <span class='unexecuted'>        IERC20 _underlyingToken = IERC20(_pool.token());</span>
 43 |     | <span class='unexecuted'>        underlyingToken = _underlyingToken;</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='unexecuted'>        _underlyingToken.safeApprove(address(_stargateRouter), type(uint256).max);</span>
 46 |     | <span class='unexecuted'>        _pool.approve(address(_bentoBox), type(uint256).max);</span>
 47 |     | <span class='unexecuted'>        _mim.approve(_zeroXExchangeProxy, type(uint256).max);</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    /// @inheritdoc ILevSwapperV2</span>
 51 |     | <span class='unexecuted'>    function swap(</span>
 52 |     | <span class='neutral'>        address recipient,</span>
 53 |     | <span class='neutral'>        uint256 shareToMin,</span>
 54 |     | <span class='neutral'>        uint256 shareFrom,</span>
 55 |     | <span class='neutral'>        bytes calldata swapData</span>
 56 |     | <span class='unexecuted'>    ) external override returns (uint256 extraShare, uint256 shareReturned) {</span>
 57 |     | <span class='unexecuted'>        bentoBox.withdraw(mim, address(this), address(this), 0, shareFrom);</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>        // MIM -&gt; underlyingToken</span>
 60 |     | <span class='unexecuted'>        (bool success, ) = zeroXExchangeProxy.call(swapData);</span>
 61 |     | <span class='unexecuted'>        if (!success) {</span>
 62 |     | <span class='unexecuted'>            revert ErrSwapFailed();</span>
 63 |     | <span class='neutral'>        }</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='neutral'>        // Underlying Token -&gt; Stargate Pool LP</span>
 66 |     | <span class='unexecuted'>        stargateRouter.addLiquidity(poolId, underlyingToken.balanceOf(address(this)), address(this));</span>
 67 |     | <span class='unexecuted'>        uint256 amount = pool.balanceOf(address(this));</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='unexecuted'>        (, shareReturned) = bentoBox.deposit(IERC20(address(pool)), address(this), recipient, amount, 0);</span>
 70 |     | <span class='unexecuted'>        extraShare = shareReturned - shareToMin;</span>
 71 |     | <span class='neutral'>    }</span>
 72 |     | <span class='neutral'>}</span>
 73 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/StargateLPSwapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IUniswapV2Pair} from &quot;interfaces/IUniswapV2.sol&quot;;</span>
  8 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  9 |     | <span class='neutral'>import {ISwapperV2} from &quot;interfaces/ISwapperV2.sol&quot;;</span>
 10 |     | <span class='neutral'>import {IStargatePool, IStargateRouter} from &quot;interfaces/IStargate.sol&quot;;</span>
 11 |     | <span class='neutral'>import {SafeApproveLib} from &quot;libraries/SafeApproveLib.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>/// @notice LP liquidation/deleverage swapper for Stargate LPs using Matcha/0x aggregator</span>
 14 |     | <span class='unexecuted'>contract StargateLPSwapper is ISwapperV2 {</span>
 15 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 16 |     | <span class='neutral'>    using SafeApproveLib for IERC20;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    error ErrSwapFailed();</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    IBentoBoxV1 public immutable bentoBox;</span>
 21 |     | <span class='unexecuted'>    IStargatePool public immutable pool;</span>
 22 |     | <span class='unexecuted'>    IERC20 public immutable mim;</span>
 23 |     | <span class='unexecuted'>    IERC20 public immutable underlyingToken;</span>
 24 |     | <span class='unexecuted'>    IStargateRouter public immutable stargateRouter;</span>
 25 |     | <span class='unexecuted'>    address public immutable zeroXExchangeProxy;</span>
 26 |     | <span class='unexecuted'>    uint16 public immutable poolId;</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>    constructor(</span>
 29 |     | <span class='neutral'>        IBentoBoxV1 _bentoBox,</span>
 30 |     | <span class='neutral'>        IStargatePool _pool,</span>
 31 |     | <span class='neutral'>        uint16 _poolId,</span>
 32 |     | <span class='neutral'>        IStargateRouter _stargateRouter,</span>
 33 |     | <span class='neutral'>        IERC20 _mim,</span>
 34 |     | <span class='neutral'>        address _zeroXExchangeProxy</span>
 35 |     | <span class='neutral'>    ) {</span>
 36 |     | <span class='unexecuted'>        bentoBox = _bentoBox;</span>
 37 |     | <span class='unexecuted'>        pool = _pool;</span>
 38 |     | <span class='unexecuted'>        poolId = _poolId;</span>
 39 |     | <span class='unexecuted'>        mim = _mim;</span>
 40 |     | <span class='unexecuted'>        stargateRouter = _stargateRouter;</span>
 41 |     | <span class='unexecuted'>        zeroXExchangeProxy = _zeroXExchangeProxy;</span>
 42 |     | <span class='unexecuted'>        underlyingToken = IERC20(_pool.token());</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='unexecuted'>        underlyingToken.safeApprove(_zeroXExchangeProxy, type(uint256).max);</span>
 45 |     | <span class='unexecuted'>        mim.approve(address(_bentoBox), type(uint256).max);</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    /// @inheritdoc ISwapperV2</span>
 49 |     | <span class='unexecuted'>    function swap(</span>
 50 |     | <span class='neutral'>        address,</span>
 51 |     | <span class='neutral'>        address,</span>
 52 |     | <span class='neutral'>        address recipient,</span>
 53 |     | <span class='neutral'>        uint256 shareToMin,</span>
 54 |     | <span class='neutral'>        uint256 shareFrom,</span>
 55 |     | <span class='neutral'>        bytes calldata swapData</span>
 56 |     | <span class='unexecuted'>    ) public override returns (uint256 extraShare, uint256 shareReturned) {</span>
 57 |     | <span class='unexecuted'>        bentoBox.withdraw(IERC20(address(pool)), address(this), address(this), 0, shareFrom);</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>        // use the full balance so it&#39;s easier to check if everything has been redeemed.</span>
 60 |     | <span class='unexecuted'>        uint256 amount = IERC20(address(pool)).balanceOf(address(this));</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>        // Stargate Pool LP -&gt; Underlying Token</span>
 63 |     | <span class='unexecuted'>        stargateRouter.instantRedeemLocal(poolId, amount, address(this));</span>
 64 |     | <span class='unexecuted'>        require(IERC20(address(pool)).balanceOf(address(this)) == 0, &quot;Cannot fully redeem&quot;);</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>        // underlying -&gt; MIM</span>
 67 |     | <span class='unexecuted'>        (bool success, ) = zeroXExchangeProxy.call(swapData);</span>
 68 |     | <span class='unexecuted'>        if (!success) {</span>
 69 |     | <span class='unexecuted'>            revert ErrSwapFailed();</span>
 70 |     | <span class='neutral'>        }</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>        // Refund remaining underlying balance to the recipient</span>
 73 |     | <span class='unexecuted'>        underlyingToken.safeTransfer(recipient, underlyingToken.balanceOf(address(this)));</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='unexecuted'>        (, shareReturned) = bentoBox.deposit(mim, address(this), recipient, mim.balanceOf(address(this)), 0);</span>
 76 |     | <span class='unexecuted'>        extraShare = shareReturned - shareToMin;</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/TokenLevSwapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  8 |     | <span class='neutral'>import {ILevSwapperV2} from &quot;interfaces/ILevSwapperV2.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>/// @notice token leverage swapper for tokens using Matcha/0x aggregator</span>
 11 |     | <span class='unexecuted'>contract TokenLevSwapper is ILevSwapperV2 {</span>
 12 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    error ErrSwapFailed();</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    IBentoBoxV1 public immutable bentoBox;</span>
 17 |     | <span class='unexecuted'>    IERC20 public immutable mim;</span>
 18 |     | <span class='unexecuted'>    IERC20 public immutable token;</span>
 19 |     | <span class='unexecuted'>    address public immutable zeroXExchangeProxy;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    constructor(IBentoBoxV1 _bentoBox, IERC20 _token, IERC20 _mim, address _zeroXExchangeProxy) {</span>
 22 |     | <span class='unexecuted'>        bentoBox = _bentoBox;</span>
 23 |     | <span class='unexecuted'>        token = _token;</span>
 24 |     | <span class='unexecuted'>        mim = _mim;</span>
 25 |     | <span class='unexecuted'>        zeroXExchangeProxy = _zeroXExchangeProxy;</span>
 26 |     | <span class='unexecuted'>        _token.approve(address(_bentoBox), type(uint256).max);</span>
 27 |     | <span class='unexecuted'>        _mim.approve(_zeroXExchangeProxy, type(uint256).max);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    /// @inheritdoc ILevSwapperV2</span>
 31 |     | <span class='unexecuted'>    function swap(</span>
 32 |     | <span class='neutral'>        address recipient,</span>
 33 |     | <span class='neutral'>        uint256 shareToMin,</span>
 34 |     | <span class='neutral'>        uint256 shareFrom,</span>
 35 |     | <span class='neutral'>        bytes calldata swapData</span>
 36 |     | <span class='unexecuted'>    ) external override returns (uint256 extraShare, uint256 shareReturned) {</span>
 37 |     | <span class='unexecuted'>        bentoBox.withdraw(mim, address(this), address(this), 0, shareFrom);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>        // MIM -&gt; token</span>
 40 |     | <span class='unexecuted'>        (bool success, ) = zeroXExchangeProxy.call(swapData);</span>
 41 |     | <span class='unexecuted'>        if (!success) {</span>
 42 |     | <span class='unexecuted'>            revert ErrSwapFailed();</span>
 43 |     | <span class='neutral'>        }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>        // Refund remaining mim balance to the recipient</span>
 46 |     | <span class='unexecuted'>        uint256 balance = mim.balanceOf(address(this));</span>
 47 |     | <span class='unexecuted'>        if (balance &gt; 0) {</span>
 48 |     | <span class='unexecuted'>            mim.safeTransfer(recipient, balance);</span>
 49 |     | <span class='neutral'>        }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>        (, shareReturned) = bentoBox.deposit(token, address(this), recipient, token.balanceOf(address(this)), 0);</span>
 52 |     | <span class='unexecuted'>        extraShare = shareReturned - shareToMin;</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'>}</span>
 55 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/TokenSwapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  8 |     | <span class='neutral'>import {ISwapperV2} from &quot;interfaces/ISwapperV2.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>/// @notice token liquidation/deleverage swapper for tokens using Matcha/0x aggregator</span>
 11 |     | <span class='unexecuted'>contract TokenSwapper is ISwapperV2 {</span>
 12 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    error ErrSwapFailed();</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    IBentoBoxV1 public immutable bentoBox;</span>
 17 |     | <span class='unexecuted'>    IERC20 public immutable token;</span>
 18 |     | <span class='unexecuted'>    IERC20 public immutable mim;</span>
 19 |     | <span class='unexecuted'>    address public immutable zeroXExchangeProxy;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    constructor(IBentoBoxV1 _bentoBox, IERC20 _token, IERC20 _mim, address _zeroXExchangeProxy) {</span>
 22 |     | <span class='unexecuted'>        bentoBox = _bentoBox;</span>
 23 |     | <span class='unexecuted'>        token = _token;</span>
 24 |     | <span class='unexecuted'>        mim = _mim;</span>
 25 |     | <span class='unexecuted'>        zeroXExchangeProxy = _zeroXExchangeProxy;</span>
 26 |     | <span class='unexecuted'>        _token.approve(_zeroXExchangeProxy, type(uint256).max);</span>
 27 |     | <span class='unexecuted'>        mim.approve(address(_bentoBox), type(uint256).max);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    /// @inheritdoc ISwapperV2</span>
 31 |     | <span class='unexecuted'>    function swap(</span>
 32 |     | <span class='neutral'>        address,</span>
 33 |     | <span class='neutral'>        address,</span>
 34 |     | <span class='neutral'>        address recipient,</span>
 35 |     | <span class='neutral'>        uint256 shareToMin,</span>
 36 |     | <span class='neutral'>        uint256 shareFrom,</span>
 37 |     | <span class='neutral'>        bytes calldata swapData</span>
 38 |     | <span class='unexecuted'>    ) public override returns (uint256 extraShare, uint256 shareReturned) {</span>
 39 |     | <span class='unexecuted'>        bentoBox.withdraw(IERC20(address(token)), address(this), address(this), 0, shareFrom);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>        // token -&gt; MIM</span>
 42 |     | <span class='unexecuted'>        (bool success, ) = zeroXExchangeProxy.call(swapData);</span>
 43 |     | <span class='unexecuted'>        if (!success) {</span>
 44 |     | <span class='unexecuted'>            revert ErrSwapFailed();</span>
 45 |     | <span class='neutral'>        }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>        // Refund remaining balance to the recipient</span>
 48 |     | <span class='unexecuted'>        uint256 balance = token.balanceOf(address(this));</span>
 49 |     | <span class='unexecuted'>        if (balance &gt; 0) {</span>
 50 |     | <span class='unexecuted'>            token.safeTransfer(recipient, balance);</span>
 51 |     | <span class='neutral'>        }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='unexecuted'>        (, shareReturned) = bentoBox.deposit(mim, address(this), recipient, mim.balanceOf(address(this)), 0);</span>
 54 |     | <span class='unexecuted'>        extraShare = shareReturned - shareToMin;</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'>}</span>
 57 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/UniswapLikeLPLevSwapper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
   3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IUniswapV2Pair, IUniswapV2Router01} from &quot;interfaces/IUniswapV2.sol&quot;;</span>
   8 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
   9 |     | <span class='neutral'>import {ILevSwapperV2} from &quot;interfaces/ILevSwapperV2.sol&quot;;</span>
  10 |     | <span class='neutral'>import {UniswapV2OneSided} from &quot;libraries/UniswapV2Lib.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/// @notice Generic LP leverage swapper for Uniswap like compatible DEX using Matcha/0x aggregator</span>
  13 |     | <span class='unexecuted'>contract UniswapLikeLPLevSwapper is ILevSwapperV2 {</span>
  14 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    error ErrToken0SwapFailed();</span>
  17 |     | <span class='neutral'>    error ErrToken1SwapFailed();</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>    IBentoBoxV1 public immutable bentoBox;</span>
  20 |     | <span class='unexecuted'>    IUniswapV2Pair public immutable pair;</span>
  21 |     | <span class='unexecuted'>    IUniswapV2Router01 public immutable router;</span>
  22 |     | <span class='unexecuted'>    IERC20 public immutable mim;</span>
  23 |     | <span class='unexecuted'>    IERC20 public immutable token0;</span>
  24 |     | <span class='unexecuted'>    IERC20 public immutable token1;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>    address public immutable zeroXExchangeProxy;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    constructor(IBentoBoxV1 _bentoBox, IUniswapV2Router01 _router, IUniswapV2Pair _pair, IERC20 _mim, address _zeroXExchangeProxy) {</span>
  29 |     | <span class='unexecuted'>        bentoBox = _bentoBox;</span>
  30 |     | <span class='unexecuted'>        router = _router;</span>
  31 |     | <span class='unexecuted'>        pair = _pair;</span>
  32 |     | <span class='unexecuted'>        mim = _mim;</span>
  33 |     | <span class='unexecuted'>        zeroXExchangeProxy = _zeroXExchangeProxy;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>        IERC20 _token0 = IERC20(_pair.token0());</span>
  36 |     | <span class='unexecuted'>        IERC20 _token1 = IERC20(_pair.token1());</span>
  37 |     | <span class='unexecuted'>        token0 = _token0;</span>
  38 |     | <span class='unexecuted'>        token1 = _token1;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>        _token0.approve(address(_router), type(uint256).max);</span>
  41 |     | <span class='unexecuted'>        _token1.approve(address(_router), type(uint256).max);</span>
  42 |     | <span class='unexecuted'>        _mim.approve(_zeroXExchangeProxy, type(uint256).max);</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /// @inheritdoc ILevSwapperV2</span>
  46 |     | <span class='unexecuted'>    function swap(</span>
  47 |     | <span class='neutral'>        address recipient,</span>
  48 |     | <span class='neutral'>        uint256 shareToMin,</span>
  49 |     | <span class='neutral'>        uint256 shareFrom,</span>
  50 |     | <span class='neutral'>        bytes calldata data</span>
  51 |     | <span class='unexecuted'>    ) external override returns (uint256 extraShare, uint256 shareReturned) {</span>
  52 |     | <span class='neutral'>        // 0: MIM -&gt; token0</span>
  53 |     | <span class='neutral'>        // 1: MIM -&gt; token1</span>
  54 |     | <span class='unexecuted'>        (bytes[] memory swapData, uint256 minOneSideableAmount0, uint256 minOneSideableAmount1) = abi.decode(</span>
  55 |     | <span class='unexecuted'>            data,</span>
  56 |     | <span class='neutral'>            (bytes[], uint256, uint256)</span>
  57 |     | <span class='neutral'>        );</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>        bentoBox.withdraw(mim, address(this), address(this), 0, shareFrom);</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>        // MIM -&gt; token0</span>
  62 |     | <span class='unexecuted'>        (bool success, ) = zeroXExchangeProxy.call(swapData[0]);</span>
  63 |     | <span class='unexecuted'>        if (!success) {</span>
  64 |     | <span class='unexecuted'>            revert ErrToken0SwapFailed();</span>
  65 |     | <span class='neutral'>        }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>        // MIM -&gt; token1</span>
  68 |     | <span class='unexecuted'>        (success, ) = zeroXExchangeProxy.call(swapData[1]);</span>
  69 |     | <span class='unexecuted'>        if (!success) {</span>
  70 |     | <span class='unexecuted'>            revert ErrToken1SwapFailed();</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        uint256 liquidity;</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>        {</span>
  76 |     | <span class='unexecuted'>            (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>            UniswapV2OneSided.AddLiquidityAndOneSideRemainingParams memory params = UniswapV2OneSided.AddLiquidityAndOneSideRemainingParams(</span>
  79 |     | <span class='unexecuted'>                router,</span>
  80 |     | <span class='unexecuted'>                pair,</span>
  81 |     | <span class='unexecuted'>                address(token0),</span>
  82 |     | <span class='unexecuted'>                address(token1),</span>
  83 |     | <span class='unexecuted'>                reserve0,</span>
  84 |     | <span class='unexecuted'>                reserve1,</span>
  85 |     | <span class='unexecuted'>                token0.balanceOf(address(this)),</span>
  86 |     | <span class='unexecuted'>                token1.balanceOf(address(this)),</span>
  87 |     | <span class='unexecuted'>                minOneSideableAmount0,</span>
  88 |     | <span class='unexecuted'>                minOneSideableAmount1,</span>
  89 |     | <span class='unexecuted'>                address(bentoBox)</span>
  90 |     | <span class='neutral'>            );</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>            (, , liquidity) = UniswapV2OneSided.addLiquidityAndOneSideRemaining(params);</span>
  93 |     | <span class='neutral'>        }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>        (, shareReturned) = bentoBox.deposit(IERC20(address(pair)), address(bentoBox), recipient, liquidity, 0);</span>
  96 |     | <span class='unexecuted'>        extraShare = shareReturned - shareToMin;</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'>}</span>
  99 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/UniswapLikeLPSwapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IUniswapV2Pair} from &quot;interfaces/IUniswapV2.sol&quot;;</span>
  8 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  9 |     | <span class='neutral'>import {ISwapperV2} from &quot;interfaces/ISwapperV2.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>/// @notice Generic LP liquidation/deleverage swapper for Uniswap like compatible DEX using Matcha/0x aggregator</span>
 12 |     | <span class='unexecuted'>contract UniswapLikeLPSwapper is ISwapperV2 {</span>
 13 |     | <span class='neutral'>    using BoringERC20 for IERC20;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    error ErrToken0SwapFailed();</span>
 16 |     | <span class='neutral'>    error ErrToken1SwapFailed();</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>    IBentoBoxV1 public immutable bentoBox;</span>
 19 |     | <span class='unexecuted'>    IUniswapV2Pair public immutable pair;</span>
 20 |     | <span class='unexecuted'>    IERC20 public immutable mim;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    address public immutable zeroXExchangeProxy;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    constructor(IBentoBoxV1 _bentoBox, IUniswapV2Pair _pair, IERC20 _mim, address _zeroXExchangeProxy) {</span>
 25 |     | <span class='unexecuted'>        bentoBox = _bentoBox;</span>
 26 |     | <span class='unexecuted'>        pair = _pair;</span>
 27 |     | <span class='unexecuted'>        mim = _mim;</span>
 28 |     | <span class='unexecuted'>        zeroXExchangeProxy = _zeroXExchangeProxy;</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>        IERC20(pair.token0()).approve(_zeroXExchangeProxy, type(uint256).max);</span>
 31 |     | <span class='unexecuted'>        IERC20(pair.token1()).approve(_zeroXExchangeProxy, type(uint256).max);</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='unexecuted'>        mim.approve(address(_bentoBox), type(uint256).max);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @inheritdoc ISwapperV2</span>
 37 |     | <span class='unexecuted'>    function swap(</span>
 38 |     | <span class='neutral'>        address,</span>
 39 |     | <span class='neutral'>        address,</span>
 40 |     | <span class='neutral'>        address recipient,</span>
 41 |     | <span class='neutral'>        uint256 shareToMin,</span>
 42 |     | <span class='neutral'>        uint256 shareFrom,</span>
 43 |     | <span class='neutral'>        bytes calldata data</span>
 44 |     | <span class='unexecuted'>    ) public override returns (uint256 extraShare, uint256 shareReturned) {</span>
 45 |     | <span class='neutral'>        // 0: token0 -&gt; MIM</span>
 46 |     | <span class='neutral'>        // 1: token1 -&gt; MIM</span>
 47 |     | <span class='unexecuted'>        bytes[] memory swapData = abi.decode(data, (bytes[]));</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='unexecuted'>        (uint256 amountFrom, ) = bentoBox.withdraw(IERC20(address(pair)), address(this), address(this), 0, shareFrom);</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>        pair.transfer(address(pair), amountFrom);</span>
 52 |     | <span class='unexecuted'>        pair.burn(address(this));</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>        // token0 -&gt; MIM</span>
 55 |     | <span class='unexecuted'>        (bool success, ) = zeroXExchangeProxy.call(swapData[0]);</span>
 56 |     | <span class='unexecuted'>        if (!success) {</span>
 57 |     | <span class='unexecuted'>            revert ErrToken0SwapFailed();</span>
 58 |     | <span class='neutral'>        }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>        // token1 -&gt; MIM</span>
 61 |     | <span class='unexecuted'>        (success, ) = zeroXExchangeProxy.call(swapData[1]);</span>
 62 |     | <span class='unexecuted'>        if (!success) {</span>
 63 |     | <span class='unexecuted'>            revert ErrToken1SwapFailed();</span>
 64 |     | <span class='neutral'>        }</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='unexecuted'>        (, shareReturned) = bentoBox.deposit(mim, address(this), recipient, mim.balanceOf(address(this)), 0);</span>
 67 |     | <span class='unexecuted'>        extraShare = shareReturned - shareToMin;</span>
 68 |     | <span class='neutral'>    }</span>
 69 |     | <span class='neutral'>}</span>
 70 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/YearnCurveLevSwapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solady/utils/SafeTransferLib.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  8 |     | <span class='neutral'>import {CurveLevSwapper} from &quot;swappers/CurveLevSwapper.sol&quot;;</span>
  9 |     | <span class='neutral'>import {IYearnVault} from &quot;interfaces/IYearnVault.sol&quot;;</span>
 10 |     | <span class='neutral'>import {ICurvePool, CurvePoolInterfaceType} from &quot;interfaces/ICurvePool.sol&quot;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>contract YearnCurveLevSwapper is CurveLevSwapper {</span>
 13 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    IYearnVault public immutable wrapper;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    constructor(</span>
 18 |     | <span class='neutral'>        IBentoBoxV1 _bentoBox,</span>
 19 |     | <span class='neutral'>        IYearnVault _wrapper,</span>
 20 |     | <span class='neutral'>        address _mim,</span>
 21 |     | <span class='neutral'>        CurvePoolInterfaceType _curvePoolInterfaceType,</span>
 22 |     | <span class='neutral'>        address _curvePool,</span>
 23 |     | <span class='neutral'>        address _curvePoolDepositor /* Optional Curve Deposit Zapper */,</span>
 24 |     | <span class='neutral'>        address[] memory _poolTokens,</span>
 25 |     | <span class='neutral'>        address _zeroXExchangeProxy</span>
 26 |     | <span class='neutral'>    )</span>
 27 |     | <span class='neutral'>        CurveLevSwapper(</span>
 28 |     | <span class='unexecuted'>            _bentoBox,</span>
 29 |     | <span class='unexecuted'>            _wrapper.token(),</span>
 30 |     | <span class='unexecuted'>            _mim,</span>
 31 |     | <span class='unexecuted'>            _curvePoolInterfaceType,</span>
 32 |     | <span class='unexecuted'>            _curvePool,</span>
 33 |     | <span class='unexecuted'>            _curvePoolDepositor,</span>
 34 |     | <span class='unexecuted'>            _poolTokens,</span>
 35 |     | <span class='unexecuted'>            _zeroXExchangeProxy</span>
 36 |     | <span class='neutral'>        )</span>
 37 |     | <span class='neutral'>    {</span>
 38 |     | <span class='unexecuted'>        wrapper = _wrapper;</span>
 39 |     | <span class='unexecuted'>        curveToken.safeApprove(address(_wrapper), type(uint256).max);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='unexecuted'>    function depositInBentoBox(uint256 amount, address recipient) internal override returns (uint256 shareReturned) {</span>
 43 |     | <span class='neutral'>        // CurveLP -&gt; Yearn Vault</span>
 44 |     | <span class='unexecuted'>        amount = wrapper.deposit(amount, address(bentoBox));</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>        (, shareReturned) = bentoBox.deposit(IERC20(address(wrapper)), address(bentoBox), recipient, amount, 0);</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'>}</span>
 49 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/YearnCurveSwapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solady/utils/SafeTransferLib.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import {CurveSwapper} from &quot;swappers/CurveSwapper.sol&quot;;</span>
  8 |     | <span class='neutral'>import {IBentoBoxV1} from &quot;interfaces/IBentoBoxV1.sol&quot;;</span>
  9 |     | <span class='neutral'>import {IYearnVault} from &quot;interfaces/IYearnVault.sol&quot;;</span>
 10 |     | <span class='neutral'>import {CurvePoolInterfaceType} from &quot;interfaces/ICurvePool.sol&quot;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>contract YearnCurveSwapper is CurveSwapper {</span>
 13 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    IYearnVault public immutable wrapper;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    constructor(</span>
 18 |     | <span class='neutral'>        IBentoBoxV1 _bentoBox,</span>
 19 |     | <span class='neutral'>        IYearnVault _wrapper,</span>
 20 |     | <span class='neutral'>        address _mim,</span>
 21 |     | <span class='neutral'>        CurvePoolInterfaceType _curvePoolInterfaceType,</span>
 22 |     | <span class='neutral'>        address _curvePool,</span>
 23 |     | <span class='neutral'>        address _curvePoolDepositor /* Optional Curve Deposit Zapper */,</span>
 24 |     | <span class='neutral'>        address[] memory _poolTokens,</span>
 25 |     | <span class='neutral'>        address _zeroXExchangeProxy</span>
 26 |     | <span class='neutral'>    )</span>
 27 |     | <span class='neutral'>        CurveSwapper(</span>
 28 |     | <span class='unexecuted'>            _bentoBox,</span>
 29 |     | <span class='unexecuted'>            _wrapper.token(),</span>
 30 |     | <span class='unexecuted'>            _mim,</span>
 31 |     | <span class='unexecuted'>            _curvePoolInterfaceType,</span>
 32 |     | <span class='unexecuted'>            _curvePool,</span>
 33 |     | <span class='unexecuted'>            _curvePoolDepositor,</span>
 34 |     | <span class='unexecuted'>            _poolTokens,</span>
 35 |     | <span class='unexecuted'>            _zeroXExchangeProxy</span>
 36 |     | <span class='neutral'>        )</span>
 37 |     | <span class='neutral'>    {</span>
 38 |     | <span class='unexecuted'>        wrapper = _wrapper;</span>
 39 |     | <span class='unexecuted'>        if (_curvePoolDepositor != address(0)) {</span>
 40 |     | <span class='unexecuted'>            address curveToken = wrapper.token();</span>
 41 |     | <span class='unexecuted'>            curveToken.safeApprove(_curvePoolDepositor, type(uint256).max);</span>
 42 |     | <span class='neutral'>        }</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='unexecuted'>    function withdrawFromBentoBox(uint256 shareFrom) internal override returns (uint256 amount) {</span>
 46 |     | <span class='unexecuted'>        (amount, ) = bentoBox.withdraw(IERC20(address(wrapper)), address(this), address(this), 0, shareFrom);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>        // Yearn Vault -&gt; CurveLP token</span>
 49 |     | <span class='unexecuted'>        amount = wrapper.withdraw();</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'>}</span>
 52 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/tokens/ERC4626.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import {ERC20, ERC20WithSupply} from &quot;BoringSolidity/ERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BoringERC20} from &quot;BoringSolidity/libraries/BoringERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {FixedPointMathLib} from &quot;solmate/utils/FixedPointMathLib.sol&quot;;</span>
   8 |     | <span class='neutral'>import {IERC4626} from &quot;interfaces/IERC4626.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/// @notice Adapted from Solmate ERC4626</span>
  11 |     | <span class='neutral'>/// @notice Minimal ERC4626 tokenized Vault implementation.</span>
  12 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)</span>
  13 |     | <span class='unexecuted'>contract ERC4626 is IERC4626, ERC20WithSupply {</span>
  14 |     | <span class='neutral'>    using BoringERC20 for ERC20;</span>
  15 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    error ErrZeroAssets();</span>
  18 |     | <span class='neutral'>    error ErrZeroShares();</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    string public name;</span>
  21 |     | <span class='unexecuted'>    string public symbol;</span>
  22 |     | <span class='unexecuted'>    ERC20 public _asset;</span>
  23 |     | <span class='neutral'>    uint256 internal _totalAssets;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    function asset() external view returns (IERC20) {</span>
  26 |     | <span class='unexecuted'>        return _asset;</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    function decimals() external view returns (uint8) {</span>
  30 |     | <span class='unexecuted'>        return _asset.safeDecimals();</span>
  31 |     | <span class='neutral'>    }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {</span>
  34 |     | <span class='neutral'>        // Check for rounding error since we round down in previewDeposit.</span>
  35 |     | <span class='unexecuted'>        if ((shares = previewDeposit(assets)) == 0) {</span>
  36 |     | <span class='unexecuted'>            revert ErrZeroShares();</span>
  37 |     | <span class='neutral'>        }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>        // Need to transfer before minting or ERC777s could reenter.</span>
  40 |     | <span class='unexecuted'>        _asset.safeTransferFrom(msg.sender, address(this), assets);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>        unchecked {</span>
  43 |     | <span class='unexecuted'>            _totalAssets += assets;</span>
  44 |     | <span class='neutral'>        }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>        _mint(receiver, shares);</span>
  47 |     | <span class='unexecuted'>        emit Deposit(msg.sender, receiver, assets, shares);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>        _afterDeposit(assets, shares);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {</span>
  53 |     | <span class='unexecuted'>        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>        // Need to transfer before minting or ERC777s could reenter.</span>
  56 |     | <span class='unexecuted'>        _asset.safeTransferFrom(msg.sender, address(this), assets);</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>        unchecked {</span>
  59 |     | <span class='unexecuted'>            _totalAssets += assets;</span>
  60 |     | <span class='neutral'>        }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>        _mint(receiver, shares);</span>
  63 |     | <span class='unexecuted'>        emit Deposit(msg.sender, receiver, assets, shares);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>        _afterDeposit(assets, shares);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>    function withdraw(</span>
  69 |     | <span class='neutral'>        uint256 assets,</span>
  70 |     | <span class='neutral'>        address receiver,</span>
  71 |     | <span class='neutral'>        address owner</span>
  72 |     | <span class='unexecuted'>    ) public virtual returns (uint256 shares) {</span>
  73 |     | <span class='unexecuted'>        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>        if (msg.sender != owner) {</span>
  76 |     | <span class='unexecuted'>            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>            if (allowed != type(uint256).max) {</span>
  79 |     | <span class='unexecuted'>                allowance[owner][msg.sender] = allowed - shares;</span>
  80 |     | <span class='neutral'>            }</span>
  81 |     | <span class='neutral'>        }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        _beforeWithdraw(assets, shares);</span>
  84 |     | <span class='unexecuted'>        _burn(owner, shares);</span>
  85 |     | <span class='unexecuted'>        emit Withdraw(msg.sender, receiver, owner, assets, shares);</span>
  86 |     | <span class='unexecuted'>        _asset.safeTransfer(receiver, assets);</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        unchecked {</span>
  89 |     | <span class='unexecuted'>            _totalAssets -= assets;</span>
  90 |     | <span class='neutral'>        }</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>    function redeem(</span>
  94 |     | <span class='neutral'>        uint256 shares,</span>
  95 |     | <span class='neutral'>        address receiver,</span>
  96 |     | <span class='neutral'>        address owner</span>
  97 |     | <span class='unexecuted'>    ) public virtual returns (uint256 assets) {</span>
  98 |     | <span class='unexecuted'>        if (msg.sender != owner) {</span>
  99 |     | <span class='unexecuted'>            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.</span>
 100 |     | <span class='unexecuted'>            if (allowed != type(uint256).max) {</span>
 101 |     | <span class='unexecuted'>                allowance[owner][msg.sender] = allowed - shares;</span>
 102 |     | <span class='neutral'>            }</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>        // Check for rounding error since we round down in previewRedeem.</span>
 106 |     | <span class='unexecuted'>        if ((assets = previewRedeem(shares)) == 0) {</span>
 107 |     | <span class='unexecuted'>            revert ErrZeroAssets();</span>
 108 |     | <span class='neutral'>        }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>        _beforeWithdraw(assets, shares);</span>
 111 |     | <span class='unexecuted'>        _burn(owner, shares);</span>
 112 |     | <span class='unexecuted'>        emit Withdraw(msg.sender, receiver, owner, assets, shares);</span>
 113 |     | <span class='unexecuted'>        _asset.safeTransfer(receiver, assets);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>        unchecked {</span>
 116 |     | <span class='unexecuted'>            _totalAssets -= assets;</span>
 117 |     | <span class='neutral'>        }</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>    function totalAssets() public view virtual returns (uint256) {</span>
 121 |     | <span class='unexecuted'>        return _totalAssets;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>    function convertToShares(uint256 assets) public view virtual returns (uint256) {</span>
 125 |     | <span class='unexecuted'>        uint256 supply = totalSupply;</span>
 126 |     | <span class='unexecuted'>        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>    function convertToAssets(uint256 shares) public view virtual returns (uint256) {</span>
 130 |     | <span class='unexecuted'>        uint256 supply = totalSupply;</span>
 131 |     | <span class='unexecuted'>        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>    function previewDeposit(uint256 assets) public view virtual returns (uint256) {</span>
 135 |     | <span class='unexecuted'>        return convertToShares(assets);</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>    function previewMint(uint256 shares) public view virtual returns (uint256) {</span>
 139 |     | <span class='unexecuted'>        uint256 supply = totalSupply;</span>
 140 |     | <span class='unexecuted'>        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {</span>
 144 |     | <span class='unexecuted'>        uint256 supply = totalSupply;</span>
 145 |     | <span class='unexecuted'>        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='unexecuted'>    function previewRedeem(uint256 shares) public view virtual returns (uint256) {</span>
 149 |     | <span class='unexecuted'>        return convertToAssets(shares);</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='unexecuted'>    function maxDeposit(address) public view virtual returns (uint256) {</span>
 153 |     | <span class='unexecuted'>        return type(uint256).max;</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    function maxMint(address) public view virtual returns (uint256) {</span>
 157 |     | <span class='neutral'>        return type(uint256).max;</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>    function maxWithdraw(address owner) public view virtual returns (uint256) {</span>
 161 |     | <span class='unexecuted'>        return convertToAssets(balanceOf[owner]);</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='unexecuted'>    function maxRedeem(address owner) public view virtual returns (uint256) {</span>
 165 |     | <span class='unexecuted'>        return balanceOf[owner];</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>    function _afterDeposit(uint256 assets, uint256 shares) internal virtual {}</span>
 171 |     | <span class='neutral'>}</span>
 172 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/tokens/LzBaseOFTV2.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {IERC165} from &quot;openzeppelin-contracts/utils/introspection/IERC165.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {ILzOFTV2, ILzFeeHandler} from &quot;interfaces/ILayerZero.sol&quot;;</span>
   8 |     | <span class='neutral'>import {LzOFTCoreV2} from &quot;tokens/LzOFTCoreV2.sol&quot;;</span>
   9 |     | <span class='neutral'>import {ERC165} from &quot;openzeppelin-contracts/utils/introspection/ERC165.sol&quot;;</span>
  10 |     | <span class='neutral'>import {SafeERC20} from &quot;openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
  11 |     | <span class='neutral'>import {ReentrancyGuard} from &quot;solmate/utils/ReentrancyGuard.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>abstract contract LzBaseOFTV2 is LzOFTCoreV2, ERC165, ReentrancyGuard, ILzOFTV2 {</span>
  14 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    error ErrFeeCollectingFailed();</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    event LogFeeHandlerChanged(ILzFeeHandler previous, ILzFeeHandler current);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    ILzFeeHandler public feeHandler;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>    constructor(uint8 _sharedDecimals, address _lzEndpoint, address _owner) LzOFTCoreV2(_sharedDecimals, _lzEndpoint, _owner) {}</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    /************************************************************************</span>
  25 |     | <span class='neutral'>     * public functions</span>
  26 |     | <span class='neutral'>     ************************************************************************/</span>
  27 |     | <span class='unexecuted'>    function sendFrom(</span>
  28 |     | <span class='neutral'>        address _from,</span>
  29 |     | <span class='neutral'>        uint16 _dstChainId,</span>
  30 |     | <span class='neutral'>        bytes32 _toAddress,</span>
  31 |     | <span class='neutral'>        uint _amount,</span>
  32 |     | <span class='neutral'>        LzCallParams calldata _callParams</span>
  33 |     | <span class='neutral'>    ) public payable virtual override nonReentrant {</span>
  34 |     | <span class='unexecuted'>        uint _valueAfterFees = _handleFees();</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>        _send(</span>
  37 |     | <span class='unexecuted'>            _from,</span>
  38 |     | <span class='unexecuted'>            _dstChainId,</span>
  39 |     | <span class='unexecuted'>            _toAddress,</span>
  40 |     | <span class='unexecuted'>            _amount,</span>
  41 |     | <span class='unexecuted'>            _callParams.refundAddress,</span>
  42 |     | <span class='unexecuted'>            _callParams.zroPaymentAddress,</span>
  43 |     | <span class='unexecuted'>            _callParams.adapterParams,</span>
  44 |     | <span class='unexecuted'>            _valueAfterFees</span>
  45 |     | <span class='neutral'>        );</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>    function sendAndCall(</span>
  49 |     | <span class='neutral'>        address _from,</span>
  50 |     | <span class='neutral'>        uint16 _dstChainId,</span>
  51 |     | <span class='neutral'>        bytes32 _toAddress,</span>
  52 |     | <span class='neutral'>        uint _amount,</span>
  53 |     | <span class='neutral'>        bytes calldata _payload,</span>
  54 |     | <span class='neutral'>        uint64 _dstGasForCall,</span>
  55 |     | <span class='neutral'>        LzCallParams calldata _callParams</span>
  56 |     | <span class='neutral'>    ) public payable virtual override nonReentrant {</span>
  57 |     | <span class='unexecuted'>        uint _valueAfterFees = _handleFees();</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>        _sendAndCall(</span>
  60 |     | <span class='unexecuted'>            _from,</span>
  61 |     | <span class='unexecuted'>            _dstChainId,</span>
  62 |     | <span class='unexecuted'>            _toAddress,</span>
  63 |     | <span class='unexecuted'>            _amount,</span>
  64 |     | <span class='unexecuted'>            _payload,</span>
  65 |     | <span class='unexecuted'>            _dstGasForCall,</span>
  66 |     | <span class='unexecuted'>            _callParams.refundAddress,</span>
  67 |     | <span class='unexecuted'>            _callParams.zroPaymentAddress,</span>
  68 |     | <span class='unexecuted'>            _callParams.adapterParams,</span>
  69 |     | <span class='unexecuted'>            _valueAfterFees</span>
  70 |     | <span class='neutral'>        );</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>    function _handleFees() internal returns (uint256 adjustedValue) {</span>
  74 |     | <span class='unexecuted'>        adjustedValue = msg.value;</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>        if (address(feeHandler) != address(0)) {</span>
  77 |     | <span class='unexecuted'>            uint256 fee = feeHandler.getFee();</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>            // let it revert when the value is not enough to cover the fees</span>
  80 |     | <span class='unexecuted'>            adjustedValue -= fee;</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>            // collect the native fee, calling the `receive` function on the fee handler</span>
  83 |     | <span class='unexecuted'>            (bool success, ) = address(feeHandler).call{value: fee}(&quot;&quot;);</span>
  84 |     | <span class='unexecuted'>            if (!success) {</span>
  85 |     | <span class='unexecuted'>                revert ErrFeeCollectingFailed();</span>
  86 |     | <span class='neutral'>            }</span>
  87 |     | <span class='neutral'>        }</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /************************************************************************</span>
  91 |     | <span class='neutral'>     * public view functions</span>
  92 |     | <span class='neutral'>     ************************************************************************/</span>
  93 |     | <span class='unexecuted'>    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {</span>
  94 |     | <span class='unexecuted'>        return interfaceId == type(ILzOFTV2).interfaceId || super.supportsInterface(interfaceId);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>    function estimateSendFee(</span>
  98 |     | <span class='neutral'>        uint16 _dstChainId,</span>
  99 |     | <span class='neutral'>        bytes32 _toAddress,</span>
 100 |     | <span class='neutral'>        uint _amount,</span>
 101 |     | <span class='neutral'>        bool _useZro,</span>
 102 |     | <span class='neutral'>        bytes calldata _adapterParams</span>
 103 |     | <span class='unexecuted'>    ) public view virtual override returns (uint nativeFee, uint zroFee) {</span>
 104 |     | <span class='unexecuted'>        (nativeFee, zroFee) = _estimateSendFee(_dstChainId, _toAddress, _amount, _useZro, _adapterParams);</span>
 105 |     | <span class='unexecuted'>        if (address(feeHandler) != address(0)) {</span>
 106 |     | <span class='unexecuted'>            nativeFee += feeHandler.getFee();</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>    function estimateSendAndCallFee(</span>
 111 |     | <span class='neutral'>        uint16 _dstChainId,</span>
 112 |     | <span class='neutral'>        bytes32 _toAddress,</span>
 113 |     | <span class='neutral'>        uint _amount,</span>
 114 |     | <span class='neutral'>        bytes calldata _payload,</span>
 115 |     | <span class='neutral'>        uint64 _dstGasForCall,</span>
 116 |     | <span class='neutral'>        bool _useZro,</span>
 117 |     | <span class='neutral'>        bytes calldata _adapterParams</span>
 118 |     | <span class='unexecuted'>    ) public view virtual override returns (uint nativeFee, uint zroFee) {</span>
 119 |     | <span class='unexecuted'>        (nativeFee, zroFee) = _estimateSendAndCallFee(_dstChainId, _toAddress, _amount, _dstGasForCall, _payload, _useZro, _adapterParams);</span>
 120 |     | <span class='unexecuted'>        if (address(feeHandler) != address(0)) {</span>
 121 |     | <span class='unexecuted'>            nativeFee += feeHandler.getFee();</span>
 122 |     | <span class='neutral'>        }</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    function circulatingSupply() public view virtual override returns (uint);</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function token() public view virtual override returns (address);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>    function setFeeHandler(ILzFeeHandler _feeHandler) public virtual onlyOwner {</span>
 130 |     | <span class='unexecuted'>        emit LogFeeHandlerChanged(feeHandler, _feeHandler);</span>
 131 |     | <span class='unexecuted'>        feeHandler = _feeHandler;</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'>}</span>
 134 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/tokens/LzIndirectOFTV2.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {IERC20} from &quot;BoringSolidity/interfaces/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IMintableBurnable} from &quot;interfaces/IMintableBurnable.sol&quot;;</span>
  7 |     | <span class='neutral'>import {LzBaseOFTV2} from &quot;tokens/LzBaseOFTV2.sol&quot;;</span>
  8 |     | <span class='neutral'>import {SafeERC20} from &quot;openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>contract LzIndirectOFTV2 is LzBaseOFTV2 {</span>
 11 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
 12 |     | <span class='unexecuted'>    IMintableBurnable public immutable minterBurner;</span>
 13 |     | <span class='unexecuted'>    IERC20 public immutable innerToken;</span>
 14 |     | <span class='unexecuted'>    uint public immutable ld2sdRate;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    constructor(</span>
 17 |     | <span class='neutral'>        address _token,</span>
 18 |     | <span class='neutral'>        IMintableBurnable _minterBurner,</span>
 19 |     | <span class='neutral'>        uint8 _sharedDecimals,</span>
 20 |     | <span class='neutral'>        address _lzEndpoint,</span>
 21 |     | <span class='neutral'>        address _owner</span>
 22 |     | <span class='unexecuted'>    ) LzBaseOFTV2(_sharedDecimals, _lzEndpoint, _owner) {</span>
 23 |     | <span class='unexecuted'>        innerToken = IERC20(_token);</span>
 24 |     | <span class='unexecuted'>        minterBurner = _minterBurner;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>        (bool success, bytes memory data) = _token.staticcall(abi.encodeWithSignature(&quot;decimals()&quot;));</span>
 27 |     | <span class='unexecuted'>        require(success, &quot;IndirectOFT: failed to get token decimals&quot;);</span>
 28 |     | <span class='unexecuted'>        uint8 decimals = abi.decode(data, (uint8));</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>        require(_sharedDecimals &lt;= decimals, &quot;IndirectOFT: sharedDecimals must be &lt;= decimals&quot;);</span>
 31 |     | <span class='unexecuted'>        ld2sdRate = 10 ** (decimals - _sharedDecimals);</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /************************************************************************</span>
 35 |     | <span class='neutral'>     * public functions</span>
 36 |     | <span class='neutral'>     ************************************************************************/</span>
 37 |     | <span class='unexecuted'>    function circulatingSupply() public view virtual override returns (uint) {</span>
 38 |     | <span class='unexecuted'>        return innerToken.totalSupply();</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='unexecuted'>    function token() public view virtual override returns (address) {</span>
 42 |     | <span class='unexecuted'>        return address(innerToken);</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    /************************************************************************</span>
 46 |     | <span class='neutral'>     * internal functions</span>
 47 |     | <span class='neutral'>     ************************************************************************/</span>
 48 |     | <span class='unexecuted'>    function _debitFrom(address _from, uint16, bytes32, uint _amount) internal virtual override returns (uint) {</span>
 49 |     | <span class='unexecuted'>        require(_from == msg.sender, &quot;IndirectOFT: owner is not send caller&quot;);</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>        minterBurner.burn(_from, _amount);</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='unexecuted'>        return _amount;</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='unexecuted'>    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns (uint) {</span>
 57 |     | <span class='unexecuted'>        minterBurner.mint(_toAddress, _amount);</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>        return _amount;</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    function _ld2sdRate() internal view virtual override returns (uint) {</span>
 63 |     | <span class='unexecuted'>        return ld2sdRate;</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'>}</span>
 66 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/tokens/LzOFTCoreV2.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {LzNonblockingApp} from &quot;mixins/LzNonblockingApp.sol&quot;;</span>
   5 |     | <span class='neutral'>import {ExcessivelySafeCall} from &quot;ExcessivelySafeCall/ExcessivelySafeCall.sol&quot;;</span>
   6 |     | <span class='neutral'>import {ILzCommonOFT, ILzOFTReceiverV2} from &quot;interfaces/ILayerZero.sol&quot;;</span>
   7 |     | <span class='neutral'>import {BytesLib} from &quot;libraries/BytesLib.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>abstract contract LzOFTCoreV2 is LzNonblockingApp {</span>
  10 |     | <span class='neutral'>    using BytesLib for bytes;</span>
  11 |     | <span class='neutral'>    using ExcessivelySafeCall for address;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>    uint public constant NO_EXTRA_GAS = 0;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    // packet type</span>
  16 |     | <span class='unexecuted'>    uint8 public constant PT_SEND = 0;</span>
  17 |     | <span class='unexecuted'>    uint8 public constant PT_SEND_AND_CALL = 1;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>    uint8 public immutable sharedDecimals;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    bool public useCustomAdapterParams;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /**</span>
  24 |     | <span class='neutral'>     * @dev Emitted when `_amount` tokens are moved from the `_sender` to (`_dstChainId`, `_toAddress`)</span>
  25 |     | <span class='neutral'>     * `_nonce` is the outbound nonce</span>
  26 |     | <span class='neutral'>     */</span>
  27 |     | <span class='neutral'>    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes32 indexed _toAddress, uint _amount);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    /**</span>
  30 |     | <span class='neutral'>     * @dev Emitted when `_amount` tokens are received from `_srcChainId` into the `_toAddress` on the local chain.</span>
  31 |     | <span class='neutral'>     * `_nonce` is the inbound nonce.</span>
  32 |     | <span class='neutral'>     */</span>
  33 |     | <span class='neutral'>    event ReceiveFromChain(uint16 indexed _srcChainId, address indexed _to, uint _amount);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    event SetUseCustomAdapterParams(bool _useCustomAdapterParams);</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    event CallOFTReceivedSuccess(uint16 indexed _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _hash);</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    event NonContractAddress(address _address);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    // _sharedDecimals should be the minimum decimals on all chains</span>
  42 |     | <span class='unexecuted'>    constructor(uint8 _sharedDecimals, address _lzEndpoint, address _owner) LzNonblockingApp(_lzEndpoint, _owner) {</span>
  43 |     | <span class='unexecuted'>        sharedDecimals = _sharedDecimals;</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>    function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {</span>
  47 |     | <span class='unexecuted'>        useCustomAdapterParams = _useCustomAdapterParams;</span>
  48 |     | <span class='unexecuted'>        emit SetUseCustomAdapterParams(_useCustomAdapterParams);</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /************************************************************************</span>
  52 |     | <span class='neutral'>     * internal functions</span>
  53 |     | <span class='neutral'>     ************************************************************************/</span>
  54 |     | <span class='unexecuted'>    function _estimateSendFee(</span>
  55 |     | <span class='neutral'>        uint16 _dstChainId,</span>
  56 |     | <span class='neutral'>        bytes32 _toAddress,</span>
  57 |     | <span class='neutral'>        uint _amount,</span>
  58 |     | <span class='neutral'>        bool _useZro,</span>
  59 |     | <span class='neutral'>        bytes memory _adapterParams</span>
  60 |     | <span class='unexecuted'>    ) internal view virtual returns (uint nativeFee, uint zroFee) {</span>
  61 |     | <span class='neutral'>        // mock the payload for sendFrom()</span>
  62 |     | <span class='unexecuted'>        bytes memory payload = _encodeSendPayload(_toAddress, _ld2sd(_amount));</span>
  63 |     | <span class='unexecuted'>        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>    function _estimateSendAndCallFee(</span>
  67 |     | <span class='neutral'>        uint16 _dstChainId,</span>
  68 |     | <span class='neutral'>        bytes32 _toAddress,</span>
  69 |     | <span class='neutral'>        uint _amount,</span>
  70 |     | <span class='neutral'>        uint64 _dstGasForCall,</span>
  71 |     | <span class='neutral'>        bytes memory _payload,</span>
  72 |     | <span class='neutral'>        bool _useZro,</span>
  73 |     | <span class='neutral'>        bytes memory _adapterParams</span>
  74 |     | <span class='unexecuted'>    ) internal view virtual returns (uint nativeFee, uint zroFee) {</span>
  75 |     | <span class='neutral'>        // mock the payload for sendAndCall()</span>
  76 |     | <span class='unexecuted'>        bytes memory payload = _encodeSendAndCallPayload(msg.sender, _toAddress, _ld2sd(_amount), _payload, _dstGasForCall);</span>
  77 |     | <span class='unexecuted'>        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>    function _nonblockingLzReceive(</span>
  81 |     | <span class='neutral'>        uint16 _srcChainId,</span>
  82 |     | <span class='neutral'>        bytes memory _srcAddress,</span>
  83 |     | <span class='neutral'>        uint64 _nonce,</span>
  84 |     | <span class='neutral'>        bytes memory _payload,</span>
  85 |     | <span class='neutral'>        bool retry</span>
  86 |     | <span class='neutral'>    ) internal virtual override {</span>
  87 |     | <span class='unexecuted'>        uint8 packetType = _payload.toUint8(0);</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>        if (packetType == PT_SEND) {</span>
  90 |     | <span class='unexecuted'>            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);</span>
  91 |     | <span class='unexecuted'>        } else if (packetType == PT_SEND_AND_CALL) {</span>
  92 |     | <span class='unexecuted'>            _sendAndCallAck(_srcChainId, _srcAddress, _nonce, _payload, retry);</span>
  93 |     | <span class='neutral'>        } else {</span>
  94 |     | <span class='unexecuted'>            revert(&quot;OFTCore: unknown packet type&quot;);</span>
  95 |     | <span class='neutral'>        }</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='unexecuted'>    function _send(</span>
  99 |     | <span class='neutral'>        address _from,</span>
 100 |     | <span class='neutral'>        uint16 _dstChainId,</span>
 101 |     | <span class='neutral'>        bytes32 _toAddress,</span>
 102 |     | <span class='neutral'>        uint _amount,</span>
 103 |     | <span class='neutral'>        address payable _refundAddress,</span>
 104 |     | <span class='neutral'>        address _zroPaymentAddress,</span>
 105 |     | <span class='neutral'>        bytes memory _adapterParams,</span>
 106 |     | <span class='neutral'>        uint256 value</span>
 107 |     | <span class='unexecuted'>    ) internal virtual returns (uint amount) {</span>
 108 |     | <span class='unexecuted'>        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, 0);</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>        (amount, ) = _removeDust(_amount);</span>
 111 |     | <span class='unexecuted'>        amount = _debitFrom(_from, _dstChainId, _toAddress, amount); // amount returned should not have dust</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>        bytes memory lzPayload = _encodeSendPayload(_toAddress, _ld2sd(amount));</span>
 114 |     | <span class='unexecuted'>        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, value);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>        emit SendToChain(_dstChainId, _from, _toAddress, amount);</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>    function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {</span>
 120 |     | <span class='unexecuted'>        (address to, uint64 amountSD) = _decodeSendPayload(_payload);</span>
 121 |     | <span class='unexecuted'>        if (to == address(0)) {</span>
 122 |     | <span class='unexecuted'>            to = address(0xdead);</span>
 123 |     | <span class='neutral'>        }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>        uint amount = _sd2ld(amountSD);</span>
 126 |     | <span class='unexecuted'>        amount = _creditTo(_srcChainId, to, amount);</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>        emit ReceiveFromChain(_srcChainId, to, amount);</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>    function _sendAndCall(</span>
 132 |     | <span class='neutral'>        address _from,</span>
 133 |     | <span class='neutral'>        uint16 _dstChainId,</span>
 134 |     | <span class='neutral'>        bytes32 _toAddress,</span>
 135 |     | <span class='neutral'>        uint _amount,</span>
 136 |     | <span class='neutral'>        bytes memory _payload,</span>
 137 |     | <span class='neutral'>        uint64 _dstGasForCall,</span>
 138 |     | <span class='neutral'>        address payable _refundAddress,</span>
 139 |     | <span class='neutral'>        address _zroPaymentAddress,</span>
 140 |     | <span class='neutral'>        bytes memory _adapterParams,</span>
 141 |     | <span class='neutral'>        uint256 value</span>
 142 |     | <span class='unexecuted'>    ) internal virtual returns (uint amount) {</span>
 143 |     | <span class='unexecuted'>        _checkAdapterParams(_dstChainId, PT_SEND_AND_CALL, _adapterParams, _dstGasForCall);</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='unexecuted'>        (amount, ) = _removeDust(_amount);</span>
 146 |     | <span class='unexecuted'>        amount = _debitFrom(_from, _dstChainId, _toAddress, amount);</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>        // encode the msg.sender into the payload instead of _from</span>
 149 |     | <span class='unexecuted'>        bytes memory lzPayload = _encodeSendAndCallPayload(msg.sender, _toAddress, _ld2sd(amount), _payload, _dstGasForCall);</span>
 150 |     | <span class='unexecuted'>        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, value);</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='unexecuted'>        emit SendToChain(_dstChainId, _from, _toAddress, amount);</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>    function _sendAndCallAck(</span>
 156 |     | <span class='neutral'>        uint16 _srcChainId,</span>
 157 |     | <span class='neutral'>        bytes memory _srcAddress,</span>
 158 |     | <span class='neutral'>        uint64 _nonce,</span>
 159 |     | <span class='neutral'>        bytes memory _payload,</span>
 160 |     | <span class='neutral'>        bool retry</span>
 161 |     | <span class='unexecuted'>    ) internal virtual {</span>
 162 |     | <span class='unexecuted'>        bytes32 from;</span>
 163 |     | <span class='unexecuted'>        address to;</span>
 164 |     | <span class='unexecuted'>        uint amount;</span>
 165 |     | <span class='unexecuted'>        uint gas;</span>
 166 |     | <span class='unexecuted'>        bytes memory payloadForCall;</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>        {</span>
 169 |     | <span class='unexecuted'>            uint64 amountSD;</span>
 170 |     | <span class='unexecuted'>            uint64 gasForCall;</span>
 171 |     | <span class='unexecuted'>            (from, to, amountSD, payloadForCall, gasForCall) = _decodeSendAndCallPayload(_payload);</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='unexecuted'>            amount = _sd2ld(amountSD);</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>            // send</span>
 176 |     | <span class='unexecuted'>            amount = _creditTo(_srcChainId, to, amount);</span>
 177 |     | <span class='unexecuted'>            emit ReceiveFromChain(_srcChainId, to, amount);</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='unexecuted'>            gas = retry ? gasleft() : gasForCall;</span>
 180 |     | <span class='neutral'>        }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>        // call, using low level call to not revert on EOA</span>
 183 |     | <span class='unexecuted'>        (bool success, bytes memory result) = address(to).excessivelySafeCall(</span>
 184 |     | <span class='unexecuted'>            gas,</span>
 185 |     | <span class='unexecuted'>            150,</span>
 186 |     | <span class='unexecuted'>            abi.encodeWithSelector(ILzOFTReceiverV2.onOFTReceived.selector, _srcChainId, _srcAddress, _nonce, from, amount, payloadForCall)</span>
 187 |     | <span class='neutral'>        );</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='unexecuted'>        if (success) {</span>
 190 |     | <span class='unexecuted'>            bytes32 hash = keccak256(_payload);</span>
 191 |     | <span class='unexecuted'>            emit CallOFTReceivedSuccess(_srcChainId, _srcAddress, _nonce, hash);</span>
 192 |     | <span class='neutral'>        } else {</span>
 193 |     | <span class='unexecuted'>            if (!success) {</span>
 194 |     | <span class='neutral'>                // If call reverts</span>
 195 |     | <span class='neutral'>                // If there is return data, the call reverted without a reason or a custom error.</span>
 196 |     | <span class='unexecuted'>                if (result.length == 0) revert(&quot;OFTCore: call reverted without a reason&quot;);</span>
 197 |     | <span class='neutral'>                assembly {</span>
 198 |     | <span class='neutral'>                    // We use Yul&#39;s revert() to bubble up errors from the target contract.</span>
 199 |     | <span class='unexecuted'>                    revert(add(32, result), mload(result))</span>
 200 |     | <span class='neutral'>                }</span>
 201 |     | <span class='neutral'>            }</span>
 202 |     | <span class='neutral'>        }</span>
 203 |     | <span class='neutral'>    }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>    function _isContract(address _account) internal view returns (bool) {</span>
 206 |     | <span class='neutral'>        return _account.code.length &gt; 0;</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='unexecuted'>    function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {</span>
 210 |     | <span class='unexecuted'>        if (useCustomAdapterParams) {</span>
 211 |     | <span class='unexecuted'>            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);</span>
 212 |     | <span class='neutral'>        } else {</span>
 213 |     | <span class='unexecuted'>            require(_adapterParams.length == 0, &quot;OFTCore: _adapterParams must be empty.&quot;);</span>
 214 |     | <span class='neutral'>        }</span>
 215 |     | <span class='neutral'>    }</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='unexecuted'>    function _ld2sd(uint _amount) internal view virtual returns (uint64) {</span>
 218 |     | <span class='unexecuted'>        uint amountSD = _amount / _ld2sdRate();</span>
 219 |     | <span class='unexecuted'>        require(amountSD &lt;= type(uint64).max, &quot;OFTCore: amountSD overflow&quot;);</span>
 220 |     | <span class='neutral'>        return uint64(amountSD);</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='unexecuted'>    function _sd2ld(uint64 _amountSD) internal view virtual returns (uint) {</span>
 224 |     | <span class='unexecuted'>        return _amountSD * _ld2sdRate();</span>
 225 |     | <span class='neutral'>    }</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='unexecuted'>    function _removeDust(uint _amount) internal view virtual returns (uint amountAfter, uint dust) {</span>
 228 |     | <span class='unexecuted'>        dust = _amount % _ld2sdRate();</span>
 229 |     | <span class='unexecuted'>        amountAfter = _amount - dust;</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='unexecuted'>    function _encodeSendPayload(bytes32 _toAddress, uint64 _amountSD) internal view virtual returns (bytes memory) {</span>
 233 |     | <span class='unexecuted'>        return abi.encodePacked(PT_SEND, _toAddress, _amountSD);</span>
 234 |     | <span class='neutral'>    }</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='unexecuted'>    function _decodeSendPayload(bytes memory _payload) internal view virtual returns (address to, uint64 amountSD) {</span>
 237 |     | <span class='unexecuted'>        require(_payload.toUint8(0) == PT_SEND &amp;&amp; _payload.length == 41, &quot;OFTCore: invalid payload&quot;);</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='unexecuted'>        to = _payload.toAddress(13); // drop the first 12 bytes of bytes32</span>
 240 |     | <span class='unexecuted'>        amountSD = _payload.toUint64(33);</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='unexecuted'>    function _encodeSendAndCallPayload(</span>
 244 |     | <span class='neutral'>        address _from,</span>
 245 |     | <span class='neutral'>        bytes32 _toAddress,</span>
 246 |     | <span class='neutral'>        uint64 _amountSD,</span>
 247 |     | <span class='neutral'>        bytes memory _payload,</span>
 248 |     | <span class='neutral'>        uint64 _dstGasForCall</span>
 249 |     | <span class='unexecuted'>    ) internal view virtual returns (bytes memory) {</span>
 250 |     | <span class='unexecuted'>        return abi.encodePacked(PT_SEND_AND_CALL, _toAddress, _amountSD, _addressToBytes32(_from), _dstGasForCall, _payload);</span>
 251 |     | <span class='neutral'>    }</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='unexecuted'>    function _decodeSendAndCallPayload(</span>
 254 |     | <span class='neutral'>        bytes memory _payload</span>
 255 |     | <span class='unexecuted'>    ) internal view virtual returns (bytes32 from, address to, uint64 amountSD, bytes memory payload, uint64 dstGasForCall) {</span>
 256 |     | <span class='unexecuted'>        require(_payload.toUint8(0) == PT_SEND_AND_CALL, &quot;OFTCore: invalid payload&quot;);</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='unexecuted'>        to = _payload.toAddress(13); // drop the first 12 bytes of bytes32</span>
 259 |     | <span class='unexecuted'>        amountSD = _payload.toUint64(33);</span>
 260 |     | <span class='unexecuted'>        from = _payload.toBytes32(41);</span>
 261 |     | <span class='unexecuted'>        dstGasForCall = _payload.toUint64(73);</span>
 262 |     | <span class='unexecuted'>        payload = _payload.slice(81, _payload.length - 81);</span>
 263 |     | <span class='neutral'>    }</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>    function _addressToBytes32(address _address) internal pure virtual returns (bytes32) {</span>
 266 |     | <span class='unexecuted'>        return bytes32(uint(uint160(_address)));</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>    function _debitFrom(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount) internal virtual returns (uint);</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns (uint);</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='neutral'>    function _ld2sdRate() internal view virtual returns (uint);</span>
 274 |     | <span class='neutral'>}</span>
 275 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/tokens/LzProxyOFTV2.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {LzBaseOFTV2} from &quot;tokens/LzBaseOFTV2.sol&quot;;</span>
  5 |     | <span class='neutral'>import {SafeERC20, IERC20} from &quot;openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract LzProxyOFTV2 is LzBaseOFTV2 {</span>
  8 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    IERC20 public immutable innerToken;</span>
 11 |     | <span class='unexecuted'>    uint public immutable ld2sdRate;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    constructor(</span>
 14 |     | <span class='neutral'>        address _token,</span>
 15 |     | <span class='neutral'>        uint8 _sharedDecimals,</span>
 16 |     | <span class='neutral'>        address _lzEndpoint,</span>
 17 |     | <span class='neutral'>        address _owner</span>
 18 |     | <span class='unexecuted'>    ) LzBaseOFTV2(_sharedDecimals, _lzEndpoint, _owner) {</span>
 19 |     | <span class='unexecuted'>        innerToken = IERC20(_token);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>        (bool success, bytes memory data) = _token.staticcall(abi.encodeWithSignature(&quot;decimals()&quot;));</span>
 22 |     | <span class='unexecuted'>        require(success, &quot;ProxyOFT: failed to get token decimals&quot;);</span>
 23 |     | <span class='unexecuted'>        uint8 decimals = abi.decode(data, (uint8));</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>        require(_sharedDecimals &lt;= decimals, &quot;ProxyOFT: sharedDecimals must be &lt;= decimals&quot;);</span>
 26 |     | <span class='unexecuted'>        ld2sdRate = 10 ** (decimals - _sharedDecimals);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /************************************************************************</span>
 30 |     | <span class='neutral'>     * public functions</span>
 31 |     | <span class='neutral'>     ************************************************************************/</span>
 32 |     | <span class='unexecuted'>    function circulatingSupply() public view virtual override returns (uint) {</span>
 33 |     | <span class='unexecuted'>        return innerToken.totalSupply() - innerToken.balanceOf(address(this));</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>    function token() public view virtual override returns (address) {</span>
 37 |     | <span class='unexecuted'>        return address(innerToken);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /************************************************************************</span>
 41 |     | <span class='neutral'>     * internal functions</span>
 42 |     | <span class='neutral'>     ************************************************************************/</span>
 43 |     | <span class='unexecuted'>    function _debitFrom(address _from, uint16, bytes32, uint _amount) internal virtual override returns (uint) {</span>
 44 |     | <span class='unexecuted'>        require(_from == msg.sender, &quot;ProxyOFT: owner is not send caller&quot;);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>        innerToken.safeTransferFrom(_from, address(this), _amount);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>        return _amount;</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns (uint) {</span>
 52 |     | <span class='unexecuted'>        innerToken.safeTransfer(_toAddress, _amount);</span>
 53 |     | <span class='unexecuted'>        return _amount;</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    function _ld2sdRate() internal view virtual override returns (uint) {</span>
 57 |     | <span class='unexecuted'>        return ld2sdRate;</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'>}</span>
 60 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/tokens/MagicCurveLp.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ERC20} from &quot;BoringSolidity/ERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Proxy} from &quot;openzeppelin-contracts/proxy/Proxy.sol&quot;;</span>
  6 |     | <span class='neutral'>import {Address} from &quot;openzeppelin-contracts/utils/Address.sol&quot;;</span>
  7 |     | <span class='neutral'>import {ERC4626} from &quot;./ERC4626.sol&quot;;</span>
  8 |     | <span class='neutral'>import {IMagicCurveLpRewardHandler} from &quot;interfaces/IMagicCurveLpRewardHandler.sol&quot;;</span>
  9 |     | <span class='neutral'>import {Operatable} from &quot;mixins/Operatable.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>contract MagicCurveLpData is ERC4626, Operatable {</span>
 12 |     | <span class='neutral'>    error ErrPrivateFunction();</span>
 13 |     | <span class='unexecuted'>    IMagicCurveLpRewardHandler public rewardHandler;</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>contract MagicCurveLp is MagicCurveLpData, Proxy {</span>
 17 |     | <span class='neutral'>    using Address for address;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    event LogRewardHandlerChanged(IMagicCurveLpRewardHandler indexed previous, IMagicCurveLpRewardHandler indexed current);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    constructor(ERC20 __asset, string memory _name, string memory _symbol) {</span>
 22 |     | <span class='unexecuted'>        _asset = __asset;</span>
 23 |     | <span class='unexecuted'>        name = _name;</span>
 24 |     | <span class='unexecuted'>        symbol = _symbol;</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function setRewardHandler(IMagicCurveLpRewardHandler _rewardHandler) external onlyOwner {</span>
 28 |     | <span class='unexecuted'>        emit LogRewardHandlerChanged(rewardHandler, _rewardHandler);</span>
 29 |     | <span class='unexecuted'>        rewardHandler = _rewardHandler;</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    function _afterDeposit(uint256 assets, uint256 /* shares */) internal override {</span>
 33 |     | <span class='unexecuted'>        address(rewardHandler).functionDelegateCall(abi.encodeWithSelector(IMagicCurveLpRewardHandler.stakeAsset.selector, assets));</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>    function _beforeWithdraw(uint256 assets, uint256 /* shares */) internal override {</span>
 37 |     | <span class='unexecuted'>        address(rewardHandler).functionDelegateCall(abi.encodeWithSelector(IMagicCurveLpRewardHandler.unstakeAsset.selector, assets));</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>    function _fallback() internal override {</span>
 41 |     | <span class='unexecuted'>        if (rewardHandler.isPrivateDelegateFunction(msg.sig)) {</span>
 42 |     | <span class='unexecuted'>            revert ErrPrivateFunction();</span>
 43 |     | <span class='neutral'>        }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='unexecuted'>        _delegate(_implementation());</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>    function _implementation() internal view override returns (address) {</span>
 49 |     | <span class='unexecuted'>        return address(rewardHandler);</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'>}</span>
 52 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/tokens/MagicGlp.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ERC20} from &quot;BoringSolidity/ERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {BoringOwnable} from &quot;BoringSolidity/BoringOwnable.sol&quot;;</span>
  6 |     | <span class='neutral'>import {ERC4626} from &quot;tokens/ERC4626.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>contract MagicGlpData is ERC4626, BoringOwnable {</span>
  9 |     | <span class='neutral'>    error ErrNotStrategyExecutor(address);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    address public rewardHandler;</span>
 12 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public strategyExecutors;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    modifier onlyStrategyExecutor() {</span>
 15 |     | <span class='unexecuted'>        if (msg.sender != owner &amp;&amp; !strategyExecutors[msg.sender]) {</span>
 16 |     | <span class='unexecuted'>            revert ErrNotStrategyExecutor(msg.sender);</span>
 17 |     | <span class='neutral'>        }</span>
 18 |     | <span class='neutral'>        _;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>/// @dev Vault version of the GLP Wrapper, auto compound yield increase shares value</span>
 23 |     | <span class='unexecuted'>contract MagicGlp is MagicGlpData {</span>
 24 |     | <span class='neutral'>    event LogRewardHandlerChanged(address indexed previous, address indexed current);</span>
 25 |     | <span class='neutral'>    event LogStrategyExecutorChanged(address indexed executor, bool allowed);</span>
 26 |     | <span class='neutral'>    event LogStakedGlpChanged(ERC20 indexed previous, ERC20 indexed current);</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>    constructor(</span>
 29 |     | <span class='neutral'>        ERC20 __asset,</span>
 30 |     | <span class='neutral'>        string memory _name,</span>
 31 |     | <span class='neutral'>        string memory _symbol</span>
 32 |     | <span class='neutral'>    ) {</span>
 33 |     | <span class='unexecuted'>        _asset = __asset;</span>
 34 |     | <span class='unexecuted'>        name = _name;</span>
 35 |     | <span class='unexecuted'>        symbol = _symbol;</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='unexecuted'>    function setStrategyExecutor(address executor, bool value) external onlyOwner {</span>
 39 |     | <span class='unexecuted'>        strategyExecutors[executor] = value;</span>
 40 |     | <span class='unexecuted'>        emit LogStrategyExecutorChanged(executor, value);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>    function setRewardHandler(address _rewardHandler) external onlyOwner {</span>
 44 |     | <span class='unexecuted'>        emit LogRewardHandlerChanged(rewardHandler, _rewardHandler);</span>
 45 |     | <span class='unexecuted'>        rewardHandler = _rewardHandler;</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>    function setStakedGlp(ERC20 _sGlp) external onlyOwner {</span>
 49 |     | <span class='unexecuted'>        emit LogStakedGlpChanged(_asset, _sGlp);</span>
 50 |     | <span class='unexecuted'>        _asset = _sGlp;</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    // Forward unknown function calls to the reward handler.</span>
 54 |     | <span class='neutral'>    fallback() external {</span>
 55 |     | <span class='unexecuted'>        _delegate(rewardHandler);</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    /**</span>
 59 |     | <span class='neutral'>     * From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Proxy.sol</span>
 60 |     | <span class='neutral'>     *</span>
 61 |     | <span class='neutral'>     * @dev Delegates the current call to `implementation`.</span>
 62 |     | <span class='neutral'>     *</span>
 63 |     | <span class='neutral'>     * This function does not return to its internal call site, it will return directly to the external caller.</span>
 64 |     | <span class='neutral'>     */</span>
 65 |     | <span class='unexecuted'>    function _delegate(address implementation) private {</span>
 66 |     | <span class='neutral'>        assembly {</span>
 67 |     | <span class='neutral'>            // Copy msg.data. We take full control of memory in this inline assembly</span>
 68 |     | <span class='neutral'>            // block because it will not return to Solidity code. We overwrite the</span>
 69 |     | <span class='neutral'>            // Solidity scratch pad at memory position 0.</span>
 70 |     | <span class='unexecuted'>            calldatacopy(0, 0, calldatasize())</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>            // Call the implementation.</span>
 73 |     | <span class='neutral'>            // out and outsize are 0 because we don&#39;t know the size yet.</span>
 74 |     | <span class='unexecuted'>            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>            // Copy the returned data.</span>
 77 |     | <span class='unexecuted'>            returndatacopy(0, 0, returndatasize())</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='unexecuted'>            switch result</span>
 80 |     | <span class='neutral'>            // delegatecall returns 0 on error.</span>
 81 |     | <span class='unexecuted'>            case 0 {</span>
 82 |     | <span class='unexecuted'>                revert(0, returndatasize())</span>
 83 |     | <span class='neutral'>            }</span>
 84 |     | <span class='neutral'>            default {</span>
 85 |     | <span class='unexecuted'>                return(0, returndatasize())</span>
 86 |     | <span class='neutral'>            }</span>
 87 |     | <span class='neutral'>        }</span>
 88 |     | <span class='neutral'>    }</span>
 89 |     | <span class='neutral'>}</span>
 90 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/tokens/MintableBurnableERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ERC20} from &quot;solmate/tokens/ERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {OperatableV2} from &quot;mixins/OperatableV2.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IMintableBurnable} from &quot;interfaces/IMintableBurnable.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/// @title MintableBurnableERC20</span>
  9 |     | <span class='neutral'>/// @notice MintableBurnableERC20 is an ERC20 token with mint, burn functions.</span>
 10 |     | <span class='neutral'>/// In this context, operators are allowed minters and burners.</span>
 11 |     | <span class='unexecuted'>contract MintableBurnableERC20 is ERC20, OperatableV2, IMintableBurnable {</span>
 12 |     | <span class='unexecuted'>    constructor(</span>
 13 |     | <span class='neutral'>        address _owner,</span>
 14 |     | <span class='neutral'>        string memory name_,</span>
 15 |     | <span class='neutral'>        string memory symbol_,</span>
 16 |     | <span class='neutral'>        uint8 decimals_</span>
 17 |     | <span class='unexecuted'>    ) ERC20(name_, symbol_, decimals_) OperatableV2(_owner) {}</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function burn(address from, uint256 amount) external onlyOperators returns (bool) {</span>
 20 |     | <span class='unexecuted'>        _burn(from, amount);</span>
 21 |     | <span class='neutral'>        return true;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    function mint(address to, uint256 amount) external onlyOperators returns (bool) {</span>
 25 |     | <span class='unexecuted'>        _mint(to, amount);</span>
 26 |     | <span class='unexecuted'>        return true;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>}</span>

</code>
<br />

