/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/BoringBatchable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | // solhint-disable avoid-low-level-calls
  4 |     | // solhint-disable no-inline-assembly
  5 |     | 
  6 |     | // WARNING!!!
  7 |     | // Combining BoringBatchable with msg.value can cause double spending issues
  8 |     | // https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/
  9 |     | 
 10 |     | import {IERC20} from "./interfaces/IERC20.sol";
 11 |     | 
 12 |     | contract BaseBoringBatchable {
 13 |     |     error BatchError(bytes innerError);
 14 |     | 
 15 |     |     /// @dev Helper function to extract a useful revert message from a failed call.
 16 |     |     /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.
 17 |     |     function _getRevertMsg(bytes memory _returnData) internal pure{
 18 |     |         // If the _res length is less than 68, then
 19 |     |         // the transaction failed with custom error or silently (without a revert message)
 20 |     |         if (_returnData.length < 68) revert BatchError(_returnData);
 21 |     | 
 22 |     |         assembly {
 23 |     |             // Slice the sighash.
 24 |     |             _returnData := add(_returnData, 0x04)
 25 |     |         }
 26 |     |         revert(abi.decode(_returnData, (string))); // All that remains is the revert string
 27 |     |     }
 28 |     | 
 29 |     |     /// @notice Allows batched call to self (this contract).
 30 |     |     /// @param calls An array of inputs for each call.
 31 |     |     /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.
 32 |     |     // F1: External is ok here because this is the batch function, adding it to a batch makes no sense
 33 |     |     // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value
 34 |     |     // C3: The length of the loop is fully under user control, so can't be exploited
 35 |     |     // C7: Delegatecall is only used on the same contract, so it's safe
 36 |     |     function batch(bytes[] calldata calls, bool revertOnFail) external payable {
 37 |     |         for (uint256 i = 0; i < calls.length; i++) {
 38 |     |             (bool success, bytes memory result) = address(this).delegatecall(calls[i]);
 39 |     |             if (!success && revertOnFail) {
 40 |     |                 _getRevertMsg(result);
 41 |     |             }
 42 |     |         }
 43 |     |     }
 44 |     | }
 45 |     | 
 46 |     | contract BoringBatchable is BaseBoringBatchable {
 47 |     |     /// @notice Call wrapper that performs `ERC20.permit` on `token`.
 48 |     |     /// Lookup `IERC20.permit`.
 49 |     |     // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)
 50 |     |     //     if part of a batch this could be used to grief once as the second call would not need the permit
 51 |     |     function permitToken(
 52 |     |         IERC20 token,
 53 |     |         address from,
 54 |     |         address to,
 55 |     |         uint256 amount,
 56 |     |         uint256 deadline,
 57 |     |         uint8 v,
 58 |     |         bytes32 r,
 59 |     |         bytes32 s
 60 |     |     ) public {
 61 |     |         token.permit(from, to, amount, deadline, v, r, s);
 62 |     |     }
 63 |     | }
 64 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/BoringFactory.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | import {IMasterContract} from "./interfaces/IMasterContract.sol";
  4 |     | 
  5 |     | // solhint-disable no-inline-assembly
  6 |     | 
  7 |     | contract BoringFactory {
  8 |     |     event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);
  9 |     | 
 10 |     |     /// @notice Mapping from clone contracts to their masterContract.
 11 |     |     mapping(address => address) public masterContractOf;
 12 |     | 
 13 |     |     /// @notice Mapping from masterContract to an array of all clones
 14 |     |     /// On mainnet events can be used to get this list, but events aren't always easy to retrieve and
 15 |     |     /// barely work on sidechains. While this adds gas, it makes enumerating all clones much easier.
 16 |     |     mapping(address => address[]) public clonesOf;
 17 |     | 
 18 |     |     /// @notice Returns the count of clones that exists for a specific masterContract
 19 |     |     /// @param masterContract The address of the master contract.
 20 |     |     /// @return cloneCount total number of clones for the masterContract.
 21 |     |     function clonesOfCount(address masterContract) public view returns (uint256 cloneCount) {
 22 |     |         cloneCount = clonesOf[masterContract].length;
 23 |     |     }
 24 |     | 
 25 |     |     /// @notice Deploys a given master Contract as a clone.
 26 |     |     /// Any ETH transferred with this call is forwarded to the new clone.
 27 |     |     /// Emits `LogDeploy`.
 28 |     |     /// @param masterContract The address of the contract to clone.
 29 |     |     /// @param data Additional abi encoded calldata that is passed to the new clone via `IMasterContract.init`.
 30 |     |     /// @param useCreate2 Creates the clone by using the CREATE2 opcode, in this case `data` will be used as salt.
 31 |     |     /// @return cloneAddress Address of the created clone contract.
 32 |     |     function deploy(
 33 |     |         address masterContract,
 34 |     |         bytes calldata data,
 35 |     |         bool useCreate2
 36 |     |     ) public payable returns (address cloneAddress) {
 37 |     |         require(masterContract != address(0), "BoringFactory: No masterContract");
 38 |     |         bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address
 39 |     | 
 40 |     |         if (useCreate2) {
 41 |     |             // each masterContract has different code already. So clones are distinguished by their data only.
 42 |     |             bytes32 salt = keccak256(data);
 43 |     | 
 44 |     |             // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/
 45 |     |             assembly {
 46 |     |                 let clone := mload(0x40)
 47 |     |                 mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
 48 |     |                 mstore(add(clone, 0x14), targetBytes)
 49 |     |                 mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
 50 |     |                 cloneAddress := create2(0, clone, 0x37, salt)
 51 |     |             }
 52 |     |         } else {
 53 |     |             assembly {
 54 |     |                 let clone := mload(0x40)
 55 |     |                 mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
 56 |     |                 mstore(add(clone, 0x14), targetBytes)
 57 |     |                 mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
 58 |     |                 cloneAddress := create(0, clone, 0x37)
 59 |     |             }
 60 |     |         }
 61 |     |         masterContractOf[cloneAddress] = masterContract;
 62 |     |         clonesOf[masterContract].push(cloneAddress);
 63 |     | 
 64 |     |         IMasterContract(cloneAddress).init{value: msg.value}(data);
 65 |     | 
 66 |     |         emit LogDeploy(masterContract, data, cloneAddress);
 67 |     |     }
 68 |     | }
 69 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/BoringOwnable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | // Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol
  5 |     | // Simplified by BoringCrypto
  6 |     | 
  7 |     | contract BoringOwnableData {
  8 |     |     address public owner;
  9 |     |     address public pendingOwner;
 10 |     | }
 11 |     | 
 12 |     | contract BoringOwnable is BoringOwnableData {
 13 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
 14 |     | 
 15 |     |     /// @notice `owner` defaults to msg.sender on construction.
 16 |     |     constructor() {
 17 |     |         owner = msg.sender;
 18 |     |         emit OwnershipTransferred(address(0), msg.sender);
 19 |     |     }
 20 |     | 
 21 |     |     /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.
 22 |     |     /// Can only be invoked by the current `owner`.
 23 |     |     /// @param newOwner Address of the new owner.
 24 |     |     /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.
 25 |     |     /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.
 26 |     |     function transferOwnership(
 27 |     |         address newOwner,
 28 |     |         bool direct,
 29 |     |         bool renounce
 30 |     |     ) public onlyOwner {
 31 |     |         if (direct) {
 32 |     |             // Checks
 33 |     |             require(newOwner != address(0) || renounce, "Ownable: zero address");
 34 |     | 
 35 |     |             // Effects
 36 |     |             emit OwnershipTransferred(owner, newOwner);
 37 |     |             owner = newOwner;
 38 |     |             pendingOwner = address(0);
 39 |     |         } else {
 40 |     |             // Effects
 41 |     |             pendingOwner = newOwner;
 42 |     |         }
 43 |     |     }
 44 |     | 
 45 |     |     /// @notice Needs to be called by `pendingOwner` to claim ownership.
 46 |     |     function claimOwnership() public {
 47 |     |         address _pendingOwner = pendingOwner;
 48 |     | 
 49 |     |         // Checks
 50 |     |         require(msg.sender == _pendingOwner, "Ownable: caller != pending owner");
 51 |     | 
 52 |     |         // Effects
 53 |     |         emit OwnershipTransferred(owner, _pendingOwner);
 54 |     |         owner = _pendingOwner;
 55 |     |         pendingOwner = address(0);
 56 |     |     }
 57 |     | 
 58 |     |     /// @notice Only allows the `owner` to execute the function.
 59 |     |     modifier onlyOwner() {
 60 |     |         require(msg.sender == owner, "Ownable: caller is not the owner");
 61 |     |         _;
 62 |     |     }
 63 |     | }
 64 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/Domain.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // Based on code and smartness by Ross Campbell and Keno
  3 |     | // Uses immutable to store the domain separator to reduce gas usage
  4 |     | // If the chain id changes due to a fork, the forked chain will calculate on the fly.
  5 |     | pragma solidity ^0.8.0;
  6 |     | 
  7 |     | // solhint-disable no-inline-assembly
  8 |     | 
  9 |     | contract Domain {
 10 |     |     bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256("EIP712Domain(uint256 chainId,address verifyingContract)");
 11 |     |     // See https://eips.ethereum.org/EIPS/eip-191
 12 |     |     string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = "\x19\x01";
 13 |     | 
 14 |     |     // solhint-disable var-name-mixedcase
 15 |     |     bytes32 private immutable _DOMAIN_SEPARATOR;
 16 |     |     uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;
 17 |     | 
 18 |     |     /// @dev Calculate the DOMAIN_SEPARATOR
 19 |     |     function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {
 20 |     |         return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, chainId, address(this)));
 21 |     |     }
 22 |     | 
 23 |     |     constructor() {
 24 |     |         _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = block.chainid);
 25 |     |     }
 26 |     | 
 27 |     |     /// @dev Return the DOMAIN_SEPARATOR
 28 |     |     // It's named internal to allow making it public from the contract that uses it by creating a simple view function
 29 |     |     // with the desired public name, such as DOMAIN_SEPARATOR or domainSeparator.
 30 |     |     // solhint-disable-next-line func-name-mixedcase
 31 |     |     function _domainSeparator() internal view returns (bytes32) {
 32 |     |         return block.chainid == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid);
 33 |     |     }
 34 |     | 
 35 |     |     function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {
 36 |     |         digest = keccak256(abi.encodePacked(EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA, _domainSeparator(), dataHash));
 37 |     |     }
 38 |     | }
 39 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | import {IERC20} from "./interfaces/IERC20.sol";
   4 |     | import {Domain} from "./Domain.sol";
   5 |     | 
   6 |     | // solhint-disable no-inline-assembly
   7 |     | // solhint-disable not-rely-on-time
   8 |     | 
   9 |     | // Data part taken out for building of contracts that receive delegate calls
  10 |     | contract ERC20Data {
  11 |     |     /// @notice owner > balance mapping.
  12 |     |     mapping(address => uint256) public balanceOf;
  13 |     |     /// @notice owner > spender > allowance mapping.
  14 |     |     mapping(address => mapping(address => uint256)) public allowance;
  15 |     |     /// @notice owner > nonce mapping. Used in `permit`.
  16 |     |     mapping(address => uint256) public nonces;
  17 |     | }
  18 |     | 
  19 |     | abstract contract ERC20 is IERC20, Domain {
  20 |     |     /// @notice owner > balance mapping.
  21 |     |     mapping(address => uint256) public override balanceOf;
  22 |     |     /// @notice owner > spender > allowance mapping.
  23 |     |     mapping(address => mapping(address => uint256)) public override allowance;
  24 |     |     /// @notice owner > nonce mapping. Used in `permit`.
  25 |     |     mapping(address => uint256) public nonces;
  26 |     | 
  27 |     |     /// @notice Transfers `amount` tokens from `msg.sender` to `to`.
  28 |     |     /// @param to The address to move the tokens.
  29 |     |     /// @param amount of the tokens to move.
  30 |     |     /// @return (bool) Returns True if succeeded.
  31 |     |     function transfer(address to, uint256 amount) public returns (bool) {
  32 |     |         // If `amount` is 0, or `msg.sender` is `to` nothing happens
  33 |     |         if (amount != 0 || msg.sender == to) {
  34 |     |             uint256 srcBalance = balanceOf[msg.sender];
  35 |     |             require(srcBalance >= amount, "ERC20: balance too low");
  36 |     |             if (msg.sender != to) {
  37 |     |                 require(to != address(0), "ERC20: no zero address"); // Moved down so low balance calls safe some gas
  38 |     | 
  39 |     |                 balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked
  40 |     |                 balanceOf[to] += amount;
  41 |     |             }
  42 |     |         }
  43 |     |         emit Transfer(msg.sender, to, amount);
  44 |     |         return true;
  45 |     |     }
  46 |     | 
  47 |     |     /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.
  48 |     |     /// @param from Address to draw tokens from.
  49 |     |     /// @param to The address to move the tokens.
  50 |     |     /// @param amount The token amount to move.
  51 |     |     /// @return (bool) Returns True if succeeded.
  52 |     |     function transferFrom(
  53 |     |         address from,
  54 |     |         address to,
  55 |     |         uint256 amount
  56 |     |     ) public returns (bool) {
  57 |     |         // If `amount` is 0, or `from` is `to` nothing happens
  58 |     |         if (amount != 0) {
  59 |     |             uint256 srcBalance = balanceOf[from];
  60 |     |             require(srcBalance >= amount, "ERC20: balance too low");
  61 |     | 
  62 |     |             if (from != to) {
  63 |     |                 uint256 spenderAllowance = allowance[from][msg.sender];
  64 |     |                 // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).
  65 |     |                 if (spenderAllowance != type(uint256).max) {
  66 |     |                     require(spenderAllowance >= amount, "ERC20: allowance too low");
  67 |     |                     allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked
  68 |     |                 }
  69 |     |                 require(to != address(0), "ERC20: no zero address"); // Moved down so other failed calls safe some gas
  70 |     | 
  71 |     |                 balanceOf[from] = srcBalance - amount; // Underflow is checked
  72 |     |                 balanceOf[to] += amount;
  73 |     |             }
  74 |     |         }
  75 |     |         emit Transfer(from, to, amount);
  76 |     |         return true;
  77 |     |     }
  78 |     | 
  79 |     |     /// @notice Approves `amount` from sender to be spend by `spender`.
  80 |     |     /// @param spender Address of the party that can draw from msg.sender's account.
  81 |     |     /// @param amount The maximum collective amount that `spender` can draw.
  82 |     |     /// @return (bool) Returns True if approved.
  83 |     |     function approve(address spender, uint256 amount) public override returns (bool) {
  84 |     |         allowance[msg.sender][spender] = amount;
  85 |     |         emit Approval(msg.sender, spender, amount);
  86 |     |         return true;
  87 |     |     }
  88 |     | 
  89 |     |     // solhint-disable-next-line func-name-mixedcase
  90 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32) {
  91 |     |         return _domainSeparator();
  92 |     |     }
  93 |     | 
  94 |     |     // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
  95 |     |     bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
  96 |     | 
  97 |     |     /// @notice Approves `value` from `owner_` to be spend by `spender`.
  98 |     |     /// @param owner_ Address of the owner.
  99 |     |     /// @param spender The address of the spender that gets approved to draw from `owner_`.
 100 |     |     /// @param value The maximum collective amount that `spender` can draw.
 101 |     |     /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).
 102 |     |     function permit(
 103 |     |         address owner_,
 104 |     |         address spender,
 105 |     |         uint256 value,
 106 |     |         uint256 deadline,
 107 |     |         uint8 v,
 108 |     |         bytes32 r,
 109 |     |         bytes32 s
 110 |     |     ) external override {
 111 |     |         require(owner_ != address(0), "ERC20: Owner cannot be 0");
 112 |     |         require(block.timestamp < deadline, "ERC20: Expired");
 113 |     |         require(
 114 |     |             ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==
 115 |     |                 owner_,
 116 |     |             "ERC20: Invalid Signature"
 117 |     |         );
 118 |     |         allowance[owner_][spender] = value;
 119 |     |         emit Approval(owner_, spender, value);
 120 |     |     }
 121 |     | }
 122 |     | 
 123 |     | contract ERC20WithSupply is IERC20, ERC20 {
 124 |     |     uint256 public override totalSupply;
 125 |     | 
 126 |     |     function _mint(address user, uint256 amount) internal {
 127 |     |         uint256 newTotalSupply = totalSupply + amount;
 128 |     |         require(newTotalSupply >= totalSupply, "Mint overflow");
 129 |     |         totalSupply = newTotalSupply;
 130 |     |         balanceOf[user] += amount;
 131 |     |         emit Transfer(address(0), user, amount);
 132 |     |     }
 133 |     | 
 134 |     |     function _burn(address user, uint256 amount) internal {
 135 |     |         require(balanceOf[user] >= amount, "Burn too much");
 136 |     |         totalSupply -= amount;
 137 |     |         balanceOf[user] -= amount;
 138 |     |         emit Transfer(user, address(0), amount);
 139 |     |     }
 140 |     | }
 141 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/interfaces/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IERC20 {
  5 |     |     // transfer and tranferFrom have been removed, because they don't work on all tokens (some aren't ERC20 complaint).
  6 |     |     // By removing them you can't accidentally use them.
  7 |     |     // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).
  8 |     |     // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.
  9 |     |     function totalSupply() external view returns (uint256);
 10 |     | 
 11 |     |     function balanceOf(address account) external view returns (uint256);
 12 |     | 
 13 |     |     function allowance(address owner, address spender) external view returns (uint256);
 14 |     | 
 15 |     |     function approve(address spender, uint256 amount) external returns (bool);
 16 |     | 
 17 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 18 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 19 |     | 
 20 |     |     /// @notice EIP 2612
 21 |     |     function permit(
 22 |     |         address owner,
 23 |     |         address spender,
 24 |     |         uint256 value,
 25 |     |         uint256 deadline,
 26 |     |         uint8 v,
 27 |     |         bytes32 r,
 28 |     |         bytes32 s
 29 |     |     ) external;
 30 |     | }
 31 |     | 
 32 |     | interface IStrictERC20 {
 33 |     |     // This is the strict ERC20 interface. Don't use this, certainly not if you don't control the ERC20 token you're calling.
 34 |     |     function name() external view returns (string memory);
 35 |     |     function symbol() external view returns (string memory);
 36 |     |     function decimals() external view returns (uint8);
 37 |     |     function totalSupply() external view returns (uint256);
 38 |     |     function balanceOf(address _owner) external view returns (uint256 balance);
 39 |     |     function transfer(address _to, uint256 _value) external returns (bool success);
 40 |     |     function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
 41 |     |     function approve(address _spender, uint256 _value) external returns (bool success);
 42 |     |     function allowance(address _owner, address _spender) external view returns (uint256 remaining);
 43 |     | 
 44 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 45 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 46 |     | 
 47 |     |     /// @notice EIP 2612
 48 |     |     function permit(
 49 |     |         address owner,
 50 |     |         address spender,
 51 |     |         uint256 value,
 52 |     |         uint256 deadline,
 53 |     |         uint8 v,
 54 |     |         bytes32 r,
 55 |     |         bytes32 s
 56 |     |     ) external;
 57 |     | }
 58 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/interfaces/IMasterContract.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IMasterContract {
  5 |     |     /// @notice Init function that gets called from `BoringFactory.deploy`.
  6 |     |     /// Also kown as the constructor for cloned contracts.
  7 |     |     /// Any ETH send to `BoringFactory.deploy` ends up here.
  8 |     |     /// @param data Can be abi encoded arguments or anything else.
  9 |     |     function init(bytes calldata data) external payable;
 10 |     | }
 11 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/libraries/BoringERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | import {IERC20} from "../interfaces/IERC20.sol";
   4 |     | 
   5 |     | // solhint-disable avoid-low-level-calls
   6 |     | 
   7 |     | library BoringERC20 {
   8 |     |     bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()
   9 |     |     bytes4 private constant SIG_NAME = 0x06fdde03; // name()
  10 |     |     bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()
  11 |     |     bytes4 private constant SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)
  12 |     |     bytes4 private constant SIG_TOTALSUPPLY = 0x18160ddd; // balanceOf(address)
  13 |     |     bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)
  14 |     |     bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)
  15 |     | 
  16 |     |     function returnDataToString(bytes memory data) internal pure returns (string memory) {
  17 |     |         if (data.length >= 64) {
  18 |     |             return abi.decode(data, (string));
  19 |     |         } else if (data.length == 32) {
  20 |     |             uint8 i = 0;
  21 |     |             while (i < 32 && data[i] != 0) {
  22 |     |                 i++;
  23 |     |             }
  24 |     |             bytes memory bytesArray = new bytes(i);
  25 |     |             for (i = 0; i < 32 && data[i] != 0; i++) {
  26 |     |                 bytesArray[i] = data[i];
  27 |     |             }
  28 |     |             return string(bytesArray);
  29 |     |         } else {
  30 |     |             return "???";
  31 |     |         }
  32 |     |     }
  33 |     | 
  34 |     |     /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.
  35 |     |     /// @param token The address of the ERC-20 token contract.
  36 |     |     /// @return (string) Token symbol.
  37 |     |     function safeSymbol(IERC20 token) internal view returns (string memory) {
  38 |     |         (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));
  39 |     |         return success ? returnDataToString(data) : "???";
  40 |     |     }
  41 |     | 
  42 |     |     /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.
  43 |     |     /// @param token The address of the ERC-20 token contract.
  44 |     |     /// @return (string) Token name.
  45 |     |     function safeName(IERC20 token) internal view returns (string memory) {
  46 |     |         (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));
  47 |     |         return success ? returnDataToString(data) : "???";
  48 |     |     }
  49 |     | 
  50 |     |     /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.
  51 |     |     /// @param token The address of the ERC-20 token contract.
  52 |     |     /// @return (uint8) Token decimals.
  53 |     |     function safeDecimals(IERC20 token) internal view returns (uint8) {
  54 |     |         (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));
  55 |     |         return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;
  56 |     |     }
  57 |     | 
  58 |     |     /// @notice Provides a gas-optimized balance check to avoid a redundant extcodesize check in addition to the returndatasize check.
  59 |     |     /// @param token The address of the ERC-20 token.
  60 |     |     /// @param to The address of the user to check.
  61 |     |     /// @return amount The token amount.
  62 |     |     function safeBalanceOf(IERC20 token, address to) internal view returns (uint256 amount) {
  63 |     |         (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_BALANCE_OF, to));
  64 |     |         require(success && data.length >= 32, "BoringERC20: BalanceOf failed");
  65 |     |         amount = abi.decode(data, (uint256));
  66 |     |     }
  67 |     | 
  68 |     |     /// @notice Provides a gas-optimized totalSupply to avoid a redundant extcodesize check in addition to the returndatasize check.
  69 |     |     /// @param token The address of the ERC-20 token.
  70 |     |     /// @return totalSupply The token totalSupply.
  71 |     |     function safeTotalSupply(IERC20 token) internal view returns (uint256 totalSupply) {
  72 |     |         (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_TOTALSUPPLY));
  73 |     |         require(success && data.length >= 32, "BoringERC20: totalSupply failed");
  74 |     |         totalSupply = abi.decode(data, (uint256));
  75 |     |     }
  76 |     | 
  77 |     |     /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.
  78 |     |     /// Reverts on a failed transfer.
  79 |     |     /// @param token The address of the ERC-20 token.
  80 |     |     /// @param to Transfer tokens to.
  81 |     |     /// @param amount The token amount.
  82 |     |     function safeTransfer(
  83 |     |         IERC20 token,
  84 |     |         address to,
  85 |     |         uint256 amount
  86 |     |     ) internal {
  87 |     |         (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));
  88 |     |         require(success && (data.length == 0 || abi.decode(data, (bool))), "BoringERC20: Transfer failed");
  89 |     |     }
  90 |     | 
  91 |     |     /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.
  92 |     |     /// Reverts on a failed transfer.
  93 |     |     /// @param token The address of the ERC-20 token.
  94 |     |     /// @param from Transfer tokens from.
  95 |     |     /// @param to Transfer tokens to.
  96 |     |     /// @param amount The token amount.
  97 |     |     function safeTransferFrom(
  98 |     |         IERC20 token,
  99 |     |         address from,
 100 |     |         address to,
 101 |     |         uint256 amount
 102 |     |     ) internal {
 103 |     |         (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));
 104 |     |         require(success && (data.length == 0 || abi.decode(data, (bool))), "BoringERC20: TransferFrom failed");
 105 |     |     }
 106 |     | }
 107 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/libraries/BoringMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | library BoringMath {
   5 |     |     error ErrOverflow();
   6 |     | 
   7 |     |     function add(uint256 a, uint256 b) internal pure returns (uint256) {
   8 |     |         return a + b;
   9 |     |     }
  10 |     | 
  11 |     |     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
  12 |     |         return a - b;
  13 |     |     }
  14 |     | 
  15 |     |     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
  16 |     |         return a * b;
  17 |     |     }
  18 |     | 
  19 |     |     function div(uint256 a, uint256 b) internal pure returns (uint256) {
  20 |     |         return a / b;
  21 |     |     }
  22 |     | 
  23 |     |     function to32(uint256 a) internal pure returns (uint32) {
  24 |     |         if (a > type(uint32).max) {
  25 |     |             revert ErrOverflow();
  26 |     |         }
  27 |     |         return uint32(a);
  28 |     |     }
  29 |     | 
  30 |     |     function to40(uint256 a) internal pure returns (uint40) {
  31 |     |         if (a > type(uint40).max) {
  32 |     |             revert ErrOverflow();
  33 |     |         }
  34 |     |         return uint40(a);
  35 |     |     }
  36 |     | 
  37 |     |     function to64(uint256 a) internal pure returns (uint64) {
  38 |     |         if (a > type(uint64).max) {
  39 |     |             revert ErrOverflow();
  40 |     |         }
  41 |     |         return uint64(a);
  42 |     |     }
  43 |     | 
  44 |     |     function to112(uint256 a) internal pure returns (uint112) {
  45 |     |         if (a > type(uint112).max) {
  46 |     |             revert ErrOverflow();
  47 |     |         }
  48 |     |         return uint112(a);
  49 |     |     }
  50 |     | 
  51 |     |     function to128(uint256 a) internal pure returns (uint128) {
  52 |     |         if (a > type(uint128).max) {
  53 |     |             revert ErrOverflow();
  54 |     |         }
  55 |     |         return uint128(a);
  56 |     |     }
  57 |     | 
  58 |     |     function to208(uint256 a) internal pure returns (uint208) {
  59 |     |         if (a > type(uint208).max) {
  60 |     |             revert ErrOverflow();
  61 |     |         }
  62 |     |         return uint208(a);
  63 |     |     }
  64 |     | 
  65 |     |     function to216(uint256 a) internal pure returns (uint216) {
  66 |     |         if (a > type(uint216).max) {
  67 |     |             revert ErrOverflow();
  68 |     |         }
  69 |     |         return uint216(a);
  70 |     |     }
  71 |     | 
  72 |     |     function to224(uint256 a) internal pure returns (uint224) {
  73 |     |         if (a > type(uint224).max) {
  74 |     |             revert ErrOverflow();
  75 |     |         }
  76 |     |         return uint224(a);
  77 |     |     }
  78 |     | }
  79 |     | 
  80 |     | library BoringMath32 {
  81 |     |     function add(uint32 a, uint32 b) internal pure returns (uint32) {
  82 |     |         return a + b;
  83 |     |     }
  84 |     | 
  85 |     |     function sub(uint32 a, uint32 b) internal pure returns (uint32) {
  86 |     |         return a - b;
  87 |     |     }
  88 |     | 
  89 |     |     function mul(uint32 a, uint32 b) internal pure returns (uint32) {
  90 |     |         return a * b;
  91 |     |     }
  92 |     | 
  93 |     |     function div(uint32 a, uint32 b) internal pure returns (uint32) {
  94 |     |         return a / b;
  95 |     |     }
  96 |     | }
  97 |     | 
  98 |     | library BoringMath64 {
  99 |     |     function add(uint64 a, uint64 b) internal pure returns (uint64) {
 100 |     |         return a + b;
 101 |     |     }
 102 |     | 
 103 |     |     function sub(uint64 a, uint64 b) internal pure returns (uint64) {
 104 |     |         return a - b;
 105 |     |     }
 106 |     | 
 107 |     |     function mul(uint64 a, uint64 b) internal pure returns (uint64) {
 108 |     |         return a * b;
 109 |     |     }
 110 |     | 
 111 |     |     function div(uint64 a, uint64 b) internal pure returns (uint64) {
 112 |     |         return a / b;
 113 |     |     }
 114 |     | }
 115 |     | 
 116 |     | library BoringMath112 {
 117 |     |     function add(uint112 a, uint112 b) internal pure returns (uint112) {
 118 |     |         return a + b;
 119 |     |     }
 120 |     | 
 121 |     |     function sub(uint112 a, uint112 b) internal pure returns (uint112) {
 122 |     |         return a - b;
 123 |     |     }
 124 |     | 
 125 |     |     function mul(uint112 a, uint112 b) internal pure returns (uint112) {
 126 |     |         return a * b;
 127 |     |     }
 128 |     | 
 129 |     |     function div(uint112 a, uint112 b) internal pure returns (uint112) {
 130 |     |         return a / b;
 131 |     |     }
 132 |     | }
 133 |     | 
 134 |     | library BoringMath128 {
 135 |     |     function add(uint128 a, uint128 b) internal pure returns (uint128) {
 136 |     |         return a + b;
 137 |     |     }
 138 |     | 
 139 |     |     function sub(uint128 a, uint128 b) internal pure returns (uint128) {
 140 |     |         return a - b;
 141 |     |     }
 142 |     | 
 143 |     |     function mul(uint128 a, uint128 b) internal pure returns (uint128) {
 144 |     |         return a * b;
 145 |     |     }
 146 |     | 
 147 |     |     function div(uint128 a, uint128 b) internal pure returns (uint128) {
 148 |     |         return a / b;
 149 |     |     }
 150 |     | }
 151 |     | 
 152 |     | library BoringMath224 {
 153 |     |     function add(uint224 a, uint224 b) internal pure returns (uint224) {
 154 |     |         return a + b;
 155 |     |     }
 156 |     | 
 157 |     |     function sub(uint224 a, uint224 b) internal pure returns (uint224) {
 158 |     |         return a - b;
 159 |     |     }
 160 |     | 
 161 |     |     function mul(uint224 a, uint224 b) internal pure returns (uint224) {
 162 |     |         return a * b;
 163 |     |     }
 164 |     | 
 165 |     |     function div(uint224 a, uint224 b) internal pure returns (uint224) {
 166 |     |         return a / b;
 167 |     |     }
 168 |     | }
 169 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/BoringSolidity/contracts/libraries/BoringRebase.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | import {BoringMath, BoringMath128} from "./BoringMath.sol";
   4 |     | 
   5 |     | struct Rebase {
   6 |     |     uint128 elastic;
   7 |     |     uint128 base;
   8 |     | }
   9 |     | 
  10 |     | /// @notice A rebasing library using overflow-/underflow-safe math.
  11 |     | library RebaseLibrary {
  12 |     |     using BoringMath for uint256;
  13 |     |     using BoringMath128 for uint128;
  14 |     | 
  15 |     |     /// @notice Calculates the base value in relationship to `elastic` and `total`.
  16 |     |     function toBase(
  17 |     |         Rebase memory total,
  18 |     |         uint256 elastic,
  19 |     |         bool roundUp
  20 |     |     ) internal pure returns (uint256 base) {
  21 |     |         if (total.elastic == 0) {
  22 |     |             base = elastic;
  23 |     |         } else {
  24 |     |             base = (elastic * total.base) / total.elastic;
  25 |     |             if (roundUp && (base * total.elastic) / total.base < elastic) {
  26 |     |                 base++;
  27 |     |             }
  28 |     |         }
  29 |     |     }
  30 |     | 
  31 |     |     /// @notice Calculates the elastic value in relationship to `base` and `total`.
  32 |     |     function toElastic(
  33 |     |         Rebase memory total,
  34 |     |         uint256 base,
  35 |     |         bool roundUp
  36 |     |     ) internal pure returns (uint256 elastic) {
  37 |     |         if (total.base == 0) {
  38 |     |             elastic = base;
  39 |     |         } else {
  40 |     |             elastic = (base * total.elastic) / total.base;
  41 |     |             if (roundUp && (elastic * total.base) / total.elastic < base) {
  42 |     |                 elastic++;
  43 |     |             }
  44 |     |         }
  45 |     |     }
  46 |     | 
  47 |     |     /// @notice Add `elastic` to `total` and doubles `total.base`.
  48 |     |     /// @return (Rebase) The new total.
  49 |     |     /// @return base in relationship to `elastic`.
  50 |     |     function add(
  51 |     |         Rebase memory total,
  52 |     |         uint256 elastic,
  53 |     |         bool roundUp
  54 |     |     ) internal pure returns (Rebase memory, uint256 base) {
  55 |     |         base = toBase(total, elastic, roundUp);
  56 |     |         total.elastic += elastic.to128();
  57 |     |         total.base += base.to128();
  58 |     |         return (total, base);
  59 |     |     }
  60 |     | 
  61 |     |     /// @notice Sub `base` from `total` and update `total.elastic`.
  62 |     |     /// @return (Rebase) The new total.
  63 |     |     /// @return elastic in relationship to `base`.
  64 |     |     function sub(
  65 |     |         Rebase memory total,
  66 |     |         uint256 base,
  67 |     |         bool roundUp
  68 |     |     ) internal pure returns (Rebase memory, uint256 elastic) {
  69 |     |         elastic = toElastic(total, base, roundUp);
  70 |     |         total.elastic -= elastic.to128();
  71 |     |         total.base -= base.to128();
  72 |     |         return (total, elastic);
  73 |     |     }
  74 |     | 
  75 |     |     /// @notice Add `elastic` and `base` to `total`.
  76 |     |     function add(
  77 |     |         Rebase memory total,
  78 |     |         uint256 elastic,
  79 |     |         uint256 base
  80 |     |     ) internal pure returns (Rebase memory) {
  81 |     |         total.elastic += elastic.to128();
  82 |     |         total.base += base.to128();
  83 |     |         return total;
  84 |     |     }
  85 |     | 
  86 |     |     /// @notice Subtract `elastic` and `base` to `total`.
  87 |     |     function sub(
  88 |     |         Rebase memory total,
  89 |     |         uint256 elastic,
  90 |     |         uint256 base
  91 |     |     ) internal pure returns (Rebase memory) {
  92 |     |         total.elastic -= elastic.to128();
  93 |     |         total.base -= base.to128();
  94 |     |         return total;
  95 |     |     }
  96 |     | 
  97 |     |     /// @notice Add `elastic` to `total` and update storage.
  98 |     |     /// @return newElastic Returns updated `elastic`.
  99 |     |     function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {
 100 |     |         newElastic = total.elastic += elastic.to128();
 101 |     |     }
 102 |     | 
 103 |     |     /// @notice Subtract `elastic` from `total` and update storage.
 104 |     |     /// @return newElastic Returns updated `elastic`.
 105 |     |     function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {
 106 |     |         newElastic = total.elastic -= elastic.to128();
 107 |     |     }
 108 |     | }
 109 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/ExcessivelySafeCall/src/ExcessivelySafeCall.sol
   1 |     | // SPDX-License-Identifier: MIT OR Apache-2.0
   2 |     | pragma solidity >=0.7.6;
   3 |     | 
   4 |     | library ExcessivelySafeCall {
   5 |     |     uint256 constant LOW_28_MASK =
   6 |     |         0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
   7 |     | 
   8 |     |     /// @notice Use when you _really_ really _really_ don't trust the called
   9 |     |     /// contract. This prevents the called contract from causing reversion of
  10 |     |     /// the caller in as many ways as we can.
  11 |     |     /// @dev The main difference between this and a solidity low-level call is
  12 |     |     /// that we limit the number of bytes that the callee can cause to be
  13 |     |     /// copied to caller memory. This prevents stupid things like malicious
  14 |     |     /// contracts returning 10,000,000 bytes causing a local OOG when copying
  15 |     |     /// to memory.
  16 |     |     /// @param _target The address to call
  17 |     |     /// @param _gas The amount of gas to forward to the remote contract
  18 |     |     /// @param _maxCopy The maximum number of bytes of returndata to copy
  19 |     |     /// to memory.
  20 |     |     /// @param _calldata The data to send to the remote contract
  21 |     |     /// @return success and returndata, as `.call()`. Returndata is capped to
  22 |     |     /// `_maxCopy` bytes.
  23 |     |     function excessivelySafeCall(
  24 |     |         address _target,
  25 |     |         uint256 _gas,
  26 |     |         uint16 _maxCopy,
  27 |     |         bytes memory _calldata
  28 |     |     ) internal returns (bool, bytes memory) {
  29 |     |         // set up for assembly call
  30 |     |         uint256 _toCopy;
  31 |     |         bool _success;
  32 |     |         bytes memory _returnData = new bytes(_maxCopy);
  33 |     |         // dispatch message to recipient
  34 |     |         // by assembly calling "handle" function
  35 |     |         // we call via assembly to avoid memcopying a very large returndata
  36 |     |         // returned by a malicious contract
  37 |     |         assembly {
  38 |     |             _success := call(
  39 |     |                 _gas, // gas
  40 |     |                 _target, // recipient
  41 |     |                 0, // ether value
  42 |     |                 add(_calldata, 0x20), // inloc
  43 |     |                 mload(_calldata), // inlen
  44 |     |                 0, // outloc
  45 |     |                 0 // outlen
  46 |     |             )
  47 |     |             // limit our copy to 256 bytes
  48 |     |             _toCopy := returndatasize()
  49 |     |             if gt(_toCopy, _maxCopy) {
  50 |     |                 _toCopy := _maxCopy
  51 |     |             }
  52 |     |             // Store the length of the copied bytes
  53 |     |             mstore(_returnData, _toCopy)
  54 |     |             // copy the bytes from returndata[0:_toCopy]
  55 |     |             returndatacopy(add(_returnData, 0x20), 0, _toCopy)
  56 |     |         }
  57 |     |         return (_success, _returnData);
  58 |     |     }
  59 |     | 
  60 |     |     /// @notice Use when you _really_ really _really_ don't trust the called
  61 |     |     /// contract. This prevents the called contract from causing reversion of
  62 |     |     /// the caller in as many ways as we can.
  63 |     |     /// @dev The main difference between this and a solidity low-level call is
  64 |     |     /// that we limit the number of bytes that the callee can cause to be
  65 |     |     /// copied to caller memory. This prevents stupid things like malicious
  66 |     |     /// contracts returning 10,000,000 bytes causing a local OOG when copying
  67 |     |     /// to memory.
  68 |     |     /// @param _target The address to call
  69 |     |     /// @param _gas The amount of gas to forward to the remote contract
  70 |     |     /// @param _maxCopy The maximum number of bytes of returndata to copy
  71 |     |     /// to memory.
  72 |     |     /// @param _calldata The data to send to the remote contract
  73 |     |     /// @return success and returndata, as `.call()`. Returndata is capped to
  74 |     |     /// `_maxCopy` bytes.
  75 |     |     function excessivelySafeStaticCall(
  76 |     |         address _target,
  77 |     |         uint256 _gas,
  78 |     |         uint16 _maxCopy,
  79 |     |         bytes memory _calldata
  80 |     |     ) internal view returns (bool, bytes memory) {
  81 |     |         // set up for assembly call
  82 |     |         uint256 _toCopy;
  83 |     |         bool _success;
  84 |     |         bytes memory _returnData = new bytes(_maxCopy);
  85 |     |         // dispatch message to recipient
  86 |     |         // by assembly calling "handle" function
  87 |     |         // we call via assembly to avoid memcopying a very large returndata
  88 |     |         // returned by a malicious contract
  89 |     |         assembly {
  90 |     |             _success := staticcall(
  91 |     |                 _gas, // gas
  92 |     |                 _target, // recipient
  93 |     |                 add(_calldata, 0x20), // inloc
  94 |     |                 mload(_calldata), // inlen
  95 |     |                 0, // outloc
  96 |     |                 0 // outlen
  97 |     |             )
  98 |     |             // limit our copy to 256 bytes
  99 |     |             _toCopy := returndatasize()
 100 |     |             if gt(_toCopy, _maxCopy) {
 101 |     |                 _toCopy := _maxCopy
 102 |     |             }
 103 |     |             // Store the length of the copied bytes
 104 |     |             mstore(_returnData, _toCopy)
 105 |     |             // copy the bytes from returndata[0:_toCopy]
 106 |     |             returndatacopy(add(_returnData, 0x20), 0, _toCopy)
 107 |     |         }
 108 |     |         return (_success, _returnData);
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @notice Swaps function selectors in encoded contract calls
 113 |     |      * @dev Allows reuse of encoded calldata for functions with identical
 114 |     |      * argument types but different names. It simply swaps out the first 4 bytes
 115 |     |      * for the new selector. This function modifies memory in place, and should
 116 |     |      * only be used with caution.
 117 |     |      * @param _newSelector The new 4-byte selector
 118 |     |      * @param _buf The encoded contract args
 119 |     |      */
 120 |     |     function swapSelector(bytes4 _newSelector, bytes memory _buf)
 121 |     |         internal
 122 |     |         pure
 123 |     |     {
 124 |     |         require(_buf.length >= 4);
 125 |     |         uint256 _mask = LOW_28_MASK;
 126 |     |         assembly {
 127 |     |             // load the first word of
 128 |     |             let _word := mload(add(_buf, 0x20))
 129 |     |             // mask out the top 4 bytes
 130 |     |             // /x
 131 |     |             _word := and(_word, _mask)
 132 |     |             _word := or(_newSelector, _word)
 133 |     |             mstore(add(_buf, 0x20), _word)
 134 |     |         }
 135 |     |     }
 136 |     | }
 137 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/AssertHelper.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./FuzzLibString.sol";
   5 |     | 
   6 |     | /// @author Based on Crytic PropertiesHelper (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)
   7 |     | abstract contract AssertHelper {
   8 |     |     event AssertFail(string);
   9 |     |     event AssertEqFail(string);
  10 |     |     event AssertNeqFail(string);
  11 |     |     event AssertGteFail(string);
  12 |     |     event AssertGtFail(string);
  13 |     |     event AssertLteFail(string);
  14 |     |     event AssertLtFail(string);
  15 |     | 
  16 | *   |     function assertWithMsg(bool b, string memory reason) internal {
  17 | *   |         if (!b) {
  18 | *   |             emit AssertFail(reason);
  19 | *   |             assert(false);
  20 |     |         }
  21 |     |     }
  22 |     | 
  23 |     |     /// @notice asserts that a is equal to b. Violations are logged using reason.
  24 | *   |     function assertEq(
  25 |     |         uint256 a,
  26 |     |         uint256 b,
  27 |     |         string memory reason
  28 |     |     ) internal {
  29 | *   |         if (a != b) {
  30 |     |             string memory aStr = FuzzLibString.toString(a);
  31 |     |             string memory bStr = FuzzLibString.toString(b);
  32 |     |             bytes memory assertMsg = abi.encodePacked(
  33 |     |                 "Invalid: ",
  34 |     |                 aStr,
  35 |     |                 "!=",
  36 |     |                 bStr,
  37 |     |                 ", reason: ",
  38 |     |                 reason
  39 |     |             );
  40 |     |             emit AssertEqFail(string(assertMsg));
  41 |     |             assert(false);
  42 |     |         }
  43 |     |     }
  44 |     | 
  45 |     |     /// @notice int256 version of assertEq
  46 |     |     function assertEq(
  47 |     |         int256 a,
  48 |     |         int256 b,
  49 |     |         string memory reason
  50 |     |     ) internal {
  51 |     |         if (a != b) {
  52 |     |             string memory aStr = FuzzLibString.toString(a);
  53 |     |             string memory bStr = FuzzLibString.toString(b);
  54 |     |             bytes memory assertMsg = abi.encodePacked(
  55 |     |                 "Invalid: ",
  56 |     |                 aStr,
  57 |     |                 "!=",
  58 |     |                 bStr,
  59 |     |                 ", reason: ",
  60 |     |                 reason
  61 |     |             );
  62 |     |             emit AssertEqFail(string(assertMsg));
  63 |     |             assert(false);
  64 |     |         }
  65 |     |     }
  66 |     | 
  67 |     |     /// @notice bytes4 version of assertEq
  68 |     |     function assertEq(
  69 |     |         bytes4 a,
  70 |     |         bytes4 b,
  71 |     |         string memory reason
  72 |     |     ) internal {
  73 |     |         if (a != b) {
  74 |     |             bytes memory aBytes = abi.encodePacked(a);
  75 |     |             bytes memory bBytes = abi.encodePacked(b);
  76 |     |             string memory aStr = FuzzLibString.toHexString(aBytes);
  77 |     |             string memory bStr = FuzzLibString.toHexString(bBytes);
  78 |     |             bytes memory assertMsg = abi.encodePacked(
  79 |     |                 "Invalid: ",
  80 |     |                 aStr,
  81 |     |                 "!=",
  82 |     |                 bStr,
  83 |     |                 ", reason: ",
  84 |     |                 reason
  85 |     |             );
  86 |     |             emit AssertEqFail(string(assertMsg));
  87 |     |             assert(false);
  88 |     |         }
  89 |     |     }
  90 |     | 
  91 |     |     /// @notice asserts that a is not equal to b. Violations are logged using reason.
  92 |     |     function assertNeq(
  93 |     |         uint256 a,
  94 |     |         uint256 b,
  95 |     |         string memory reason
  96 |     |     ) internal {
  97 |     |         if (a == b) {
  98 |     |             string memory aStr = FuzzLibString.toString(a);
  99 |     |             string memory bStr = FuzzLibString.toString(b);
 100 |     |             bytes memory assertMsg = abi.encodePacked(
 101 |     |                 "Invalid: ",
 102 |     |                 aStr,
 103 |     |                 "==",
 104 |     |                 bStr,
 105 |     |                 ", reason: ",
 106 |     |                 reason
 107 |     |             );
 108 |     |             emit AssertNeqFail(string(assertMsg));
 109 |     |             assert(false);
 110 |     |         }
 111 |     |     }
 112 |     | 
 113 |     |     /// @notice int256 version of assertNeq
 114 |     |     function assertNeq(
 115 |     |         int256 a,
 116 |     |         int256 b,
 117 |     |         string memory reason
 118 |     |     ) internal {
 119 |     |         if (a == b) {
 120 |     |             string memory aStr = FuzzLibString.toString(a);
 121 |     |             string memory bStr = FuzzLibString.toString(b);
 122 |     |             bytes memory assertMsg = abi.encodePacked(
 123 |     |                 "Invalid: ",
 124 |     |                 aStr,
 125 |     |                 "==",
 126 |     |                 bStr,
 127 |     |                 ", reason: ",
 128 |     |                 reason
 129 |     |             );
 130 |     |             emit AssertNeqFail(string(assertMsg));
 131 |     |             assert(false);
 132 |     |         }
 133 |     |     }
 134 |     | 
 135 |     |     /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.
 136 | *   |     function assertGte(
 137 |     |         uint256 a,
 138 |     |         uint256 b,
 139 |     |         string memory reason
 140 |     |     ) internal {
 141 | *   |         if (!(a >= b)) {
 142 |     |             string memory aStr = FuzzLibString.toString(a);
 143 |     |             string memory bStr = FuzzLibString.toString(b);
 144 |     |             bytes memory assertMsg = abi.encodePacked(
 145 |     |                 "Invalid: ",
 146 |     |                 aStr,
 147 |     |                 "<",
 148 |     |                 bStr,
 149 |     |                 " failed, reason: ",
 150 |     |                 reason
 151 |     |             );
 152 |     |             emit AssertGteFail(string(assertMsg));
 153 |     |             assert(false);
 154 |     |         }
 155 |     |     }
 156 |     | 
 157 |     |     /// @notice int256 version of assertGte
 158 |     |     function assertGte(
 159 |     |         int256 a,
 160 |     |         int256 b,
 161 |     |         string memory reason
 162 |     |     ) internal {
 163 |     |         if (!(a >= b)) {
 164 |     |             string memory aStr = FuzzLibString.toString(a);
 165 |     |             string memory bStr = FuzzLibString.toString(b);
 166 |     |             bytes memory assertMsg = abi.encodePacked(
 167 |     |                 "Invalid: ",
 168 |     |                 aStr,
 169 |     |                 "<",
 170 |     |                 bStr,
 171 |     |                 " failed, reason: ",
 172 |     |                 reason
 173 |     |             );
 174 |     |             emit AssertGteFail(string(assertMsg));
 175 |     |             assert(false);
 176 |     |         }
 177 |     |     }
 178 |     | 
 179 |     |     /// @notice asserts that a is greater than b. Violations are logged using reason.
 180 | *   |     function assertGt(
 181 |     |         uint256 a,
 182 |     |         uint256 b,
 183 |     |         string memory reason
 184 |     |     ) internal {
 185 | *   |         if (!(a > b)) {
 186 |     |             string memory aStr = FuzzLibString.toString(a);
 187 |     |             string memory bStr = FuzzLibString.toString(b);
 188 |     |             bytes memory assertMsg = abi.encodePacked(
 189 |     |                 "Invalid: ",
 190 |     |                 aStr,
 191 |     |                 "<=",
 192 |     |                 bStr,
 193 |     |                 " failed, reason: ",
 194 |     |                 reason
 195 |     |             );
 196 |     |             emit AssertGtFail(string(assertMsg));
 197 |     |             assert(false);
 198 |     |         }
 199 |     |     }
 200 |     | 
 201 |     |     /// @notice int256 version of assertGt
 202 |     |     function assertGt(
 203 |     |         int256 a,
 204 |     |         int256 b,
 205 |     |         string memory reason
 206 |     |     ) internal {
 207 |     |         if (!(a > b)) {
 208 |     |             string memory aStr = FuzzLibString.toString(a);
 209 |     |             string memory bStr = FuzzLibString.toString(b);
 210 |     |             bytes memory assertMsg = abi.encodePacked(
 211 |     |                 "Invalid: ",
 212 |     |                 aStr,
 213 |     |                 "<=",
 214 |     |                 bStr,
 215 |     |                 " failed, reason: ",
 216 |     |                 reason
 217 |     |             );
 218 |     |             emit AssertGtFail(string(assertMsg));
 219 |     |             assert(false);
 220 |     |         }
 221 |     |     }
 222 |     | 
 223 |     |     /// @notice asserts that a is less than or equal to b. Violations are logged using reason.
 224 | *   |     function assertLte(
 225 |     |         uint256 a,
 226 |     |         uint256 b,
 227 |     |         string memory reason
 228 |     |     ) internal {
 229 | *   |         if (!(a <= b)) {
 230 |     |             string memory aStr = FuzzLibString.toString(a);
 231 |     |             string memory bStr = FuzzLibString.toString(b);
 232 |     |             bytes memory assertMsg = abi.encodePacked(
 233 |     |                 "Invalid: ",
 234 |     |                 aStr,
 235 |     |                 ">",
 236 |     |                 bStr,
 237 |     |                 " failed, reason: ",
 238 |     |                 reason
 239 |     |             );
 240 |     |             emit AssertLteFail(string(assertMsg));
 241 |     |             assert(false);
 242 |     |         }
 243 |     |     }
 244 |     | 
 245 |     |     /// @notice int256 version of assertLte
 246 |     |     function assertLte(
 247 |     |         int256 a,
 248 |     |         int256 b,
 249 |     |         string memory reason
 250 |     |     ) internal {
 251 |     |         if (!(a <= b)) {
 252 |     |             string memory aStr = FuzzLibString.toString(a);
 253 |     |             string memory bStr = FuzzLibString.toString(b);
 254 |     |             bytes memory assertMsg = abi.encodePacked(
 255 |     |                 "Invalid: ",
 256 |     |                 aStr,
 257 |     |                 ">",
 258 |     |                 bStr,
 259 |     |                 " failed, reason: ",
 260 |     |                 reason
 261 |     |             );
 262 |     |             emit AssertLteFail(string(assertMsg));
 263 |     |             assert(false);
 264 |     |         }
 265 |     |     }
 266 |     | 
 267 |     |     /// @notice asserts that a is less than b. Violations are logged using reason.
 268 | *   |     function assertLt(
 269 |     |         uint256 a,
 270 |     |         uint256 b,
 271 |     |         string memory reason
 272 |     |     ) internal {
 273 | *   |         if (!(a < b)) {
 274 |     |             string memory aStr = FuzzLibString.toString(a);
 275 |     |             string memory bStr = FuzzLibString.toString(b);
 276 |     |             bytes memory assertMsg = abi.encodePacked(
 277 |     |                 "Invalid: ",
 278 |     |                 aStr,
 279 |     |                 ">=",
 280 |     |                 bStr,
 281 |     |                 " failed, reason: ",
 282 |     |                 reason
 283 |     |             );
 284 |     |             emit AssertLtFail(string(assertMsg));
 285 |     |             assert(false);
 286 |     |         }
 287 |     |     }
 288 |     | 
 289 |     |     /// @notice int256 version of assertLt
 290 |     |     function assertLt(
 291 |     |         int256 a,
 292 |     |         int256 b,
 293 |     |         string memory reason
 294 |     |     ) internal {
 295 |     |         if (!(a < b)) {
 296 |     |             string memory aStr = FuzzLibString.toString(a);
 297 |     |             string memory bStr = FuzzLibString.toString(b);
 298 |     |             bytes memory assertMsg = abi.encodePacked(
 299 |     |                 "Invalid: ",
 300 |     |                 aStr,
 301 |     |                 ">=",
 302 |     |                 bStr,
 303 |     |                 " failed, reason: ",
 304 |     |                 reason
 305 |     |             );
 306 |     |             emit AssertLtFail(string(assertMsg));
 307 |     |             assert(false);
 308 |     |         }
 309 |     |     }
 310 |     | 
 311 |     |     function assertRevertReasonNotEqual(
 312 |     |         bytes memory returnData,
 313 |     |         string memory reason
 314 |     |     ) internal {
 315 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason);
 316 |     |         assertWithMsg(!isEqual, reason);
 317 |     |     }
 318 |     | 
 319 |     |     function assertRevertReasonEqual(
 320 |     |         bytes memory returnData,
 321 |     |         string memory reason
 322 |     |     ) internal {
 323 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason);
 324 |     |         assertWithMsg(isEqual, reason);
 325 |     |     }
 326 |     | 
 327 |     |     function assertRevertReasonEqual(
 328 |     |         bytes memory returnData,
 329 |     |         string memory reason1,
 330 |     |         string memory reason2
 331 |     |     ) internal {
 332 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||
 333 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason2);
 334 |     |         assertWithMsg(isEqual, string.concat(reason1, " OR ", reason2));
 335 |     |     }
 336 |     | 
 337 |     |     function assertRevertReasonEqual(
 338 |     |         bytes memory returnData,
 339 |     |         string memory reason1,
 340 |     |         string memory reason2,
 341 |     |         string memory reason3
 342 |     |     ) internal {
 343 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||
 344 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason2) ||
 345 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason3);
 346 |     |         assertWithMsg(isEqual, string.concat(reason1, " OR ", reason2, " OR ", reason3));
 347 |     |     }
 348 |     | 
 349 |     |     function assertRevertReasonEqual(
 350 |     |         bytes memory returnData,
 351 |     |         string memory reason1,
 352 |     |         string memory reason2,
 353 |     |         string memory reason3,
 354 |     |         string memory reason4
 355 |     |     ) internal {
 356 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||
 357 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason2) ||
 358 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason3) ||
 359 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason4);
 360 |     |         assertWithMsg(
 361 |     |             isEqual,
 362 |     |             string.concat(
 363 |     |                 reason1,
 364 |     |                 " OR ",
 365 |     |                 reason2,
 366 |     |                 " OR ",
 367 |     |                 reason3,
 368 |     |                 " OR ",
 369 |     |                 reason4
 370 |     |             )
 371 |     |         );
 372 |     |     }
 373 |     | }
 374 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/AssertWrapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./AssertHelper.sol";
  5 |     | 
  6 |     | abstract contract AssertWrapper is AssertHelper {
  7 | *   |     function gt(uint256 a, uint256 b, string memory message) internal {
  8 | *   |         assertGt(a, b, message);
  9 |     |     }
 10 |     | 
 11 | *   |     function lt(uint256 a, uint256 b, string memory message) internal {
 12 | *   |         assertLt(a, b, message);
 13 |     |     }
 14 |     | 
 15 | *   |     function gte(uint256 a, uint256 b, string memory message) internal {
 16 | *   |         assertGte(a, b, message);
 17 |     |     }
 18 |     | 
 19 | *   |     function lte(uint256 a, uint256 b, string memory message) internal {
 20 | *   |         assertLte(a, b, message);
 21 |     |     }
 22 |     | 
 23 | *   |     function eq(uint256 a, uint256 b, string memory message) internal {
 24 | *   |         assertEq(a, b, message);
 25 |     |     }
 26 |     | 
 27 |     |     function neq(uint256 a, uint256 b, string memory message) internal {
 28 |     |         assertNeq(a, b, message);
 29 |     |     }
 30 |     | 
 31 | *   |     function t(bool a, string memory message) internal {
 32 | *   |         assertWithMsg(a, message);
 33 |     |     }
 34 |     | }
 35 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/ClampHelper.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./FuzzLibString.sol";
   5 |     | import "./AssertHelper.sol";
   6 |     | 
   7 |     | /// @author Based on Crytic PropertiesHelper (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)
   8 |     | abstract contract ClampHelper is AssertHelper {
   9 |     |     event Clamped(string);
  10 |     | 
  11 |     |     /// @notice Clamps value to be between low and high, both inclusive
  12 | *   |     function clampBetween(
  13 |     |         uint256 value,
  14 |     |         uint256 low,
  15 |     |         uint256 high,
  16 |     |         bool enableLogs
  17 | *   |     ) internal returns (uint256) {
  18 | *   |         if (value < low || value > high) {
  19 | *   |             uint256 ans = low + (value % (high - low + 1));
  20 | *   |             if (enableLogs) {
  21 | *   |                 string memory valueStr = FuzzLibString.toString(value);
  22 | *   |                 string memory ansStr = FuzzLibString.toString(ans);
  23 | *   |                 bytes memory message = abi.encodePacked(
  24 |     |                     "Clamping value ",
  25 | *   |                     valueStr,
  26 |     |                     " to ",
  27 | *   |                     ansStr
  28 |     |                 );
  29 | *   |                 emit Clamped(string(message));
  30 |     |             }
  31 | *   |             return ans;
  32 |     |         }
  33 | *   |         return value;
  34 |     |     }
  35 |     | 
  36 |     |     /// @notice int256 version of clampBetween
  37 |     |     function clampBetween(
  38 |     |         int256 value,
  39 |     |         int256 low,
  40 |     |         int256 high,
  41 |     |         bool enableLogs
  42 |     |     ) internal returns (int256) {
  43 |     |         if (value < low || value > high) {
  44 |     |             int256 range = high - low + 1;
  45 |     |             int256 clamped = (value - low) % (range);
  46 |     |             if (clamped < 0) clamped += range;
  47 |     |             int256 ans = low + clamped;
  48 |     |             if (enableLogs) {
  49 |     |                 string memory valueStr = FuzzLibString.toString(value);
  50 |     |                 string memory ansStr = FuzzLibString.toString(ans);
  51 |     |                 bytes memory message = abi.encodePacked(
  52 |     |                     "Clamping value ",
  53 |     |                     valueStr,
  54 |     |                     " to ",
  55 |     |                     ansStr
  56 |     |                 );
  57 |     |                 emit Clamped(string(message));
  58 |     |             }
  59 |     |             return ans;
  60 |     |         }
  61 |     |         return value;
  62 |     |     }
  63 |     | 
  64 |     |     /// @notice clamps a to be less than b
  65 |     |     function clampLt(uint256 a, uint256 b, bool enableLogs) internal returns (uint256) {
  66 |     |         if (!(a < b)) {
  67 |     |             assertNeq(
  68 |     |                 b,
  69 |     |                 0,
  70 |     |                 "clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions."
  71 |     |             );
  72 |     |             uint256 value = a % b;
  73 |     |             if (enableLogs) {
  74 |     |                 string memory aStr = FuzzLibString.toString(a);
  75 |     |                 string memory valueStr = FuzzLibString.toString(value);
  76 |     |                 bytes memory message = abi.encodePacked(
  77 |     |                     "Clamping value ",
  78 |     |                     aStr,
  79 |     |                     " to ",
  80 |     |                     valueStr
  81 |     |                 );
  82 |     |                 emit Clamped(string(message));
  83 |     |             }
  84 |     |             return value;
  85 |     |         }
  86 |     |         return a;
  87 |     |     }
  88 |     | 
  89 |     |     /// @notice int256 version of clampLt
  90 |     |     function clampLt(int256 a, int256 b, bool enableLogs) internal returns (int256) {
  91 |     |         if (!(a < b)) {
  92 |     |             int256 value = b - 1;
  93 |     |             if (enableLogs) {
  94 |     |                 string memory aStr = FuzzLibString.toString(a);
  95 |     |                 string memory valueStr = FuzzLibString.toString(value);
  96 |     |                 bytes memory message = abi.encodePacked(
  97 |     |                     "Clamping value ",
  98 |     |                     aStr,
  99 |     |                     " to ",
 100 |     |                     valueStr
 101 |     |                 );
 102 |     |                 emit Clamped(string(message));
 103 |     |             }
 104 |     |             return value;
 105 |     |         }
 106 |     |         return a;
 107 |     |     }
 108 |     | 
 109 |     |     /// @notice clamps a to be less than or equal to b
 110 |     |     function clampLte(uint256 a, uint256 b, bool enableLogs) internal returns (uint256) {
 111 |     |         if (!(a <= b)) {
 112 |     |             uint256 value = a % (b + 1);
 113 |     |             if (enableLogs) {
 114 |     |                 string memory aStr = FuzzLibString.toString(a);
 115 |     |                 string memory valueStr = FuzzLibString.toString(value);
 116 |     |                 bytes memory message = abi.encodePacked(
 117 |     |                     "Clamping value ",
 118 |     |                     aStr,
 119 |     |                     " to ",
 120 |     |                     valueStr
 121 |     |                 );
 122 |     |                 emit Clamped(string(message));
 123 |     |             }
 124 |     |             return value;
 125 |     |         }
 126 |     |         return a;
 127 |     |     }
 128 |     | 
 129 |     |     /// @notice int256 version of clampLte
 130 |     |     function clampLte(int256 a, int256 b, bool enableLogs) internal returns (int256) {
 131 |     |         if (!(a <= b)) {
 132 |     |             int256 value = b;
 133 |     |             if (enableLogs) {
 134 |     |                 string memory aStr = FuzzLibString.toString(a);
 135 |     |                 string memory valueStr = FuzzLibString.toString(value);
 136 |     |                 bytes memory message = abi.encodePacked(
 137 |     |                     "Clamping value ",
 138 |     |                     aStr,
 139 |     |                     " to ",
 140 |     |                     valueStr
 141 |     |                 );
 142 |     |                 emit Clamped(string(message));
 143 |     |             }
 144 |     |             return value;
 145 |     |         }
 146 |     |         return a;
 147 |     |     }
 148 |     | 
 149 |     |     /// @notice clamps a to be greater than b
 150 |     |     function clampGt(uint256 a, uint256 b, bool enableLogs) internal returns (uint256) {
 151 |     |         if (!(a > b)) {
 152 |     |             assertNeq(
 153 |     |                 b,
 154 |     |                 type(uint256).max,
 155 |     |                 "clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions."
 156 |     |             );
 157 |     |             uint256 value = b + 1;
 158 |     |             if (enableLogs) {
 159 |     |                 string memory aStr = FuzzLibString.toString(a);
 160 |     |                 string memory valueStr = FuzzLibString.toString(value);
 161 |     |                 bytes memory message = abi.encodePacked(
 162 |     |                     "Clamping value ",
 163 |     |                     aStr,
 164 |     |                     " to ",
 165 |     |                     valueStr
 166 |     |                 );
 167 |     |                 emit Clamped(string(message));
 168 |     |             }
 169 |     |             return value;
 170 |     |         } else {
 171 |     |             return a;
 172 |     |         }
 173 |     |     }
 174 |     | 
 175 |     |     /// @notice int256 version of clampGt
 176 |     |     function clampGt(int256 a, int256 b, bool enableLogs) internal returns (int256) {
 177 |     |         if (!(a > b)) {
 178 |     |             int256 value = b + 1;
 179 |     |             if (enableLogs) {
 180 |     |                 string memory aStr = FuzzLibString.toString(a);
 181 |     |                 string memory valueStr = FuzzLibString.toString(value);
 182 |     |                 bytes memory message = abi.encodePacked(
 183 |     |                     "Clamping value ",
 184 |     |                     aStr,
 185 |     |                     " to ",
 186 |     |                     valueStr
 187 |     |                 );
 188 |     |                 emit Clamped(string(message));
 189 |     |             }
 190 |     |             return value;
 191 |     |         } else {
 192 |     |             return a;
 193 |     |         }
 194 |     |     }
 195 |     | 
 196 |     |     /// @notice clamps a to be greater than or equal to b
 197 |     |     function clampGte(uint256 a, uint256 b, bool enableLogs) internal returns (uint256) {
 198 |     |         if (!(a > b)) {
 199 |     |             uint256 value = b;
 200 |     |             if (enableLogs) {
 201 |     |                 string memory aStr = FuzzLibString.toString(a);
 202 |     |                 string memory valueStr = FuzzLibString.toString(value);
 203 |     |                 bytes memory message = abi.encodePacked(
 204 |     |                     "Clamping value ",
 205 |     |                     aStr,
 206 |     |                     " to ",
 207 |     |                     valueStr
 208 |     |                 );
 209 |     |                 emit Clamped(string(message));
 210 |     |             }
 211 |     |             return value;
 212 |     |         }
 213 |     |         return a;
 214 |     |     }
 215 |     | 
 216 |     |     /// @notice int256 version of clampGte
 217 |     |     function clampGte(int256 a, int256 b, bool enableLogs) internal returns (int256) {
 218 |     |         if (!(a > b)) {
 219 |     |             int256 value = b;
 220 |     |             if (enableLogs) {
 221 |     |                 string memory aStr = FuzzLibString.toString(a);
 222 |     |                 string memory valueStr = FuzzLibString.toString(value);
 223 |     |                 bytes memory message = abi.encodePacked(
 224 |     |                     "Clamping value ",
 225 |     |                     aStr,
 226 |     |                     " to ",
 227 |     |                     valueStr
 228 |     |                 );
 229 |     |                 emit Clamped(string(message));
 230 |     |             }
 231 |     |             return value;
 232 |     |         }
 233 |     |         return a;
 234 |     |     }
 235 |     | }
 236 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/ClampWrapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./ClampHelper.sol";
  5 |     | 
  6 |     | abstract contract ClampWrapper is ClampHelper {
  7 |     | 
  8 |     |     /// @notice Clamps value to be between low and high, both inclusive
  9 | *   |     function clampBetween(
 10 |     |         uint256 value,
 11 |     |         uint256 low,
 12 |     |         uint256 high
 13 | *   |     ) internal returns (uint256) {
 14 | *   |         return clampBetween(value, low, high, true);
 15 |     |     }
 16 |     | 
 17 |     |     /// @notice int256 version of clampBetween
 18 |     |     function clampBetween(
 19 |     |         int256 value,
 20 |     |         int256 low,
 21 |     |         int256 high
 22 |     |     ) internal returns (int256) {
 23 |     |         return clampBetween(value, low, high, true);
 24 |     |     }
 25 |     | 
 26 |     |     /// @notice clamps a to be less than b
 27 |     |     function clampLt(uint256 a, uint256 b) internal returns (uint256) {
 28 |     |         return clampLt(a, b);
 29 |     |     }
 30 |     | 
 31 |     |     /// @notice int256 version of clampLt
 32 |     |     function clampLt(int256 a, int256 b) internal returns (int256) {
 33 |     |         return clampLt(a, b, true);
 34 |     |     }
 35 |     | 
 36 |     |     /// @notice clamps a to be less than or equal to b
 37 |     |     function clampLte(uint256 a, uint256 b) internal returns (uint256) {
 38 |     |         return clampLte(a, b, true);
 39 |     |     }
 40 |     | 
 41 |     |     /// @notice int256 version of clampLte
 42 |     |     function clampLte(int256 a, int256 b) internal returns (int256) {
 43 |     |         return clampLte(a, b, true);
 44 |     |     }
 45 |     | 
 46 |     |     /// @notice clamps a to be greater than b
 47 |     |     function clampGt(uint256 a, uint256 b) internal returns (uint256) {
 48 |     |         return clampGt(a, b, true);
 49 |     |     }
 50 |     | 
 51 |     |     /// @notice int256 version of clampGt
 52 |     |     function clampGt(int256 a, int256 b) internal returns (int256) {
 53 |     |         return clampGt(a, b, true);
 54 |     |     }
 55 |     | 
 56 |     |     /// @notice clamps a to be greater than or equal to b
 57 |     |     function clampGte(uint256 a, uint256 b) internal returns (uint256) {
 58 |     |         return clampGte(a, b, true);
 59 |     |     }
 60 |     | 
 61 |     |     /// @notice int256 version of clampGte
 62 |     |     function clampGte(int256 a, int256 b) internal returns (int256) {
 63 |     |         return clampGte(a, b, true);
 64 |     |     }
 65 |     | }
 66 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/Constants.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | abstract contract Constants {
  5 |     |     // https://docs.soliditylang.org/en/latest/control-structures.html#panic-via-assert-and-error-via-require
  6 |     |     // 0x00: Used for generic compiler inserted panics.
  7 |     |     // 0x01: If you call assert with an argument that evaluates to false.
  8 |     |     // 0x11: If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
  9 |     |     // 0x12; If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
 10 |     |     // 0x21: If you convert a value that is too big or negative into an enum type.
 11 |     |     // 0x22: If you access a storage byte array that is incorrectly encoded.
 12 |     |     // 0x31: If you call .pop() on an empty array.
 13 |     |     // 0x32: If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
 14 |     |     // 0x41: If you allocate too much memory or create an array that is too large.
 15 |     |     // 0x51: If you call a zero-initialized variable of internal function type.
 16 |     |     uint256 internal constant PANIC_GENERAL = 0x00;
 17 |     |     uint256 internal constant PANIC_ASSERT = 0x01;
 18 |     |     uint256 internal constant PANIC_ARITHMETIC = 0x11;
 19 |     |     uint256 internal constant PANIC_DIVISION_BY_ZERO = 0x12;
 20 |     |     uint256 internal constant PANIC_ENUM_OUT_OF_BOUNDS = 0x21;
 21 |     |     uint256 internal constant PANIC_STORAGE_BYTES_ARRAY_ENCODING = 0x22;
 22 |     |     uint256 internal constant PANIC_POP_EMPTY_ARRAY = 0x31;
 23 |     |     uint256 internal constant PANIC_ARRAY_OUT_OF_BOUNDS = 0x32;
 24 |     |     uint256 internal constant PANIC_ALLOC_TOO_MUCH_MEMORY = 0x41;
 25 |     |     uint256 internal constant PANIC_ZERO_INIT_INTERNAL_FUNCTION = 0x51;
 26 |     | }
 27 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/FuzzBase.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./Logging.sol";
  5 |     | import "./Constants.sol";
  6 |     | import "./AssertWrapper.sol";
  7 |     | import "./ClampWrapper.sol";
  8 |     | import "./IHevm.sol";
  9 |     | 
 10 |     | abstract contract FuzzBase is AssertWrapper, ClampWrapper, Logging, Constants {
 11 |     |     IHevm internal vm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
 12 |     | }
 13 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/FuzzLibString.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | /// @notice Efficient library for creating string representations of integers.
   5 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)
   6 |     | /// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)
   7 |     | /// @author Modified from Crytic Properties (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)
   8 |     | library FuzzLibString {
   9 |     |     bytes16 internal constant HEX_DIGITS = "0123456789abcdef";
  10 |     | 
  11 |     |     function toString(int256 value) internal pure returns (string memory str) {
  12 |     |         uint256 absValue = value >= 0 ? uint256(value) : uint256(-value);
  13 |     |         str = toString(absValue);
  14 |     | 
  15 |     |         if (value < 0) {
  16 |     |             str = string(abi.encodePacked("-", str));
  17 |     |         }
  18 |     |     }
  19 |     | 
  20 | *   |     function toString(uint256 value) internal pure returns (string memory str) {
  21 |     |         /// @solidity memory-safe-assembly
  22 |     |         assembly {
  23 |     |             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes
  24 |     |             // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the
  25 |     |             // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.
  26 | *   |             let newFreeMemoryPointer := add(mload(0x40), 160)
  27 |     | 
  28 |     |             // Update the free memory pointer to avoid overriding our string.
  29 | *   |             mstore(0x40, newFreeMemoryPointer)
  30 |     | 
  31 |     |             // Assign str to the end of the zone of newly allocated memory.
  32 | *   |             str := sub(newFreeMemoryPointer, 32)
  33 |     | 
  34 |     |             // Clean the last word of memory it may not be overwritten.
  35 | *   |             mstore(str, 0)
  36 |     | 
  37 |     |             // Cache the end of the memory to calculate the length later.
  38 | *   |             let end := str
  39 |     | 
  40 |     |             // We write the string from rightmost digit to leftmost digit.
  41 |     |             // The following is essentially a do-while loop that also handles the zero case.
  42 |     |             // prettier-ignore
  43 | *   |             for { let temp := value } 1 {} {
  44 |     |                 // Move the pointer 1 byte to the left.
  45 | *   |                 str := sub(str, 1)
  46 |     | 
  47 |     |                 // Write the character to the pointer.
  48 |     |                 // The ASCII index of the '0' character is 48.
  49 | *   |                 mstore8(str, add(48, mod(temp, 10)))
  50 |     | 
  51 |     |                 // Keep dividing temp until zero.
  52 | *   |                 temp := div(temp, 10)
  53 |     | 
  54 |     |                  // prettier-ignore
  55 | *   |                 if iszero(temp) { break }
  56 |     |             }
  57 |     | 
  58 |     |             // Compute and cache the final total length of the string.
  59 | *   |             let length := sub(end, str)
  60 |     | 
  61 |     |             // Move the pointer 32 bytes leftwards to make room for the length.
  62 | *   |             str := sub(str, 32)
  63 |     | 
  64 |     |             // Store the string's length at the start of memory allocated for our string.
  65 | *   |             mstore(str, length)
  66 |     |         }
  67 |     |     }
  68 |     | 
  69 |     |     function toString(address value) internal pure returns (string memory str) {
  70 |     |         bytes memory s = new bytes(40);
  71 |     |         for (uint256 i = 0; i < 20; i++) {
  72 |     |             bytes1 b = bytes1(
  73 |     |                 uint8(uint256(uint160(value)) / (2**(8 * (19 - i))))
  74 |     |             );
  75 |     |             bytes1 hi = bytes1(uint8(b) / 16);
  76 |     |             bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
  77 |     |             s[2 * i] = char(hi);
  78 |     |             s[2 * i + 1] = char(lo);
  79 |     |         }
  80 |     |         return string(s);
  81 |     |     }
  82 |     | 
  83 |     |     function char(bytes1 b) internal pure returns (bytes1 c) {
  84 |     |         if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
  85 |     |         else return bytes1(uint8(b) + 0x57);
  86 |     |     }
  87 |     | 
  88 |     |     // based on OZ's toHexString
  89 |     |     // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol
  90 |     |     function toHexString(bytes memory value)
  91 |     |         internal
  92 |     |         pure
  93 |     |         returns (string memory)
  94 |     |     {
  95 |     |         bytes memory buffer = new bytes(2 * value.length + 2);
  96 |     |         buffer[0] = "0";
  97 |     |         buffer[1] = "x";
  98 |     |         for (uint256 i = 0; i < value.length; i++) {
  99 |     |             uint8 valueByte = uint8(value[i]);
 100 |     |             buffer[2 * i + 2] = HEX_DIGITS[valueByte >> 4];
 101 |     |             buffer[2 * i + 3] = HEX_DIGITS[valueByte & 0xf];
 102 |     |         }
 103 |     |         return string(buffer);
 104 |     |     }
 105 |     | 
 106 |     |     // https://ethereum.stackexchange.com/a/83577
 107 |     |     function getRevertMsg(bytes memory returnData)
 108 |     |         internal
 109 |     |         pure
 110 |     |         returns (string memory)
 111 |     |     {
 112 |     |         // Check that the data has the right size: 4 bytes for signature + 32 bytes for panic code
 113 |     |         if (returnData.length == 4 + 32) {
 114 |     |             // Check that the data starts with the Panic signature
 115 |     |             bytes4 panicSignature = bytes4(keccak256(bytes("Panic(uint256)")));
 116 |     |             for (uint256 i = 0; i < 4; i++) {
 117 |     |                 if (returnData[i] != panicSignature[i])
 118 |     |                     return "Undefined signature";
 119 |     |             }
 120 |     | 
 121 |     |             uint256 panicCode;
 122 |     |             for (uint256 i = 4; i < 36; i++) {
 123 |     |                 panicCode = panicCode << 8;
 124 |     |                 panicCode |= uint8(returnData[i]);
 125 |     |             }
 126 |     | 
 127 |     |             // Now convert the panic code into its string representation
 128 |     |             if (panicCode == 17) {
 129 |     |                 return "Panic(17)";
 130 |     |             }
 131 |     | 
 132 |     |             // Add other panic codes as needed or return a generic "Unknown panic"
 133 |     |             return "Undefined panic code";
 134 |     |         }
 135 |     | 
 136 |     |         // If the returnData length is less than 68, then the transaction failed silently (without a revert message)
 137 |     |         if (returnData.length < 68) return "Transaction reverted silently";
 138 |     | 
 139 |     |         assembly {
 140 |     |             // Slice the sighash.
 141 |     |             returnData := add(returnData, 0x04)
 142 |     |         }
 143 |     |         return abi.decode(returnData, (string)); // All that remains is the revert string
 144 |     |     }
 145 |     | 
 146 |     |     function isRevertReasonEqual(bytes memory returnData, string memory reason)
 147 |     |         internal
 148 |     |         pure
 149 |     |         returns (bool)
 150 |     |     {
 151 |     |         return (keccak256(abi.encodePacked(getRevertMsg(returnData))) ==
 152 |     |             keccak256(abi.encodePacked(reason)));
 153 |     |     }
 154 |     | }
 155 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/IHevm.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | // https://github.com/ethereum/hevm/blob/main/doc/src/controlling-the-unit-testing-environment.md#cheat-codes
  5 |     | 
  6 |     | interface IHevm {
  7 |     |     function warp(uint256 x) external;
  8 |     | 
  9 |     |     function roll(uint256 x) external;
 10 |     | 
 11 |     |     function store(
 12 |     |         address c,
 13 |     |         bytes32 loc,
 14 |     |         bytes32 val
 15 |     |     ) external;
 16 |     | 
 17 |     |     function load(address c, bytes32 loc) external returns (bytes32 val);
 18 |     | 
 19 |     |     function sign(uint256 sk, bytes32 digest)
 20 |     |         external
 21 |     |         returns (
 22 |     |             uint8 v,
 23 |     |             bytes32 r,
 24 |     |             bytes32 s
 25 |     |         );
 26 |     | 
 27 |     |     function addr(uint256 sk) external returns (address addr);
 28 |     | 
 29 |     |     function ffi(string[] calldata) external returns (bytes memory);
 30 |     | 
 31 |     |     function prank(address sender) external;
 32 |     | }
 33 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/fuzzlib/src/Logging.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | abstract contract Logging {
   5 |     |     event Log(string debugString);
   6 |     |     event LogString(string description, string data);
   7 |     |     event LogString(string prefix, string description, string data);
   8 |     |     event LogBytes(string description, bytes data);
   9 |     |     event LogBytes(string prefix, string description, bytes data);
  10 |     |     event LogUint(string description, uint256 data);
  11 |     |     event LogUint(string prefix, string description, uint256 data);
  12 |     |     event LogInt(string description, int256 data);
  13 |     |     event LogInt(string prefix, string description, int256 data);
  14 |     |     event LogAddress(string description, address data);
  15 |     |     event LogAddress(string prefix, string description, address data);
  16 |     |     event LogBool(string description, bool data);
  17 |     |     event LogBool(string prefix, string description, bool data);
  18 |     |     
  19 |     |     event AssertionFailed();
  20 |     |     event AssertionFailed(string description);
  21 |     |     event AssertionFailed(string description, string data);
  22 |     |     event AssertionFailed(string prefix, string description, string data);
  23 |     |     event AssertionFailed(string description, bytes data);
  24 |     |     event AssertionFailed(string prefix, string description, bytes data);
  25 |     |     event AssertionFailed(string description, uint256 data);
  26 |     |     event AssertionFailed(string prefix, string description, uint256 data);
  27 |     |     event AssertionFailed(string description, int256 data);
  28 |     |     event AssertionFailed(string prefix, string description, int256 data);
  29 |     |     event AssertionFailed(string description, address data);
  30 |     |     event AssertionFailed(string prefix, string description, address data);
  31 |     |     event AssertionFailed(string description, bool data);
  32 |     |     event AssertionFailed(string prefix, string description, bool data);
  33 |     | 
  34 |     |     function log(string memory debugString) internal {
  35 |     |         emit Log(debugString);
  36 |     |     }
  37 |     | 
  38 |     |     function log(string memory description, string memory data) internal {
  39 |     |         emit LogString(description, data);
  40 |     |     }
  41 |     | 
  42 |     |     function log(
  43 |     |         string memory prefix,
  44 |     |         string memory description,
  45 |     |         string memory data
  46 |     |     ) internal {
  47 |     |         emit LogString(prefix, description, data);
  48 |     |     }
  49 |     | 
  50 |     |     function log(string memory description, bytes memory data) internal {
  51 |     |         emit LogBytes(description, data);
  52 |     |     }
  53 |     | 
  54 |     |     function log(
  55 |     |         string memory prefix,
  56 |     |         string memory description,
  57 |     |         bytes memory data
  58 |     |     ) internal {
  59 |     |         emit LogBytes(prefix, description, data);
  60 |     |     }
  61 |     | 
  62 |     |     function log(string memory description, uint256 data) internal {
  63 |     |         emit LogUint(description, data);
  64 |     |     }
  65 |     | 
  66 |     |     function log(
  67 |     |         string memory prefix,
  68 |     |         string memory description,
  69 |     |         uint256 data
  70 |     |     ) internal {
  71 |     |         emit LogUint(prefix, description, data);
  72 |     |     }
  73 |     | 
  74 |     |     function log(string memory description, int256 data) internal {
  75 |     |         emit LogInt(description, data);
  76 |     |     }
  77 |     | 
  78 |     |     function log(
  79 |     |         string memory prefix,
  80 |     |         string memory description,
  81 |     |         int256 data
  82 |     |     ) internal {
  83 |     |         emit LogInt(prefix, description, data);
  84 |     |     }
  85 |     | 
  86 |     |     function log(string memory description, address data) internal {
  87 |     |         emit LogAddress(description, data);
  88 |     |     }
  89 |     | 
  90 |     |     function log(
  91 |     |         string memory prefix,
  92 |     |         string memory description,
  93 |     |         address data
  94 |     |     ) internal {
  95 |     |         emit LogAddress(prefix, description, data);
  96 |     |     }
  97 |     | 
  98 |     |     function log(string memory description, bool data) internal {
  99 |     |         emit LogBool(description, data);
 100 |     |     }
 101 |     | 
 102 |     |     function log(
 103 |     |         string memory prefix,
 104 |     |         string memory description,
 105 |     |         bool data
 106 |     |     ) internal {
 107 |     |         emit LogBool(prefix, description, data);
 108 |     |     }
 109 |     | 
 110 |     |     function logFail() internal {
 111 |     |         emit AssertionFailed();
 112 |     |     }
 113 |     | 
 114 |     |     function logFail(string memory debugString) internal {
 115 |     |         emit AssertionFailed(debugString);
 116 |     |     }
 117 |     | 
 118 |     |     function logFail(string memory description, string memory data) internal {
 119 |     |         emit AssertionFailed(description, data);
 120 |     |     }
 121 |     | 
 122 |     |     function logFail(
 123 |     |         string memory prefix,
 124 |     |         string memory description,
 125 |     |         string memory data
 126 |     |     ) internal {
 127 |     |         emit AssertionFailed(prefix, description, data);
 128 |     |     }
 129 |     | 
 130 |     |     function logFail(string memory description, bytes memory data) internal {
 131 |     |         emit AssertionFailed(description, data);
 132 |     |     }
 133 |     | 
 134 |     |     function logFail(
 135 |     |         string memory prefix,
 136 |     |         string memory description,
 137 |     |         bytes memory data
 138 |     |     ) internal {
 139 |     |         emit AssertionFailed(prefix, description, data);
 140 |     |     }
 141 |     | 
 142 |     |     function logFail(string memory description, uint256 data) internal {
 143 |     |         emit AssertionFailed(description, data);
 144 |     |     }
 145 |     | 
 146 |     |     function logFail(
 147 |     |         string memory prefix,
 148 |     |         string memory description,
 149 |     |         uint256 data
 150 |     |     ) internal {
 151 |     |         emit AssertionFailed(prefix, description, data);
 152 |     |     }
 153 |     | 
 154 |     |     function logFail(string memory description, int256 data) internal {
 155 |     |         emit AssertionFailed(description, data);
 156 |     |     }
 157 |     | 
 158 |     |     function logFail(
 159 |     |         string memory prefix,
 160 |     |         string memory description,
 161 |     |         int256 data
 162 |     |     ) internal {
 163 |     |         emit AssertionFailed(prefix, description, data);
 164 |     |     }
 165 |     | 
 166 |     |     function logFail(string memory description, address data) internal {
 167 |     |         emit AssertionFailed(description, data);
 168 |     |     }
 169 |     | 
 170 |     |     function logFail(
 171 |     |         string memory prefix,
 172 |     |         string memory description,
 173 |     |         address data
 174 |     |     ) internal {
 175 |     |         emit AssertionFailed(prefix, description, data);
 176 |     |     }
 177 |     | 
 178 |     |     function logFail(string memory description, bool data) internal {
 179 |     |         emit AssertionFailed(description, data);
 180 |     |     }
 181 |     | 
 182 |     |     function logFail(
 183 |     |         string memory prefix,
 184 |     |         string memory description,
 185 |     |         bool data
 186 |     |     ) internal {
 187 |     |         emit AssertionFailed(prefix, description, data);
 188 |     |     }
 189 |     | }
 190 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | // OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)
 3 |     | 
 4 |     | pragma solidity ^0.8.0;
 5 |     | 
 6 |     | import "../token/ERC20/IERC20.sol";
 7 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/interfaces/IERC20Metadata.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | // OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)
 3 |     | 
 4 |     | pragma solidity ^0.8.0;
 5 |     | 
 6 |     | import "../token/ERC20/extensions/IERC20Metadata.sol";
 7 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/proxy/Proxy.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM
  8 |     |  * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to
  9 |     |  * be specified by overriding the virtual {_implementation} function.
 10 |     |  *
 11 |     |  * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a
 12 |     |  * different contract through the {_delegate} function.
 13 |     |  *
 14 |     |  * The success and return data of the delegated call will be returned back to the caller of the proxy.
 15 |     |  */
 16 |     | abstract contract Proxy {
 17 |     |     /**
 18 |     |      * @dev Delegates the current call to `implementation`.
 19 |     |      *
 20 |     |      * This function does not return to its internal call site, it will return directly to the external caller.
 21 |     |      */
 22 |     |     function _delegate(address implementation) internal virtual {
 23 |     |         assembly {
 24 |     |             // Copy msg.data. We take full control of memory in this inline assembly
 25 |     |             // block because it will not return to Solidity code. We overwrite the
 26 |     |             // Solidity scratch pad at memory position 0.
 27 |     |             calldatacopy(0, 0, calldatasize())
 28 |     | 
 29 |     |             // Call the implementation.
 30 |     |             // out and outsize are 0 because we don't know the size yet.
 31 |     |             let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
 32 |     | 
 33 |     |             // Copy the returned data.
 34 |     |             returndatacopy(0, 0, returndatasize())
 35 |     | 
 36 |     |             switch result
 37 |     |             // delegatecall returns 0 on error.
 38 |     |             case 0 {
 39 |     |                 revert(0, returndatasize())
 40 |     |             }
 41 |     |             default {
 42 |     |                 return(0, returndatasize())
 43 |     |             }
 44 |     |         }
 45 |     |     }
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function
 49 |     |      * and {_fallback} should delegate.
 50 |     |      */
 51 |     |     function _implementation() internal view virtual returns (address);
 52 |     | 
 53 |     |     /**
 54 |     |      * @dev Delegates the current call to the address returned by `_implementation()`.
 55 |     |      *
 56 |     |      * This function does not return to its internal call site, it will return directly to the external caller.
 57 |     |      */
 58 |     |     function _fallback() internal virtual {
 59 |     |         _beforeFallback();
 60 |     |         _delegate(_implementation());
 61 |     |     }
 62 |     | 
 63 |     |     /**
 64 |     |      * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other
 65 |     |      * function in the contract matches the call data.
 66 |     |      */
 67 |     |     fallback() external payable virtual {
 68 |     |         _fallback();
 69 |     |     }
 70 |     | 
 71 |     |     /**
 72 |     |      * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data
 73 |     |      * is empty.
 74 |     |      */
 75 |     |     receive() external payable virtual {
 76 |     |         _fallback();
 77 |     |     }
 78 |     | 
 79 |     |     /**
 80 |     |      * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`
 81 |     |      * call, or as part of the Solidity `fallback` or `receive` functions.
 82 |     |      *
 83 |     |      * If overridden should call `super._beforeFallback()`.
 84 |     |      */
 85 |     |     function _beforeFallback() internal virtual {}
 86 |     | }
 87 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/security/Pausable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../utils/Context.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Contract module which allows children to implement an emergency stop
  10 |     |  * mechanism that can be triggered by an authorized account.
  11 |     |  *
  12 |     |  * This module is used through inheritance. It will make available the
  13 |     |  * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
  14 |     |  * the functions of your contract. Note that they will not be pausable by
  15 |     |  * simply including this module, only once the modifiers are put in place.
  16 |     |  */
  17 |     | abstract contract Pausable is Context {
  18 |     |     /**
  19 |     |      * @dev Emitted when the pause is triggered by `account`.
  20 |     |      */
  21 |     |     event Paused(address account);
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev Emitted when the pause is lifted by `account`.
  25 |     |      */
  26 |     |     event Unpaused(address account);
  27 |     | 
  28 |     |     bool private _paused;
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Initializes the contract in unpaused state.
  32 |     |      */
  33 |     |     constructor() {
  34 |     |         _paused = false;
  35 |     |     }
  36 |     | 
  37 |     |     /**
  38 |     |      * @dev Modifier to make a function callable only when the contract is not paused.
  39 |     |      *
  40 |     |      * Requirements:
  41 |     |      *
  42 |     |      * - The contract must not be paused.
  43 |     |      */
  44 |     |     modifier whenNotPaused() {
  45 |     |         _requireNotPaused();
  46 |     |         _;
  47 |     |     }
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev Modifier to make a function callable only when the contract is paused.
  51 |     |      *
  52 |     |      * Requirements:
  53 |     |      *
  54 |     |      * - The contract must be paused.
  55 |     |      */
  56 |     |     modifier whenPaused() {
  57 |     |         _requirePaused();
  58 |     |         _;
  59 |     |     }
  60 |     | 
  61 |     |     /**
  62 |     |      * @dev Returns true if the contract is paused, and false otherwise.
  63 |     |      */
  64 |     |     function paused() public view virtual returns (bool) {
  65 |     |         return _paused;
  66 |     |     }
  67 |     | 
  68 |     |     /**
  69 |     |      * @dev Throws if the contract is paused.
  70 |     |      */
  71 |     |     function _requireNotPaused() internal view virtual {
  72 |     |         require(!paused(), "Pausable: paused");
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev Throws if the contract is not paused.
  77 |     |      */
  78 |     |     function _requirePaused() internal view virtual {
  79 |     |         require(paused(), "Pausable: not paused");
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev Triggers stopped state.
  84 |     |      *
  85 |     |      * Requirements:
  86 |     |      *
  87 |     |      * - The contract must not be paused.
  88 |     |      */
  89 |     |     function _pause() internal virtual whenNotPaused {
  90 |     |         _paused = true;
  91 |     |         emit Paused(_msgSender());
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev Returns to normal state.
  96 |     |      *
  97 |     |      * Requirements:
  98 |     |      *
  99 |     |      * - The contract must be paused.
 100 |     |      */
 101 |     |     function _unpause() internal virtual whenPaused {
 102 |     |         _paused = false;
 103 |     |         emit Unpaused(_msgSender());
 104 |     |     }
 105 |     | }
 106 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
  8 |     |  *
  9 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 10 |     |  * available, which can be applied to functions to make sure there are no nested
 11 |     |  * (reentrant) calls to them.
 12 |     |  *
 13 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
 14 |     |  * `nonReentrant` may not call one another. This can be worked around by making
 15 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
 16 |     |  * points to them.
 17 |     |  *
 18 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
 19 |     |  * to protect against it, check out our blog post
 20 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 21 |     |  */
 22 |     | abstract contract ReentrancyGuard {
 23 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
 24 |     |     // word because each write operation emits an extra SLOAD to first read the
 25 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
 26 |     |     // back. This is the compiler's defense against contract upgrades and
 27 |     |     // pointer aliasing, and it cannot be disabled.
 28 |     | 
 29 |     |     // The values being non-zero value makes deployment a bit more expensive,
 30 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
 31 |     |     // amount. Since refunds are capped to a percentage of the total
 32 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
 33 |     |     // increase the likelihood of the full refund coming into effect.
 34 |     |     uint256 private constant _NOT_ENTERED = 1;
 35 |     |     uint256 private constant _ENTERED = 2;
 36 |     | 
 37 |     |     uint256 private _status;
 38 |     | 
 39 |     |     constructor() {
 40 |     |         _status = _NOT_ENTERED;
 41 |     |     }
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
 45 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
 46 |     |      * function is not supported. It is possible to prevent this from happening
 47 |     |      * by making the `nonReentrant` function external, and making it call a
 48 |     |      * `private` function that does the actual work.
 49 |     |      */
 50 |     |     modifier nonReentrant() {
 51 |     |         _nonReentrantBefore();
 52 |     |         _;
 53 |     |         _nonReentrantAfter();
 54 |     |     }
 55 |     | 
 56 |     |     function _nonReentrantBefore() private {
 57 |     |         // On the first call to nonReentrant, _status will be _NOT_ENTERED
 58 |     |         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
 59 |     | 
 60 |     |         // Any calls to nonReentrant after this point will fail
 61 |     |         _status = _ENTERED;
 62 |     |     }
 63 |     | 
 64 |     |     function _nonReentrantAfter() private {
 65 |     |         // By storing the original value once again, a refund is triggered (see
 66 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
 67 |     |         _status = _NOT_ENTERED;
 68 |     |     }
 69 |     | 
 70 |     |     /**
 71 |     |      * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
 72 |     |      * `nonReentrant` function in the call stack.
 73 |     |      */
 74 |     |     function _reentrancyGuardEntered() internal view returns (bool) {
 75 |     |         return _status == _ENTERED;
 76 |     |     }
 77 |     | }
 78 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC20
  27 |     |  * applications.
  28 |     |  *
  29 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  30 |     |  * This allows applications to reconstruct the allowance for all accounts just
  31 |     |  * by listening to said events. Other implementations of the EIP may not emit
  32 |     |  * these events, as it isn't required by the specification.
  33 |     |  *
  34 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  35 |     |  * functions have been added to mitigate the well-known issues around setting
  36 |     |  * allowances. See {IERC20-approve}.
  37 |     |  */
  38 |     | contract ERC20 is Context, IERC20, IERC20Metadata {
  39 |     |     mapping(address => uint256) private _balances;
  40 |     | 
  41 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  42 |     | 
  43 |     |     uint256 private _totalSupply;
  44 |     | 
  45 |     |     string private _name;
  46 |     |     string private _symbol;
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Sets the values for {name} and {symbol}.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 |     |     constructor(string memory name_, string memory symbol_) {
  55 |     |         _name = name_;
  56 |     |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 | *   |     function name() public view virtual override returns (string memory) {
  63 |     |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 |     |     function symbol() public view virtual override returns (string memory) {
  71 |     |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the default value returned by this function, unless
  81 |     |      * it's overridden.
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 |     |     function decimals() public view virtual override returns (uint8) {
  88 |     |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 | *   |     function totalSupply() public view virtual override returns (uint256) {
  95 |     |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 | *   |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 | *   |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 | *   |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 |     |         address owner = _msgSender();
 115 | *   |         _transfer(owner, to, amount);
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 |     |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 | *   |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 | *   |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 |     |         address owner = _msgSender();
 138 | *   |         _approve(owner, spender, amount);
 139 | *   |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 | *   |     function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
 159 |     |         address spender = _msgSender();
 160 | *   |         _spendAllowance(from, spender, amount);
 161 | *   |         _transfer(from, to, amount);
 162 | *   |         return true;
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 167 |     |      *
 168 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 169 |     |      * problems described in {IERC20-approve}.
 170 |     |      *
 171 |     |      * Emits an {Approval} event indicating the updated allowance.
 172 |     |      *
 173 |     |      * Requirements:
 174 |     |      *
 175 |     |      * - `spender` cannot be the zero address.
 176 |     |      */
 177 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 178 |     |         address owner = _msgSender();
 179 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 180 |     |         return true;
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 185 |     |      *
 186 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 187 |     |      * problems described in {IERC20-approve}.
 188 |     |      *
 189 |     |      * Emits an {Approval} event indicating the updated allowance.
 190 |     |      *
 191 |     |      * Requirements:
 192 |     |      *
 193 |     |      * - `spender` cannot be the zero address.
 194 |     |      * - `spender` must have allowance for the caller of at least
 195 |     |      * `subtractedValue`.
 196 |     |      */
 197 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 198 |     |         address owner = _msgSender();
 199 |     |         uint256 currentAllowance = allowance(owner, spender);
 200 | *   |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 201 |     |         unchecked {
 202 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 203 |     |         }
 204 |     | 
 205 |     |         return true;
 206 |     |     }
 207 |     | 
 208 |     |     /**
 209 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 210 |     |      *
 211 |     |      * This internal function is equivalent to {transfer}, and can be used to
 212 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 213 |     |      *
 214 |     |      * Emits a {Transfer} event.
 215 |     |      *
 216 |     |      * Requirements:
 217 |     |      *
 218 |     |      * - `from` cannot be the zero address.
 219 |     |      * - `to` cannot be the zero address.
 220 |     |      * - `from` must have a balance of at least `amount`.
 221 |     |      */
 222 | *   |     function _transfer(address from, address to, uint256 amount) internal virtual {
 223 | *   |         require(from != address(0), "ERC20: transfer from the zero address");
 224 | *   |         require(to != address(0), "ERC20: transfer to the zero address");
 225 |     | 
 226 |     |         _beforeTokenTransfer(from, to, amount);
 227 |     | 
 228 | *   |         uint256 fromBalance = _balances[from];
 229 | *   |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 230 |     |         unchecked {
 231 | *   |             _balances[from] = fromBalance - amount;
 232 |     |             // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
 233 |     |             // decrementing then incrementing.
 234 | *   |             _balances[to] += amount;
 235 |     |         }
 236 |     | 
 237 | *   |         emit Transfer(from, to, amount);
 238 |     | 
 239 | *   |         _afterTokenTransfer(from, to, amount);
 240 |     |     }
 241 |     | 
 242 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 243 |     |      * the total supply.
 244 |     |      *
 245 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 246 |     |      *
 247 |     |      * Requirements:
 248 |     |      *
 249 |     |      * - `account` cannot be the zero address.
 250 |     |      */
 251 | *   |     function _mint(address account, uint256 amount) internal virtual {
 252 | *   |         require(account != address(0), "ERC20: mint to the zero address");
 253 |     | 
 254 |     |         _beforeTokenTransfer(address(0), account, amount);
 255 |     | 
 256 | *   |         _totalSupply += amount;
 257 |     |         unchecked {
 258 |     |             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
 259 | *   |             _balances[account] += amount;
 260 |     |         }
 261 | *   |         emit Transfer(address(0), account, amount);
 262 |     | 
 263 |     |         _afterTokenTransfer(address(0), account, amount);
 264 |     |     }
 265 |     | 
 266 |     |     /**
 267 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 268 |     |      * total supply.
 269 |     |      *
 270 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 271 |     |      *
 272 |     |      * Requirements:
 273 |     |      *
 274 |     |      * - `account` cannot be the zero address.
 275 |     |      * - `account` must have at least `amount` tokens.
 276 |     |      */
 277 | *   |     function _burn(address account, uint256 amount) internal virtual {
 278 |     |         require(account != address(0), "ERC20: burn from the zero address");
 279 |     | 
 280 |     |         _beforeTokenTransfer(account, address(0), amount);
 281 |     | 
 282 |     |         uint256 accountBalance = _balances[account];
 283 |     |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 284 |     |         unchecked {
 285 |     |             _balances[account] = accountBalance - amount;
 286 |     |             // Overflow not possible: amount <= accountBalance <= totalSupply.
 287 |     |             _totalSupply -= amount;
 288 |     |         }
 289 |     | 
 290 |     |         emit Transfer(account, address(0), amount);
 291 |     | 
 292 |     |         _afterTokenTransfer(account, address(0), amount);
 293 |     |     }
 294 |     | 
 295 |     |     /**
 296 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 297 |     |      *
 298 |     |      * This internal function is equivalent to `approve`, and can be used to
 299 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 300 |     |      *
 301 |     |      * Emits an {Approval} event.
 302 |     |      *
 303 |     |      * Requirements:
 304 |     |      *
 305 |     |      * - `owner` cannot be the zero address.
 306 |     |      * - `spender` cannot be the zero address.
 307 |     |      */
 308 | *   |     function _approve(address owner, address spender, uint256 amount) internal virtual {
 309 | *   |         require(owner != address(0), "ERC20: approve from the zero address");
 310 | *   |         require(spender != address(0), "ERC20: approve to the zero address");
 311 |     | 
 312 | *   |         _allowances[owner][spender] = amount;
 313 | *   |         emit Approval(owner, spender, amount);
 314 |     |     }
 315 |     | 
 316 |     |     /**
 317 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 318 |     |      *
 319 |     |      * Does not update the allowance amount in case of infinite allowance.
 320 |     |      * Revert if not enough allowance is available.
 321 |     |      *
 322 |     |      * Might emit an {Approval} event.
 323 |     |      */
 324 | *   |     function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
 325 | *   |         uint256 currentAllowance = allowance(owner, spender);
 326 | *   |         if (currentAllowance != type(uint256).max) {
 327 | *   |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 328 |     |             unchecked {
 329 | *   |                 _approve(owner, spender, currentAllowance - amount);
 330 |     |             }
 331 |     |         }
 332 |     |     }
 333 |     | 
 334 |     |     /**
 335 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 336 |     |      * minting and burning.
 337 |     |      *
 338 |     |      * Calling conditions:
 339 |     |      *
 340 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 341 |     |      * will be transferred to `to`.
 342 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 343 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 344 |     |      * - `from` and `to` are never both zero.
 345 |     |      *
 346 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 347 |     |      */
 348 |     |     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 349 |     | 
 350 |     |     /**
 351 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 352 |     |      * minting and burning.
 353 |     |      *
 354 |     |      * Calling conditions:
 355 |     |      *
 356 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 357 |     |      * has been transferred to `to`.
 358 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 359 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 360 |     |      * - `from` and `to` are never both zero.
 361 |     |      *
 362 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 363 |     |      */
 364 |     |     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 365 |     | }
 366 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 78 |     | }
 79 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  *
 11 |     |  * _Available since v4.1._
 12 |     |  */
 13 |     | interface IERC20Metadata is IERC20 {
 14 |     |     /**
 15 |     |      * @dev Returns the name of the token.
 16 |     |      */
 17 |     |     function name() external view returns (string memory);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Returns the symbol of the token.
 21 |     |      */
 22 |     |     function symbol() external view returns (string memory);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the decimals places of the token.
 26 |     |      */
 27 |     |     function decimals() external view returns (uint8);
 28 |     | }
 29 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
  8 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
  9 |     |  *
 10 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 11 |     |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 12 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 13 |     |  */
 14 |     | interface IERC20Permit {
 15 |     |     /**
 16 |     |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
 17 |     |      * given ``owner``'s signed approval.
 18 |     |      *
 19 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 20 |     |      * ordering also apply here.
 21 |     |      *
 22 |     |      * Emits an {Approval} event.
 23 |     |      *
 24 |     |      * Requirements:
 25 |     |      *
 26 |     |      * - `spender` cannot be the zero address.
 27 |     |      * - `deadline` must be a timestamp in the future.
 28 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 29 |     |      * over the EIP712-formatted function arguments.
 30 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 31 |     |      *
 32 |     |      * For more information on the signature format, see the
 33 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 34 |     |      * section].
 35 |     |      */
 36 |     |     function permit(
 37 |     |         address owner,
 38 |     |         address spender,
 39 |     |         uint256 value,
 40 |     |         uint256 deadline,
 41 |     |         uint8 v,
 42 |     |         bytes32 r,
 43 |     |         bytes32 s
 44 |     |     ) external;
 45 |     | 
 46 |     |     /**
 47 |     |      * @dev Returns the current nonce for `owner`. This value must be
 48 |     |      * included whenever a signature is generated for {permit}.
 49 |     |      *
 50 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 51 |     |      * prevents a signature from being used multiple times.
 52 |     |      */
 53 |     |     function nonces(address owner) external view returns (uint256);
 54 |     | 
 55 |     |     /**
 56 |     |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
 57 |     |      */
 58 |     |     // solhint-disable-next-line func-name-mixedcase
 59 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 60 |     | }
 61 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../IERC20.sol";
   7 |     | import "../extensions/IERC20Permit.sol";
   8 |     | import "../../../utils/Address.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title SafeERC20
  12 |     |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
  13 |     |  * contract returns false). Tokens that return no value (and instead revert or
  14 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  15 |     |  * successful.
  16 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  17 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  18 |     |  */
  19 |     | library SafeERC20 {
  20 |     |     using Address for address;
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
  24 |     |      * non-reverting calls are assumed to be successful.
  25 |     |      */
  26 |     |     function safeTransfer(IERC20 token, address to, uint256 value) internal {
  27 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
  32 |     |      * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
  33 |     |      */
  34 |     |     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
  35 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
  36 |     |     }
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Deprecated. This function has issues similar to the ones found in
  40 |     |      * {IERC20-approve}, and its usage is discouraged.
  41 |     |      *
  42 |     |      * Whenever possible, use {safeIncreaseAllowance} and
  43 |     |      * {safeDecreaseAllowance} instead.
  44 |     |      */
  45 |     |     function safeApprove(IERC20 token, address spender, uint256 value) internal {
  46 |     |         // safeApprove should only be called when setting an initial allowance,
  47 |     |         // or when resetting it to zero. To increase and decrease it, use
  48 |     |         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
  49 |     |         require(
  50 |     |             (value == 0) || (token.allowance(address(this), spender) == 0),
  51 |     |             "SafeERC20: approve from non-zero to non-zero allowance"
  52 |     |         );
  53 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  58 |     |      * non-reverting calls are assumed to be successful.
  59 |     |      */
  60 |     |     function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  61 |     |         uint256 oldAllowance = token.allowance(address(this), spender);
  62 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  67 |     |      * non-reverting calls are assumed to be successful.
  68 |     |      */
  69 |     |     function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  70 |     |         unchecked {
  71 |     |             uint256 oldAllowance = token.allowance(address(this), spender);
  72 |     |             require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
  73 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
  79 |     |      * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to
  80 |     |      * 0 before setting it to a non-zero value.
  81 |     |      */
  82 |     |     function forceApprove(IERC20 token, address spender, uint256 value) internal {
  83 |     |         bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);
  84 |     | 
  85 |     |         if (!_callOptionalReturnBool(token, approvalCall)) {
  86 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));
  87 |     |             _callOptionalReturn(token, approvalCall);
  88 |     |         }
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.
  93 |     |      * Revert on invalid signature.
  94 |     |      */
  95 |     |     function safePermit(
  96 |     |         IERC20Permit token,
  97 |     |         address owner,
  98 |     |         address spender,
  99 |     |         uint256 value,
 100 |     |         uint256 deadline,
 101 |     |         uint8 v,
 102 |     |         bytes32 r,
 103 |     |         bytes32 s
 104 |     |     ) internal {
 105 |     |         uint256 nonceBefore = token.nonces(owner);
 106 |     |         token.permit(owner, spender, value, deadline, v, r, s);
 107 |     |         uint256 nonceAfter = token.nonces(owner);
 108 |     |         require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 113 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 114 |     |      * @param token The token targeted by the call.
 115 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 116 |     |      */
 117 |     |     function _callOptionalReturn(IERC20 token, bytes memory data) private {
 118 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 119 |     |         // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
 120 |     |         // the target address contains contract code and also asserts for success in the low-level call.
 121 |     | 
 122 |     |         bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
 123 |     |         require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 128 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 129 |     |      * @param token The token targeted by the call.
 130 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 131 |     |      *
 132 |     |      * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
 133 |     |      */
 134 |     |     function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
 135 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 136 |     |         // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
 137 |     |         // and not revert is the subcall reverts.
 138 |     | 
 139 |     |         (bool success, bytes memory returndata) = address(token).call(data);
 140 |     |         return
 141 |     |             success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));
 142 |     |     }
 143 |     | }
 144 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.1;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library Address {
  10 |     |     /**
  11 |     |      * @dev Returns true if `account` is a contract.
  12 |     |      *
  13 |     |      * [IMPORTANT]
  14 |     |      * ====
  15 |     |      * It is unsafe to assume that an address for which this function returns
  16 |     |      * false is an externally-owned account (EOA) and not a contract.
  17 |     |      *
  18 |     |      * Among others, `isContract` will return false for the following
  19 |     |      * types of addresses:
  20 |     |      *
  21 |     |      *  - an externally-owned account
  22 |     |      *  - a contract in construction
  23 |     |      *  - an address where a contract will be created
  24 |     |      *  - an address where a contract lived, but was destroyed
  25 |     |      *
  26 |     |      * Furthermore, `isContract` will also return true if the target contract within
  27 |     |      * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,
  28 |     |      * which only has an effect at the end of a transaction.
  29 |     |      * ====
  30 |     |      *
  31 |     |      * [IMPORTANT]
  32 |     |      * ====
  33 |     |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
  34 |     |      *
  35 |     |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
  36 |     |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
  37 |     |      * constructor.
  38 |     |      * ====
  39 |     |      */
  40 |     |     function isContract(address account) internal view returns (bool) {
  41 |     |         // This method relies on extcodesize/address.code.length, which returns 0
  42 |     |         // for contracts in construction, since the code is only stored at the end
  43 |     |         // of the constructor execution.
  44 |     | 
  45 |     |         return account.code.length > 0;
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  50 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  51 |     |      *
  52 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  53 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  54 |     |      * imposed by `transfer`, making them unable to receive funds via
  55 |     |      * `transfer`. {sendValue} removes this limitation.
  56 |     |      *
  57 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  58 |     |      *
  59 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  60 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  61 |     |      * {ReentrancyGuard} or the
  62 |     |      * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  63 |     |      */
  64 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  65 |     |         require(address(this).balance >= amount, "Address: insufficient balance");
  66 |     | 
  67 |     |         (bool success, ) = recipient.call{value: amount}("");
  68 |     |         require(success, "Address: unable to send value, recipient may have reverted");
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  73 |     |      * plain `call` is an unsafe replacement for a function call: use this
  74 |     |      * function instead.
  75 |     |      *
  76 |     |      * If `target` reverts with a revert reason, it is bubbled up by this
  77 |     |      * function (like regular Solidity function calls).
  78 |     |      *
  79 |     |      * Returns the raw returned data. To convert to the expected return value,
  80 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  81 |     |      *
  82 |     |      * Requirements:
  83 |     |      *
  84 |     |      * - `target` must be a contract.
  85 |     |      * - calling `target` with `data` must not revert.
  86 |     |      *
  87 |     |      * _Available since v3.1._
  88 |     |      */
  89 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  90 |     |         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  95 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  96 |     |      *
  97 |     |      * _Available since v3.1._
  98 |     |      */
  99 |     |     function functionCall(
 100 |     |         address target,
 101 |     |         bytes memory data,
 102 |     |         string memory errorMessage
 103 |     |     ) internal returns (bytes memory) {
 104 |     |         return functionCallWithValue(target, data, 0, errorMessage);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 109 |     |      * but also transferring `value` wei to `target`.
 110 |     |      *
 111 |     |      * Requirements:
 112 |     |      *
 113 |     |      * - the calling contract must have an ETH balance of at least `value`.
 114 |     |      * - the called Solidity function must be `payable`.
 115 |     |      *
 116 |     |      * _Available since v3.1._
 117 |     |      */
 118 |     |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
 119 |     |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
 124 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
 125 |     |      *
 126 |     |      * _Available since v3.1._
 127 |     |      */
 128 |     |     function functionCallWithValue(
 129 |     |         address target,
 130 |     |         bytes memory data,
 131 |     |         uint256 value,
 132 |     |         string memory errorMessage
 133 |     |     ) internal returns (bytes memory) {
 134 |     |         require(address(this).balance >= value, "Address: insufficient balance for call");
 135 |     |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 136 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 141 |     |      * but performing a static call.
 142 |     |      *
 143 |     |      * _Available since v3.3._
 144 |     |      */
 145 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
 146 |     |         return functionStaticCall(target, data, "Address: low-level static call failed");
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 151 |     |      * but performing a static call.
 152 |     |      *
 153 |     |      * _Available since v3.3._
 154 |     |      */
 155 |     |     function functionStaticCall(
 156 |     |         address target,
 157 |     |         bytes memory data,
 158 |     |         string memory errorMessage
 159 |     |     ) internal view returns (bytes memory) {
 160 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
 161 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 166 |     |      * but performing a delegate call.
 167 |     |      *
 168 |     |      * _Available since v3.4._
 169 |     |      */
 170 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 171 |     |         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 176 |     |      * but performing a delegate call.
 177 |     |      *
 178 |     |      * _Available since v3.4._
 179 |     |      */
 180 |     |     function functionDelegateCall(
 181 |     |         address target,
 182 |     |         bytes memory data,
 183 |     |         string memory errorMessage
 184 |     |     ) internal returns (bytes memory) {
 185 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 186 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
 191 |     |      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
 192 |     |      *
 193 |     |      * _Available since v4.8._
 194 |     |      */
 195 |     |     function verifyCallResultFromTarget(
 196 |     |         address target,
 197 |     |         bool success,
 198 |     |         bytes memory returndata,
 199 |     |         string memory errorMessage
 200 |     |     ) internal view returns (bytes memory) {
 201 |     |         if (success) {
 202 |     |             if (returndata.length == 0) {
 203 |     |                 // only check isContract if the call was successful and the return data is empty
 204 |     |                 // otherwise we already know that it was a contract
 205 |     |                 require(isContract(target), "Address: call to non-contract");
 206 |     |             }
 207 |     |             return returndata;
 208 |     |         } else {
 209 |     |             _revert(returndata, errorMessage);
 210 |     |         }
 211 |     |     }
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
 215 |     |      * revert reason or using the provided one.
 216 |     |      *
 217 |     |      * _Available since v4.3._
 218 |     |      */
 219 |     |     function verifyCallResult(
 220 |     |         bool success,
 221 |     |         bytes memory returndata,
 222 |     |         string memory errorMessage
 223 |     |     ) internal pure returns (bytes memory) {
 224 |     |         if (success) {
 225 |     |             return returndata;
 226 |     |         } else {
 227 |     |             _revert(returndata, errorMessage);
 228 |     |         }
 229 |     |     }
 230 |     | 
 231 |     |     function _revert(bytes memory returndata, string memory errorMessage) private pure {
 232 |     |         // Look for revert reason and bubble it up if present
 233 |     |         if (returndata.length > 0) {
 234 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 235 |     |             /// @solidity memory-safe-assembly
 236 |     |             assembly {
 237 |     |                 let returndata_size := mload(returndata)
 238 |     |                 revert(add(32, returndata), returndata_size)
 239 |     |             }
 240 |     |         } else {
 241 |     |             revert(errorMessage);
 242 |     |         }
 243 |     |     }
 244 |     | }
 245 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | }
 25 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev These functions deal with verification of Merkle Tree proofs.
   8 |     |  *
   9 |     |  * The tree and the proofs can be generated using our
  10 |     |  * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].
  11 |     |  * You will find a quickstart guide in the readme.
  12 |     |  *
  13 |     |  * WARNING: You should avoid using leaf values that are 64 bytes long prior to
  14 |     |  * hashing, or use a hash function other than keccak256 for hashing leaves.
  15 |     |  * This is because the concatenation of a sorted pair of internal nodes in
  16 |     |  * the merkle tree could be reinterpreted as a leaf value.
  17 |     |  * OpenZeppelin's JavaScript library generates merkle trees that are safe
  18 |     |  * against this attack out of the box.
  19 |     |  */
  20 |     | library MerkleProof {
  21 |     |     /**
  22 |     |      * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
  23 |     |      * defined by `root`. For this, a `proof` must be provided, containing
  24 |     |      * sibling hashes on the branch from the leaf to the root of the tree. Each
  25 |     |      * pair of leaves and each pair of pre-images are assumed to be sorted.
  26 |     |      */
  27 |     |     function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {
  28 |     |         return processProof(proof, leaf) == root;
  29 |     |     }
  30 |     | 
  31 |     |     /**
  32 |     |      * @dev Calldata version of {verify}
  33 |     |      *
  34 |     |      * _Available since v4.7._
  35 |     |      */
  36 |     |     function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {
  37 |     |         return processProofCalldata(proof, leaf) == root;
  38 |     |     }
  39 |     | 
  40 |     |     /**
  41 |     |      * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up
  42 |     |      * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt
  43 |     |      * hash matches the root of the tree. When processing the proof, the pairs
  44 |     |      * of leafs & pre-images are assumed to be sorted.
  45 |     |      *
  46 |     |      * _Available since v4.4._
  47 |     |      */
  48 |     |     function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
  49 |     |         bytes32 computedHash = leaf;
  50 |     |         for (uint256 i = 0; i < proof.length; i++) {
  51 |     |             computedHash = _hashPair(computedHash, proof[i]);
  52 |     |         }
  53 |     |         return computedHash;
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Calldata version of {processProof}
  58 |     |      *
  59 |     |      * _Available since v4.7._
  60 |     |      */
  61 |     |     function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {
  62 |     |         bytes32 computedHash = leaf;
  63 |     |         for (uint256 i = 0; i < proof.length; i++) {
  64 |     |             computedHash = _hashPair(computedHash, proof[i]);
  65 |     |         }
  66 |     |         return computedHash;
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by
  71 |     |      * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.
  72 |     |      *
  73 |     |      * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.
  74 |     |      *
  75 |     |      * _Available since v4.7._
  76 |     |      */
  77 |     |     function multiProofVerify(
  78 |     |         bytes32[] memory proof,
  79 |     |         bool[] memory proofFlags,
  80 |     |         bytes32 root,
  81 |     |         bytes32[] memory leaves
  82 |     |     ) internal pure returns (bool) {
  83 |     |         return processMultiProof(proof, proofFlags, leaves) == root;
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @dev Calldata version of {multiProofVerify}
  88 |     |      *
  89 |     |      * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.
  90 |     |      *
  91 |     |      * _Available since v4.7._
  92 |     |      */
  93 |     |     function multiProofVerifyCalldata(
  94 |     |         bytes32[] calldata proof,
  95 |     |         bool[] calldata proofFlags,
  96 |     |         bytes32 root,
  97 |     |         bytes32[] memory leaves
  98 |     |     ) internal pure returns (bool) {
  99 |     |         return processMultiProofCalldata(proof, proofFlags, leaves) == root;
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction
 104 |     |      * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another
 105 |     |      * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false
 106 |     |      * respectively.
 107 |     |      *
 108 |     |      * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree
 109 |     |      * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the
 110 |     |      * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).
 111 |     |      *
 112 |     |      * _Available since v4.7._
 113 |     |      */
 114 |     |     function processMultiProof(
 115 |     |         bytes32[] memory proof,
 116 |     |         bool[] memory proofFlags,
 117 |     |         bytes32[] memory leaves
 118 |     |     ) internal pure returns (bytes32 merkleRoot) {
 119 |     |         // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by
 120 |     |         // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the
 121 |     |         // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of
 122 |     |         // the merkle tree.
 123 |     |         uint256 leavesLen = leaves.length;
 124 |     |         uint256 proofLen = proof.length;
 125 |     |         uint256 totalHashes = proofFlags.length;
 126 |     | 
 127 |     |         // Check proof validity.
 128 |     |         require(leavesLen + proofLen - 1 == totalHashes, "MerkleProof: invalid multiproof");
 129 |     | 
 130 |     |         // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using
 131 |     |         // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's "pop".
 132 |     |         bytes32[] memory hashes = new bytes32[](totalHashes);
 133 |     |         uint256 leafPos = 0;
 134 |     |         uint256 hashPos = 0;
 135 |     |         uint256 proofPos = 0;
 136 |     |         // At each step, we compute the next hash using two values:
 137 |     |         // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we
 138 |     |         //   get the next hash.
 139 |     |         // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the
 140 |     |         //   `proof` array.
 141 |     |         for (uint256 i = 0; i < totalHashes; i++) {
 142 |     |             bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
 143 |     |             bytes32 b = proofFlags[i]
 144 |     |                 ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])
 145 |     |                 : proof[proofPos++];
 146 |     |             hashes[i] = _hashPair(a, b);
 147 |     |         }
 148 |     | 
 149 |     |         if (totalHashes > 0) {
 150 |     |             require(proofPos == proofLen, "MerkleProof: invalid multiproof");
 151 |     |             unchecked {
 152 |     |                 return hashes[totalHashes - 1];
 153 |     |             }
 154 |     |         } else if (leavesLen > 0) {
 155 |     |             return leaves[0];
 156 |     |         } else {
 157 |     |             return proof[0];
 158 |     |         }
 159 |     |     }
 160 |     | 
 161 |     |     /**
 162 |     |      * @dev Calldata version of {processMultiProof}.
 163 |     |      *
 164 |     |      * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.
 165 |     |      *
 166 |     |      * _Available since v4.7._
 167 |     |      */
 168 |     |     function processMultiProofCalldata(
 169 |     |         bytes32[] calldata proof,
 170 |     |         bool[] calldata proofFlags,
 171 |     |         bytes32[] memory leaves
 172 |     |     ) internal pure returns (bytes32 merkleRoot) {
 173 |     |         // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by
 174 |     |         // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the
 175 |     |         // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of
 176 |     |         // the merkle tree.
 177 |     |         uint256 leavesLen = leaves.length;
 178 |     |         uint256 proofLen = proof.length;
 179 |     |         uint256 totalHashes = proofFlags.length;
 180 |     | 
 181 |     |         // Check proof validity.
 182 |     |         require(leavesLen + proofLen - 1 == totalHashes, "MerkleProof: invalid multiproof");
 183 |     | 
 184 |     |         // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using
 185 |     |         // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's "pop".
 186 |     |         bytes32[] memory hashes = new bytes32[](totalHashes);
 187 |     |         uint256 leafPos = 0;
 188 |     |         uint256 hashPos = 0;
 189 |     |         uint256 proofPos = 0;
 190 |     |         // At each step, we compute the next hash using two values:
 191 |     |         // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we
 192 |     |         //   get the next hash.
 193 |     |         // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the
 194 |     |         //   `proof` array.
 195 |     |         for (uint256 i = 0; i < totalHashes; i++) {
 196 |     |             bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
 197 |     |             bytes32 b = proofFlags[i]
 198 |     |                 ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])
 199 |     |                 : proof[proofPos++];
 200 |     |             hashes[i] = _hashPair(a, b);
 201 |     |         }
 202 |     | 
 203 |     |         if (totalHashes > 0) {
 204 |     |             require(proofPos == proofLen, "MerkleProof: invalid multiproof");
 205 |     |             unchecked {
 206 |     |                 return hashes[totalHashes - 1];
 207 |     |             }
 208 |     |         } else if (leavesLen > 0) {
 209 |     |             return leaves[0];
 210 |     |         } else {
 211 |     |             return proof[0];
 212 |     |         }
 213 |     |     }
 214 |     | 
 215 |     |     function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {
 216 |     |         return a < b ? _efficientHash(a, b) : _efficientHash(b, a);
 217 |     |     }
 218 |     | 
 219 |     |     function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {
 220 |     |         /// @solidity memory-safe-assembly
 221 |     |         assembly {
 222 |     |             mstore(0x00, a)
 223 |     |             mstore(0x20, b)
 224 |     |             value := keccak256(0x00, 0x40)
 225 |     |         }
 226 |     |     }
 227 |     | }
 228 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC165} interface.
 10 |     |  *
 11 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 12 |     |  * for the additional interface id that will be supported. For example:
 13 |     |  *
 14 |     |  * ```solidity
 15 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 16 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 17 |     |  * }
 18 |     |  * ```
 19 |     |  *
 20 |     |  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 21 |     |  */
 22 |     | abstract contract ERC165 is IERC165 {
 23 |     |     /**
 24 |     |      * @dev See {IERC165-supportsInterface}.
 25 |     |      */
 26 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 27 |     |         return interfaceId == type(IERC165).interfaceId;
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solady/src/tokens/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.4;
   3 |     | 
   4 |     | /// @notice Simple ERC20 + EIP-2612 implementation.
   5 |     | /// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)
   6 |     | /// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)
   7 |     | /// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)
   8 |     | ///
   9 |     | /// @dev Note:
  10 |     | /// - The ERC20 standard allows minting and transferring to and from the zero address,
  11 |     | ///   minting and transferring zero tokens, as well as self-approvals.
  12 |     | ///   For performance, this implementation WILL NOT revert for such actions.
  13 |     | ///   Please add any checks with overrides if desired.
  14 |     | /// - The `permit` function uses the ecrecover precompile (0x1).
  15 |     | ///
  16 |     | /// If you are overriding:
  17 |     | /// - NEVER violate the ERC20 invariant:
  18 |     | ///   the total sum of all balances must be equal to `totalSupply()`.
  19 |     | /// - Check that the overridden function is actually used in the function you want to
  20 |     | ///   change the behavior of. Much of the code has been manually inlined for performance.
  21 |     | abstract contract ERC20 {
  22 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  23 |     |     /*                       CUSTOM ERRORS                        */
  24 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  25 |     | 
  26 |     |     /// @dev The total supply has overflowed.
  27 |     |     error TotalSupplyOverflow();
  28 |     | 
  29 |     |     /// @dev The allowance has overflowed.
  30 |     |     error AllowanceOverflow();
  31 |     | 
  32 |     |     /// @dev The allowance has underflowed.
  33 |     |     error AllowanceUnderflow();
  34 |     | 
  35 |     |     /// @dev Insufficient balance.
  36 |     |     error InsufficientBalance();
  37 |     | 
  38 |     |     /// @dev Insufficient allowance.
  39 |     |     error InsufficientAllowance();
  40 |     | 
  41 |     |     /// @dev The permit is invalid.
  42 |     |     error InvalidPermit();
  43 |     | 
  44 |     |     /// @dev The permit has expired.
  45 |     |     error PermitExpired();
  46 |     | 
  47 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  48 |     |     /*                           EVENTS                           */
  49 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  50 |     | 
  51 |     |     /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.
  52 |     |     event Transfer(address indexed from, address indexed to, uint256 amount);
  53 |     | 
  54 |     |     /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.
  55 |     |     event Approval(address indexed owner, address indexed spender, uint256 amount);
  56 |     | 
  57 |     |     /// @dev `keccak256(bytes("Transfer(address,address,uint256)"))`.
  58 |     |     uint256 private constant _TRANSFER_EVENT_SIGNATURE =
  59 |     |         0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;
  60 |     | 
  61 |     |     /// @dev `keccak256(bytes("Approval(address,address,uint256)"))`.
  62 |     |     uint256 private constant _APPROVAL_EVENT_SIGNATURE =
  63 |     |         0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;
  64 |     | 
  65 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  66 |     |     /*                          STORAGE                           */
  67 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  68 |     | 
  69 |     |     /// @dev The storage slot for the total supply.
  70 |     |     uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;
  71 |     | 
  72 |     |     /// @dev The balance slot of `owner` is given by:
  73 |     |     /// ```
  74 |     |     ///     mstore(0x0c, _BALANCE_SLOT_SEED)
  75 |     |     ///     mstore(0x00, owner)
  76 |     |     ///     let balanceSlot := keccak256(0x0c, 0x20)
  77 |     |     /// ```
  78 |     |     uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;
  79 |     | 
  80 |     |     /// @dev The allowance slot of (`owner`, `spender`) is given by:
  81 |     |     /// ```
  82 |     |     ///     mstore(0x20, spender)
  83 |     |     ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)
  84 |     |     ///     mstore(0x00, owner)
  85 |     |     ///     let allowanceSlot := keccak256(0x0c, 0x34)
  86 |     |     /// ```
  87 |     |     uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;
  88 |     | 
  89 |     |     /// @dev The nonce slot of `owner` is given by:
  90 |     |     /// ```
  91 |     |     ///     mstore(0x0c, _NONCES_SLOT_SEED)
  92 |     |     ///     mstore(0x00, owner)
  93 |     |     ///     let nonceSlot := keccak256(0x0c, 0x20)
  94 |     |     /// ```
  95 |     |     uint256 private constant _NONCES_SLOT_SEED = 0x38377508;
  96 |     | 
  97 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  98 |     |     /*                         CONSTANTS                          */
  99 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 100 |     | 
 101 |     |     /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.
 102 |     |     uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;
 103 |     | 
 104 |     |     /// @dev `keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")`.
 105 |     |     bytes32 private constant _DOMAIN_TYPEHASH =
 106 |     |         0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;
 107 |     | 
 108 |     |     /// @dev `keccak256("1")`.
 109 |     |     bytes32 private constant _VERSION_HASH =
 110 |     |         0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;
 111 |     | 
 112 |     |     /// @dev `keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")`.
 113 |     |     bytes32 private constant _PERMIT_TYPEHASH =
 114 |     |         0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
 115 |     | 
 116 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 117 |     |     /*                       ERC20 METADATA                       */
 118 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 119 |     | 
 120 |     |     /// @dev Returns the name of the token.
 121 |     |     function name() public view virtual returns (string memory);
 122 |     | 
 123 |     |     /// @dev Returns the symbol of the token.
 124 |     |     function symbol() public view virtual returns (string memory);
 125 |     | 
 126 |     |     /// @dev Returns the decimals places of the token.
 127 |     |     function decimals() public view virtual returns (uint8) {
 128 |     |         return 18;
 129 |     |     }
 130 |     | 
 131 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 132 |     |     /*                           ERC20                            */
 133 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 134 |     | 
 135 |     |     /// @dev Returns the amount of tokens in existence.
 136 |     |     function totalSupply() public view virtual returns (uint256 result) {
 137 |     |         /// @solidity memory-safe-assembly
 138 |     |         assembly {
 139 |     |             result := sload(_TOTAL_SUPPLY_SLOT)
 140 |     |         }
 141 |     |     }
 142 |     | 
 143 |     |     /// @dev Returns the amount of tokens owned by `owner`.
 144 |     |     function balanceOf(address owner) public view virtual returns (uint256 result) {
 145 |     |         /// @solidity memory-safe-assembly
 146 |     |         assembly {
 147 |     |             mstore(0x0c, _BALANCE_SLOT_SEED)
 148 |     |             mstore(0x00, owner)
 149 |     |             result := sload(keccak256(0x0c, 0x20))
 150 |     |         }
 151 |     |     }
 152 |     | 
 153 |     |     /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.
 154 |     |     function allowance(address owner, address spender)
 155 |     |         public
 156 |     |         view
 157 |     |         virtual
 158 |     |         returns (uint256 result)
 159 |     |     {
 160 |     |         /// @solidity memory-safe-assembly
 161 |     |         assembly {
 162 |     |             mstore(0x20, spender)
 163 |     |             mstore(0x0c, _ALLOWANCE_SLOT_SEED)
 164 |     |             mstore(0x00, owner)
 165 |     |             result := sload(keccak256(0x0c, 0x34))
 166 |     |         }
 167 |     |     }
 168 |     | 
 169 |     |     /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 170 |     |     ///
 171 |     |     /// Emits a {Approval} event.
 172 |     |     function approve(address spender, uint256 amount) public virtual returns (bool) {
 173 |     |         /// @solidity memory-safe-assembly
 174 |     |         assembly {
 175 |     |             // Compute the allowance slot and store the amount.
 176 |     |             mstore(0x20, spender)
 177 |     |             mstore(0x0c, _ALLOWANCE_SLOT_SEED)
 178 |     |             mstore(0x00, caller())
 179 |     |             sstore(keccak256(0x0c, 0x34), amount)
 180 |     |             // Emit the {Approval} event.
 181 |     |             mstore(0x00, amount)
 182 |     |             log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))
 183 |     |         }
 184 |     |         return true;
 185 |     |     }
 186 |     | 
 187 |     |     /// @dev Transfer `amount` tokens from the caller to `to`.
 188 |     |     ///
 189 |     |     /// Requirements:
 190 |     |     /// - `from` must at least have `amount`.
 191 |     |     ///
 192 |     |     /// Emits a {Transfer} event.
 193 |     |     function transfer(address to, uint256 amount) public virtual returns (bool) {
 194 |     |         _beforeTokenTransfer(msg.sender, to, amount);
 195 |     |         /// @solidity memory-safe-assembly
 196 |     |         assembly {
 197 |     |             // Compute the balance slot and load its value.
 198 |     |             mstore(0x0c, _BALANCE_SLOT_SEED)
 199 |     |             mstore(0x00, caller())
 200 |     |             let fromBalanceSlot := keccak256(0x0c, 0x20)
 201 |     |             let fromBalance := sload(fromBalanceSlot)
 202 |     |             // Revert if insufficient balance.
 203 |     |             if gt(amount, fromBalance) {
 204 |     |                 mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.
 205 |     |                 revert(0x1c, 0x04)
 206 |     |             }
 207 |     |             // Subtract and store the updated balance.
 208 |     |             sstore(fromBalanceSlot, sub(fromBalance, amount))
 209 |     |             // Compute the balance slot of `to`.
 210 |     |             mstore(0x00, to)
 211 |     |             let toBalanceSlot := keccak256(0x0c, 0x20)
 212 |     |             // Add and store the updated balance of `to`.
 213 |     |             // Will not overflow because the sum of all user balances
 214 |     |             // cannot exceed the maximum uint256 value.
 215 |     |             sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))
 216 |     |             // Emit the {Transfer} event.
 217 |     |             mstore(0x20, amount)
 218 |     |             log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))
 219 |     |         }
 220 |     |         _afterTokenTransfer(msg.sender, to, amount);
 221 |     |         return true;
 222 |     |     }
 223 |     | 
 224 |     |     /// @dev Transfers `amount` tokens from `from` to `to`.
 225 |     |     ///
 226 |     |     /// Note: Does not update the allowance if it is the maximum uint256 value.
 227 |     |     ///
 228 |     |     /// Requirements:
 229 |     |     /// - `from` must at least have `amount`.
 230 |     |     /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.
 231 |     |     ///
 232 |     |     /// Emits a {Transfer} event.
 233 |     |     function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {
 234 |     |         _beforeTokenTransfer(from, to, amount);
 235 |     |         /// @solidity memory-safe-assembly
 236 |     |         assembly {
 237 |     |             let from_ := shl(96, from)
 238 |     |             // Compute the allowance slot and load its value.
 239 |     |             mstore(0x20, caller())
 240 |     |             mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))
 241 |     |             let allowanceSlot := keccak256(0x0c, 0x34)
 242 |     |             let allowance_ := sload(allowanceSlot)
 243 |     |             // If the allowance is not the maximum uint256 value.
 244 |     |             if add(allowance_, 1) {
 245 |     |                 // Revert if the amount to be transferred exceeds the allowance.
 246 |     |                 if gt(amount, allowance_) {
 247 |     |                     mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.
 248 |     |                     revert(0x1c, 0x04)
 249 |     |                 }
 250 |     |                 // Subtract and store the updated allowance.
 251 |     |                 sstore(allowanceSlot, sub(allowance_, amount))
 252 |     |             }
 253 |     |             // Compute the balance slot and load its value.
 254 |     |             mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))
 255 |     |             let fromBalanceSlot := keccak256(0x0c, 0x20)
 256 |     |             let fromBalance := sload(fromBalanceSlot)
 257 |     |             // Revert if insufficient balance.
 258 |     |             if gt(amount, fromBalance) {
 259 |     |                 mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.
 260 |     |                 revert(0x1c, 0x04)
 261 |     |             }
 262 |     |             // Subtract and store the updated balance.
 263 |     |             sstore(fromBalanceSlot, sub(fromBalance, amount))
 264 |     |             // Compute the balance slot of `to`.
 265 |     |             mstore(0x00, to)
 266 |     |             let toBalanceSlot := keccak256(0x0c, 0x20)
 267 |     |             // Add and store the updated balance of `to`.
 268 |     |             // Will not overflow because the sum of all user balances
 269 |     |             // cannot exceed the maximum uint256 value.
 270 |     |             sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))
 271 |     |             // Emit the {Transfer} event.
 272 |     |             mstore(0x20, amount)
 273 |     |             log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))
 274 |     |         }
 275 |     |         _afterTokenTransfer(from, to, amount);
 276 |     |         return true;
 277 |     |     }
 278 |     | 
 279 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 280 |     |     /*                          EIP-2612                          */
 281 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 282 |     | 
 283 |     |     /// @dev For more performance, override to return the constant value
 284 |     |     /// of `keccak256(bytes(name()))` if `name()` will never change.
 285 |     |     function _constantNameHash() internal view virtual returns (bytes32 result) {}
 286 |     | 
 287 |     |     /// @dev Returns the current nonce for `owner`.
 288 |     |     /// This value is used to compute the signature for EIP-2612 permit.
 289 |     |     function nonces(address owner) public view virtual returns (uint256 result) {
 290 |     |         /// @solidity memory-safe-assembly
 291 |     |         assembly {
 292 |     |             // Compute the nonce slot and load its value.
 293 |     |             mstore(0x0c, _NONCES_SLOT_SEED)
 294 |     |             mstore(0x00, owner)
 295 |     |             result := sload(keccak256(0x0c, 0x20))
 296 |     |         }
 297 |     |     }
 298 |     | 
 299 |     |     /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,
 300 |     |     /// authorized by a signed approval by `owner`.
 301 |     |     ///
 302 |     |     /// Emits a {Approval} event.
 303 |     |     function permit(
 304 |     |         address owner,
 305 |     |         address spender,
 306 |     |         uint256 value,
 307 |     |         uint256 deadline,
 308 |     |         uint8 v,
 309 |     |         bytes32 r,
 310 |     |         bytes32 s
 311 |     |     ) public virtual {
 312 |     |         bytes32 nameHash = _constantNameHash();
 313 |     |         //  We simply calculate it on-the-fly to allow for cases where the `name` may change.
 314 |     |         if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));
 315 |     |         /// @solidity memory-safe-assembly
 316 |     |         assembly {
 317 |     |             // Revert if the block timestamp is greater than `deadline`.
 318 |     |             if gt(timestamp(), deadline) {
 319 |     |                 mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.
 320 |     |                 revert(0x1c, 0x04)
 321 |     |             }
 322 |     |             let m := mload(0x40) // Grab the free memory pointer.
 323 |     |             // Clean the upper 96 bits.
 324 |     |             owner := shr(96, shl(96, owner))
 325 |     |             spender := shr(96, shl(96, spender))
 326 |     |             // Compute the nonce slot and load its value.
 327 |     |             mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)
 328 |     |             mstore(0x00, owner)
 329 |     |             let nonceSlot := keccak256(0x0c, 0x20)
 330 |     |             let nonceValue := sload(nonceSlot)
 331 |     |             // Prepare the domain separator.
 332 |     |             mstore(m, _DOMAIN_TYPEHASH)
 333 |     |             mstore(add(m, 0x20), nameHash)
 334 |     |             mstore(add(m, 0x40), _VERSION_HASH)
 335 |     |             mstore(add(m, 0x60), chainid())
 336 |     |             mstore(add(m, 0x80), address())
 337 |     |             mstore(0x2e, keccak256(m, 0xa0))
 338 |     |             // Prepare the struct hash.
 339 |     |             mstore(m, _PERMIT_TYPEHASH)
 340 |     |             mstore(add(m, 0x20), owner)
 341 |     |             mstore(add(m, 0x40), spender)
 342 |     |             mstore(add(m, 0x60), value)
 343 |     |             mstore(add(m, 0x80), nonceValue)
 344 |     |             mstore(add(m, 0xa0), deadline)
 345 |     |             mstore(0x4e, keccak256(m, 0xc0))
 346 |     |             // Prepare the ecrecover calldata.
 347 |     |             mstore(0x00, keccak256(0x2c, 0x42))
 348 |     |             mstore(0x20, and(0xff, v))
 349 |     |             mstore(0x40, r)
 350 |     |             mstore(0x60, s)
 351 |     |             let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)
 352 |     |             // If the ecrecover fails, the returndatasize will be 0x00,
 353 |     |             // `owner` will be checked if it equals the hash at 0x00,
 354 |     |             // which evaluates to false (i.e. 0), and we will revert.
 355 |     |             // If the ecrecover succeeds, the returndatasize will be 0x20,
 356 |     |             // `owner` will be compared against the returned address at 0x20.
 357 |     |             if iszero(eq(mload(returndatasize()), owner)) {
 358 |     |                 mstore(0x00, 0xddafbaef) // `InvalidPermit()`.
 359 |     |                 revert(0x1c, 0x04)
 360 |     |             }
 361 |     |             // Increment and store the updated nonce.
 362 |     |             sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.
 363 |     |             // Compute the allowance slot and store the value.
 364 |     |             // The `owner` is already at slot 0x20.
 365 |     |             mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))
 366 |     |             sstore(keccak256(0x2c, 0x34), value)
 367 |     |             // Emit the {Approval} event.
 368 |     |             log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)
 369 |     |             mstore(0x40, m) // Restore the free memory pointer.
 370 |     |             mstore(0x60, 0) // Restore the zero pointer.
 371 |     |         }
 372 |     |     }
 373 |     | 
 374 |     |     /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.
 375 |     |     function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {
 376 |     |         bytes32 nameHash = _constantNameHash();
 377 |     |         //  We simply calculate it on-the-fly to allow for cases where the `name` may change.
 378 |     |         if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));
 379 |     |         /// @solidity memory-safe-assembly
 380 |     |         assembly {
 381 |     |             let m := mload(0x40) // Grab the free memory pointer.
 382 |     |             mstore(m, _DOMAIN_TYPEHASH)
 383 |     |             mstore(add(m, 0x20), nameHash)
 384 |     |             mstore(add(m, 0x40), _VERSION_HASH)
 385 |     |             mstore(add(m, 0x60), chainid())
 386 |     |             mstore(add(m, 0x80), address())
 387 |     |             result := keccak256(m, 0xa0)
 388 |     |         }
 389 |     |     }
 390 |     | 
 391 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 392 |     |     /*                  INTERNAL MINT FUNCTIONS                   */
 393 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 394 |     | 
 395 |     |     /// @dev Mints `amount` tokens to `to`, increasing the total supply.
 396 |     |     ///
 397 |     |     /// Emits a {Transfer} event.
 398 |     |     function _mint(address to, uint256 amount) internal virtual {
 399 |     |         _beforeTokenTransfer(address(0), to, amount);
 400 |     |         /// @solidity memory-safe-assembly
 401 |     |         assembly {
 402 |     |             let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)
 403 |     |             let totalSupplyAfter := add(totalSupplyBefore, amount)
 404 |     |             // Revert if the total supply overflows.
 405 |     |             if lt(totalSupplyAfter, totalSupplyBefore) {
 406 |     |                 mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.
 407 |     |                 revert(0x1c, 0x04)
 408 |     |             }
 409 |     |             // Store the updated total supply.
 410 |     |             sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)
 411 |     |             // Compute the balance slot and load its value.
 412 |     |             mstore(0x0c, _BALANCE_SLOT_SEED)
 413 |     |             mstore(0x00, to)
 414 |     |             let toBalanceSlot := keccak256(0x0c, 0x20)
 415 |     |             // Add and store the updated balance.
 416 |     |             sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))
 417 |     |             // Emit the {Transfer} event.
 418 |     |             mstore(0x20, amount)
 419 |     |             log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))
 420 |     |         }
 421 |     |         _afterTokenTransfer(address(0), to, amount);
 422 |     |     }
 423 |     | 
 424 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 425 |     |     /*                  INTERNAL BURN FUNCTIONS                   */
 426 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 427 |     | 
 428 |     |     /// @dev Burns `amount` tokens from `from`, reducing the total supply.
 429 |     |     ///
 430 |     |     /// Emits a {Transfer} event.
 431 |     |     function _burn(address from, uint256 amount) internal virtual {
 432 |     |         _beforeTokenTransfer(from, address(0), amount);
 433 |     |         /// @solidity memory-safe-assembly
 434 |     |         assembly {
 435 |     |             // Compute the balance slot and load its value.
 436 |     |             mstore(0x0c, _BALANCE_SLOT_SEED)
 437 |     |             mstore(0x00, from)
 438 |     |             let fromBalanceSlot := keccak256(0x0c, 0x20)
 439 |     |             let fromBalance := sload(fromBalanceSlot)
 440 |     |             // Revert if insufficient balance.
 441 |     |             if gt(amount, fromBalance) {
 442 |     |                 mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.
 443 |     |                 revert(0x1c, 0x04)
 444 |     |             }
 445 |     |             // Subtract and store the updated balance.
 446 |     |             sstore(fromBalanceSlot, sub(fromBalance, amount))
 447 |     |             // Subtract and store the updated total supply.
 448 |     |             sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))
 449 |     |             // Emit the {Transfer} event.
 450 |     |             mstore(0x00, amount)
 451 |     |             log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)
 452 |     |         }
 453 |     |         _afterTokenTransfer(from, address(0), amount);
 454 |     |     }
 455 |     | 
 456 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 457 |     |     /*                INTERNAL TRANSFER FUNCTIONS                 */
 458 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 459 |     | 
 460 |     |     /// @dev Moves `amount` of tokens from `from` to `to`.
 461 |     |     function _transfer(address from, address to, uint256 amount) internal virtual {
 462 |     |         _beforeTokenTransfer(from, to, amount);
 463 |     |         /// @solidity memory-safe-assembly
 464 |     |         assembly {
 465 |     |             let from_ := shl(96, from)
 466 |     |             // Compute the balance slot and load its value.
 467 |     |             mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))
 468 |     |             let fromBalanceSlot := keccak256(0x0c, 0x20)
 469 |     |             let fromBalance := sload(fromBalanceSlot)
 470 |     |             // Revert if insufficient balance.
 471 |     |             if gt(amount, fromBalance) {
 472 |     |                 mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.
 473 |     |                 revert(0x1c, 0x04)
 474 |     |             }
 475 |     |             // Subtract and store the updated balance.
 476 |     |             sstore(fromBalanceSlot, sub(fromBalance, amount))
 477 |     |             // Compute the balance slot of `to`.
 478 |     |             mstore(0x00, to)
 479 |     |             let toBalanceSlot := keccak256(0x0c, 0x20)
 480 |     |             // Add and store the updated balance of `to`.
 481 |     |             // Will not overflow because the sum of all user balances
 482 |     |             // cannot exceed the maximum uint256 value.
 483 |     |             sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))
 484 |     |             // Emit the {Transfer} event.
 485 |     |             mstore(0x20, amount)
 486 |     |             log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))
 487 |     |         }
 488 |     |         _afterTokenTransfer(from, to, amount);
 489 |     |     }
 490 |     | 
 491 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 492 |     |     /*                INTERNAL ALLOWANCE FUNCTIONS                */
 493 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 494 |     | 
 495 |     |     /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.
 496 |     |     function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
 497 |     |         /// @solidity memory-safe-assembly
 498 |     |         assembly {
 499 |     |             // Compute the allowance slot and load its value.
 500 |     |             mstore(0x20, spender)
 501 |     |             mstore(0x0c, _ALLOWANCE_SLOT_SEED)
 502 |     |             mstore(0x00, owner)
 503 |     |             let allowanceSlot := keccak256(0x0c, 0x34)
 504 |     |             let allowance_ := sload(allowanceSlot)
 505 |     |             // If the allowance is not the maximum uint256 value.
 506 |     |             if add(allowance_, 1) {
 507 |     |                 // Revert if the amount to be transferred exceeds the allowance.
 508 |     |                 if gt(amount, allowance_) {
 509 |     |                     mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.
 510 |     |                     revert(0x1c, 0x04)
 511 |     |                 }
 512 |     |                 // Subtract and store the updated allowance.
 513 |     |                 sstore(allowanceSlot, sub(allowance_, amount))
 514 |     |             }
 515 |     |         }
 516 |     |     }
 517 |     | 
 518 |     |     /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.
 519 |     |     ///
 520 |     |     /// Emits a {Approval} event.
 521 |     |     function _approve(address owner, address spender, uint256 amount) internal virtual {
 522 |     |         /// @solidity memory-safe-assembly
 523 |     |         assembly {
 524 |     |             let owner_ := shl(96, owner)
 525 |     |             // Compute the allowance slot and store the amount.
 526 |     |             mstore(0x20, spender)
 527 |     |             mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))
 528 |     |             sstore(keccak256(0x0c, 0x34), amount)
 529 |     |             // Emit the {Approval} event.
 530 |     |             mstore(0x00, amount)
 531 |     |             log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))
 532 |     |         }
 533 |     |     }
 534 |     | 
 535 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 536 |     |     /*                     HOOKS TO OVERRIDE                      */
 537 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 538 |     | 
 539 |     |     /// @dev Hook that is called before any transfer of tokens.
 540 |     |     /// This includes minting and burning.
 541 |     |     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 542 |     | 
 543 |     |     /// @dev Hook that is called after any transfer of tokens.
 544 |     |     /// This includes minting and burning.
 545 |     |     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 546 |     | }
 547 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solady/src/utils/FixedPointMathLib.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity ^0.8.4;
    3 |     | 
    4 |     | /// @notice Arithmetic library with operations for fixed-point numbers.
    5 |     | /// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)
    6 |     | /// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)
    7 |     | library FixedPointMathLib {
    8 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    9 |     |     /*                       CUSTOM ERRORS                        */
   10 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
   11 |     | 
   12 |     |     /// @dev The operation failed, as the output exceeds the maximum value of uint256.
   13 |     |     error ExpOverflow();
   14 |     | 
   15 |     |     /// @dev The operation failed, as the output exceeds the maximum value of uint256.
   16 |     |     error FactorialOverflow();
   17 |     | 
   18 |     |     /// @dev The operation failed, due to an overflow.
   19 |     |     error RPowOverflow();
   20 |     | 
   21 |     |     /// @dev The mantissa is too big to fit.
   22 |     |     error MantissaOverflow();
   23 |     | 
   24 |     |     /// @dev The operation failed, due to an multiplication overflow.
   25 |     |     error MulWadFailed();
   26 |     | 
   27 |     |     /// @dev The operation failed, due to an multiplication overflow.
   28 |     |     error SMulWadFailed();
   29 |     | 
   30 |     |     /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.
   31 |     |     error DivWadFailed();
   32 |     | 
   33 |     |     /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.
   34 |     |     error SDivWadFailed();
   35 |     | 
   36 |     |     /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.
   37 |     |     error MulDivFailed();
   38 |     | 
   39 |     |     /// @dev The division failed, as the denominator is zero.
   40 |     |     error DivFailed();
   41 |     | 
   42 |     |     /// @dev The full precision multiply-divide operation failed, either due
   43 |     |     /// to the result being larger than 256 bits, or a division by a zero.
   44 |     |     error FullMulDivFailed();
   45 |     | 
   46 |     |     /// @dev The output is undefined, as the input is less-than-or-equal to zero.
   47 |     |     error LnWadUndefined();
   48 |     | 
   49 |     |     /// @dev The input outside the acceptable domain.
   50 |     |     error OutOfDomain();
   51 |     | 
   52 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
   53 |     |     /*                         CONSTANTS                          */
   54 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
   55 |     | 
   56 |     |     /// @dev The scalar of ETH and most ERC20s.
   57 |     |     uint256 internal constant WAD = 1e18;
   58 |     | 
   59 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
   60 |     |     /*              SIMPLIFIED FIXED POINT OPERATIONS             */
   61 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
   62 |     | 
   63 |     |     /// @dev Equivalent to `(x * y) / WAD` rounded down.
   64 |     |     function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {
   65 |     |         /// @solidity memory-safe-assembly
   66 |     |         assembly {
   67 |     |             // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.
   68 |     |             if mul(y, gt(x, div(not(0), y))) {
   69 |     |                 mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.
   70 |     |                 revert(0x1c, 0x04)
   71 |     |             }
   72 |     |             z := div(mul(x, y), WAD)
   73 |     |         }
   74 |     |     }
   75 |     | 
   76 |     |     /// @dev Equivalent to `(x * y) / WAD` rounded down.
   77 |     |     function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {
   78 |     |         /// @solidity memory-safe-assembly
   79 |     |         assembly {
   80 |     |             z := mul(x, y)
   81 |     |             // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.
   82 |     |             if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {
   83 |     |                 mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.
   84 |     |                 revert(0x1c, 0x04)
   85 |     |             }
   86 |     |             z := sdiv(z, WAD)
   87 |     |         }
   88 |     |     }
   89 |     | 
   90 |     |     /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.
   91 |     |     function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {
   92 |     |         /// @solidity memory-safe-assembly
   93 |     |         assembly {
   94 |     |             z := div(mul(x, y), WAD)
   95 |     |         }
   96 |     |     }
   97 |     | 
   98 |     |     /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.
   99 |     |     function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {
  100 |     |         /// @solidity memory-safe-assembly
  101 |     |         assembly {
  102 |     |             z := sdiv(mul(x, y), WAD)
  103 |     |         }
  104 |     |     }
  105 |     | 
  106 |     |     /// @dev Equivalent to `(x * y) / WAD` rounded up.
  107 |     |     function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
  108 |     |         /// @solidity memory-safe-assembly
  109 |     |         assembly {
  110 |     |             // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.
  111 |     |             if mul(y, gt(x, div(not(0), y))) {
  112 |     |                 mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.
  113 |     |                 revert(0x1c, 0x04)
  114 |     |             }
  115 |     |             z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))
  116 |     |         }
  117 |     |     }
  118 |     | 
  119 |     |     /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.
  120 |     |     function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
  121 |     |         /// @solidity memory-safe-assembly
  122 |     |         assembly {
  123 |     |             z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))
  124 |     |         }
  125 |     |     }
  126 |     | 
  127 |     |     /// @dev Equivalent to `(x * WAD) / y` rounded down.
  128 |     |     function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {
  129 |     |         /// @solidity memory-safe-assembly
  130 |     |         assembly {
  131 |     |             // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.
  132 |     |             if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {
  133 |     |                 mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.
  134 |     |                 revert(0x1c, 0x04)
  135 |     |             }
  136 |     |             z := div(mul(x, WAD), y)
  137 |     |         }
  138 |     |     }
  139 |     | 
  140 |     |     /// @dev Equivalent to `(x * WAD) / y` rounded down.
  141 |     |     function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {
  142 |     |         /// @solidity memory-safe-assembly
  143 |     |         assembly {
  144 |     |             z := mul(x, WAD)
  145 |     |             // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.
  146 |     |             if iszero(and(iszero(iszero(y)), eq(sdiv(z, WAD), x))) {
  147 |     |                 mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.
  148 |     |                 revert(0x1c, 0x04)
  149 |     |             }
  150 |     |             z := sdiv(mul(x, WAD), y)
  151 |     |         }
  152 |     |     }
  153 |     | 
  154 |     |     /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.
  155 |     |     function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {
  156 |     |         /// @solidity memory-safe-assembly
  157 |     |         assembly {
  158 |     |             z := div(mul(x, WAD), y)
  159 |     |         }
  160 |     |     }
  161 |     | 
  162 |     |     /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.
  163 |     |     function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {
  164 |     |         /// @solidity memory-safe-assembly
  165 |     |         assembly {
  166 |     |             z := sdiv(mul(x, WAD), y)
  167 |     |         }
  168 |     |     }
  169 |     | 
  170 |     |     /// @dev Equivalent to `(x * WAD) / y` rounded up.
  171 |     |     function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
  172 |     |         /// @solidity memory-safe-assembly
  173 |     |         assembly {
  174 |     |             // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.
  175 |     |             if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {
  176 |     |                 mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.
  177 |     |                 revert(0x1c, 0x04)
  178 |     |             }
  179 |     |             z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))
  180 |     |         }
  181 |     |     }
  182 |     | 
  183 |     |     /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.
  184 |     |     function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
  185 |     |         /// @solidity memory-safe-assembly
  186 |     |         assembly {
  187 |     |             z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))
  188 |     |         }
  189 |     |     }
  190 |     | 
  191 |     |     /// @dev Equivalent to `x` to the power of `y`.
  192 |     |     /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.
  193 |     |     function powWad(int256 x, int256 y) internal pure returns (int256) {
  194 |     |         // Using `ln(x)` means `x` must be greater than 0.
  195 |     |         return expWad((lnWad(x) * y) / int256(WAD));
  196 |     |     }
  197 |     | 
  198 |     |     /// @dev Returns `exp(x)`, denominated in `WAD`.
  199 |     |     /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln
  200 |     |     function expWad(int256 x) internal pure returns (int256 r) {
  201 |     |         unchecked {
  202 |     |             // When the result is less than 0.5 we return zero.
  203 |     |             // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.
  204 |     |             if (x <= -41446531673892822313) return r;
  205 |     | 
  206 |     |             /// @solidity memory-safe-assembly
  207 |     |             assembly {
  208 |     |                 // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as
  209 |     |                 // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) ≈ 135`.
  210 |     |                 if iszero(slt(x, 135305999368893231589)) {
  211 |     |                     mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.
  212 |     |                     revert(0x1c, 0x04)
  213 |     |                 }
  214 |     |             }
  215 |     | 
  216 |     |             // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`
  217 |     |             // for more intermediate precision and a binary basis. This base conversion
  218 |     |             // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.
  219 |     |             x = (x << 78) / 5 ** 18;
  220 |     | 
  221 |     |             // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers
  222 |     |             // of two such that exp(x) = exp(x') * 2**k, where k is an integer.
  223 |     |             // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).
  224 |     |             int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;
  225 |     |             x = x - k * 54916777467707473351141471128;
  226 |     | 
  227 |     |             // `k` is in the range `[-61, 195]`.
  228 |     | 
  229 |     |             // Evaluate using a (6, 7)-term rational approximation.
  230 |     |             // `p` is made monic, we'll multiply by a scale factor later.
  231 |     |             int256 y = x + 1346386616545796478920950773328;
  232 |     |             y = ((y * x) >> 96) + 57155421227552351082224309758442;
  233 |     |             int256 p = y + x - 94201549194550492254356042504812;
  234 |     |             p = ((p * y) >> 96) + 28719021644029726153956944680412240;
  235 |     |             p = p * x + (4385272521454847904659076985693276 << 96);
  236 |     | 
  237 |     |             // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.
  238 |     |             int256 q = x - 2855989394907223263936484059900;
  239 |     |             q = ((q * x) >> 96) + 50020603652535783019961831881945;
  240 |     |             q = ((q * x) >> 96) - 533845033583426703283633433725380;
  241 |     |             q = ((q * x) >> 96) + 3604857256930695427073651918091429;
  242 |     |             q = ((q * x) >> 96) - 14423608567350463180887372962807573;
  243 |     |             q = ((q * x) >> 96) + 26449188498355588339934803723976023;
  244 |     | 
  245 |     |             /// @solidity memory-safe-assembly
  246 |     |             assembly {
  247 |     |                 // Div in assembly because solidity adds a zero check despite the unchecked.
  248 |     |                 // The q polynomial won't have zeros in the domain as all its roots are complex.
  249 |     |                 // No scaling is necessary because p is already `2**96` too large.
  250 |     |                 r := sdiv(p, q)
  251 |     |             }
  252 |     | 
  253 |     |             // r should be in the range `(0.09, 0.25) * 2**96`.
  254 |     | 
  255 |     |             // We now need to multiply r by:
  256 |     |             // - The scale factor `s ≈ 6.031367120`.
  257 |     |             // - The `2**k` factor from the range reduction.
  258 |     |             // - The `1e18 / 2**96` factor for base conversion.
  259 |     |             // We do this all at once, with an intermediate result in `2**213`
  260 |     |             // basis, so the final right shift is always by a positive amount.
  261 |     |             r = int256(
  262 |     |                 (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)
  263 |     |             );
  264 |     |         }
  265 |     |     }
  266 |     | 
  267 |     |     /// @dev Returns `ln(x)`, denominated in `WAD`.
  268 |     |     /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln
  269 |     |     function lnWad(int256 x) internal pure returns (int256 r) {
  270 |     |         /// @solidity memory-safe-assembly
  271 |     |         assembly {
  272 |     |             // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.
  273 |     |             // We do this by multiplying by `2**96 / 10**18`. But since
  274 |     |             // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here
  275 |     |             // and add `ln(2**96 / 10**18)` at the end.
  276 |     | 
  277 |     |             // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.
  278 |     |             r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))
  279 |     |             r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))
  280 |     |             r := or(r, shl(5, lt(0xffffffff, shr(r, x))))
  281 |     |             r := or(r, shl(4, lt(0xffff, shr(r, x))))
  282 |     |             r := or(r, shl(3, lt(0xff, shr(r, x))))
  283 |     |             // We place the check here for more optimal stack operations.
  284 |     |             if iszero(sgt(x, 0)) {
  285 |     |                 mstore(0x00, 0x1615e638) // `LnWadUndefined()`.
  286 |     |                 revert(0x1c, 0x04)
  287 |     |             }
  288 |     |             // forgefmt: disable-next-item
  289 |     |             r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),
  290 |     |                 0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))
  291 |     | 
  292 |     |             // Reduce range of x to (1, 2) * 2**96
  293 |     |             // ln(2^k * x) = k * ln(2) + ln(x)
  294 |     |             x := shr(159, shl(r, x))
  295 |     | 
  296 |     |             // Evaluate using a (8, 8)-term rational approximation.
  297 |     |             // `p` is made monic, we will multiply by a scale factor later.
  298 |     |             // forgefmt: disable-next-item
  299 |     |             let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.
  300 |     |                 sar(96, mul(add(43456485725739037958740375743393,
  301 |     |                 sar(96, mul(add(24828157081833163892658089445524,
  302 |     |                 sar(96, mul(add(3273285459638523848632254066296,
  303 |     |                     x), x))), x))), x)), 11111509109440967052023855526967)
  304 |     |             p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)
  305 |     |             p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)
  306 |     |             p := sub(mul(p, x), shl(96, 795164235651350426258249787498))
  307 |     |             // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.
  308 |     | 
  309 |     |             // `q` is monic by convention.
  310 |     |             let q := add(5573035233440673466300451813936, x)
  311 |     |             q := add(71694874799317883764090561454958, sar(96, mul(x, q)))
  312 |     |             q := add(283447036172924575727196451306956, sar(96, mul(x, q)))
  313 |     |             q := add(401686690394027663651624208769553, sar(96, mul(x, q)))
  314 |     |             q := add(204048457590392012362485061816622, sar(96, mul(x, q)))
  315 |     |             q := add(31853899698501571402653359427138, sar(96, mul(x, q)))
  316 |     |             q := add(909429971244387300277376558375, sar(96, mul(x, q)))
  317 |     | 
  318 |     |             // `p / q` is in the range `(0, 0.125) * 2**96`.
  319 |     | 
  320 |     |             // Finalization, we need to:
  321 |     |             // - Multiply by the scale factor `s = 5.549…`.
  322 |     |             // - Add `ln(2**96 / 10**18)`.
  323 |     |             // - Add `k * ln(2)`.
  324 |     |             // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.
  325 |     | 
  326 |     |             // The q polynomial is known not to have zeros in the domain.
  327 |     |             // No scaling required because p is already `2**96` too large.
  328 |     |             p := sdiv(p, q)
  329 |     |             // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.
  330 |     |             p := mul(1677202110996718588342820967067443963516166, p)
  331 |     |             // Add `ln(2) * k * 5**18 * 2**192`.
  332 |     |             // forgefmt: disable-next-item
  333 |     |             p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)
  334 |     |             // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.
  335 |     |             p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)
  336 |     |             // Base conversion: mul `2**18 / 2**192`.
  337 |     |             r := sar(174, p)
  338 |     |         }
  339 |     |     }
  340 |     | 
  341 |     |     /// @dev Returns `W_0(x)`, denominated in `WAD`.
  342 |     |     /// See: https://en.wikipedia.org/wiki/Lambert_W_function
  343 |     |     /// a.k.a. Product log function. This is an approximation of the principal branch.
  344 |     |     function lambertW0Wad(int256 x) internal pure returns (int256 w) {
  345 |     |         // forgefmt: disable-next-item
  346 |     |         unchecked {
  347 |     |             if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.
  348 |     |             int256 wad = int256(WAD);
  349 |     |             int256 p = x;
  350 |     |             uint256 c; // Whether we need to avoid catastrophic cancellation.
  351 |     |             uint256 i = 4; // Number of iterations.
  352 |     |             if (w <= 0x1ffffffffffff) {
  353 |     |                 if (-0x4000000000000 <= w) {
  354 |     |                     i = 1; // Inputs near zero only take one step to converge.
  355 |     |                 } else if (w <= -0x3ffffffffffffff) {
  356 |     |                     i = 32; // Inputs near `-1/e` take very long to converge.
  357 |     |                 }
  358 |     |             } else if (w >> 63 == 0) {
  359 |     |                 /// @solidity memory-safe-assembly
  360 |     |                 assembly {
  361 |     |                     // Inline log2 for more performance, since the range is small.
  362 |     |                     let v := shr(49, w)
  363 |     |                     let l := shl(3, lt(0xff, v))
  364 |     |                     l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),
  365 |     |                         0x0706060506020504060203020504030106050205030304010505030400000000)), 49)
  366 |     |                     w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))
  367 |     |                     c := gt(l, 60)
  368 |     |                     i := add(2, add(gt(l, 53), c))
  369 |     |                 }
  370 |     |             } else {
  371 |     |                 int256 ll = lnWad(w = lnWad(w));
  372 |     |                 /// @solidity memory-safe-assembly
  373 |     |                 assembly {
  374 |     |                     // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.
  375 |     |                     w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))
  376 |     |                     i := add(3, iszero(shr(68, x)))
  377 |     |                     c := iszero(shr(143, x))
  378 |     |                 }
  379 |     |                 if (c == 0) {
  380 |     |                     do { // If `x` is big, use Newton's so that intermediate values won't overflow.
  381 |     |                         int256 e = expWad(w);
  382 |     |                         /// @solidity memory-safe-assembly
  383 |     |                         assembly {
  384 |     |                             let t := mul(w, div(e, wad))
  385 |     |                             w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))
  386 |     |                         }
  387 |     |                         if (p <= w) break;
  388 |     |                         p = w;
  389 |     |                     } while (--i != 0);
  390 |     |                     /// @solidity memory-safe-assembly
  391 |     |                     assembly {
  392 |     |                         w := sub(w, sgt(w, 2))
  393 |     |                     }
  394 |     |                     return w;
  395 |     |                 }
  396 |     |             }
  397 |     |             do { // Otherwise, use Halley's for faster convergence.
  398 |     |                 int256 e = expWad(w);
  399 |     |                 /// @solidity memory-safe-assembly
  400 |     |                 assembly {
  401 |     |                     let t := add(w, wad)
  402 |     |                     let s := sub(mul(w, e), mul(x, wad))
  403 |     |                     w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))
  404 |     |                 }
  405 |     |                 if (p <= w) break;
  406 |     |                 p = w;
  407 |     |             } while (--i != c);
  408 |     |             /// @solidity memory-safe-assembly
  409 |     |             assembly {
  410 |     |                 w := sub(w, sgt(w, 2))
  411 |     |             }
  412 |     |             // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of
  413 |     |             // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.
  414 |     |             if (c != 0) {
  415 |     |                 int256 t = w | 1;
  416 |     |                 /// @solidity memory-safe-assembly
  417 |     |                 assembly {
  418 |     |                     x := sdiv(mul(x, wad), t)
  419 |     |                 }
  420 |     |                 x = (t * (wad + lnWad(x)));
  421 |     |                 /// @solidity memory-safe-assembly
  422 |     |                 assembly {
  423 |     |                     w := sdiv(x, add(wad, t))
  424 |     |                 }
  425 |     |             }
  426 |     |         }
  427 |     |     }
  428 |     | 
  429 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  430 |     |     /*                  GENERAL NUMBER UTILITIES                  */
  431 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  432 |     | 
  433 |     |     /// @dev Calculates `floor(x * y / d)` with full precision.
  434 |     |     /// Throws if result overflows a uint256 or when `d` is zero.
  435 |     |     /// Credit to Remco Bloemen under MIT license: https://2π.com/21/muldiv
  436 |     |     function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {
  437 |     |         /// @solidity memory-safe-assembly
  438 |     |         assembly {
  439 |     |             for {} 1 {} {
  440 |     |                 // 512-bit multiply `[p1 p0] = x * y`.
  441 |     |                 // Compute the product mod `2**256` and mod `2**256 - 1`
  442 |     |                 // then use the Chinese Remainder Theorem to reconstruct
  443 |     |                 // the 512 bit result. The result is stored in two 256
  444 |     |                 // variables such that `product = p1 * 2**256 + p0`.
  445 |     | 
  446 |     |                 // Least significant 256 bits of the product.
  447 |     |                 result := mul(x, y) // Temporarily use `result` as `p0` to save gas.
  448 |     |                 let mm := mulmod(x, y, not(0))
  449 |     |                 // Most significant 256 bits of the product.
  450 |     |                 let p1 := sub(mm, add(result, lt(mm, result)))
  451 |     | 
  452 |     |                 // Handle non-overflow cases, 256 by 256 division.
  453 |     |                 if iszero(p1) {
  454 |     |                     if iszero(d) {
  455 |     |                         mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.
  456 |     |                         revert(0x1c, 0x04)
  457 |     |                     }
  458 |     |                     result := div(result, d)
  459 |     |                     break
  460 |     |                 }
  461 |     | 
  462 |     |                 // Make sure the result is less than `2**256`. Also prevents `d == 0`.
  463 |     |                 if iszero(gt(d, p1)) {
  464 |     |                     mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.
  465 |     |                     revert(0x1c, 0x04)
  466 |     |                 }
  467 |     | 
  468 |     |                 /*------------------- 512 by 256 division --------------------*/
  469 |     | 
  470 |     |                 // Make division exact by subtracting the remainder from `[p1 p0]`.
  471 |     |                 // Compute remainder using mulmod.
  472 |     |                 let r := mulmod(x, y, d)
  473 |     |                 // `t` is the least significant bit of `d`.
  474 |     |                 // Always greater or equal to 1.
  475 |     |                 let t := and(d, sub(0, d))
  476 |     |                 // Divide `d` by `t`, which is a power of two.
  477 |     |                 d := div(d, t)
  478 |     |                 // Invert `d mod 2**256`
  479 |     |                 // Now that `d` is an odd number, it has an inverse
  480 |     |                 // modulo `2**256` such that `d * inv = 1 mod 2**256`.
  481 |     |                 // Compute the inverse by starting with a seed that is correct
  482 |     |                 // correct for four bits. That is, `d * inv = 1 mod 2**4`.
  483 |     |                 let inv := xor(2, mul(3, d))
  484 |     |                 // Now use Newton-Raphson iteration to improve the precision.
  485 |     |                 // Thanks to Hensel's lifting lemma, this also works in modular
  486 |     |                 // arithmetic, doubling the correct bits in each step.
  487 |     |                 inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8
  488 |     |                 inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16
  489 |     |                 inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32
  490 |     |                 inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64
  491 |     |                 inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128
  492 |     |                 result :=
  493 |     |                     mul(
  494 |     |                         // Divide [p1 p0] by the factors of two.
  495 |     |                         // Shift in bits from `p1` into `p0`. For this we need
  496 |     |                         // to flip `t` such that it is `2**256 / t`.
  497 |     |                         or(
  498 |     |                             mul(sub(p1, gt(r, result)), add(div(sub(0, t), t), 1)),
  499 |     |                             div(sub(result, r), t)
  500 |     |                         ),
  501 |     |                         // inverse mod 2**256
  502 |     |                         mul(inv, sub(2, mul(d, inv)))
  503 |     |                     )
  504 |     |                 break
  505 |     |             }
  506 |     |         }
  507 |     |     }
  508 |     | 
  509 |     |     /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.
  510 |     |     /// Throws if result overflows a uint256 or when `d` is zero.
  511 |     |     /// Credit to Uniswap-v3-core under MIT license:
  512 |     |     /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol
  513 |     |     function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {
  514 |     |         result = fullMulDiv(x, y, d);
  515 |     |         /// @solidity memory-safe-assembly
  516 |     |         assembly {
  517 |     |             if mulmod(x, y, d) {
  518 |     |                 result := add(result, 1)
  519 |     |                 if iszero(result) {
  520 |     |                     mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.
  521 |     |                     revert(0x1c, 0x04)
  522 |     |                 }
  523 |     |             }
  524 |     |         }
  525 |     |     }
  526 |     | 
  527 |     |     /// @dev Returns `floor(x * y / d)`.
  528 |     |     /// Reverts if `x * y` overflows, or `d` is zero.
  529 |     |     function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {
  530 |     |         /// @solidity memory-safe-assembly
  531 |     |         assembly {
  532 |     |             // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))
  533 |     |             if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {
  534 |     |                 mstore(0x00, 0xad251c27) // `MulDivFailed()`.
  535 |     |                 revert(0x1c, 0x04)
  536 |     |             }
  537 |     |             z := div(mul(x, y), d)
  538 |     |         }
  539 |     |     }
  540 |     | 
  541 |     |     /// @dev Returns `ceil(x * y / d)`.
  542 |     |     /// Reverts if `x * y` overflows, or `d` is zero.
  543 |     |     function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {
  544 |     |         /// @solidity memory-safe-assembly
  545 |     |         assembly {
  546 |     |             // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))
  547 |     |             if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {
  548 |     |                 mstore(0x00, 0xad251c27) // `MulDivFailed()`.
  549 |     |                 revert(0x1c, 0x04)
  550 |     |             }
  551 |     |             z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))
  552 |     |         }
  553 |     |     }
  554 |     | 
  555 |     |     /// @dev Returns `ceil(x / d)`.
  556 |     |     /// Reverts if `d` is zero.
  557 |     |     function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {
  558 |     |         /// @solidity memory-safe-assembly
  559 |     |         assembly {
  560 |     |             if iszero(d) {
  561 |     |                 mstore(0x00, 0x65244e4e) // `DivFailed()`.
  562 |     |                 revert(0x1c, 0x04)
  563 |     |             }
  564 |     |             z := add(iszero(iszero(mod(x, d))), div(x, d))
  565 |     |         }
  566 |     |     }
  567 |     | 
  568 |     |     /// @dev Returns `max(0, x - y)`.
  569 |     |     function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {
  570 |     |         /// @solidity memory-safe-assembly
  571 |     |         assembly {
  572 |     |             z := mul(gt(x, y), sub(x, y))
  573 |     |         }
  574 |     |     }
  575 |     | 
  576 |     |     /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.
  577 |     |     /// Reverts if the computation overflows.
  578 |     |     function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {
  579 |     |         /// @solidity memory-safe-assembly
  580 |     |         assembly {
  581 |     |             z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.
  582 |     |             if x {
  583 |     |                 z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`
  584 |     |                 let half := shr(1, b) // Divide `b` by 2.
  585 |     |                 // Divide `y` by 2 every iteration.
  586 |     |                 for { y := shr(1, y) } y { y := shr(1, y) } {
  587 |     |                     let xx := mul(x, x) // Store x squared.
  588 |     |                     let xxRound := add(xx, half) // Round to the nearest number.
  589 |     |                     // Revert if `xx + half` overflowed, or if `x ** 2` overflows.
  590 |     |                     if or(lt(xxRound, xx), shr(128, x)) {
  591 |     |                         mstore(0x00, 0x49f7642b) // `RPowOverflow()`.
  592 |     |                         revert(0x1c, 0x04)
  593 |     |                     }
  594 |     |                     x := div(xxRound, b) // Set `x` to scaled `xxRound`.
  595 |     |                     // If `y` is odd:
  596 |     |                     if and(y, 1) {
  597 |     |                         let zx := mul(z, x) // Compute `z * x`.
  598 |     |                         let zxRound := add(zx, half) // Round to the nearest number.
  599 |     |                         // If `z * x` overflowed or `zx + half` overflowed:
  600 |     |                         if or(xor(div(zx, x), z), lt(zxRound, zx)) {
  601 |     |                             // Revert if `x` is non-zero.
  602 |     |                             if iszero(iszero(x)) {
  603 |     |                                 mstore(0x00, 0x49f7642b) // `RPowOverflow()`.
  604 |     |                                 revert(0x1c, 0x04)
  605 |     |                             }
  606 |     |                         }
  607 |     |                         z := div(zxRound, b) // Return properly scaled `zxRound`.
  608 |     |                     }
  609 |     |                 }
  610 |     |             }
  611 |     |         }
  612 |     |     }
  613 |     | 
  614 |     |     /// @dev Returns the square root of `x`.
  615 |     |     function sqrt(uint256 x) internal pure returns (uint256 z) {
  616 |     |         /// @solidity memory-safe-assembly
  617 |     |         assembly {
  618 |     |             // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.
  619 |     |             z := 181 // The "correct" value is 1, but this saves a multiplication later.
  620 |     | 
  621 |     |             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
  622 |     |             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
  623 |     | 
  624 |     |             // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`
  625 |     |             // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.
  626 |     |             let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))
  627 |     |             r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))
  628 |     |             r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))
  629 |     |             r := or(r, shl(4, lt(0xffffff, shr(r, x))))
  630 |     |             z := shl(shr(1, r), z)
  631 |     | 
  632 |     |             // Goal was to get `z*z*y` within a small factor of `x`. More iterations could
  633 |     |             // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.
  634 |     |             // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.
  635 |     |             // That's not possible if `x < 256` but we can just verify those cases exhaustively.
  636 |     | 
  637 |     |             // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.
  638 |     |             // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.
  639 |     |             // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.
  640 |     | 
  641 |     |             // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`
  642 |     |             // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,
  643 |     |             // with largest error when `s = 1` and when `s = 256` or `1/256`.
  644 |     | 
  645 |     |             // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.
  646 |     |             // Then we can estimate `sqrt(y)` using
  647 |     |             // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.
  648 |     | 
  649 |     |             // There is no overflow risk here since `y < 2**136` after the first branch above.
  650 |     |             z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.
  651 |     | 
  652 |     |             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
  653 |     |             z := shr(1, add(z, div(x, z)))
  654 |     |             z := shr(1, add(z, div(x, z)))
  655 |     |             z := shr(1, add(z, div(x, z)))
  656 |     |             z := shr(1, add(z, div(x, z)))
  657 |     |             z := shr(1, add(z, div(x, z)))
  658 |     |             z := shr(1, add(z, div(x, z)))
  659 |     |             z := shr(1, add(z, div(x, z)))
  660 |     | 
  661 |     |             // If `x+1` is a perfect square, the Babylonian method cycles between
  662 |     |             // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.
  663 |     |             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
  664 |     |             z := sub(z, lt(div(x, z), z))
  665 |     |         }
  666 |     |     }
  667 |     | 
  668 |     |     /// @dev Returns the cube root of `x`.
  669 |     |     /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:
  670 |     |     /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy
  671 |     |     function cbrt(uint256 x) internal pure returns (uint256 z) {
  672 |     |         /// @solidity memory-safe-assembly
  673 |     |         assembly {
  674 |     |             let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))
  675 |     |             r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))
  676 |     |             r := or(r, shl(5, lt(0xffffffff, shr(r, x))))
  677 |     |             r := or(r, shl(4, lt(0xffff, shr(r, x))))
  678 |     |             r := or(r, shl(3, lt(0xff, shr(r, x))))
  679 |     | 
  680 |     |             z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))
  681 |     | 
  682 |     |             z := div(add(add(div(x, mul(z, z)), z), z), 3)
  683 |     |             z := div(add(add(div(x, mul(z, z)), z), z), 3)
  684 |     |             z := div(add(add(div(x, mul(z, z)), z), z), 3)
  685 |     |             z := div(add(add(div(x, mul(z, z)), z), z), 3)
  686 |     |             z := div(add(add(div(x, mul(z, z)), z), z), 3)
  687 |     |             z := div(add(add(div(x, mul(z, z)), z), z), 3)
  688 |     |             z := div(add(add(div(x, mul(z, z)), z), z), 3)
  689 |     | 
  690 |     |             z := sub(z, lt(div(x, mul(z, z)), z))
  691 |     |         }
  692 |     |     }
  693 |     | 
  694 |     |     /// @dev Returns the square root of `x`, denominated in `WAD`.
  695 |     |     function sqrtWad(uint256 x) internal pure returns (uint256 z) {
  696 |     |         unchecked {
  697 |     |             z = 10 ** 9;
  698 |     |             if (x <= type(uint256).max / 10 ** 36 - 1) {
  699 |     |                 x *= 10 ** 18;
  700 |     |                 z = 1;
  701 |     |             }
  702 |     |             z *= sqrt(x);
  703 |     |         }
  704 |     |     }
  705 |     | 
  706 |     |     /// @dev Returns the cube root of `x`, denominated in `WAD`.
  707 |     |     function cbrtWad(uint256 x) internal pure returns (uint256 z) {
  708 |     |         unchecked {
  709 |     |             z = 10 ** 12;
  710 |     |             if (x <= (type(uint256).max / 10 ** 36) * 10 ** 18 - 1) {
  711 |     |                 if (x >= type(uint256).max / 10 ** 36) {
  712 |     |                     x *= 10 ** 18;
  713 |     |                     z = 10 ** 6;
  714 |     |                 } else {
  715 |     |                     x *= 10 ** 36;
  716 |     |                     z = 1;
  717 |     |                 }
  718 |     |             }
  719 |     |             z *= cbrt(x);
  720 |     |         }
  721 |     |     }
  722 |     | 
  723 |     |     /// @dev Returns the factorial of `x`.
  724 |     |     function factorial(uint256 x) internal pure returns (uint256 result) {
  725 |     |         /// @solidity memory-safe-assembly
  726 |     |         assembly {
  727 |     |             if iszero(lt(x, 58)) {
  728 |     |                 mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.
  729 |     |                 revert(0x1c, 0x04)
  730 |     |             }
  731 |     |             for { result := 1 } x { x := sub(x, 1) } { result := mul(result, x) }
  732 |     |         }
  733 |     |     }
  734 |     | 
  735 |     |     /// @dev Returns the log2 of `x`.
  736 |     |     /// Equivalent to computing the index of the most significant bit (MSB) of `x`.
  737 |     |     /// Returns 0 if `x` is zero.
  738 |     |     function log2(uint256 x) internal pure returns (uint256 r) {
  739 |     |         /// @solidity memory-safe-assembly
  740 |     |         assembly {
  741 |     |             r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))
  742 |     |             r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))
  743 |     |             r := or(r, shl(5, lt(0xffffffff, shr(r, x))))
  744 |     |             r := or(r, shl(4, lt(0xffff, shr(r, x))))
  745 |     |             r := or(r, shl(3, lt(0xff, shr(r, x))))
  746 |     |             // forgefmt: disable-next-item
  747 |     |             r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),
  748 |     |                 0x0706060506020504060203020504030106050205030304010505030400000000))
  749 |     |         }
  750 |     |     }
  751 |     | 
  752 |     |     /// @dev Returns the log2 of `x`, rounded up.
  753 |     |     /// Returns 0 if `x` is zero.
  754 |     |     function log2Up(uint256 x) internal pure returns (uint256 r) {
  755 |     |         r = log2(x);
  756 |     |         /// @solidity memory-safe-assembly
  757 |     |         assembly {
  758 |     |             r := add(r, lt(shl(r, 1), x))
  759 |     |         }
  760 |     |     }
  761 |     | 
  762 |     |     /// @dev Returns the log10 of `x`.
  763 |     |     /// Returns 0 if `x` is zero.
  764 |     |     function log10(uint256 x) internal pure returns (uint256 r) {
  765 |     |         /// @solidity memory-safe-assembly
  766 |     |         assembly {
  767 |     |             if iszero(lt(x, 100000000000000000000000000000000000000)) {
  768 |     |                 x := div(x, 100000000000000000000000000000000000000)
  769 |     |                 r := 38
  770 |     |             }
  771 |     |             if iszero(lt(x, 100000000000000000000)) {
  772 |     |                 x := div(x, 100000000000000000000)
  773 |     |                 r := add(r, 20)
  774 |     |             }
  775 |     |             if iszero(lt(x, 10000000000)) {
  776 |     |                 x := div(x, 10000000000)
  777 |     |                 r := add(r, 10)
  778 |     |             }
  779 |     |             if iszero(lt(x, 100000)) {
  780 |     |                 x := div(x, 100000)
  781 |     |                 r := add(r, 5)
  782 |     |             }
  783 |     |             r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))
  784 |     |         }
  785 |     |     }
  786 |     | 
  787 |     |     /// @dev Returns the log10 of `x`, rounded up.
  788 |     |     /// Returns 0 if `x` is zero.
  789 |     |     function log10Up(uint256 x) internal pure returns (uint256 r) {
  790 |     |         r = log10(x);
  791 |     |         /// @solidity memory-safe-assembly
  792 |     |         assembly {
  793 |     |             r := add(r, lt(exp(10, r), x))
  794 |     |         }
  795 |     |     }
  796 |     | 
  797 |     |     /// @dev Returns the log256 of `x`.
  798 |     |     /// Returns 0 if `x` is zero.
  799 |     |     function log256(uint256 x) internal pure returns (uint256 r) {
  800 |     |         /// @solidity memory-safe-assembly
  801 |     |         assembly {
  802 |     |             r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))
  803 |     |             r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))
  804 |     |             r := or(r, shl(5, lt(0xffffffff, shr(r, x))))
  805 |     |             r := or(r, shl(4, lt(0xffff, shr(r, x))))
  806 |     |             r := or(shr(3, r), lt(0xff, shr(r, x)))
  807 |     |         }
  808 |     |     }
  809 |     | 
  810 |     |     /// @dev Returns the log256 of `x`, rounded up.
  811 |     |     /// Returns 0 if `x` is zero.
  812 |     |     function log256Up(uint256 x) internal pure returns (uint256 r) {
  813 |     |         r = log256(x);
  814 |     |         /// @solidity memory-safe-assembly
  815 |     |         assembly {
  816 |     |             r := add(r, lt(shl(shl(3, r), 1), x))
  817 |     |         }
  818 |     |     }
  819 |     | 
  820 |     |     /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.
  821 |     |     /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).
  822 |     |     function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {
  823 |     |         /// @solidity memory-safe-assembly
  824 |     |         assembly {
  825 |     |             mantissa := x
  826 |     |             if mantissa {
  827 |     |                 if iszero(mod(mantissa, 1000000000000000000000000000000000)) {
  828 |     |                     mantissa := div(mantissa, 1000000000000000000000000000000000)
  829 |     |                     exponent := 33
  830 |     |                 }
  831 |     |                 if iszero(mod(mantissa, 10000000000000000000)) {
  832 |     |                     mantissa := div(mantissa, 10000000000000000000)
  833 |     |                     exponent := add(exponent, 19)
  834 |     |                 }
  835 |     |                 if iszero(mod(mantissa, 1000000000000)) {
  836 |     |                     mantissa := div(mantissa, 1000000000000)
  837 |     |                     exponent := add(exponent, 12)
  838 |     |                 }
  839 |     |                 if iszero(mod(mantissa, 1000000)) {
  840 |     |                     mantissa := div(mantissa, 1000000)
  841 |     |                     exponent := add(exponent, 6)
  842 |     |                 }
  843 |     |                 if iszero(mod(mantissa, 10000)) {
  844 |     |                     mantissa := div(mantissa, 10000)
  845 |     |                     exponent := add(exponent, 4)
  846 |     |                 }
  847 |     |                 if iszero(mod(mantissa, 100)) {
  848 |     |                     mantissa := div(mantissa, 100)
  849 |     |                     exponent := add(exponent, 2)
  850 |     |                 }
  851 |     |                 if iszero(mod(mantissa, 10)) {
  852 |     |                     mantissa := div(mantissa, 10)
  853 |     |                     exponent := add(exponent, 1)
  854 |     |                 }
  855 |     |             }
  856 |     |         }
  857 |     |     }
  858 |     | 
  859 |     |     /// @dev Convenience function for packing `x` into a smaller number using `sci`.
  860 |     |     /// The `mantissa` will be in bits [7..255] (the upper 249 bits).
  861 |     |     /// The `exponent` will be in bits [0..6] (the lower 7 bits).
  862 |     |     /// Use `SafeCastLib` to safely ensure that the `packed` number is small
  863 |     |     /// enough to fit in the desired unsigned integer type:
  864 |     |     /// ```
  865 |     |     ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));
  866 |     |     /// ```
  867 |     |     function packSci(uint256 x) internal pure returns (uint256 packed) {
  868 |     |         (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.
  869 |     |         /// @solidity memory-safe-assembly
  870 |     |         assembly {
  871 |     |             if shr(249, x) {
  872 |     |                 mstore(0x00, 0xce30380c) // `MantissaOverflow()`.
  873 |     |                 revert(0x1c, 0x04)
  874 |     |             }
  875 |     |             packed := or(shl(7, x), packed)
  876 |     |         }
  877 |     |     }
  878 |     | 
  879 |     |     /// @dev Convenience function for unpacking a packed number from `packSci`.
  880 |     |     function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {
  881 |     |         unchecked {
  882 |     |             unpacked = (packed >> 7) * 10 ** (packed & 0x7f);
  883 |     |         }
  884 |     |     }
  885 |     | 
  886 |     |     /// @dev Returns the average of `x` and `y`.
  887 |     |     function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {
  888 |     |         unchecked {
  889 |     |             z = (x & y) + ((x ^ y) >> 1);
  890 |     |         }
  891 |     |     }
  892 |     | 
  893 |     |     /// @dev Returns the average of `x` and `y`.
  894 |     |     function avg(int256 x, int256 y) internal pure returns (int256 z) {
  895 |     |         unchecked {
  896 |     |             z = (x >> 1) + (y >> 1) + (((x & 1) + (y & 1)) >> 1);
  897 |     |         }
  898 |     |     }
  899 |     | 
  900 |     |     /// @dev Returns the absolute value of `x`.
  901 |     |     function abs(int256 x) internal pure returns (uint256 z) {
  902 |     |         /// @solidity memory-safe-assembly
  903 |     |         assembly {
  904 |     |             z := xor(sub(0, shr(255, x)), add(sub(0, shr(255, x)), x))
  905 |     |         }
  906 |     |     }
  907 |     | 
  908 |     |     /// @dev Returns the absolute distance between `x` and `y`.
  909 |     |     function dist(int256 x, int256 y) internal pure returns (uint256 z) {
  910 |     |         /// @solidity memory-safe-assembly
  911 |     |         assembly {
  912 |     |             z := xor(mul(xor(sub(y, x), sub(x, y)), sgt(x, y)), sub(y, x))
  913 |     |         }
  914 |     |     }
  915 |     | 
  916 |     |     /// @dev Returns the minimum of `x` and `y`.
  917 |     |     function min(uint256 x, uint256 y) internal pure returns (uint256 z) {
  918 |     |         /// @solidity memory-safe-assembly
  919 |     |         assembly {
  920 |     |             z := xor(x, mul(xor(x, y), lt(y, x)))
  921 |     |         }
  922 |     |     }
  923 |     | 
  924 |     |     /// @dev Returns the minimum of `x` and `y`.
  925 |     |     function min(int256 x, int256 y) internal pure returns (int256 z) {
  926 |     |         /// @solidity memory-safe-assembly
  927 |     |         assembly {
  928 |     |             z := xor(x, mul(xor(x, y), slt(y, x)))
  929 |     |         }
  930 |     |     }
  931 |     | 
  932 |     |     /// @dev Returns the maximum of `x` and `y`.
  933 |     |     function max(uint256 x, uint256 y) internal pure returns (uint256 z) {
  934 |     |         /// @solidity memory-safe-assembly
  935 |     |         assembly {
  936 |     |             z := xor(x, mul(xor(x, y), gt(y, x)))
  937 |     |         }
  938 |     |     }
  939 |     | 
  940 |     |     /// @dev Returns the maximum of `x` and `y`.
  941 |     |     function max(int256 x, int256 y) internal pure returns (int256 z) {
  942 |     |         /// @solidity memory-safe-assembly
  943 |     |         assembly {
  944 |     |             z := xor(x, mul(xor(x, y), sgt(y, x)))
  945 |     |         }
  946 |     |     }
  947 |     | 
  948 |     |     /// @dev Returns `x`, bounded to `minValue` and `maxValue`.
  949 |     |     function clamp(uint256 x, uint256 minValue, uint256 maxValue)
  950 |     |         internal
  951 |     |         pure
  952 |     |         returns (uint256 z)
  953 |     |     {
  954 |     |         /// @solidity memory-safe-assembly
  955 |     |         assembly {
  956 |     |             z := xor(x, mul(xor(x, minValue), gt(minValue, x)))
  957 |     |             z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))
  958 |     |         }
  959 |     |     }
  960 |     | 
  961 |     |     /// @dev Returns `x`, bounded to `minValue` and `maxValue`.
  962 |     |     function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {
  963 |     |         /// @solidity memory-safe-assembly
  964 |     |         assembly {
  965 |     |             z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))
  966 |     |             z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))
  967 |     |         }
  968 |     |     }
  969 |     | 
  970 |     |     /// @dev Returns greatest common divisor of `x` and `y`.
  971 |     |     function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {
  972 |     |         /// @solidity memory-safe-assembly
  973 |     |         assembly {
  974 |     |             for { z := x } y {} {
  975 |     |                 let t := y
  976 |     |                 y := mod(z, y)
  977 |     |                 z := t
  978 |     |             }
  979 |     |         }
  980 |     |     }
  981 |     | 
  982 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  983 |     |     /*                   RAW NUMBER OPERATIONS                    */
  984 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  985 |     | 
  986 |     |     /// @dev Returns `x + y`, without checking for overflow.
  987 |     |     function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {
  988 |     |         unchecked {
  989 |     |             z = x + y;
  990 |     |         }
  991 |     |     }
  992 |     | 
  993 |     |     /// @dev Returns `x + y`, without checking for overflow.
  994 |     |     function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {
  995 |     |         unchecked {
  996 |     |             z = x + y;
  997 |     |         }
  998 |     |     }
  999 |     | 
 1000 |     |     /// @dev Returns `x - y`, without checking for underflow.
 1001 |     |     function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {
 1002 |     |         unchecked {
 1003 |     |             z = x - y;
 1004 |     |         }
 1005 |     |     }
 1006 |     | 
 1007 |     |     /// @dev Returns `x - y`, without checking for underflow.
 1008 |     |     function rawSub(int256 x, int256 y) internal pure returns (int256 z) {
 1009 |     |         unchecked {
 1010 |     |             z = x - y;
 1011 |     |         }
 1012 |     |     }
 1013 |     | 
 1014 |     |     /// @dev Returns `x * y`, without checking for overflow.
 1015 |     |     function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {
 1016 |     |         unchecked {
 1017 |     |             z = x * y;
 1018 |     |         }
 1019 |     |     }
 1020 |     | 
 1021 |     |     /// @dev Returns `x * y`, without checking for overflow.
 1022 |     |     function rawMul(int256 x, int256 y) internal pure returns (int256 z) {
 1023 |     |         unchecked {
 1024 |     |             z = x * y;
 1025 |     |         }
 1026 |     |     }
 1027 |     | 
 1028 |     |     /// @dev Returns `x / y`, returning 0 if `y` is zero.
 1029 |     |     function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {
 1030 |     |         /// @solidity memory-safe-assembly
 1031 |     |         assembly {
 1032 |     |             z := div(x, y)
 1033 |     |         }
 1034 |     |     }
 1035 |     | 
 1036 |     |     /// @dev Returns `x / y`, returning 0 if `y` is zero.
 1037 |     |     function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {
 1038 |     |         /// @solidity memory-safe-assembly
 1039 |     |         assembly {
 1040 |     |             z := sdiv(x, y)
 1041 |     |         }
 1042 |     |     }
 1043 |     | 
 1044 |     |     /// @dev Returns `x % y`, returning 0 if `y` is zero.
 1045 |     |     function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {
 1046 |     |         /// @solidity memory-safe-assembly
 1047 |     |         assembly {
 1048 |     |             z := mod(x, y)
 1049 |     |         }
 1050 |     |     }
 1051 |     | 
 1052 |     |     /// @dev Returns `x % y`, returning 0 if `y` is zero.
 1053 |     |     function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {
 1054 |     |         /// @solidity memory-safe-assembly
 1055 |     |         assembly {
 1056 |     |             z := smod(x, y)
 1057 |     |         }
 1058 |     |     }
 1059 |     | 
 1060 |     |     /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.
 1061 |     |     function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {
 1062 |     |         /// @solidity memory-safe-assembly
 1063 |     |         assembly {
 1064 |     |             z := addmod(x, y, d)
 1065 |     |         }
 1066 |     |     }
 1067 |     | 
 1068 |     |     /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.
 1069 |     |     function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {
 1070 |     |         /// @solidity memory-safe-assembly
 1071 |     |         assembly {
 1072 |     |             z := mulmod(x, y, d)
 1073 |     |         }
 1074 |     |     }
 1075 |     | }
 1076 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solady/src/utils/LibClone.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity ^0.8.4;
    3 |     | 
    4 |     | /// @notice Minimal proxy library.
    5 |     | /// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)
    6 |     | /// @author Minimal proxy by 0age (https://github.com/0age)
    7 |     | /// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie
    8 |     | /// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)
    9 |     | /// @author Minimal ERC1967 proxy by jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)
   10 |     | ///
   11 |     | /// @dev Minimal proxy:
   12 |     | /// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,
   13 |     | /// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,
   14 |     | /// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.
   15 |     | ///
   16 |     | /// @dev Minimal proxy (PUSH0 variant):
   17 |     | /// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.
   18 |     | /// It is optimized first for minimal runtime gas, then for minimal bytecode.
   19 |     | /// The PUSH0 clone functions are intentionally postfixed with a jarring "_PUSH0" as
   20 |     | /// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.
   21 |     | /// Please use with caution.
   22 |     | ///
   23 |     | /// @dev Clones with immutable args (CWIA):
   24 |     | /// The implementation of CWIA here implements a `receive()` method that emits the
   25 |     | /// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,
   26 |     | /// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards
   27 |     | /// composability. The minimal proxy implementation does not offer this feature.
   28 |     | ///
   29 |     | /// @dev Minimal ERC1967 proxy:
   30 |     | /// An minimal ERC1967 proxy, intended to be upgraded with UUPS.
   31 |     | /// This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.
   32 |     | ///
   33 |     | /// @dev ERC1967I proxy:
   34 |     | /// An variant of the minimal ERC1967 proxy, with a special code path that activates
   35 |     | /// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the
   36 |     | /// `implementation` address. The returned implementation is guaranteed to be valid if the
   37 |     | /// keccak256 of the proxy's code is equal to `ERC1967I_CODE_HASH`.
   38 |     | library LibClone {
   39 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
   40 |     |     /*                         CONSTANTS                          */
   41 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
   42 |     | 
   43 |     |     /// @dev The keccak256 of the deployed code for the ERC1967 proxy.
   44 |     |     bytes32 internal constant ERC1967_CODE_HASH =
   45 |     |         0xaaa52c8cc8a0e3fd27ce756cc6b4e70c51423e9b597b11f32d3e49f8b1fc890d;
   46 |     | 
   47 |     |     /// @dev The keccak256 of the deployed code for the ERC1967I proxy.
   48 |     |     bytes32 internal constant ERC1967I_CODE_HASH =
   49 |     |         0xce700223c0d4cea4583409accfc45adac4a093b3519998a9cbbe1504dadba6f7;
   50 |     | 
   51 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
   52 |     |     /*                       CUSTOM ERRORS                        */
   53 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
   54 |     | 
   55 |     |     /// @dev Unable to deploy the clone.
   56 |     |     error DeploymentFailed();
   57 |     | 
   58 |     |     /// @dev The salt must start with either the zero address or `by`.
   59 |     |     error SaltDoesNotStartWith();
   60 |     | 
   61 |     |     /// @dev The ETH transfer has failed.
   62 |     |     error ETHTransferFailed();
   63 |     | 
   64 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
   65 |     |     /*                  MINIMAL PROXY OPERATIONS                  */
   66 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
   67 |     | 
   68 |     |     /// @dev Deploys a clone of `implementation`.
   69 |     |     function clone(address implementation) internal returns (address instance) {
   70 |     |         instance = clone(0, implementation);
   71 |     |     }
   72 |     | 
   73 |     |     /// @dev Deploys a clone of `implementation`.
   74 |     |     /// Deposits `value` ETH during deployment.
   75 |     |     function clone(uint256 value, address implementation) internal returns (address instance) {
   76 |     |         /// @solidity memory-safe-assembly
   77 |     |         assembly {
   78 |     |             /**
   79 |     |              * --------------------------------------------------------------------------+
   80 |     |              * CREATION (9 bytes)                                                        |
   81 |     |              * --------------------------------------------------------------------------|
   82 |     |              * Opcode     | Mnemonic          | Stack     | Memory                       |
   83 |     |              * --------------------------------------------------------------------------|
   84 |     |              * 60 runSize | PUSH1 runSize     | r         |                              |
   85 |     |              * 3d         | RETURNDATASIZE    | 0 r       |                              |
   86 |     |              * 81         | DUP2              | r 0 r     |                              |
   87 |     |              * 60 offset  | PUSH1 offset      | o r 0 r   |                              |
   88 |     |              * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |
   89 |     |              * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |
   90 |     |              * f3         | RETURN            |           | [0..runSize): runtime code   |
   91 |     |              * --------------------------------------------------------------------------|
   92 |     |              * RUNTIME (44 bytes)                                                        |
   93 |     |              * --------------------------------------------------------------------------|
   94 |     |              * Opcode  | Mnemonic       | Stack                  | Memory                |
   95 |     |              * --------------------------------------------------------------------------|
   96 |     |              *                                                                           |
   97 |     |              * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |
   98 |     |              * 3d      | RETURNDATASIZE | 0                      |                       |
   99 |     |              * 3d      | RETURNDATASIZE | 0 0                    |                       |
  100 |     |              * 3d      | RETURNDATASIZE | 0 0 0                  |                       |
  101 |     |              * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |
  102 |     |              *                                                                           |
  103 |     |              * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |
  104 |     |              * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |
  105 |     |              * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |
  106 |     |              * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |
  107 |     |              * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |
  108 |     |              *                                                                           |
  109 |     |              * ::: delegate call to the implementation contract :::::::::::::::::::::::: |
  110 |     |              * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |
  111 |     |              * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |
  112 |     |              * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |
  113 |     |              * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |
  114 |     |              * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |
  115 |     |              *                                                                           |
  116 |     |              * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |
  117 |     |              * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |
  118 |     |              * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |
  119 |     |              * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |
  120 |     |              * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |
  121 |     |              * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |
  122 |     |              *                                                                           |
  123 |     |              * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |
  124 |     |              * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |
  125 |     |              *                                                                           |
  126 |     |              * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |
  127 |     |              * fd      | REVERT         |                        | [0..rds): returndata  |
  128 |     |              *                                                                           |
  129 |     |              * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |
  130 |     |              * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |
  131 |     |              * f3      | RETURN         |                        | [0..rds): returndata  |
  132 |     |              * --------------------------------------------------------------------------+
  133 |     |              */
  134 |     |             mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)
  135 |     |             mstore(0x14, implementation)
  136 |     |             mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)
  137 |     |             instance := create(value, 0x0c, 0x35)
  138 |     |             if iszero(instance) {
  139 |     |                 mstore(0x00, 0x30116425) // `DeploymentFailed()`.
  140 |     |                 revert(0x1c, 0x04)
  141 |     |             }
  142 |     |             mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.
  143 |     |         }
  144 |     |     }
  145 |     | 
  146 |     |     /// @dev Deploys a deterministic clone of `implementation` with `salt`.
  147 | *   |     function cloneDeterministic(address implementation, bytes32 salt)
  148 |     |         internal
  149 | *   |         returns (address instance)
  150 |     |     {
  151 | *   |         instance = cloneDeterministic(0, implementation, salt);
  152 |     |     }
  153 |     | 
  154 |     |     /// @dev Deploys a deterministic clone of `implementation` with `salt`.
  155 |     |     /// Deposits `value` ETH during deployment.
  156 | *   |     function cloneDeterministic(uint256 value, address implementation, bytes32 salt)
  157 |     |         internal
  158 | *   |         returns (address instance)
  159 |     |     {
  160 |     |         /// @solidity memory-safe-assembly
  161 |     |         assembly {
  162 | *   |             mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)
  163 | *   |             mstore(0x14, implementation)
  164 | *   |             mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)
  165 | *   |             instance := create2(value, 0x0c, 0x35, salt)
  166 | *   |             if iszero(instance) {
  167 | *   |                 mstore(0x00, 0x30116425) // `DeploymentFailed()`.
  168 | *   |                 revert(0x1c, 0x04)
  169 |     |             }
  170 | *   |             mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.
  171 |     |         }
  172 |     |     }
  173 |     | 
  174 |     |     /// @dev Returns the initialization code of the clone of `implementation`.
  175 |     |     function initCode(address implementation) internal pure returns (bytes memory result) {
  176 |     |         /// @solidity memory-safe-assembly
  177 |     |         assembly {
  178 |     |             result := mload(0x40)
  179 |     |             mstore(add(result, 0x40), 0x5af43d3d93803e602a57fd5bf30000000000000000000000)
  180 |     |             mstore(add(result, 0x28), implementation)
  181 |     |             mstore(add(result, 0x14), 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)
  182 |     |             mstore(result, 0x35) // Store the length.
  183 |     |             mstore(0x40, add(result, 0x60)) // Allocate memory.
  184 |     |         }
  185 |     |     }
  186 |     | 
  187 |     |     /// @dev Returns the initialization code hash of the clone of `implementation`.
  188 |     |     /// Used for mining vanity addresses with create2crunch.
  189 |     |     function initCodeHash(address implementation) internal pure returns (bytes32 hash) {
  190 |     |         /// @solidity memory-safe-assembly
  191 |     |         assembly {
  192 |     |             mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)
  193 |     |             mstore(0x14, implementation)
  194 |     |             mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)
  195 |     |             hash := keccak256(0x0c, 0x35)
  196 |     |             mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.
  197 |     |         }
  198 |     |     }
  199 |     | 
  200 |     |     /// @dev Returns the address of the deterministic clone of `implementation`,
  201 |     |     /// with `salt` by `deployer`.
  202 |     |     /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.
  203 |     |     function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)
  204 |     |         internal
  205 |     |         pure
  206 |     |         returns (address predicted)
  207 |     |     {
  208 |     |         bytes32 hash = initCodeHash(implementation);
  209 |     |         predicted = predictDeterministicAddress(hash, salt, deployer);
  210 |     |     }
  211 |     | 
  212 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  213 |     |     /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */
  214 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  215 |     | 
  216 |     |     /// @dev Deploys a PUSH0 clone of `implementation`.
  217 |     |     function clone_PUSH0(address implementation) internal returns (address instance) {
  218 |     |         instance = clone_PUSH0(0, implementation);
  219 |     |     }
  220 |     | 
  221 |     |     /// @dev Deploys a PUSH0 clone of `implementation`.
  222 |     |     /// Deposits `value` ETH during deployment.
  223 |     |     function clone_PUSH0(uint256 value, address implementation)
  224 |     |         internal
  225 |     |         returns (address instance)
  226 |     |     {
  227 |     |         /// @solidity memory-safe-assembly
  228 |     |         assembly {
  229 |     |             /**
  230 |     |              * --------------------------------------------------------------------------+
  231 |     |              * CREATION (9 bytes)                                                        |
  232 |     |              * --------------------------------------------------------------------------|
  233 |     |              * Opcode     | Mnemonic          | Stack     | Memory                       |
  234 |     |              * --------------------------------------------------------------------------|
  235 |     |              * 60 runSize | PUSH1 runSize     | r         |                              |
  236 |     |              * 5f         | PUSH0             | 0 r       |                              |
  237 |     |              * 81         | DUP2              | r 0 r     |                              |
  238 |     |              * 60 offset  | PUSH1 offset      | o r 0 r   |                              |
  239 |     |              * 5f         | PUSH0             | 0 o r 0 r |                              |
  240 |     |              * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |
  241 |     |              * f3         | RETURN            |           | [0..runSize): runtime code   |
  242 |     |              * --------------------------------------------------------------------------|
  243 |     |              * RUNTIME (45 bytes)                                                        |
  244 |     |              * --------------------------------------------------------------------------|
  245 |     |              * Opcode  | Mnemonic       | Stack                  | Memory                |
  246 |     |              * --------------------------------------------------------------------------|
  247 |     |              *                                                                           |
  248 |     |              * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |
  249 |     |              * 5f      | PUSH0          | 0                      |                       |
  250 |     |              * 5f      | PUSH0          | 0 0                    |                       |
  251 |     |              *                                                                           |
  252 |     |              * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |
  253 |     |              * 36      | CALLDATASIZE   | cds 0 0                |                       |
  254 |     |              * 5f      | PUSH0          | 0 cds 0 0              |                       |
  255 |     |              * 5f      | PUSH0          | 0 0 cds 0 0            |                       |
  256 |     |              * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |
  257 |     |              *                                                                           |
  258 |     |              * ::: delegate call to the implementation contract :::::::::::::::::::::::: |
  259 |     |              * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |
  260 |     |              * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |
  261 |     |              * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |
  262 |     |              * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |
  263 |     |              * f4      | DELEGATECALL   | success                | [0..cds): calldata    |
  264 |     |              *                                                                           |
  265 |     |              * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |
  266 |     |              * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |
  267 |     |              * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |
  268 |     |              * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |
  269 |     |              * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |
  270 |     |              *                                                                           |
  271 |     |              * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |
  272 |     |              * 57      | JUMPI          |                        | [0..rds): returndata  |
  273 |     |              *                                                                           |
  274 |     |              * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |
  275 |     |              * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |
  276 |     |              * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |
  277 |     |              * fd      | REVERT         |                        | [0..rds): returndata  |
  278 |     |              *                                                                           |
  279 |     |              * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |
  280 |     |              * 5b      | JUMPDEST       |                        | [0..rds): returndata  |
  281 |     |              * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |
  282 |     |              * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |
  283 |     |              * f3      | RETURN         |                        | [0..rds): returndata  |
  284 |     |              * --------------------------------------------------------------------------+
  285 |     |              */
  286 |     |             mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16
  287 |     |             mstore(0x14, implementation) // 20
  288 |     |             mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9
  289 |     |             instance := create(value, 0x0e, 0x36)
  290 |     |             if iszero(instance) {
  291 |     |                 mstore(0x00, 0x30116425) // `DeploymentFailed()`.
  292 |     |                 revert(0x1c, 0x04)
  293 |     |             }
  294 |     |             mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.
  295 |     |         }
  296 |     |     }
  297 |     | 
  298 |     |     /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.
  299 |     |     function cloneDeterministic_PUSH0(address implementation, bytes32 salt)
  300 |     |         internal
  301 |     |         returns (address instance)
  302 |     |     {
  303 |     |         instance = cloneDeterministic_PUSH0(0, implementation, salt);
  304 |     |     }
  305 |     | 
  306 |     |     /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.
  307 |     |     /// Deposits `value` ETH during deployment.
  308 |     |     function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt)
  309 |     |         internal
  310 |     |         returns (address instance)
  311 |     |     {
  312 |     |         /// @solidity memory-safe-assembly
  313 |     |         assembly {
  314 |     |             mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16
  315 |     |             mstore(0x14, implementation) // 20
  316 |     |             mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9
  317 |     |             instance := create2(value, 0x0e, 0x36, salt)
  318 |     |             if iszero(instance) {
  319 |     |                 mstore(0x00, 0x30116425) // `DeploymentFailed()`.
  320 |     |                 revert(0x1c, 0x04)
  321 |     |             }
  322 |     |             mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.
  323 |     |         }
  324 |     |     }
  325 |     | 
  326 |     |     /// @dev Returns the initialization code of the PUSH0 clone of `implementation`.
  327 |     |     function initCode_PUSH0(address implementation) internal pure returns (bytes memory result) {
  328 |     |         /// @solidity memory-safe-assembly
  329 |     |         assembly {
  330 |     |             result := mload(0x40)
  331 |     |             mstore(add(result, 0x40), 0x5af43d5f5f3e6029573d5ffd5b3d5ff300000000000000000000) // 16
  332 |     |             mstore(add(result, 0x26), implementation) // 20
  333 |     |             mstore(add(result, 0x12), 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9
  334 |     |             mstore(result, 0x36) // Store the length.
  335 |     |             mstore(0x40, add(result, 0x60)) // Allocate memory.
  336 |     |         }
  337 |     |     }
  338 |     | 
  339 |     |     /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.
  340 |     |     /// Used for mining vanity addresses with create2crunch.
  341 |     |     function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {
  342 |     |         /// @solidity memory-safe-assembly
  343 |     |         assembly {
  344 |     |             mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16
  345 |     |             mstore(0x14, implementation) // 20
  346 |     |             mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9
  347 |     |             hash := keccak256(0x0e, 0x36)
  348 |     |             mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.
  349 |     |         }
  350 |     |     }
  351 |     | 
  352 |     |     /// @dev Returns the address of the deterministic PUSH0 clone of `implementation`,
  353 |     |     /// with `salt` by `deployer`.
  354 |     |     /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.
  355 |     |     function predictDeterministicAddress_PUSH0(
  356 |     |         address implementation,
  357 |     |         bytes32 salt,
  358 |     |         address deployer
  359 |     |     ) internal pure returns (address predicted) {
  360 |     |         bytes32 hash = initCodeHash_PUSH0(implementation);
  361 |     |         predicted = predictDeterministicAddress(hash, salt, deployer);
  362 |     |     }
  363 |     | 
  364 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  365 |     |     /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */
  366 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  367 |     | 
  368 |     |     // Note: This implementation of CWIA differs from the original implementation.
  369 |     |     // If the calldata is empty, it will emit a `ReceiveETH(uint256)` event and skip the `DELEGATECALL`.
  370 |     | 
  371 |     |     /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.
  372 |     |     function clone(address implementation, bytes memory data) internal returns (address instance) {
  373 |     |         instance = clone(0, implementation, data);
  374 |     |     }
  375 |     | 
  376 |     |     /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.
  377 |     |     /// Deposits `value` ETH during deployment.
  378 |     |     function clone(uint256 value, address implementation, bytes memory data)
  379 |     |         internal
  380 |     |         returns (address instance)
  381 |     |     {
  382 |     |         assembly {
  383 |     |             // Compute the boundaries of the data and cache the memory slots around it.
  384 |     |             let mBefore3 := mload(sub(data, 0x60))
  385 |     |             let mBefore2 := mload(sub(data, 0x40))
  386 |     |             let mBefore1 := mload(sub(data, 0x20))
  387 |     |             let dataLength := mload(data)
  388 |     |             let dataEnd := add(add(data, 0x20), dataLength)
  389 |     |             let mAfter1 := mload(dataEnd)
  390 |     | 
  391 |     |             // +2 bytes for telling how much data there is appended to the call.
  392 |     |             let extraLength := add(dataLength, 2)
  393 |     |             // The `creationSize` is `extraLength + 108`
  394 |     |             // The `runSize` is `creationSize - 10`.
  395 |     | 
  396 |     |             /**
  397 |     |              * ---------------------------------------------------------------------------------------------------+
  398 |     |              * CREATION (10 bytes)                                                                                |
  399 |     |              * ---------------------------------------------------------------------------------------------------|
  400 |     |              * Opcode     | Mnemonic          | Stack     | Memory                                                |
  401 |     |              * ---------------------------------------------------------------------------------------------------|
  402 |     |              * 61 runSize | PUSH2 runSize     | r         |                                                       |
  403 |     |              * 3d         | RETURNDATASIZE    | 0 r       |                                                       |
  404 |     |              * 81         | DUP2              | r 0 r     |                                                       |
  405 |     |              * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |
  406 |     |              * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |
  407 |     |              * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |
  408 |     |              * f3         | RETURN            |           | [0..runSize): runtime code                            |
  409 |     |              * ---------------------------------------------------------------------------------------------------|
  410 |     |              * RUNTIME (98 bytes + extraLength)                                                                   |
  411 |     |              * ---------------------------------------------------------------------------------------------------|
  412 |     |              * Opcode   | Mnemonic       | Stack                    | Memory                                      |
  413 |     |              * ---------------------------------------------------------------------------------------------------|
  414 |     |              *                                                                                                    |
  415 |     |              * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |
  416 |     |              * 36       | CALLDATASIZE   | cds                      |                                             |
  417 |     |              * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |
  418 |     |              * 57       | JUMPI          |                          |                                             |
  419 |     |              * 34       | CALLVALUE      | cv                       |                                             |
  420 |     |              * 3d       | RETURNDATASIZE | 0 cv                     |                                             |
  421 |     |              * 52       | MSTORE         |                          | [0..0x20): callvalue                        |
  422 |     |              * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |
  423 |     |              * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |
  424 |     |              * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |
  425 |     |              * a1       | LOG1           |                          | [0..0x20): callvalue                        |
  426 |     |              * 00       | STOP           |                          | [0..0x20): callvalue                        |
  427 |     |              * 5b       | JUMPDEST       |                          |                                             |
  428 |     |              *                                                                                                    |
  429 |     |              * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |
  430 |     |              * 36       | CALLDATASIZE   | cds                      |                                             |
  431 |     |              * 3d       | RETURNDATASIZE | 0 cds                    |                                             |
  432 |     |              * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |
  433 |     |              * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |
  434 |     |              *                                                                                                    |
  435 |     |              * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |
  436 |     |              * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |
  437 |     |              * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |
  438 |     |              * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |
  439 |     |              * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |
  440 |     |              * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |
  441 |     |              *                                                                                                    |
  442 |     |              * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |
  443 |     |              * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |
  444 |     |              * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |
  445 |     |              * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |
  446 |     |              * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |
  447 |     |              *                                                                                                    |
  448 |     |              * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |
  449 |     |              * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |
  450 |     |              * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |
  451 |     |              * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |
  452 |     |              * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |
  453 |     |              * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |
  454 |     |              * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |
  455 |     |              *                                                                                                    |
  456 |     |              * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |
  457 |     |              * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |
  458 |     |              * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |
  459 |     |              * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |
  460 |     |              * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |
  461 |     |              * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |
  462 |     |              *                                                                                                    |
  463 |     |              * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |
  464 |     |              * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |
  465 |     |              *                                                                                                    |
  466 |     |              * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |
  467 |     |              * fd       | REVERT         |                          | [0..rds): returndata                        |
  468 |     |              *                                                                                                    |
  469 |     |              * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |
  470 |     |              * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |
  471 |     |              * f3       | RETURN         |                          | [0..rds): returndata                        |
  472 |     |              * ---------------------------------------------------------------------------------------------------+
  473 |     |              */
  474 |     |             mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.
  475 |     |             mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.
  476 |     |             // Write the rest of the bytecode.
  477 |     |             mstore(
  478 |     |                 sub(data, 0x21),
  479 |     |                 or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)
  480 |     |             )
  481 |     |             // `keccak256("ReceiveETH(uint256)")`
  482 |     |             mstore(
  483 |     |                 sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff
  484 |     |             )
  485 |     |             mstore(
  486 |     |                 // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.
  487 |     |                 // The actual EVM limit may be smaller and may change over time.
  488 |     |                 sub(data, add(0x59, lt(extraLength, 0xff9e))),
  489 |     |                 or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)
  490 |     |             )
  491 |     |             mstore(dataEnd, shl(0xf0, extraLength))
  492 |     | 
  493 |     |             instance := create(value, sub(data, 0x4c), add(extraLength, 0x6c))
  494 |     |             if iszero(instance) {
  495 |     |                 mstore(0x00, 0x30116425) // `DeploymentFailed()`.
  496 |     |                 revert(0x1c, 0x04)
  497 |     |             }
  498 |     | 
  499 |     |             // Restore the overwritten memory surrounding `data`.
  500 |     |             mstore(dataEnd, mAfter1)
  501 |     |             mstore(data, dataLength)
  502 |     |             mstore(sub(data, 0x20), mBefore1)
  503 |     |             mstore(sub(data, 0x40), mBefore2)
  504 |     |             mstore(sub(data, 0x60), mBefore3)
  505 |     |         }
  506 |     |     }
  507 |     | 
  508 |     |     /// @dev Deploys a deterministic clone of `implementation`
  509 |     |     /// with immutable arguments encoded in `data` and `salt`.
  510 |     |     function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)
  511 |     |         internal
  512 |     |         returns (address instance)
  513 |     |     {
  514 |     |         instance = cloneDeterministic(0, implementation, data, salt);
  515 |     |     }
  516 |     | 
  517 |     |     /// @dev Deploys a deterministic clone of `implementation`
  518 |     |     /// with immutable arguments encoded in `data` and `salt`.
  519 |     |     function cloneDeterministic(
  520 |     |         uint256 value,
  521 |     |         address implementation,
  522 |     |         bytes memory data,
  523 |     |         bytes32 salt
  524 |     |     ) internal returns (address instance) {
  525 |     |         assembly {
  526 |     |             // Compute the boundaries of the data and cache the memory slots around it.
  527 |     |             let mBefore3 := mload(sub(data, 0x60))
  528 |     |             let mBefore2 := mload(sub(data, 0x40))
  529 |     |             let mBefore1 := mload(sub(data, 0x20))
  530 |     |             let dataLength := mload(data)
  531 |     |             let dataEnd := add(add(data, 0x20), dataLength)
  532 |     |             let mAfter1 := mload(dataEnd)
  533 |     | 
  534 |     |             // +2 bytes for telling how much data there is appended to the call.
  535 |     |             let extraLength := add(dataLength, 2)
  536 |     | 
  537 |     |             mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.
  538 |     |             mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.
  539 |     |             // Write the rest of the bytecode.
  540 |     |             mstore(
  541 |     |                 sub(data, 0x21),
  542 |     |                 or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)
  543 |     |             )
  544 |     |             // `keccak256("ReceiveETH(uint256)")`
  545 |     |             mstore(
  546 |     |                 sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff
  547 |     |             )
  548 |     |             mstore(
  549 |     |                 // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.
  550 |     |                 // The actual EVM limit may be smaller and may change over time.
  551 |     |                 sub(data, add(0x59, lt(extraLength, 0xff9e))),
  552 |     |                 or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)
  553 |     |             )
  554 |     |             mstore(dataEnd, shl(0xf0, extraLength))
  555 |     | 
  556 |     |             instance := create2(value, sub(data, 0x4c), add(extraLength, 0x6c), salt)
  557 |     |             if iszero(instance) {
  558 |     |                 mstore(0x00, 0x30116425) // `DeploymentFailed()`.
  559 |     |                 revert(0x1c, 0x04)
  560 |     |             }
  561 |     | 
  562 |     |             // Restore the overwritten memory surrounding `data`.
  563 |     |             mstore(dataEnd, mAfter1)
  564 |     |             mstore(data, dataLength)
  565 |     |             mstore(sub(data, 0x20), mBefore1)
  566 |     |             mstore(sub(data, 0x40), mBefore2)
  567 |     |             mstore(sub(data, 0x60), mBefore3)
  568 |     |         }
  569 |     |     }
  570 |     | 
  571 |     |     /// @dev Returns the initialization code hash of the clone of `implementation`
  572 |     |     /// using immutable arguments encoded in `data`.
  573 |     |     function initCode(address implementation, bytes memory data)
  574 |     |         internal
  575 |     |         pure
  576 |     |         returns (bytes memory result)
  577 |     |     {
  578 |     |         /// @solidity memory-safe-assembly
  579 |     |         assembly {
  580 |     |             result := mload(0x40)
  581 |     |             let dataLength := mload(data)
  582 |     | 
  583 |     |             // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.
  584 |     |             // The actual EVM limit may be smaller and may change over time.
  585 |     |             returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))
  586 |     | 
  587 |     |             let o := add(result, 0x8c)
  588 |     |             let end := add(o, dataLength)
  589 |     | 
  590 |     |             // Copy the `data` into `result`.
  591 |     |             for { let d := sub(add(data, 0x20), o) } 1 {} {
  592 |     |                 mstore(o, mload(add(o, d)))
  593 |     |                 o := add(o, 0x20)
  594 |     |                 if iszero(lt(o, end)) { break }
  595 |     |             }
  596 |     | 
  597 |     |             // +2 bytes for telling how much data there is appended to the call.
  598 |     |             let extraLength := add(dataLength, 2)
  599 |     | 
  600 |     |             mstore(add(result, 0x6c), 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.
  601 |     |             mstore(add(result, 0x5f), implementation) // Write the address of the implementation.
  602 |     |             // Write the rest of the bytecode.
  603 |     |             mstore(
  604 |     |                 add(result, 0x4b),
  605 |     |                 or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)
  606 |     |             )
  607 |     |             // `keccak256("ReceiveETH(uint256)")`
  608 |     |             mstore(
  609 |     |                 add(result, 0x32),
  610 |     |                 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff
  611 |     |             )
  612 |     |             mstore(
  613 |     |                 add(result, 0x12),
  614 |     |                 or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)
  615 |     |             )
  616 |     |             mstore(end, shl(0xf0, extraLength))
  617 |     |             mstore(add(end, 0x02), 0) // Zeroize the slot after the result.
  618 |     |             mstore(result, add(extraLength, 0x6c)) // Store the length.
  619 |     |             mstore(0x40, add(0x22, end)) // Allocate memory.
  620 |     |         }
  621 |     |     }
  622 |     | 
  623 |     |     /// @dev Returns the initialization code hash of the clone of `implementation`
  624 |     |     /// using immutable arguments encoded in `data`.
  625 |     |     /// Used for mining vanity addresses with create2crunch.
  626 |     |     function initCodeHash(address implementation, bytes memory data)
  627 |     |         internal
  628 |     |         pure
  629 |     |         returns (bytes32 hash)
  630 |     |     {
  631 |     |         assembly {
  632 |     |             // Compute the boundaries of the data and cache the memory slots around it.
  633 |     |             let mBefore3 := mload(sub(data, 0x60))
  634 |     |             let mBefore2 := mload(sub(data, 0x40))
  635 |     |             let mBefore1 := mload(sub(data, 0x20))
  636 |     |             let dataLength := mload(data)
  637 |     |             let dataEnd := add(add(data, 0x20), dataLength)
  638 |     |             let mAfter1 := mload(dataEnd)
  639 |     | 
  640 |     |             // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.
  641 |     |             // The actual EVM limit may be smaller and may change over time.
  642 |     |             returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))
  643 |     | 
  644 |     |             // +2 bytes for telling how much data there is appended to the call.
  645 |     |             let extraLength := add(dataLength, 2)
  646 |     | 
  647 |     |             mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.
  648 |     |             mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.
  649 |     |             // Write the rest of the bytecode.
  650 |     |             mstore(
  651 |     |                 sub(data, 0x21),
  652 |     |                 or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)
  653 |     |             )
  654 |     |             // `keccak256("ReceiveETH(uint256)")`
  655 |     |             mstore(
  656 |     |                 sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff
  657 |     |             )
  658 |     |             mstore(
  659 |     |                 sub(data, 0x5a),
  660 |     |                 or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)
  661 |     |             )
  662 |     |             mstore(dataEnd, shl(0xf0, extraLength))
  663 |     | 
  664 |     |             hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))
  665 |     | 
  666 |     |             // Restore the overwritten memory surrounding `data`.
  667 |     |             mstore(dataEnd, mAfter1)
  668 |     |             mstore(data, dataLength)
  669 |     |             mstore(sub(data, 0x20), mBefore1)
  670 |     |             mstore(sub(data, 0x40), mBefore2)
  671 |     |             mstore(sub(data, 0x60), mBefore3)
  672 |     |         }
  673 |     |     }
  674 |     | 
  675 |     |     /// @dev Returns the address of the deterministic clone of
  676 |     |     /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.
  677 |     |     /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.
  678 |     |     function predictDeterministicAddress(
  679 |     |         address implementation,
  680 |     |         bytes memory data,
  681 |     |         bytes32 salt,
  682 |     |         address deployer
  683 |     |     ) internal pure returns (address predicted) {
  684 |     |         bytes32 hash = initCodeHash(implementation, data);
  685 |     |         predicted = predictDeterministicAddress(hash, salt, deployer);
  686 |     |     }
  687 |     | 
  688 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  689 |     |     /*              MINIMAL ERC1967 PROXY OPERATIONS              */
  690 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  691 |     | 
  692 |     |     // Note: The ERC1967 proxy here is intended to be upgraded with UUPS.
  693 |     |     // This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.
  694 |     | 
  695 |     |     /// @dev Deploys a minimal ERC1967 proxy with `implementation`.
  696 |     |     function deployERC1967(address implementation) internal returns (address instance) {
  697 |     |         instance = deployERC1967(0, implementation);
  698 |     |     }
  699 |     | 
  700 |     |     /// @dev Deploys a minimal ERC1967 proxy with `implementation`.
  701 |     |     /// Deposits `value` ETH during deployment.
  702 |     |     function deployERC1967(uint256 value, address implementation)
  703 |     |         internal
  704 |     |         returns (address instance)
  705 |     |     {
  706 |     |         /// @solidity memory-safe-assembly
  707 |     |         assembly {
  708 |     |             /**
  709 |     |              * ---------------------------------------------------------------------------------+
  710 |     |              * CREATION (34 bytes)                                                              |
  711 |     |              * ---------------------------------------------------------------------------------|
  712 |     |              * Opcode     | Mnemonic       | Stack            | Memory                          |
  713 |     |              * ---------------------------------------------------------------------------------|
  714 |     |              * 60 runSize | PUSH1 runSize  | r                |                                 |
  715 |     |              * 3d         | RETURNDATASIZE | 0 r              |                                 |
  716 |     |              * 81         | DUP2           | r 0 r            |                                 |
  717 |     |              * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |
  718 |     |              * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |
  719 |     |              * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |
  720 |     |              * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |
  721 |     |              * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |
  722 |     |              * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |
  723 |     |              * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |
  724 |     |              * f3         | RETURN         |                  | [0..runSize): runtime code      |
  725 |     |              * ---------------------------------------------------------------------------------|
  726 |     |              * RUNTIME (61 bytes)                                                               |
  727 |     |              * ---------------------------------------------------------------------------------|
  728 |     |              * Opcode     | Mnemonic       | Stack            | Memory                          |
  729 |     |              * ---------------------------------------------------------------------------------|
  730 |     |              *                                                                                  |
  731 |     |              * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |
  732 |     |              * 36         | CALLDATASIZE   | cds              |                                 |
  733 |     |              * 3d         | RETURNDATASIZE | 0 cds            |                                 |
  734 |     |              * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |
  735 |     |              * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |
  736 |     |              *                                                                                  |
  737 |     |              * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |
  738 |     |              * 3d         | RETURNDATASIZE | 0                |                                 |
  739 |     |              * 3d         | RETURNDATASIZE | 0 0              |                                 |
  740 |     |              * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |
  741 |     |              * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |
  742 |     |              * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |
  743 |     |              * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |
  744 |     |              * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |
  745 |     |              * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |
  746 |     |              *                                                                                  |
  747 |     |              * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |
  748 |     |              * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |
  749 |     |              * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |
  750 |     |              * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |
  751 |     |              * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |
  752 |     |              *                                                                                  |
  753 |     |              * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |
  754 |     |              * 60 0x38    | PUSH1 0x38     | dest succ        | [0..returndatasize): returndata |
  755 |     |              * 57         | JUMPI          |                  | [0..returndatasize): returndata |
  756 |     |              *                                                                                  |
  757 |     |              * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |
  758 |     |              * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |
  759 |     |              * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |
  760 |     |              * fd         | REVERT         |                  | [0..returndatasize): returndata |
  761 |     |              *                                                                                  |
  762 |     |              * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |
  763 |     |              * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |
  764 |     |              * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |
  765 |     |              * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |
  766 |     |              * f3         | RETURN         |                  | [0..returndatasize): returndata |
  767 |     |              * ---------------------------------------------------------------------------------+
  768 |     |              */
  769 |     |             let m := mload(0x40) // Cache the free memory pointer.
  770 |     |             mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)
  771 |     |             mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)
  772 |     |             mstore(0x20, 0x6009)
  773 |     |             mstore(0x1e, implementation)
  774 |     |             mstore(0x0a, 0x603d3d8160223d3973)
  775 |     |             instance := create(value, 0x21, 0x5f)
  776 |     |             if iszero(instance) {
  777 |     |                 mstore(0x00, 0x30116425) // `DeploymentFailed()`.
  778 |     |                 revert(0x1c, 0x04)
  779 |     |             }
  780 |     |             mstore(0x40, m) // Restore the free memory pointer.
  781 |     |             mstore(0x60, 0) // Restore the zero slot.
  782 |     |         }
  783 |     |     }
  784 |     | 
  785 |     |     /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.
  786 |     |     function deployDeterministicERC1967(address implementation, bytes32 salt)
  787 |     |         internal
  788 |     |         returns (address instance)
  789 |     |     {
  790 |     |         instance = deployDeterministicERC1967(0, implementation, salt);
  791 |     |     }
  792 |     | 
  793 |     |     /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.
  794 |     |     /// Deposits `value` ETH during deployment.
  795 |     |     function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt)
  796 |     |         internal
  797 |     |         returns (address instance)
  798 |     |     {
  799 |     |         /// @solidity memory-safe-assembly
  800 |     |         assembly {
  801 |     |             let m := mload(0x40) // Cache the free memory pointer.
  802 |     |             mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)
  803 |     |             mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)
  804 |     |             mstore(0x20, 0x6009)
  805 |     |             mstore(0x1e, implementation)
  806 |     |             mstore(0x0a, 0x603d3d8160223d3973)
  807 |     |             instance := create2(value, 0x21, 0x5f, salt)
  808 |     |             if iszero(instance) {
  809 |     |                 mstore(0x00, 0x30116425) // `DeploymentFailed()`.
  810 |     |                 revert(0x1c, 0x04)
  811 |     |             }
  812 |     |             mstore(0x40, m) // Restore the free memory pointer.
  813 |     |             mstore(0x60, 0) // Restore the zero slot.
  814 |     |         }
  815 |     |     }
  816 |     | 
  817 |     |     /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.
  818 |     |     /// Note: This method is intended for use in ERC4337 factories,
  819 |     |     /// which are expected to NOT revert if the proxy is already deployed.
  820 |     |     function createDeterministicERC1967(address implementation, bytes32 salt)
  821 |     |         internal
  822 |     |         returns (bool alreadyDeployed, address instance)
  823 |     |     {
  824 |     |         return createDeterministicERC1967(0, implementation, salt);
  825 |     |     }
  826 |     | 
  827 |     |     /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.
  828 |     |     /// Deposits `value` ETH during deployment.
  829 |     |     /// Note: This method is intended for use in ERC4337 factories,
  830 |     |     /// which are expected to NOT revert if the proxy is already deployed.
  831 |     |     function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt)
  832 |     |         internal
  833 |     |         returns (bool alreadyDeployed, address instance)
  834 |     |     {
  835 |     |         /// @solidity memory-safe-assembly
  836 |     |         assembly {
  837 |     |             let m := mload(0x40) // Cache the free memory pointer.
  838 |     |             mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)
  839 |     |             mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)
  840 |     |             mstore(0x20, 0x6009)
  841 |     |             mstore(0x1e, implementation)
  842 |     |             mstore(0x0a, 0x603d3d8160223d3973)
  843 |     |             // Compute and store the bytecode hash.
  844 |     |             mstore(add(m, 0x35), keccak256(0x21, 0x5f))
  845 |     |             mstore(m, shl(88, address()))
  846 |     |             mstore8(m, 0xff) // Write the prefix.
  847 |     |             mstore(add(m, 0x15), salt)
  848 |     |             instance := keccak256(m, 0x55)
  849 |     |             for {} 1 {} {
  850 |     |                 if iszero(extcodesize(instance)) {
  851 |     |                     instance := create2(value, 0x21, 0x5f, salt)
  852 |     |                     if iszero(instance) {
  853 |     |                         mstore(0x00, 0x30116425) // `DeploymentFailed()`.
  854 |     |                         revert(0x1c, 0x04)
  855 |     |                     }
  856 |     |                     break
  857 |     |                 }
  858 |     |                 alreadyDeployed := 1
  859 |     |                 if iszero(value) { break }
  860 |     |                 if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {
  861 |     |                     mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.
  862 |     |                     revert(0x1c, 0x04)
  863 |     |                 }
  864 |     |                 break
  865 |     |             }
  866 |     |             mstore(0x40, m) // Restore the free memory pointer.
  867 |     |             mstore(0x60, 0) // Restore the zero slot.
  868 |     |         }
  869 |     |     }
  870 |     | 
  871 |     |     /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.
  872 |     |     function initCodeERC1967(address implementation) internal pure returns (bytes memory result) {
  873 |     |         /// @solidity memory-safe-assembly
  874 |     |         assembly {
  875 |     |             result := mload(0x40)
  876 |     |             mstore(
  877 |     |                 add(result, 0x60),
  878 |     |                 0x3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f300
  879 |     |             )
  880 |     |             mstore(
  881 |     |                 add(result, 0x40),
  882 |     |                 0x55f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076cc
  883 |     |             )
  884 |     |             mstore(add(result, 0x20), or(shl(24, implementation), 0x600951))
  885 |     |             mstore(add(result, 0x09), 0x603d3d8160223d3973)
  886 |     |             mstore(result, 0x5f) // Store the length.
  887 |     |             mstore(0x40, add(result, 0x80)) // Allocate memory.
  888 |     |         }
  889 |     |     }
  890 |     | 
  891 |     |     /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.
  892 |     |     /// Used for mining vanity addresses with create2crunch.
  893 |     |     function initCodeHashERC1967(address implementation) internal pure returns (bytes32 hash) {
  894 |     |         /// @solidity memory-safe-assembly
  895 |     |         assembly {
  896 |     |             let m := mload(0x40) // Cache the free memory pointer.
  897 |     |             mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)
  898 |     |             mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)
  899 |     |             mstore(0x20, 0x6009)
  900 |     |             mstore(0x1e, implementation)
  901 |     |             mstore(0x0a, 0x603d3d8160223d3973)
  902 |     |             hash := keccak256(0x21, 0x5f)
  903 |     |             mstore(0x40, m) // Restore the free memory pointer.
  904 |     |             mstore(0x60, 0) // Restore the zero slot.
  905 |     |         }
  906 |     |     }
  907 |     | 
  908 |     |     /// @dev Returns the address of the deterministic ERC1967 proxy of `implementation`,
  909 |     |     /// with `salt` by `deployer`.
  910 |     |     /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.
  911 |     |     function predictDeterministicAddressERC1967(
  912 |     |         address implementation,
  913 |     |         bytes32 salt,
  914 |     |         address deployer
  915 |     |     ) internal pure returns (address predicted) {
  916 |     |         bytes32 hash = initCodeHashERC1967(implementation);
  917 |     |         predicted = predictDeterministicAddress(hash, salt, deployer);
  918 |     |     }
  919 |     | 
  920 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  921 |     |     /*                 ERC1967I PROXY OPERATIONS                  */
  922 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  923 |     | 
  924 |     |     // Note: This proxy has a special code path that activates if `calldatasize() == 1`.
  925 |     |     // This code path skips the delegatecall and directly returns the `implementation` address.
  926 |     |     // The returned implementation is guaranteed to be valid if the keccak256 of the
  927 |     |     // proxy's code is equal to `ERC1967I_CODE_HASH`.
  928 |     | 
  929 |     |     /// @dev Deploys a minimal ERC1967I proxy with `implementation`.
  930 |     |     function deployERC1967I(address implementation) internal returns (address instance) {
  931 |     |         instance = deployERC1967I(0, implementation);
  932 |     |     }
  933 |     | 
  934 |     |     /// @dev Deploys a ERC1967I proxy with `implementation`.
  935 |     |     /// Deposits `value` ETH during deployment.
  936 |     |     function deployERC1967I(uint256 value, address implementation)
  937 |     |         internal
  938 |     |         returns (address instance)
  939 |     |     {
  940 |     |         /// @solidity memory-safe-assembly
  941 |     |         assembly {
  942 |     |             /**
  943 |     |              * ---------------------------------------------------------------------------------+
  944 |     |              * CREATION (34 bytes)                                                              |
  945 |     |              * ---------------------------------------------------------------------------------|
  946 |     |              * Opcode     | Mnemonic       | Stack            | Memory                          |
  947 |     |              * ---------------------------------------------------------------------------------|
  948 |     |              * 60 runSize | PUSH1 runSize  | r                |                                 |
  949 |     |              * 3d         | RETURNDATASIZE | 0 r              |                                 |
  950 |     |              * 81         | DUP2           | r 0 r            |                                 |
  951 |     |              * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |
  952 |     |              * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |
  953 |     |              * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |
  954 |     |              * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |
  955 |     |              * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |
  956 |     |              * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |
  957 |     |              * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |
  958 |     |              * f3         | RETURN         |                  | [0..runSize): runtime code      |
  959 |     |              * ---------------------------------------------------------------------------------|
  960 |     |              * RUNTIME (82 bytes)                                                               |
  961 |     |              * ---------------------------------------------------------------------------------|
  962 |     |              * Opcode     | Mnemonic       | Stack            | Memory                          |
  963 |     |              * ---------------------------------------------------------------------------------|
  964 |     |              *                                                                                  |
  965 |     |              * ::: check calldatasize ::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |
  966 |     |              * 36         | CALLDATASIZE   | cds              |                                 |
  967 |     |              * 58         | PC             | 1 cds            |                                 |
  968 |     |              * 14         | EQ             | eqs              |                                 |
  969 |     |              * 60 0x43    | PUSH1 0x43     | dest eqs         |                                 |
  970 |     |              * 57         | JUMPI          |                  |                                 |
  971 |     |              *                                                                                  |
  972 |     |              * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |
  973 |     |              * 36         | CALLDATASIZE   | cds              |                                 |
  974 |     |              * 3d         | RETURNDATASIZE | 0 cds            |                                 |
  975 |     |              * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |
  976 |     |              * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |
  977 |     |              *                                                                                  |
  978 |     |              * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |
  979 |     |              * 3d         | RETURNDATASIZE | 0                |                                 |
  980 |     |              * 3d         | RETURNDATASIZE | 0 0              |                                 |
  981 |     |              * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |
  982 |     |              * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |
  983 |     |              * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |
  984 |     |              * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |
  985 |     |              * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |
  986 |     |              * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |
  987 |     |              *                                                                                  |
  988 |     |              * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |
  989 |     |              * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |
  990 |     |              * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |
  991 |     |              * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |
  992 |     |              * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |
  993 |     |              *                                                                                  |
  994 |     |              * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |
  995 |     |              * 60 0x3E    | PUSH1 0x3E     | dest succ        | [0..returndatasize): returndata |
  996 |     |              * 57         | JUMPI          |                  | [0..returndatasize): returndata |
  997 |     |              *                                                                                  |
  998 |     |              * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |
  999 |     |              * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |
 1000 |     |              * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |
 1001 |     |              * fd         | REVERT         |                  | [0..returndatasize): returndata |
 1002 |     |              *                                                                                  |
 1003 |     |              * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |
 1004 |     |              * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |
 1005 |     |              * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |
 1006 |     |              * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |
 1007 |     |              * f3         | RETURN         |                  | [0..returndatasize): returndata |
 1008 |     |              *                                                                                  |
 1009 |     |              * ::: implementation , return :::::::::::::::::::::::::::::::::::::::::::::::::::: |
 1010 |     |              * 5b         | JUMPDEST       |                  |                                 |
 1011 |     |              * 60 0x20    | PUSH1 0x20     | 32               |                                 |
 1012 |     |              * 60 0x0F    | PUSH1 0x0F     | o 32             |                                 |
 1013 |     |              * 3d         | RETURNDATASIZE | 0 o 32           |                                 |
 1014 |     |              * 39         | CODECOPY       |                  | [0..32): implementation slot    |
 1015 |     |              * 3d         | RETURNDATASIZE | 0                | [0..32): implementation slot    |
 1016 |     |              * 51         | MLOAD          | slot             | [0..32): implementation slot    |
 1017 |     |              * 54         | SLOAD          | impl             | [0..32): implementation slot    |
 1018 |     |              * 3d         | RETURNDATASIZE | 0 impl           | [0..32): implementation slot    |
 1019 |     |              * 52         | MSTORE         |                  | [0..32): implementation address |
 1020 |     |              * 59         | MSIZE          | 32               | [0..32): implementation address |
 1021 |     |              * 3d         | RETURNDATASIZE | 0 32             | [0..32): implementation address |
 1022 |     |              * f3         | RETURN         |                  | [0..32): implementation address |
 1023 |     |              *                                                                                  |
 1024 |     |              * ---------------------------------------------------------------------------------+
 1025 |     |              */
 1026 |     |             let m := mload(0x40) // Cache the free memory pointer.
 1027 |     |             mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)
 1028 |     |             mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)
 1029 |     |             mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)
 1030 |     |             mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))
 1031 |     |             instance := create(value, 0x0c, 0x74)
 1032 |     |             if iszero(instance) {
 1033 |     |                 mstore(0x00, 0x30116425) // `DeploymentFailed()`.
 1034 |     |                 revert(0x1c, 0x04)
 1035 |     |             }
 1036 |     |             mstore(0x40, m) // Restore the free memory pointer.
 1037 |     |             mstore(0x60, 0) // Restore the zero slot.
 1038 |     |         }
 1039 |     |     }
 1040 |     | 
 1041 |     |     /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.
 1042 |     |     function deployDeterministicERC1967I(address implementation, bytes32 salt)
 1043 |     |         internal
 1044 |     |         returns (address instance)
 1045 |     |     {
 1046 |     |         instance = deployDeterministicERC1967I(0, implementation, salt);
 1047 |     |     }
 1048 |     | 
 1049 |     |     /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.
 1050 |     |     /// Deposits `value` ETH during deployment.
 1051 |     |     function deployDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)
 1052 |     |         internal
 1053 |     |         returns (address instance)
 1054 |     |     {
 1055 |     |         /// @solidity memory-safe-assembly
 1056 |     |         assembly {
 1057 |     |             let m := mload(0x40) // Cache the free memory pointer.
 1058 |     |             mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)
 1059 |     |             mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)
 1060 |     |             mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)
 1061 |     |             mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))
 1062 |     |             instance := create2(value, 0x0c, 0x74, salt)
 1063 |     |             if iszero(instance) {
 1064 |     |                 mstore(0x00, 0x30116425) // `DeploymentFailed()`.
 1065 |     |                 revert(0x1c, 0x04)
 1066 |     |             }
 1067 |     |             mstore(0x40, m) // Restore the free memory pointer.
 1068 |     |             mstore(0x60, 0) // Restore the zero slot.
 1069 |     |         }
 1070 |     |     }
 1071 |     | 
 1072 |     |     /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.
 1073 |     |     /// Note: This method is intended for use in ERC4337 factories,
 1074 |     |     /// which are expected to NOT revert if the proxy is already deployed.
 1075 |     |     function createDeterministicERC1967I(address implementation, bytes32 salt)
 1076 |     |         internal
 1077 |     |         returns (bool alreadyDeployed, address instance)
 1078 |     |     {
 1079 |     |         return createDeterministicERC1967I(0, implementation, salt);
 1080 |     |     }
 1081 |     | 
 1082 |     |     /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.
 1083 |     |     /// Deposits `value` ETH during deployment.
 1084 |     |     /// Note: This method is intended for use in ERC4337 factories,
 1085 |     |     /// which are expected to NOT revert if the proxy is already deployed.
 1086 |     |     function createDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)
 1087 |     |         internal
 1088 |     |         returns (bool alreadyDeployed, address instance)
 1089 |     |     {
 1090 |     |         /// @solidity memory-safe-assembly
 1091 |     |         assembly {
 1092 |     |             let m := mload(0x40) // Cache the free memory pointer.
 1093 |     |             mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)
 1094 |     |             mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)
 1095 |     |             mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)
 1096 |     |             mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))
 1097 |     |             // Compute and store the bytecode hash.
 1098 |     |             mstore(add(m, 0x35), keccak256(0x0c, 0x74))
 1099 |     |             mstore(m, shl(88, address()))
 1100 |     |             mstore8(m, 0xff) // Write the prefix.
 1101 |     |             mstore(add(m, 0x15), salt)
 1102 |     |             instance := keccak256(m, 0x55)
 1103 |     |             for {} 1 {} {
 1104 |     |                 if iszero(extcodesize(instance)) {
 1105 |     |                     instance := create2(value, 0x0c, 0x74, salt)
 1106 |     |                     if iszero(instance) {
 1107 |     |                         mstore(0x00, 0x30116425) // `DeploymentFailed()`.
 1108 |     |                         revert(0x1c, 0x04)
 1109 |     |                     }
 1110 |     |                     break
 1111 |     |                 }
 1112 |     |                 alreadyDeployed := 1
 1113 |     |                 if iszero(value) { break }
 1114 |     |                 if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {
 1115 |     |                     mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.
 1116 |     |                     revert(0x1c, 0x04)
 1117 |     |                 }
 1118 |     |                 break
 1119 |     |             }
 1120 |     |             mstore(0x40, m) // Restore the free memory pointer.
 1121 |     |             mstore(0x60, 0) // Restore the zero slot.
 1122 |     |         }
 1123 |     |     }
 1124 |     | 
 1125 |     |     /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.
 1126 |     |     function initCodeERC1967I(address implementation) internal pure returns (bytes memory result) {
 1127 |     |         /// @solidity memory-safe-assembly
 1128 |     |         assembly {
 1129 |     |             result := mload(0x40)
 1130 |     |             mstore(
 1131 |     |                 add(result, 0x74),
 1132 |     |                 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3
 1133 |     |             )
 1134 |     |             mstore(
 1135 |     |                 add(result, 0x54),
 1136 |     |                 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4
 1137 |     |             )
 1138 |     |             mstore(add(result, 0x34), 0x600f5155f3365814604357363d3d373d3d363d7f360894)
 1139 |     |             mstore(add(result, 0x1d), implementation)
 1140 |     |             mstore(add(result, 0x09), 0x60523d8160223d3973)
 1141 |     |             mstore(add(result, 0x94), 0)
 1142 |     |             mstore(result, 0x74) // Store the length.
 1143 |     |             mstore(0x40, add(result, 0xa0)) // Allocate memory.
 1144 |     |         }
 1145 |     |     }
 1146 |     | 
 1147 |     |     /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.
 1148 |     |     /// Used for mining vanity addresses with create2crunch.
 1149 |     |     function initCodeHashERC1967I(address implementation) internal pure returns (bytes32 hash) {
 1150 |     |         /// @solidity memory-safe-assembly
 1151 |     |         assembly {
 1152 |     |             let m := mload(0x40) // Cache the free memory pointer.
 1153 |     |             mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)
 1154 |     |             mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)
 1155 |     |             mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)
 1156 |     |             mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))
 1157 |     |             hash := keccak256(0x0c, 0x74)
 1158 |     |             mstore(0x40, m) // Restore the free memory pointer.
 1159 |     |             mstore(0x60, 0) // Restore the zero slot.
 1160 |     |         }
 1161 |     |     }
 1162 |     | 
 1163 |     |     /// @dev Returns the address of the deterministic ERC1967I proxy of `implementation`,
 1164 |     |     /// with `salt` by `deployer`.
 1165 |     |     /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.
 1166 |     |     function predictDeterministicAddressERC1967I(
 1167 |     |         address implementation,
 1168 |     |         bytes32 salt,
 1169 |     |         address deployer
 1170 |     |     ) internal pure returns (address predicted) {
 1171 |     |         bytes32 hash = initCodeHashERC1967I(implementation);
 1172 |     |         predicted = predictDeterministicAddress(hash, salt, deployer);
 1173 |     |     }
 1174 |     | 
 1175 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 1176 |     |     /*                      OTHER OPERATIONS                      */
 1177 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 1178 |     | 
 1179 |     |     /// @dev Returns the address when a contract with initialization code hash,
 1180 |     |     /// `hash`, is deployed with `salt`, by `deployer`.
 1181 |     |     /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.
 1182 |     |     function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)
 1183 |     |         internal
 1184 |     |         pure
 1185 |     |         returns (address predicted)
 1186 |     |     {
 1187 |     |         /// @solidity memory-safe-assembly
 1188 |     |         assembly {
 1189 |     |             // Compute and store the bytecode hash.
 1190 |     |             mstore8(0x00, 0xff) // Write the prefix.
 1191 |     |             mstore(0x35, hash)
 1192 |     |             mstore(0x01, shl(96, deployer))
 1193 |     |             mstore(0x15, salt)
 1194 |     |             predicted := keccak256(0x00, 0x55)
 1195 |     |             mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.
 1196 |     |         }
 1197 |     |     }
 1198 |     | 
 1199 |     |     /// @dev Requires that `salt` starts with either the zero address or `by`.
 1200 |     |     function checkStartsWith(bytes32 salt, address by) internal pure {
 1201 |     |         /// @solidity memory-safe-assembly
 1202 |     |         assembly {
 1203 |     |             // If the salt does not start with the zero address or `by`.
 1204 |     |             if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {
 1205 |     |                 mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.
 1206 |     |                 revert(0x1c, 0x04)
 1207 |     |             }
 1208 |     |         }
 1209 |     |     }
 1210 |     | }
 1211 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solady/src/utils/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.4;
  3 |     | 
  4 |     | /// @notice Reentrancy guard mixin.
  5 |     | /// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ReentrancyGuard.sol)
  6 |     | abstract contract ReentrancyGuard {
  7 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  8 |     |     /*                       CUSTOM ERRORS                        */
  9 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 10 |     | 
 11 |     |     /// @dev Unauthorized reentrant call.
 12 |     |     error Reentrancy();
 13 |     | 
 14 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 15 |     |     /*                          STORAGE                           */
 16 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 17 |     | 
 18 |     |     /// @dev Equivalent to: `uint72(bytes9(keccak256("_REENTRANCY_GUARD_SLOT")))`.
 19 |     |     /// 9 bytes is large enough to avoid collisions with lower slots,
 20 |     |     /// but not too large to result in excessive bytecode bloat.
 21 |     |     uint256 private constant _REENTRANCY_GUARD_SLOT = 0x929eee149b4bd21268;
 22 |     | 
 23 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 24 |     |     /*                      REENTRANCY GUARD                      */
 25 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 26 |     | 
 27 |     |     /// @dev Guards a function from reentrancy.
 28 |     |     modifier nonReentrant() virtual {
 29 |     |         /// @solidity memory-safe-assembly
 30 |     |         assembly {
 31 |     |             if eq(sload(_REENTRANCY_GUARD_SLOT), address()) {
 32 |     |                 mstore(0x00, 0xab143c06) // `Reentrancy()`.
 33 |     |                 revert(0x1c, 0x04)
 34 |     |             }
 35 |     |             sstore(_REENTRANCY_GUARD_SLOT, address())
 36 |     |         }
 37 |     |         _;
 38 |     |         /// @solidity memory-safe-assembly
 39 |     |         assembly {
 40 |     |             sstore(_REENTRANCY_GUARD_SLOT, codesize())
 41 |     |         }
 42 |     |     }
 43 |     | 
 44 |     |     /// @dev Guards a view function from read-only reentrancy.
 45 |     |     modifier nonReadReentrant() virtual {
 46 |     |         /// @solidity memory-safe-assembly
 47 |     |         assembly {
 48 | *   |             if eq(sload(_REENTRANCY_GUARD_SLOT), address()) {
 49 |     |                 mstore(0x00, 0xab143c06) // `Reentrancy()`.
 50 |     |                 revert(0x1c, 0x04)
 51 |     |             }
 52 |     |         }
 53 | *   |         _;
 54 |     |     }
 55 |     | }
 56 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solady/src/utils/SafeCastLib.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.4;
   3 |     | 
   4 |     | /// @notice Safe integer casting library that reverts on overflow.
   5 |     | /// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeCastLib.sol)
   6 |     | /// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)
   7 |     | library SafeCastLib {
   8 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
   9 |     |     /*                       CUSTOM ERRORS                        */
  10 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  11 |     | 
  12 |     |     error Overflow();
  13 |     | 
  14 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  15 |     |     /*          UNSIGNED INTEGER SAFE CASTING OPERATIONS          */
  16 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  17 |     | 
  18 |     |     function toUint8(uint256 x) internal pure returns (uint8) {
  19 |     |         if (x >= 1 << 8) _revertOverflow();
  20 |     |         return uint8(x);
  21 |     |     }
  22 |     | 
  23 |     |     function toUint16(uint256 x) internal pure returns (uint16) {
  24 |     |         if (x >= 1 << 16) _revertOverflow();
  25 |     |         return uint16(x);
  26 |     |     }
  27 |     | 
  28 |     |     function toUint24(uint256 x) internal pure returns (uint24) {
  29 |     |         if (x >= 1 << 24) _revertOverflow();
  30 |     |         return uint24(x);
  31 |     |     }
  32 |     | 
  33 |     |     function toUint32(uint256 x) internal pure returns (uint32) {
  34 |     |         if (x >= 1 << 32) _revertOverflow();
  35 |     |         return uint32(x);
  36 |     |     }
  37 |     | 
  38 |     |     function toUint40(uint256 x) internal pure returns (uint40) {
  39 |     |         if (x >= 1 << 40) _revertOverflow();
  40 |     |         return uint40(x);
  41 |     |     }
  42 |     | 
  43 |     |     function toUint48(uint256 x) internal pure returns (uint48) {
  44 |     |         if (x >= 1 << 48) _revertOverflow();
  45 |     |         return uint48(x);
  46 |     |     }
  47 |     | 
  48 |     |     function toUint56(uint256 x) internal pure returns (uint56) {
  49 |     |         if (x >= 1 << 56) _revertOverflow();
  50 |     |         return uint56(x);
  51 |     |     }
  52 |     | 
  53 |     |     function toUint64(uint256 x) internal pure returns (uint64) {
  54 |     |         if (x >= 1 << 64) _revertOverflow();
  55 |     |         return uint64(x);
  56 |     |     }
  57 |     | 
  58 |     |     function toUint72(uint256 x) internal pure returns (uint72) {
  59 |     |         if (x >= 1 << 72) _revertOverflow();
  60 |     |         return uint72(x);
  61 |     |     }
  62 |     | 
  63 |     |     function toUint80(uint256 x) internal pure returns (uint80) {
  64 |     |         if (x >= 1 << 80) _revertOverflow();
  65 |     |         return uint80(x);
  66 |     |     }
  67 |     | 
  68 |     |     function toUint88(uint256 x) internal pure returns (uint88) {
  69 |     |         if (x >= 1 << 88) _revertOverflow();
  70 |     |         return uint88(x);
  71 |     |     }
  72 |     | 
  73 |     |     function toUint96(uint256 x) internal pure returns (uint96) {
  74 |     |         if (x >= 1 << 96) _revertOverflow();
  75 |     |         return uint96(x);
  76 |     |     }
  77 |     | 
  78 |     |     function toUint104(uint256 x) internal pure returns (uint104) {
  79 |     |         if (x >= 1 << 104) _revertOverflow();
  80 |     |         return uint104(x);
  81 |     |     }
  82 |     | 
  83 |     |     function toUint112(uint256 x) internal pure returns (uint112) {
  84 |     |         if (x >= 1 << 112) _revertOverflow();
  85 |     |         return uint112(x);
  86 |     |     }
  87 |     | 
  88 |     |     function toUint120(uint256 x) internal pure returns (uint120) {
  89 |     |         if (x >= 1 << 120) _revertOverflow();
  90 |     |         return uint120(x);
  91 |     |     }
  92 |     | 
  93 |     |     function toUint128(uint256 x) internal pure returns (uint128) {
  94 |     |         if (x >= 1 << 128) _revertOverflow();
  95 |     |         return uint128(x);
  96 |     |     }
  97 |     | 
  98 |     |     function toUint136(uint256 x) internal pure returns (uint136) {
  99 |     |         if (x >= 1 << 136) _revertOverflow();
 100 |     |         return uint136(x);
 101 |     |     }
 102 |     | 
 103 |     |     function toUint144(uint256 x) internal pure returns (uint144) {
 104 |     |         if (x >= 1 << 144) _revertOverflow();
 105 |     |         return uint144(x);
 106 |     |     }
 107 |     | 
 108 |     |     function toUint152(uint256 x) internal pure returns (uint152) {
 109 |     |         if (x >= 1 << 152) _revertOverflow();
 110 |     |         return uint152(x);
 111 |     |     }
 112 |     | 
 113 |     |     function toUint160(uint256 x) internal pure returns (uint160) {
 114 |     |         if (x >= 1 << 160) _revertOverflow();
 115 |     |         return uint160(x);
 116 |     |     }
 117 |     | 
 118 |     |     function toUint168(uint256 x) internal pure returns (uint168) {
 119 |     |         if (x >= 1 << 168) _revertOverflow();
 120 |     |         return uint168(x);
 121 |     |     }
 122 |     | 
 123 |     |     function toUint176(uint256 x) internal pure returns (uint176) {
 124 |     |         if (x >= 1 << 176) _revertOverflow();
 125 |     |         return uint176(x);
 126 |     |     }
 127 |     | 
 128 |     |     function toUint184(uint256 x) internal pure returns (uint184) {
 129 |     |         if (x >= 1 << 184) _revertOverflow();
 130 |     |         return uint184(x);
 131 |     |     }
 132 |     | 
 133 |     |     function toUint192(uint256 x) internal pure returns (uint192) {
 134 |     |         if (x >= 1 << 192) _revertOverflow();
 135 |     |         return uint192(x);
 136 |     |     }
 137 |     | 
 138 |     |     function toUint200(uint256 x) internal pure returns (uint200) {
 139 |     |         if (x >= 1 << 200) _revertOverflow();
 140 |     |         return uint200(x);
 141 |     |     }
 142 |     | 
 143 |     |     function toUint208(uint256 x) internal pure returns (uint208) {
 144 |     |         if (x >= 1 << 208) _revertOverflow();
 145 |     |         return uint208(x);
 146 |     |     }
 147 |     | 
 148 |     |     function toUint216(uint256 x) internal pure returns (uint216) {
 149 |     |         if (x >= 1 << 216) _revertOverflow();
 150 |     |         return uint216(x);
 151 |     |     }
 152 |     | 
 153 |     |     function toUint224(uint256 x) internal pure returns (uint224) {
 154 |     |         if (x >= 1 << 224) _revertOverflow();
 155 |     |         return uint224(x);
 156 |     |     }
 157 |     | 
 158 |     |     function toUint232(uint256 x) internal pure returns (uint232) {
 159 |     |         if (x >= 1 << 232) _revertOverflow();
 160 |     |         return uint232(x);
 161 |     |     }
 162 |     | 
 163 |     |     function toUint240(uint256 x) internal pure returns (uint240) {
 164 |     |         if (x >= 1 << 240) _revertOverflow();
 165 |     |         return uint240(x);
 166 |     |     }
 167 |     | 
 168 |     |     function toUint248(uint256 x) internal pure returns (uint248) {
 169 |     |         if (x >= 1 << 248) _revertOverflow();
 170 |     |         return uint248(x);
 171 |     |     }
 172 |     | 
 173 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 174 |     |     /*           SIGNED INTEGER SAFE CASTING OPERATIONS           */
 175 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 176 |     | 
 177 |     |     function toInt8(int256 x) internal pure returns (int8) {
 178 |     |         int8 y = int8(x);
 179 |     |         if (x != y) _revertOverflow();
 180 |     |         return y;
 181 |     |     }
 182 |     | 
 183 |     |     function toInt16(int256 x) internal pure returns (int16) {
 184 |     |         int16 y = int16(x);
 185 |     |         if (x != y) _revertOverflow();
 186 |     |         return y;
 187 |     |     }
 188 |     | 
 189 |     |     function toInt24(int256 x) internal pure returns (int24) {
 190 |     |         int24 y = int24(x);
 191 |     |         if (x != y) _revertOverflow();
 192 |     |         return y;
 193 |     |     }
 194 |     | 
 195 |     |     function toInt32(int256 x) internal pure returns (int32) {
 196 |     |         int32 y = int32(x);
 197 |     |         if (x != y) _revertOverflow();
 198 |     |         return y;
 199 |     |     }
 200 |     | 
 201 |     |     function toInt40(int256 x) internal pure returns (int40) {
 202 |     |         int40 y = int40(x);
 203 |     |         if (x != y) _revertOverflow();
 204 |     |         return y;
 205 |     |     }
 206 |     | 
 207 |     |     function toInt48(int256 x) internal pure returns (int48) {
 208 |     |         int48 y = int48(x);
 209 |     |         if (x != y) _revertOverflow();
 210 |     |         return y;
 211 |     |     }
 212 |     | 
 213 |     |     function toInt56(int256 x) internal pure returns (int56) {
 214 |     |         int56 y = int56(x);
 215 |     |         if (x != y) _revertOverflow();
 216 |     |         return y;
 217 |     |     }
 218 |     | 
 219 |     |     function toInt64(int256 x) internal pure returns (int64) {
 220 |     |         int64 y = int64(x);
 221 |     |         if (x != y) _revertOverflow();
 222 |     |         return y;
 223 |     |     }
 224 |     | 
 225 |     |     function toInt72(int256 x) internal pure returns (int72) {
 226 |     |         int72 y = int72(x);
 227 |     |         if (x != y) _revertOverflow();
 228 |     |         return y;
 229 |     |     }
 230 |     | 
 231 |     |     function toInt80(int256 x) internal pure returns (int80) {
 232 |     |         int80 y = int80(x);
 233 |     |         if (x != y) _revertOverflow();
 234 |     |         return y;
 235 |     |     }
 236 |     | 
 237 |     |     function toInt88(int256 x) internal pure returns (int88) {
 238 |     |         int88 y = int88(x);
 239 |     |         if (x != y) _revertOverflow();
 240 |     |         return y;
 241 |     |     }
 242 |     | 
 243 |     |     function toInt96(int256 x) internal pure returns (int96) {
 244 |     |         int96 y = int96(x);
 245 |     |         if (x != y) _revertOverflow();
 246 |     |         return y;
 247 |     |     }
 248 |     | 
 249 |     |     function toInt104(int256 x) internal pure returns (int104) {
 250 |     |         int104 y = int104(x);
 251 |     |         if (x != y) _revertOverflow();
 252 |     |         return y;
 253 |     |     }
 254 |     | 
 255 |     |     function toInt112(int256 x) internal pure returns (int112) {
 256 |     |         int112 y = int112(x);
 257 |     |         if (x != y) _revertOverflow();
 258 |     |         return y;
 259 |     |     }
 260 |     | 
 261 |     |     function toInt120(int256 x) internal pure returns (int120) {
 262 |     |         int120 y = int120(x);
 263 |     |         if (x != y) _revertOverflow();
 264 |     |         return y;
 265 |     |     }
 266 |     | 
 267 |     |     function toInt128(int256 x) internal pure returns (int128) {
 268 |     |         int128 y = int128(x);
 269 |     |         if (x != y) _revertOverflow();
 270 |     |         return y;
 271 |     |     }
 272 |     | 
 273 |     |     function toInt136(int256 x) internal pure returns (int136) {
 274 |     |         int136 y = int136(x);
 275 |     |         if (x != y) _revertOverflow();
 276 |     |         return y;
 277 |     |     }
 278 |     | 
 279 |     |     function toInt144(int256 x) internal pure returns (int144) {
 280 |     |         int144 y = int144(x);
 281 |     |         if (x != y) _revertOverflow();
 282 |     |         return y;
 283 |     |     }
 284 |     | 
 285 |     |     function toInt152(int256 x) internal pure returns (int152) {
 286 |     |         int152 y = int152(x);
 287 |     |         if (x != y) _revertOverflow();
 288 |     |         return y;
 289 |     |     }
 290 |     | 
 291 |     |     function toInt160(int256 x) internal pure returns (int160) {
 292 |     |         int160 y = int160(x);
 293 |     |         if (x != y) _revertOverflow();
 294 |     |         return y;
 295 |     |     }
 296 |     | 
 297 |     |     function toInt168(int256 x) internal pure returns (int168) {
 298 |     |         int168 y = int168(x);
 299 |     |         if (x != y) _revertOverflow();
 300 |     |         return y;
 301 |     |     }
 302 |     | 
 303 |     |     function toInt176(int256 x) internal pure returns (int176) {
 304 |     |         int176 y = int176(x);
 305 |     |         if (x != y) _revertOverflow();
 306 |     |         return y;
 307 |     |     }
 308 |     | 
 309 |     |     function toInt184(int256 x) internal pure returns (int184) {
 310 |     |         int184 y = int184(x);
 311 |     |         if (x != y) _revertOverflow();
 312 |     |         return y;
 313 |     |     }
 314 |     | 
 315 |     |     function toInt192(int256 x) internal pure returns (int192) {
 316 |     |         int192 y = int192(x);
 317 |     |         if (x != y) _revertOverflow();
 318 |     |         return y;
 319 |     |     }
 320 |     | 
 321 |     |     function toInt200(int256 x) internal pure returns (int200) {
 322 |     |         int200 y = int200(x);
 323 |     |         if (x != y) _revertOverflow();
 324 |     |         return y;
 325 |     |     }
 326 |     | 
 327 |     |     function toInt208(int256 x) internal pure returns (int208) {
 328 |     |         int208 y = int208(x);
 329 |     |         if (x != y) _revertOverflow();
 330 |     |         return y;
 331 |     |     }
 332 |     | 
 333 |     |     function toInt216(int256 x) internal pure returns (int216) {
 334 |     |         int216 y = int216(x);
 335 |     |         if (x != y) _revertOverflow();
 336 |     |         return y;
 337 |     |     }
 338 |     | 
 339 |     |     function toInt224(int256 x) internal pure returns (int224) {
 340 |     |         int224 y = int224(x);
 341 |     |         if (x != y) _revertOverflow();
 342 |     |         return y;
 343 |     |     }
 344 |     | 
 345 |     |     function toInt232(int256 x) internal pure returns (int232) {
 346 |     |         int232 y = int232(x);
 347 |     |         if (x != y) _revertOverflow();
 348 |     |         return y;
 349 |     |     }
 350 |     | 
 351 |     |     function toInt240(int256 x) internal pure returns (int240) {
 352 |     |         int240 y = int240(x);
 353 |     |         if (x != y) _revertOverflow();
 354 |     |         return y;
 355 |     |     }
 356 |     | 
 357 |     |     function toInt248(int256 x) internal pure returns (int248) {
 358 |     |         int248 y = int248(x);
 359 |     |         if (x != y) _revertOverflow();
 360 |     |         return y;
 361 |     |     }
 362 |     | 
 363 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 364 |     |     /*               OTHER SAFE CASTING OPERATIONS                */
 365 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 366 |     | 
 367 |     |     function toInt256(uint256 x) internal pure returns (int256) {
 368 |     |         if (x >= 1 << 255) _revertOverflow();
 369 |     |         return int256(x);
 370 |     |     }
 371 |     | 
 372 |     |     function toUint256(int256 x) internal pure returns (uint256) {
 373 |     |         if (x < 0) _revertOverflow();
 374 |     |         return uint256(x);
 375 |     |     }
 376 |     | 
 377 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 378 |     |     /*                      PRIVATE HELPERS                       */
 379 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 380 |     | 
 381 |     |     function _revertOverflow() private pure {
 382 |     |         /// @solidity memory-safe-assembly
 383 |     |         assembly {
 384 |     |             // Store the function selector of `Overflow()`.
 385 |     |             mstore(0x00, 0x35278d12)
 386 |     |             // Revert with (offset, size).
 387 |     |             revert(0x1c, 0x04)
 388 |     |         }
 389 |     |     }
 390 |     | }
 391 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solady/src/utils/SafeTransferLib.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.4;
   3 |     | 
   4 |     | /// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.
   5 |     | /// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)
   6 |     | /// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)
   7 |     | ///
   8 |     | /// @dev Note:
   9 |     | /// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.
  10 |     | /// - For ERC20s, this implementation won't check that a token has code,
  11 |     | ///   responsibility is delegated to the caller.
  12 |     | library SafeTransferLib {
  13 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  14 |     |     /*                       CUSTOM ERRORS                        */
  15 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  16 |     | 
  17 |     |     /// @dev The ETH transfer has failed.
  18 |     |     error ETHTransferFailed();
  19 |     | 
  20 |     |     /// @dev The ERC20 `transferFrom` has failed.
  21 |     |     error TransferFromFailed();
  22 |     | 
  23 |     |     /// @dev The ERC20 `transfer` has failed.
  24 |     |     error TransferFailed();
  25 |     | 
  26 |     |     /// @dev The ERC20 `approve` has failed.
  27 |     |     error ApproveFailed();
  28 |     | 
  29 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  30 |     |     /*                         CONSTANTS                          */
  31 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  32 |     | 
  33 |     |     /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.
  34 |     |     uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;
  35 |     | 
  36 |     |     /// @dev Suggested gas stipend for contract receiving ETH to perform a few
  37 |     |     /// storage reads and writes, but low enough to prevent griefing.
  38 |     |     uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;
  39 |     | 
  40 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  41 |     |     /*                       ETH OPERATIONS                       */
  42 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  43 |     | 
  44 |     |     // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.
  45 |     |     //
  46 |     |     // The regular variants:
  47 |     |     // - Forwards all remaining gas to the target.
  48 |     |     // - Reverts if the target reverts.
  49 |     |     // - Reverts if the current contract has insufficient balance.
  50 |     |     //
  51 |     |     // The force variants:
  52 |     |     // - Forwards with an optional gas stipend
  53 |     |     //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).
  54 |     |     // - If the target reverts, or if the gas stipend is exhausted,
  55 |     |     //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.
  56 |     |     //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.
  57 |     |     // - Reverts if the current contract has insufficient balance.
  58 |     |     //
  59 |     |     // The try variants:
  60 |     |     // - Forwards with a mandatory gas stipend.
  61 |     |     // - Instead of reverting, returns whether the transfer succeeded.
  62 |     | 
  63 |     |     /// @dev Sends `amount` (in wei) ETH to `to`.
  64 |     |     function safeTransferETH(address to, uint256 amount) internal {
  65 |     |         /// @solidity memory-safe-assembly
  66 |     |         assembly {
  67 |     |             if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {
  68 |     |                 mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.
  69 |     |                 revert(0x1c, 0x04)
  70 |     |             }
  71 |     |         }
  72 |     |     }
  73 |     | 
  74 |     |     /// @dev Sends all the ETH in the current contract to `to`.
  75 |     |     function safeTransferAllETH(address to) internal {
  76 |     |         /// @solidity memory-safe-assembly
  77 |     |         assembly {
  78 |     |             // Transfer all the ETH and check if it succeeded or not.
  79 |     |             if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {
  80 |     |                 mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.
  81 |     |                 revert(0x1c, 0x04)
  82 |     |             }
  83 |     |         }
  84 |     |     }
  85 |     | 
  86 |     |     /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.
  87 |     |     function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {
  88 |     |         /// @solidity memory-safe-assembly
  89 |     |         assembly {
  90 |     |             if lt(selfbalance(), amount) {
  91 |     |                 mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.
  92 |     |                 revert(0x1c, 0x04)
  93 |     |             }
  94 |     |             if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {
  95 |     |                 mstore(0x00, to) // Store the address in scratch space.
  96 |     |                 mstore8(0x0b, 0x73) // Opcode `PUSH20`.
  97 |     |                 mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.
  98 |     |                 if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.
  99 |     |             }
 100 |     |         }
 101 |     |     }
 102 |     | 
 103 |     |     /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.
 104 |     |     function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {
 105 |     |         /// @solidity memory-safe-assembly
 106 |     |         assembly {
 107 |     |             if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {
 108 |     |                 mstore(0x00, to) // Store the address in scratch space.
 109 |     |                 mstore8(0x0b, 0x73) // Opcode `PUSH20`.
 110 |     |                 mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.
 111 |     |                 if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.
 112 |     |             }
 113 |     |         }
 114 |     |     }
 115 |     | 
 116 |     |     /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.
 117 |     |     function forceSafeTransferETH(address to, uint256 amount) internal {
 118 |     |         /// @solidity memory-safe-assembly
 119 |     |         assembly {
 120 |     |             if lt(selfbalance(), amount) {
 121 |     |                 mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.
 122 |     |                 revert(0x1c, 0x04)
 123 |     |             }
 124 |     |             if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {
 125 |     |                 mstore(0x00, to) // Store the address in scratch space.
 126 |     |                 mstore8(0x0b, 0x73) // Opcode `PUSH20`.
 127 |     |                 mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.
 128 |     |                 if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.
 129 |     |             }
 130 |     |         }
 131 |     |     }
 132 |     | 
 133 |     |     /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.
 134 |     |     function forceSafeTransferAllETH(address to) internal {
 135 |     |         /// @solidity memory-safe-assembly
 136 |     |         assembly {
 137 |     |             // forgefmt: disable-next-item
 138 |     |             if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {
 139 |     |                 mstore(0x00, to) // Store the address in scratch space.
 140 |     |                 mstore8(0x0b, 0x73) // Opcode `PUSH20`.
 141 |     |                 mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.
 142 |     |                 if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.
 143 |     |             }
 144 |     |         }
 145 |     |     }
 146 |     | 
 147 |     |     /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.
 148 |     |     function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)
 149 |     |         internal
 150 |     |         returns (bool success)
 151 |     |     {
 152 |     |         /// @solidity memory-safe-assembly
 153 |     |         assembly {
 154 |     |             success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)
 155 |     |         }
 156 |     |     }
 157 |     | 
 158 |     |     /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.
 159 |     |     function trySafeTransferAllETH(address to, uint256 gasStipend)
 160 |     |         internal
 161 |     |         returns (bool success)
 162 |     |     {
 163 |     |         /// @solidity memory-safe-assembly
 164 |     |         assembly {
 165 |     |             success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)
 166 |     |         }
 167 |     |     }
 168 |     | 
 169 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 170 |     |     /*                      ERC20 OPERATIONS                      */
 171 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 172 |     | 
 173 |     |     /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.
 174 |     |     /// Reverts upon failure.
 175 |     |     ///
 176 |     |     /// The `from` account must have at least `amount` approved for
 177 |     |     /// the current contract to manage.
 178 | *   |     function safeTransferFrom(address token, address from, address to, uint256 amount) internal {
 179 |     |         /// @solidity memory-safe-assembly
 180 |     |         assembly {
 181 | *   |             let m := mload(0x40) // Cache the free memory pointer.
 182 | *   |             mstore(0x60, amount) // Store the `amount` argument.
 183 | *   |             mstore(0x40, to) // Store the `to` argument.
 184 | *   |             mstore(0x2c, shl(96, from)) // Store the `from` argument.
 185 | *   |             mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.
 186 |     |             // Perform the transfer, reverting upon failure.
 187 | *   |             if iszero(
 188 | *   |                 and( // The arguments of `and` are evaluated from right to left.
 189 | *   |                     or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.
 190 | *   |                     call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)
 191 |     |                 )
 192 |     |             ) {
 193 | *   |                 mstore(0x00, 0x7939f424) // `TransferFromFailed()`.
 194 | *   |                 revert(0x1c, 0x04)
 195 |     |             }
 196 | *   |             mstore(0x60, 0) // Restore the zero slot to zero.
 197 | *   |             mstore(0x40, m) // Restore the free memory pointer.
 198 |     |         }
 199 |     |     }
 200 |     | 
 201 |     |     /// @dev Sends all of ERC20 `token` from `from` to `to`.
 202 |     |     /// Reverts upon failure.
 203 |     |     ///
 204 |     |     /// The `from` account must have their entire balance approved for
 205 |     |     /// the current contract to manage.
 206 |     |     function safeTransferAllFrom(address token, address from, address to)
 207 |     |         internal
 208 |     |         returns (uint256 amount)
 209 |     |     {
 210 |     |         /// @solidity memory-safe-assembly
 211 |     |         assembly {
 212 |     |             let m := mload(0x40) // Cache the free memory pointer.
 213 |     |             mstore(0x40, to) // Store the `to` argument.
 214 |     |             mstore(0x2c, shl(96, from)) // Store the `from` argument.
 215 |     |             mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.
 216 |     |             // Read the balance, reverting upon failure.
 217 |     |             if iszero(
 218 |     |                 and( // The arguments of `and` are evaluated from right to left.
 219 |     |                     gt(returndatasize(), 0x1f), // At least 32 bytes returned.
 220 |     |                     staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)
 221 |     |                 )
 222 |     |             ) {
 223 |     |                 mstore(0x00, 0x7939f424) // `TransferFromFailed()`.
 224 |     |                 revert(0x1c, 0x04)
 225 |     |             }
 226 |     |             mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.
 227 |     |             amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.
 228 |     |             // Perform the transfer, reverting upon failure.
 229 |     |             if iszero(
 230 |     |                 and( // The arguments of `and` are evaluated from right to left.
 231 |     |                     or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.
 232 |     |                     call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)
 233 |     |                 )
 234 |     |             ) {
 235 |     |                 mstore(0x00, 0x7939f424) // `TransferFromFailed()`.
 236 |     |                 revert(0x1c, 0x04)
 237 |     |             }
 238 |     |             mstore(0x60, 0) // Restore the zero slot to zero.
 239 |     |             mstore(0x40, m) // Restore the free memory pointer.
 240 |     |         }
 241 |     |     }
 242 |     | 
 243 |     |     /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.
 244 |     |     /// Reverts upon failure.
 245 |     |     function safeTransfer(address token, address to, uint256 amount) internal {
 246 |     |         /// @solidity memory-safe-assembly
 247 |     |         assembly {
 248 |     |             mstore(0x14, to) // Store the `to` argument.
 249 |     |             mstore(0x34, amount) // Store the `amount` argument.
 250 |     |             mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.
 251 |     |             // Perform the transfer, reverting upon failure.
 252 |     |             if iszero(
 253 |     |                 and( // The arguments of `and` are evaluated from right to left.
 254 |     |                     or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.
 255 |     |                     call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)
 256 |     |                 )
 257 |     |             ) {
 258 |     |                 mstore(0x00, 0x90b8ec18) // `TransferFailed()`.
 259 |     |                 revert(0x1c, 0x04)
 260 |     |             }
 261 |     |             mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.
 262 |     |         }
 263 |     |     }
 264 |     | 
 265 |     |     /// @dev Sends all of ERC20 `token` from the current contract to `to`.
 266 |     |     /// Reverts upon failure.
 267 |     |     function safeTransferAll(address token, address to) internal returns (uint256 amount) {
 268 |     |         /// @solidity memory-safe-assembly
 269 |     |         assembly {
 270 |     |             mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.
 271 |     |             mstore(0x20, address()) // Store the address of the current contract.
 272 |     |             // Read the balance, reverting upon failure.
 273 |     |             if iszero(
 274 |     |                 and( // The arguments of `and` are evaluated from right to left.
 275 |     |                     gt(returndatasize(), 0x1f), // At least 32 bytes returned.
 276 |     |                     staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)
 277 |     |                 )
 278 |     |             ) {
 279 |     |                 mstore(0x00, 0x90b8ec18) // `TransferFailed()`.
 280 |     |                 revert(0x1c, 0x04)
 281 |     |             }
 282 |     |             mstore(0x14, to) // Store the `to` argument.
 283 |     |             amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.
 284 |     |             mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.
 285 |     |             // Perform the transfer, reverting upon failure.
 286 |     |             if iszero(
 287 |     |                 and( // The arguments of `and` are evaluated from right to left.
 288 |     |                     or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.
 289 |     |                     call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)
 290 |     |                 )
 291 |     |             ) {
 292 |     |                 mstore(0x00, 0x90b8ec18) // `TransferFailed()`.
 293 |     |                 revert(0x1c, 0x04)
 294 |     |             }
 295 |     |             mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.
 296 |     |         }
 297 |     |     }
 298 |     | 
 299 |     |     /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.
 300 |     |     /// Reverts upon failure.
 301 |     |     function safeApprove(address token, address to, uint256 amount) internal {
 302 |     |         /// @solidity memory-safe-assembly
 303 |     |         assembly {
 304 |     |             mstore(0x14, to) // Store the `to` argument.
 305 |     |             mstore(0x34, amount) // Store the `amount` argument.
 306 |     |             mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.
 307 |     |             // Perform the approval, reverting upon failure.
 308 |     |             if iszero(
 309 |     |                 and( // The arguments of `and` are evaluated from right to left.
 310 |     |                     or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.
 311 |     |                     call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)
 312 |     |                 )
 313 |     |             ) {
 314 |     |                 mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.
 315 |     |                 revert(0x1c, 0x04)
 316 |     |             }
 317 |     |             mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.
 318 |     |         }
 319 |     |     }
 320 |     | 
 321 |     |     /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.
 322 |     |     /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,
 323 |     |     /// then retries the approval again (some tokens, e.g. USDT, requires this).
 324 |     |     /// Reverts upon failure.
 325 |     |     function safeApproveWithRetry(address token, address to, uint256 amount) internal {
 326 |     |         /// @solidity memory-safe-assembly
 327 |     |         assembly {
 328 |     |             mstore(0x14, to) // Store the `to` argument.
 329 |     |             mstore(0x34, amount) // Store the `amount` argument.
 330 |     |             mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.
 331 |     |             // Perform the approval, retrying upon failure.
 332 |     |             if iszero(
 333 |     |                 and( // The arguments of `and` are evaluated from right to left.
 334 |     |                     or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.
 335 |     |                     call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)
 336 |     |                 )
 337 |     |             ) {
 338 |     |                 mstore(0x34, 0) // Store 0 for the `amount`.
 339 |     |                 mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.
 340 |     |                 pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.
 341 |     |                 mstore(0x34, amount) // Store back the original `amount`.
 342 |     |                 // Retry the approval, reverting upon failure.
 343 |     |                 if iszero(
 344 |     |                     and(
 345 |     |                         or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.
 346 |     |                         call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)
 347 |     |                     )
 348 |     |                 ) {
 349 |     |                     mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.
 350 |     |                     revert(0x1c, 0x04)
 351 |     |                 }
 352 |     |             }
 353 |     |             mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.
 354 |     |         }
 355 |     |     }
 356 |     | 
 357 |     |     /// @dev Returns the amount of ERC20 `token` owned by `account`.
 358 |     |     /// Returns zero if the `token` does not exist.
 359 | *   |     function balanceOf(address token, address account) internal view returns (uint256 amount) {
 360 |     |         /// @solidity memory-safe-assembly
 361 |     |         assembly {
 362 | *   |             mstore(0x14, account) // Store the `account` argument.
 363 | *   |             mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.
 364 | *   |             amount :=
 365 | *   |                 mul(
 366 | *   |                     mload(0x20),
 367 | *   |                     and( // The arguments of `and` are evaluated from right to left.
 368 | *   |                         gt(returndatasize(), 0x1f), // At least 32 bytes returned.
 369 | *   |                         staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)
 370 |     |                     )
 371 |     |                 )
 372 |     |         }
 373 |     |     }
 374 |     | }
 375 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solmate/src/auth/Owned.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0-only
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @notice Simple single owner authorization mixin.
  5 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)
  6 |     | abstract contract Owned {
  7 |     |     /*//////////////////////////////////////////////////////////////
  8 |     |                                  EVENTS
  9 |     |     //////////////////////////////////////////////////////////////*/
 10 |     | 
 11 |     |     event OwnershipTransferred(address indexed user, address indexed newOwner);
 12 |     | 
 13 |     |     /*//////////////////////////////////////////////////////////////
 14 |     |                             OWNERSHIP STORAGE
 15 |     |     //////////////////////////////////////////////////////////////*/
 16 |     | 
 17 |     |     address public owner;
 18 |     | 
 19 |     |     modifier onlyOwner() virtual {
 20 |     |         require(msg.sender == owner, "UNAUTHORIZED");
 21 |     | 
 22 |     |         _;
 23 |     |     }
 24 |     | 
 25 |     |     /*//////////////////////////////////////////////////////////////
 26 |     |                                CONSTRUCTOR
 27 |     |     //////////////////////////////////////////////////////////////*/
 28 |     | 
 29 |     |     constructor(address _owner) {
 30 |     |         owner = _owner;
 31 |     | 
 32 |     |         emit OwnershipTransferred(address(0), _owner);
 33 |     |     }
 34 |     | 
 35 |     |     /*//////////////////////////////////////////////////////////////
 36 |     |                              OWNERSHIP LOGIC
 37 |     |     //////////////////////////////////////////////////////////////*/
 38 |     | 
 39 |     |     function transferOwnership(address newOwner) public virtual onlyOwner {
 40 |     |         owner = newOwner;
 41 |     | 
 42 |     |         emit OwnershipTransferred(msg.sender, newOwner);
 43 |     |     }
 44 |     | }
 45 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solmate/src/tokens/ERC20.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.
   5 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)
   6 |     | /// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)
   7 |     | /// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.
   8 |     | abstract contract ERC20 {
   9 |     |     /*//////////////////////////////////////////////////////////////
  10 |     |                                  EVENTS
  11 |     |     //////////////////////////////////////////////////////////////*/
  12 |     | 
  13 |     |     event Transfer(address indexed from, address indexed to, uint256 amount);
  14 |     | 
  15 |     |     event Approval(address indexed owner, address indexed spender, uint256 amount);
  16 |     | 
  17 |     |     /*//////////////////////////////////////////////////////////////
  18 |     |                             METADATA STORAGE
  19 |     |     //////////////////////////////////////////////////////////////*/
  20 |     | 
  21 |     |     string public name;
  22 |     | 
  23 |     |     string public symbol;
  24 |     | 
  25 |     |     uint8 public immutable decimals;
  26 |     | 
  27 |     |     /*//////////////////////////////////////////////////////////////
  28 |     |                               ERC20 STORAGE
  29 |     |     //////////////////////////////////////////////////////////////*/
  30 |     | 
  31 |     |     uint256 public totalSupply;
  32 |     | 
  33 |     |     mapping(address => uint256) public balanceOf;
  34 |     | 
  35 |     |     mapping(address => mapping(address => uint256)) public allowance;
  36 |     | 
  37 |     |     /*//////////////////////////////////////////////////////////////
  38 |     |                             EIP-2612 STORAGE
  39 |     |     //////////////////////////////////////////////////////////////*/
  40 |     | 
  41 |     |     uint256 internal immutable INITIAL_CHAIN_ID;
  42 |     | 
  43 |     |     bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;
  44 |     | 
  45 |     |     mapping(address => uint256) public nonces;
  46 |     | 
  47 |     |     /*//////////////////////////////////////////////////////////////
  48 |     |                                CONSTRUCTOR
  49 |     |     //////////////////////////////////////////////////////////////*/
  50 |     | 
  51 |     |     constructor(
  52 |     |         string memory _name,
  53 |     |         string memory _symbol,
  54 |     |         uint8 _decimals
  55 |     |     ) {
  56 |     |         name = _name;
  57 |     |         symbol = _symbol;
  58 |     |         decimals = _decimals;
  59 |     | 
  60 |     |         INITIAL_CHAIN_ID = block.chainid;
  61 |     |         INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();
  62 |     |     }
  63 |     | 
  64 |     |     /*//////////////////////////////////////////////////////////////
  65 |     |                                ERC20 LOGIC
  66 |     |     //////////////////////////////////////////////////////////////*/
  67 |     | 
  68 |     |     function approve(address spender, uint256 amount) public virtual returns (bool) {
  69 |     |         allowance[msg.sender][spender] = amount;
  70 |     | 
  71 |     |         emit Approval(msg.sender, spender, amount);
  72 |     | 
  73 |     |         return true;
  74 |     |     }
  75 |     | 
  76 |     |     function transfer(address to, uint256 amount) public virtual returns (bool) {
  77 |     |         balanceOf[msg.sender] -= amount;
  78 |     | 
  79 |     |         // Cannot overflow because the sum of all user
  80 |     |         // balances can't exceed the max uint256 value.
  81 |     |         unchecked {
  82 |     |             balanceOf[to] += amount;
  83 |     |         }
  84 |     | 
  85 |     |         emit Transfer(msg.sender, to, amount);
  86 |     | 
  87 |     |         return true;
  88 |     |     }
  89 |     | 
  90 |     |     function transferFrom(
  91 |     |         address from,
  92 |     |         address to,
  93 |     |         uint256 amount
  94 |     |     ) public virtual returns (bool) {
  95 |     |         uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.
  96 |     | 
  97 |     |         if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;
  98 |     | 
  99 |     |         balanceOf[from] -= amount;
 100 |     | 
 101 |     |         // Cannot overflow because the sum of all user
 102 |     |         // balances can't exceed the max uint256 value.
 103 |     |         unchecked {
 104 |     |             balanceOf[to] += amount;
 105 |     |         }
 106 |     | 
 107 |     |         emit Transfer(from, to, amount);
 108 |     | 
 109 |     |         return true;
 110 |     |     }
 111 |     | 
 112 |     |     /*//////////////////////////////////////////////////////////////
 113 |     |                              EIP-2612 LOGIC
 114 |     |     //////////////////////////////////////////////////////////////*/
 115 |     | 
 116 |     |     function permit(
 117 |     |         address owner,
 118 |     |         address spender,
 119 |     |         uint256 value,
 120 |     |         uint256 deadline,
 121 |     |         uint8 v,
 122 |     |         bytes32 r,
 123 |     |         bytes32 s
 124 |     |     ) public virtual {
 125 |     |         require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");
 126 |     | 
 127 |     |         // Unchecked because the only math done is incrementing
 128 |     |         // the owner's nonce which cannot realistically overflow.
 129 |     |         unchecked {
 130 |     |             address recoveredAddress = ecrecover(
 131 |     |                 keccak256(
 132 |     |                     abi.encodePacked(
 133 |     |                         "\x19\x01",
 134 |     |                         DOMAIN_SEPARATOR(),
 135 |     |                         keccak256(
 136 |     |                             abi.encode(
 137 |     |                                 keccak256(
 138 |     |                                     "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
 139 |     |                                 ),
 140 |     |                                 owner,
 141 |     |                                 spender,
 142 |     |                                 value,
 143 |     |                                 nonces[owner]++,
 144 |     |                                 deadline
 145 |     |                             )
 146 |     |                         )
 147 |     |                     )
 148 |     |                 ),
 149 |     |                 v,
 150 |     |                 r,
 151 |     |                 s
 152 |     |             );
 153 |     | 
 154 |     |             require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");
 155 |     | 
 156 |     |             allowance[recoveredAddress][spender] = value;
 157 |     |         }
 158 |     | 
 159 |     |         emit Approval(owner, spender, value);
 160 |     |     }
 161 |     | 
 162 |     |     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
 163 |     |         return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();
 164 |     |     }
 165 |     | 
 166 |     |     function computeDomainSeparator() internal view virtual returns (bytes32) {
 167 |     |         return
 168 |     |             keccak256(
 169 |     |                 abi.encode(
 170 |     |                     keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
 171 |     |                     keccak256(bytes(name)),
 172 |     |                     keccak256("1"),
 173 |     |                     block.chainid,
 174 |     |                     address(this)
 175 |     |                 )
 176 |     |             );
 177 |     |     }
 178 |     | 
 179 |     |     /*//////////////////////////////////////////////////////////////
 180 |     |                         INTERNAL MINT/BURN LOGIC
 181 |     |     //////////////////////////////////////////////////////////////*/
 182 |     | 
 183 |     |     function _mint(address to, uint256 amount) internal virtual {
 184 |     |         totalSupply += amount;
 185 |     | 
 186 |     |         // Cannot overflow because the sum of all user
 187 |     |         // balances can't exceed the max uint256 value.
 188 |     |         unchecked {
 189 |     |             balanceOf[to] += amount;
 190 |     |         }
 191 |     | 
 192 |     |         emit Transfer(address(0), to, amount);
 193 |     |     }
 194 |     | 
 195 |     |     function _burn(address from, uint256 amount) internal virtual {
 196 |     |         balanceOf[from] -= amount;
 197 |     | 
 198 |     |         // Cannot underflow because a user's balance
 199 |     |         // will never be larger than the total supply.
 200 |     |         unchecked {
 201 |     |             totalSupply -= amount;
 202 |     |         }
 203 |     | 
 204 |     |         emit Transfer(from, address(0), amount);
 205 |     |     }
 206 |     | }
 207 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solmate/src/utils/Bytes32AddressLib.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0-only
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @notice Library for converting between addresses and bytes32 values.
  5 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Bytes32AddressLib.sol)
  6 |     | library Bytes32AddressLib {
  7 |     |     function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {
  8 |     |         return address(uint160(uint256(bytesValue)));
  9 |     |     }
 10 |     | 
 11 |     |     function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {
 12 |     |         return bytes32(bytes20(addressValue));
 13 |     |     }
 14 |     | }
 15 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solmate/src/utils/CREATE3.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0-only
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {Bytes32AddressLib} from "./Bytes32AddressLib.sol";
  5 |     | 
  6 |     | /// @notice Deploy to deterministic addresses without an initcode factor.
  7 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)
  8 |     | /// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)
  9 |     | library CREATE3 {
 10 |     |     using Bytes32AddressLib for bytes32;
 11 |     | 
 12 |     |     //--------------------------------------------------------------------------------//
 13 |     |     // Opcode     | Opcode + Arguments    | Description      | Stack View             //
 14 |     |     //--------------------------------------------------------------------------------//
 15 |     |     // 0x36       |  0x36                 | CALLDATASIZE     | size                   //
 16 |     |     // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //
 17 |     |     // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //
 18 |     |     // 0x37       |  0x37                 | CALLDATACOPY     |                        //
 19 |     |     // 0x36       |  0x36                 | CALLDATASIZE     | size                   //
 20 |     |     // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //
 21 |     |     // 0x34       |  0x34                 | CALLVALUE        | value 0 size           //
 22 |     |     // 0xf0       |  0xf0                 | CREATE           | newContract            //
 23 |     |     //--------------------------------------------------------------------------------//
 24 |     |     // Opcode     | Opcode + Arguments    | Description      | Stack View             //
 25 |     |     //--------------------------------------------------------------------------------//
 26 |     |     // 0x67       |  0x67XXXXXXXXXXXXXXXX | PUSH8 bytecode   | bytecode               //
 27 |     |     // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 bytecode             //
 28 |     |     // 0x52       |  0x52                 | MSTORE           |                        //
 29 |     |     // 0x60       |  0x6008               | PUSH1 08         | 8                      //
 30 |     |     // 0x60       |  0x6018               | PUSH1 18         | 24 8                   //
 31 |     |     // 0xf3       |  0xf3                 | RETURN           |                        //
 32 |     |     //--------------------------------------------------------------------------------//
 33 |     |     bytes internal constant PROXY_BYTECODE = hex"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3";
 34 |     | 
 35 |     |     bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);
 36 |     | 
 37 |     |     function deploy(
 38 |     |         bytes32 salt,
 39 |     |         bytes memory creationCode,
 40 |     |         uint256 value
 41 |     |     ) internal returns (address deployed) {
 42 |     |         bytes memory proxyChildBytecode = PROXY_BYTECODE;
 43 |     | 
 44 |     |         address proxy;
 45 |     |         /// @solidity memory-safe-assembly
 46 |     |         assembly {
 47 |     |             // Deploy a new contract with our pre-made bytecode via CREATE2.
 48 |     |             // We start 32 bytes into the code to avoid copying the byte length.
 49 |     |             proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)
 50 |     |         }
 51 |     |         require(proxy != address(0), "DEPLOYMENT_FAILED");
 52 |     | 
 53 |     |         deployed = getDeployed(salt);
 54 |     |         (bool success, ) = proxy.call{value: value}(creationCode);
 55 |     |         require(success && deployed.code.length != 0, "INITIALIZATION_FAILED");
 56 |     |     }
 57 |     | 
 58 |     |     function getDeployed(bytes32 salt) internal view returns (address) {
 59 |     |         address proxy = keccak256(
 60 |     |             abi.encodePacked(
 61 |     |                 // Prefix:
 62 |     |                 bytes1(0xFF),
 63 |     |                 // Creator:
 64 |     |                 address(this),
 65 |     |                 // Salt:
 66 |     |                 salt,
 67 |     |                 // Bytecode hash:
 68 |     |                 PROXY_BYTECODE_HASH
 69 |     |             )
 70 |     |         ).fromLast20Bytes();
 71 |     | 
 72 |     |         return
 73 |     |             keccak256(
 74 |     |                 abi.encodePacked(
 75 |     |                     // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01)
 76 |     |                     // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)
 77 |     |                     hex"d6_94",
 78 |     |                     proxy,
 79 |     |                     hex"01" // Nonce of the proxy contract (1)
 80 |     |                 )
 81 |     |             ).fromLast20Bytes();
 82 |     |     }
 83 |     | }
 84 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solmate/src/utils/FixedPointMathLib.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @notice Arithmetic library with operations for fixed-point numbers.
   5 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)
   6 |     | /// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
   7 |     | library FixedPointMathLib {
   8 |     |     /*//////////////////////////////////////////////////////////////
   9 |     |                     SIMPLIFIED FIXED POINT OPERATIONS
  10 |     |     //////////////////////////////////////////////////////////////*/
  11 |     | 
  12 |     |     uint256 internal constant MAX_UINT256 = 2**256 - 1;
  13 |     | 
  14 |     |     uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.
  15 |     | 
  16 |     |     function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
  17 |     |         return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.
  18 |     |     }
  19 |     | 
  20 |     |     function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
  21 |     |         return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.
  22 |     |     }
  23 |     | 
  24 |     |     function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
  25 |     |         return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.
  26 |     |     }
  27 |     | 
  28 |     |     function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
  29 |     |         return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.
  30 |     |     }
  31 |     | 
  32 |     |     /*//////////////////////////////////////////////////////////////
  33 |     |                     LOW LEVEL FIXED POINT OPERATIONS
  34 |     |     //////////////////////////////////////////////////////////////*/
  35 |     | 
  36 |     |     function mulDivDown(
  37 |     |         uint256 x,
  38 |     |         uint256 y,
  39 |     |         uint256 denominator
  40 |     |     ) internal pure returns (uint256 z) {
  41 |     |         /// @solidity memory-safe-assembly
  42 |     |         assembly {
  43 |     |             // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
  44 |     |             if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {
  45 |     |                 revert(0, 0)
  46 |     |             }
  47 |     | 
  48 |     |             // Divide x * y by the denominator.
  49 |     |             z := div(mul(x, y), denominator)
  50 |     |         }
  51 |     |     }
  52 |     | 
  53 |     |     function mulDivUp(
  54 |     |         uint256 x,
  55 |     |         uint256 y,
  56 |     |         uint256 denominator
  57 |     |     ) internal pure returns (uint256 z) {
  58 |     |         /// @solidity memory-safe-assembly
  59 |     |         assembly {
  60 |     |             // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
  61 |     |             if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {
  62 |     |                 revert(0, 0)
  63 |     |             }
  64 |     | 
  65 |     |             // If x * y modulo the denominator is strictly greater than 0,
  66 |     |             // 1 is added to round up the division of x * y by the denominator.
  67 |     |             z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))
  68 |     |         }
  69 |     |     }
  70 |     | 
  71 |     |     function rpow(
  72 |     |         uint256 x,
  73 |     |         uint256 n,
  74 |     |         uint256 scalar
  75 |     |     ) internal pure returns (uint256 z) {
  76 |     |         /// @solidity memory-safe-assembly
  77 |     |         assembly {
  78 |     |             switch x
  79 |     |             case 0 {
  80 |     |                 switch n
  81 |     |                 case 0 {
  82 |     |                     // 0 ** 0 = 1
  83 |     |                     z := scalar
  84 |     |                 }
  85 |     |                 default {
  86 |     |                     // 0 ** n = 0
  87 |     |                     z := 0
  88 |     |                 }
  89 |     |             }
  90 |     |             default {
  91 |     |                 switch mod(n, 2)
  92 |     |                 case 0 {
  93 |     |                     // If n is even, store scalar in z for now.
  94 |     |                     z := scalar
  95 |     |                 }
  96 |     |                 default {
  97 |     |                     // If n is odd, store x in z for now.
  98 |     |                     z := x
  99 |     |                 }
 100 |     | 
 101 |     |                 // Shifting right by 1 is like dividing by 2.
 102 |     |                 let half := shr(1, scalar)
 103 |     | 
 104 |     |                 for {
 105 |     |                     // Shift n right by 1 before looping to halve it.
 106 |     |                     n := shr(1, n)
 107 |     |                 } n {
 108 |     |                     // Shift n right by 1 each iteration to halve it.
 109 |     |                     n := shr(1, n)
 110 |     |                 } {
 111 |     |                     // Revert immediately if x ** 2 would overflow.
 112 |     |                     // Equivalent to iszero(eq(div(xx, x), x)) here.
 113 |     |                     if shr(128, x) {
 114 |     |                         revert(0, 0)
 115 |     |                     }
 116 |     | 
 117 |     |                     // Store x squared.
 118 |     |                     let xx := mul(x, x)
 119 |     | 
 120 |     |                     // Round to the nearest number.
 121 |     |                     let xxRound := add(xx, half)
 122 |     | 
 123 |     |                     // Revert if xx + half overflowed.
 124 |     |                     if lt(xxRound, xx) {
 125 |     |                         revert(0, 0)
 126 |     |                     }
 127 |     | 
 128 |     |                     // Set x to scaled xxRound.
 129 |     |                     x := div(xxRound, scalar)
 130 |     | 
 131 |     |                     // If n is even:
 132 |     |                     if mod(n, 2) {
 133 |     |                         // Compute z * x.
 134 |     |                         let zx := mul(z, x)
 135 |     | 
 136 |     |                         // If z * x overflowed:
 137 |     |                         if iszero(eq(div(zx, x), z)) {
 138 |     |                             // Revert if x is non-zero.
 139 |     |                             if iszero(iszero(x)) {
 140 |     |                                 revert(0, 0)
 141 |     |                             }
 142 |     |                         }
 143 |     | 
 144 |     |                         // Round to the nearest number.
 145 |     |                         let zxRound := add(zx, half)
 146 |     | 
 147 |     |                         // Revert if zx + half overflowed.
 148 |     |                         if lt(zxRound, zx) {
 149 |     |                             revert(0, 0)
 150 |     |                         }
 151 |     | 
 152 |     |                         // Return properly scaled zxRound.
 153 |     |                         z := div(zxRound, scalar)
 154 |     |                     }
 155 |     |                 }
 156 |     |             }
 157 |     |         }
 158 |     |     }
 159 |     | 
 160 |     |     /*//////////////////////////////////////////////////////////////
 161 |     |                         GENERAL NUMBER UTILITIES
 162 |     |     //////////////////////////////////////////////////////////////*/
 163 |     | 
 164 |     |     function sqrt(uint256 x) internal pure returns (uint256 z) {
 165 |     |         /// @solidity memory-safe-assembly
 166 |     |         assembly {
 167 |     |             let y := x // We start y at x, which will help us make our initial estimate.
 168 |     | 
 169 |     |             z := 181 // The "correct" value is 1, but this saves a multiplication later.
 170 |     | 
 171 |     |             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
 172 |     |             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
 173 |     | 
 174 |     |             // We check y >= 2^(k + 8) but shift right by k bits
 175 |     |             // each branch to ensure that if x >= 256, then y >= 256.
 176 |     |             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
 177 |     |                 y := shr(128, y)
 178 |     |                 z := shl(64, z)
 179 |     |             }
 180 |     |             if iszero(lt(y, 0x1000000000000000000)) {
 181 |     |                 y := shr(64, y)
 182 |     |                 z := shl(32, z)
 183 |     |             }
 184 |     |             if iszero(lt(y, 0x10000000000)) {
 185 |     |                 y := shr(32, y)
 186 |     |                 z := shl(16, z)
 187 |     |             }
 188 |     |             if iszero(lt(y, 0x1000000)) {
 189 |     |                 y := shr(16, y)
 190 |     |                 z := shl(8, z)
 191 |     |             }
 192 |     | 
 193 |     |             // Goal was to get z*z*y within a small factor of x. More iterations could
 194 |     |             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
 195 |     |             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
 196 |     |             // That's not possible if x < 256 but we can just verify those cases exhaustively.
 197 |     | 
 198 |     |             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
 199 |     |             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
 200 |     |             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
 201 |     | 
 202 |     |             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
 203 |     |             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
 204 |     | 
 205 |     |             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
 206 |     |             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
 207 |     | 
 208 |     |             // There is no overflow risk here since y < 2^136 after the first branch above.
 209 |     |             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
 210 |     | 
 211 |     |             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
 212 |     |             z := shr(1, add(z, div(x, z)))
 213 |     |             z := shr(1, add(z, div(x, z)))
 214 |     |             z := shr(1, add(z, div(x, z)))
 215 |     |             z := shr(1, add(z, div(x, z)))
 216 |     |             z := shr(1, add(z, div(x, z)))
 217 |     |             z := shr(1, add(z, div(x, z)))
 218 |     |             z := shr(1, add(z, div(x, z)))
 219 |     | 
 220 |     |             // If x+1 is a perfect square, the Babylonian method cycles between
 221 |     |             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
 222 |     |             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
 223 |     |             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
 224 |     |             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
 225 |     |             z := sub(z, lt(div(x, z), z))
 226 |     |         }
 227 |     |     }
 228 |     | 
 229 |     |     function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {
 230 |     |         /// @solidity memory-safe-assembly
 231 |     |         assembly {
 232 |     |             // Mod x by y. Note this will return
 233 |     |             // 0 instead of reverting if y is zero.
 234 |     |             z := mod(x, y)
 235 |     |         }
 236 |     |     }
 237 |     | 
 238 |     |     function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {
 239 |     |         /// @solidity memory-safe-assembly
 240 |     |         assembly {
 241 |     |             // Divide x by y. Note this will return
 242 |     |             // 0 instead of reverting if y is zero.
 243 |     |             r := div(x, y)
 244 |     |         }
 245 |     |     }
 246 |     | 
 247 |     |     function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
 248 |     |         /// @solidity memory-safe-assembly
 249 |     |         assembly {
 250 |     |             // Add 1 to x * y if x % y > 0. Note this will
 251 |     |             // return 0 instead of reverting if y is zero.
 252 |     |             z := add(gt(mod(x, y), 0), div(x, y))
 253 |     |         }
 254 |     |     }
 255 |     | }
 256 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solmate/src/utils/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0-only
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @notice Gas optimized reentrancy protection for smart contracts.
  5 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)
  6 |     | /// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)
  7 |     | abstract contract ReentrancyGuard {
  8 |     |     uint256 private locked = 1;
  9 |     | 
 10 |     |     modifier nonReentrant() virtual {
 11 |     |         require(locked == 1, "REENTRANCY");
 12 |     | 
 13 |     |         locked = 2;
 14 |     | 
 15 |     |         _;
 16 |     | 
 17 |     |         locked = 1;
 18 |     |     }
 19 |     | }
 20 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/lib/solmate/src/utils/SafeTransferLib.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {ERC20} from "../tokens/ERC20.sol";
   5 |     | 
   6 |     | /// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.
   7 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)
   8 |     | /// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.
   9 |     | /// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.
  10 |     | library SafeTransferLib {
  11 |     |     /*//////////////////////////////////////////////////////////////
  12 |     |                              ETH OPERATIONS
  13 |     |     //////////////////////////////////////////////////////////////*/
  14 |     | 
  15 |     |     function safeTransferETH(address to, uint256 amount) internal {
  16 |     |         bool success;
  17 |     | 
  18 |     |         /// @solidity memory-safe-assembly
  19 |     |         assembly {
  20 |     |             // Transfer the ETH and store if it succeeded or not.
  21 |     |             success := call(gas(), to, amount, 0, 0, 0, 0)
  22 |     |         }
  23 |     | 
  24 |     |         require(success, "ETH_TRANSFER_FAILED");
  25 |     |     }
  26 |     | 
  27 |     |     /*//////////////////////////////////////////////////////////////
  28 |     |                             ERC20 OPERATIONS
  29 |     |     //////////////////////////////////////////////////////////////*/
  30 |     | 
  31 |     |     function safeTransferFrom(
  32 |     |         ERC20 token,
  33 |     |         address from,
  34 |     |         address to,
  35 |     |         uint256 amount
  36 |     |     ) internal {
  37 |     |         bool success;
  38 |     | 
  39 |     |         /// @solidity memory-safe-assembly
  40 |     |         assembly {
  41 |     |             // Get a pointer to some free memory.
  42 |     |             let freeMemoryPointer := mload(0x40)
  43 |     | 
  44 |     |             // Write the abi-encoded calldata into memory, beginning with the function selector.
  45 |     |             mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)
  46 |     |             mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the "from" argument.
  47 |     |             mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the "to" argument.
  48 |     |             mstore(add(freeMemoryPointer, 68), amount) // Append the "amount" argument. Masking not required as it's a full 32 byte type.
  49 |     | 
  50 |     |             success := and(
  51 |     |                 // Set success to whether the call reverted, if not we check it either
  52 |     |                 // returned exactly 1 (can't just be non-zero data), or had no return data.
  53 |     |                 or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),
  54 |     |                 // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.
  55 |     |                 // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.
  56 |     |                 // Counterintuitively, this call must be positioned second to the or() call in the
  57 |     |                 // surrounding and() call or else returndatasize() will be zero during the computation.
  58 |     |                 call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)
  59 |     |             )
  60 |     |         }
  61 |     | 
  62 |     |         require(success, "TRANSFER_FROM_FAILED");
  63 |     |     }
  64 |     | 
  65 |     |     function safeTransfer(
  66 |     |         ERC20 token,
  67 |     |         address to,
  68 |     |         uint256 amount
  69 |     |     ) internal {
  70 |     |         bool success;
  71 |     | 
  72 |     |         /// @solidity memory-safe-assembly
  73 |     |         assembly {
  74 |     |             // Get a pointer to some free memory.
  75 |     |             let freeMemoryPointer := mload(0x40)
  76 |     | 
  77 |     |             // Write the abi-encoded calldata into memory, beginning with the function selector.
  78 |     |             mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)
  79 |     |             mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the "to" argument.
  80 |     |             mstore(add(freeMemoryPointer, 36), amount) // Append the "amount" argument. Masking not required as it's a full 32 byte type.
  81 |     | 
  82 |     |             success := and(
  83 |     |                 // Set success to whether the call reverted, if not we check it either
  84 |     |                 // returned exactly 1 (can't just be non-zero data), or had no return data.
  85 |     |                 or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),
  86 |     |                 // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.
  87 |     |                 // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.
  88 |     |                 // Counterintuitively, this call must be positioned second to the or() call in the
  89 |     |                 // surrounding and() call or else returndatasize() will be zero during the computation.
  90 |     |                 call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)
  91 |     |             )
  92 |     |         }
  93 |     | 
  94 |     |         require(success, "TRANSFER_FAILED");
  95 |     |     }
  96 |     | 
  97 |     |     function safeApprove(
  98 |     |         ERC20 token,
  99 |     |         address to,
 100 |     |         uint256 amount
 101 |     |     ) internal {
 102 |     |         bool success;
 103 |     | 
 104 |     |         /// @solidity memory-safe-assembly
 105 |     |         assembly {
 106 |     |             // Get a pointer to some free memory.
 107 |     |             let freeMemoryPointer := mload(0x40)
 108 |     | 
 109 |     |             // Write the abi-encoded calldata into memory, beginning with the function selector.
 110 |     |             mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)
 111 |     |             mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the "to" argument.
 112 |     |             mstore(add(freeMemoryPointer, 36), amount) // Append the "amount" argument. Masking not required as it's a full 32 byte type.
 113 |     | 
 114 |     |             success := and(
 115 |     |                 // Set success to whether the call reverted, if not we check it either
 116 |     |                 // returned exactly 1 (can't just be non-zero data), or had no return data.
 117 |     |                 or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),
 118 |     |                 // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.
 119 |     |                 // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.
 120 |     |                 // Counterintuitively, this call must be positioned second to the or() call in the
 121 |     |                 // surrounding and() call or else returndatasize() will be zero during the computation.
 122 |     |                 call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)
 123 |     |             )
 124 |     |         }
 125 |     | 
 126 |     |         require(success, "APPROVE_FAILED");
 127 |     |     }
 128 |     | }
 129 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/DegenBox.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | // The BentoBox
   3 |     | 
   4 |     | //  ▄▄▄▄· ▄▄▄ . ▐ ▄ ▄▄▄▄▄      ▄▄▄▄·       ▐▄• ▄
   5 |     | //  ▐█ ▀█▪▀▄.▀·█▌▐█•██  ▪     ▐█ ▀█▪▪      █▌█▌▪
   6 |     | //  ▐█▀▀█▄▐▀▀▪▄▐█▐▐▌ ▐█.▪ ▄█▀▄ ▐█▀▀█▄ ▄█▀▄  ·██·
   7 |     | //  ██▄▪▐█▐█▄▄▌██▐█▌ ▐█▌·▐█▌.▐▌██▄▪▐█▐█▌.▐▌▪▐█·█▌
   8 |     | //  ·▀▀▀▀  ▀▀▀ ▀▀ █▪ ▀▀▀  ▀█▄▀▪·▀▀▀▀  ▀█▄▀▪•▀▀ ▀▀
   9 |     | 
  10 |     | // This contract stores funds, handles their transfers, supports flash loans and strategies.
  11 |     | 
  12 |     | // Copyright (c) 2021 BoringCrypto - All rights reserved
  13 |     | // Twitter: @Boring_Crypto
  14 |     | 
  15 |     | // Special thanks to Keno for all his hard work and support
  16 |     | 
  17 |     | // Version 22-Mar-2021
  18 |     | pragma solidity >=0.8.0;
  19 |     | 
  20 |     | // solhint-disable avoid-low-level-calls
  21 |     | // solhint-disable not-rely-on-time
  22 |     | // solhint-disable no-inline-assembly
  23 |     | import {IERC20, ERC20} from "BoringSolidity/ERC20.sol";
  24 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  25 |     | import {RebaseLibrary, Rebase} from "BoringSolidity/libraries/BoringRebase.sol";
  26 |     | import {BoringOwnable} from "BoringSolidity/BoringOwnable.sol";
  27 |     | import {BoringBatchable} from "BoringSolidity/BoringBatchable.sol";
  28 |     | import {BoringMath, BoringMath128} from "BoringSolidity/libraries/BoringMath.sol";
  29 |     | import {IStrategy} from "interfaces/IStrategy.sol";
  30 |     | import {IBentoBoxV1, IFlashBorrower, IBatchFlashBorrower} from "interfaces/IBentoBoxV1.sol";
  31 |     | import {IWETH} from "interfaces/IWETH.sol";
  32 |     | import {MasterContractManager} from "mixins/MasterContractManager.sol";
  33 |     | 
  34 |     | /// @title DegenBox
  35 |     | /// @author BoringCrypto, Keno
  36 |     | /// @notice The BentoBox is a vault for tokens. The stored tokens can be flash loaned and used in strategies.
  37 |     | /// Yield from this will go to the token depositors.
  38 |     | /// Rebasing tokens ARE NOT supported and WILL cause loss of funds.
  39 |     | /// Any funds transfered directly onto the BentoBox will be lost, use the deposit function instead.
  40 |     | contract DegenBox is MasterContractManager, BoringBatchable {
  41 |     |     using BoringMath for uint256;
  42 |     |     using BoringMath128 for uint128;
  43 |     |     using BoringERC20 for IERC20;
  44 |     |     using RebaseLibrary for Rebase;
  45 |     | 
  46 |     |     // ************** //
  47 |     |     // *** EVENTS *** //
  48 |     |     // ************** //
  49 |     | 
  50 |     |     event LogDeposit(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);
  51 |     |     event LogWithdraw(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);
  52 |     |     event LogTransfer(IERC20 indexed token, address indexed from, address indexed to, uint256 share);
  53 |     | 
  54 |     |     event LogFlashLoan(address indexed borrower, IERC20 indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);
  55 |     | 
  56 |     |     event LogStrategyTargetPercentage(IERC20 indexed token, uint256 targetPercentage);
  57 |     |     event LogStrategyQueued(IERC20 indexed token, IStrategy indexed strategy);
  58 |     |     event LogStrategySet(IERC20 indexed token, IStrategy indexed strategy);
  59 |     |     event LogStrategyInvest(IERC20 indexed token, uint256 amount);
  60 |     |     event LogStrategyDivest(IERC20 indexed token, uint256 amount);
  61 |     |     event LogStrategyProfit(IERC20 indexed token, uint256 amount);
  62 |     |     event LogStrategyLoss(IERC20 indexed token, uint256 amount);
  63 |     | 
  64 |     |     // *************** //
  65 |     |     // *** STRUCTS *** //
  66 |     |     // *************** //
  67 |     | 
  68 |     |     struct StrategyData {
  69 |     |         uint64 strategyStartDate;
  70 |     |         uint64 targetPercentage;
  71 |     |         uint128 balance; // the balance of the strategy that BentoBox thinks is in there
  72 |     |     }
  73 |     | 
  74 |     |     // ******************************** //
  75 |     |     // *** CONSTANTS AND IMMUTABLES *** //
  76 |     |     // ******************************** //
  77 |     | 
  78 |     |     // V2 - Can they be private?
  79 |     |     // V2: Private to save gas, to verify it's correct, check the constructor arguments
  80 |     |     IERC20 internal immutable wethToken;
  81 |     | 
  82 |     |     IERC20 private constant USE_ETHEREUM = IERC20(address(0));
  83 |     |     uint256 private constant FLASH_LOAN_FEE = 50; // 0.05%
  84 |     |     uint256 private constant FLASH_LOAN_FEE_PRECISION = 1e5;
  85 |     |     uint256 private constant STRATEGY_DELAY = 3 days;
  86 |     |     uint256 private constant MAX_TARGET_PERCENTAGE = 95; // 95%
  87 |     |     uint256 private constant MINIMUM_SHARE_BALANCE = 1000; // To prevent the ratio going off
  88 |     | 
  89 |     |     // ***************** //
  90 |     |     // *** VARIABLES *** //
  91 |     |     // ***************** //
  92 |     | 
  93 |     |     // Balance per token per address/contract in shares
  94 |     |     mapping(IERC20 => mapping(address => uint256)) public balanceOf;
  95 |     | 
  96 |     |     // Rebase from amount to share
  97 |     |     mapping(IERC20 => Rebase) public totals;
  98 |     | 
  99 |     |     mapping(IERC20 => IStrategy) public strategy;
 100 |     |     mapping(IERC20 => IStrategy) public pendingStrategy;
 101 |     |     mapping(IERC20 => StrategyData) public strategyData;
 102 |     | 
 103 |     |     // ******************* //
 104 |     |     // *** CONSTRUCTOR *** //
 105 |     |     // ******************* //
 106 |     | 
 107 |     |     constructor(IERC20 wethToken_) {
 108 |     |         wethToken = wethToken_;
 109 |     |         _configure();
 110 |     |     }
 111 |     | 
 112 |     |     function _configure() internal virtual {}
 113 |     | 
 114 |     |     // ***************** //
 115 |     |     // *** MODIFIERS *** //
 116 |     |     // ***************** //
 117 |     | 
 118 |     |     /// Modifier to check if the msg.sender is allowed to use funds belonging to the 'from' address.
 119 |     |     /// If 'from' is msg.sender, it's allowed.
 120 |     |     /// If 'from' is the BentoBox itself, it's allowed. Any ETH, token balances (above the known balances) or BentoBox balances
 121 |     |     /// can be taken by anyone.
 122 |     |     /// This is to enable skimming, not just for deposits, but also for withdrawals or transfers, enabling better composability.
 123 |     |     /// If 'from' is a clone of a masterContract AND the 'from' address has approved that masterContract, it's allowed.
 124 |     |     modifier allowed(address from) {
 125 |     |         if (from != msg.sender && from != address(this)) {
 126 |     |             // From is sender or you are skimming
 127 |     |             address masterContract = masterContractOf[msg.sender];
 128 |     |             require(masterContract != address(0), "BentoBox: no masterContract");
 129 |     |             require(masterContractApproved[masterContract][from], "BentoBox: Transfer not approved");
 130 |     |         }
 131 |     |         _;
 132 |     |     }
 133 |     | 
 134 |     |     // ************************** //
 135 |     |     // *** INTERNAL FUNCTIONS *** //
 136 |     |     // ************************** //
 137 |     | 
 138 |     |     /// @dev Returns the total balance of `token` this contracts holds,
 139 |     |     /// plus the total amount this contract thinks the strategy holds.
 140 |     |     function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
 141 |     |         amount = token.balanceOf(address(this)).add(strategyData[token].balance);
 142 |     |     }
 143 |     | 
 144 |     |     // ************************ //
 145 |     |     // *** PUBLIC FUNCTIONS *** //
 146 |     |     // ************************ //
 147 |     | 
 148 |     |     /// @dev Helper function to represent an `amount` of `token` in shares.
 149 |     |     /// @param token The ERC-20 token.
 150 |     |     /// @param amount The `token` amount.
 151 |     |     /// @param roundUp If the result `share` should be rounded up.
 152 |     |     /// @return share The token amount represented in shares.
 153 |     |     function toShare(IERC20 token, uint256 amount, bool roundUp) external view returns (uint256 share) {
 154 |     |         share = totals[token].toBase(amount, roundUp);
 155 |     |     }
 156 |     | 
 157 |     |     /// @dev Helper function represent shares back into the `token` amount.
 158 |     |     /// @param token The ERC-20 token.
 159 |     |     /// @param share The amount of shares.
 160 |     |     /// @param roundUp If the result should be rounded up.
 161 |     |     /// @return amount The share amount back into native representation.
 162 |     |     function toAmount(IERC20 token, uint256 share, bool roundUp) external view returns (uint256 amount) {
 163 |     |         amount = totals[token].toElastic(share, roundUp);
 164 |     |     }
 165 |     | 
 166 |     |     /// @notice Deposit an amount of `token` represented in either `amount` or `share`.
 167 |     |     /// @param token_ The ERC-20 token to deposit.
 168 |     |     /// @param from which account to pull the tokens.
 169 |     |     /// @param to which account to push the tokens.
 170 |     |     /// @param amount Token amount in native representation to deposit.
 171 |     |     /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.
 172 |     |     /// @return amountOut The amount deposited.
 173 |     |     /// @return shareOut The deposited amount repesented in shares.
 174 |     |     function deposit(
 175 |     |         IERC20 token_,
 176 |     |         address from,
 177 |     |         address to,
 178 |     |         uint256 amount,
 179 |     |         uint256 share
 180 |     |     ) public payable allowed(from) returns (uint256 amountOut, uint256 shareOut) {
 181 |     |         // Checks
 182 |     |         require(to != address(0), "BentoBox: to not set"); // To avoid a bad UI from burning funds
 183 |     | 
 184 |     |         // Effects
 185 |     |         IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;
 186 |     |         _onBeforeDeposit(token, from, to, amount, share);
 187 |     | 
 188 |     |         Rebase memory total = totals[token];
 189 |     | 
 190 |     |         // If a new token gets added, the tokenSupply call checks that this is a deployed contract. Needed for security.
 191 |     |         require(total.elastic != 0 || token.totalSupply() > 0, "BentoBox: No tokens");
 192 |     |         if (share == 0) {
 193 |     |             // value of the share may be lower than the amount due to rounding, that's ok
 194 |     |             share = total.toBase(amount, false);
 195 |     |             // Any deposit should lead to at least the minimum share balance, otherwise it's ignored (no amount taken)
 196 |     |             if (total.base.add(share.to128()) < MINIMUM_SHARE_BALANCE) {
 197 |     |                 return (0, 0);
 198 |     |             }
 199 |     |         } else {
 200 |     |             // amount may be lower than the value of share due to rounding, in that case, add 1 to amount (Always round up)
 201 |     |             amount = total.toElastic(share, true);
 202 |     |         }
 203 |     | 
 204 |     |         // In case of skimming, check that only the skimmable amount is taken.
 205 |     |         // For ETH, the full balance is available, so no need to check.
 206 |     |         // During flashloans the _tokenBalanceOf is lower than 'reality', so skimming deposits will mostly fail during a flashloan.
 207 |     |         require(
 208 |     |             from != address(this) || token_ == USE_ETHEREUM || amount <= _tokenBalanceOf(token).sub(total.elastic),
 209 |     |             "BentoBox: Skim too much"
 210 |     |         );
 211 |     | 
 212 |     |         balanceOf[token][to] = balanceOf[token][to].add(share);
 213 |     |         total.base = total.base.add(share.to128());
 214 |     |         total.elastic = total.elastic.add(amount.to128());
 215 |     |         totals[token] = total;
 216 |     | 
 217 |     |         // Interactions
 218 |     |         // During the first deposit, we check that this token is 'real'
 219 |     |         if (token_ == USE_ETHEREUM) {
 220 |     |             // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)
 221 |     |             // X2: If the WETH implementation is faulty or malicious, it will block adding ETH (but we know the WETH implementation)
 222 |     |             IWETH(address(wethToken)).deposit{value: amount}();
 223 |     |         } else if (from != address(this)) {
 224 |     |             // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)
 225 |     |             // X2: If the token implementation is faulty or malicious, it may block adding tokens. Good.
 226 |     |             token.safeTransferFrom(from, address(this), amount);
 227 |     |         }
 228 |     |         emit LogDeposit(token, from, to, amount, share);
 229 |     |         amountOut = amount;
 230 |     |         shareOut = share;
 231 |     |     }
 232 |     | 
 233 |     |     /// @notice Withdraws an amount of `token` from a user account.
 234 |     |     /// @param token_ The ERC-20 token to withdraw.
 235 |     |     /// @param from which user to pull the tokens.
 236 |     |     /// @param to which user to push the tokens.
 237 |     |     /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.
 238 |     |     /// @param share Like above, but `share` takes precedence over `amount`.
 239 |     |     function withdraw(
 240 |     |         IERC20 token_,
 241 |     |         address from,
 242 |     |         address to,
 243 |     |         uint256 amount,
 244 |     |         uint256 share
 245 |     |     ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {
 246 |     |         // Checks
 247 |     |         require(to != address(0), "BentoBox: to not set"); // To avoid a bad UI from burning funds
 248 |     | 
 249 |     |         // Effects
 250 |     |         IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;
 251 |     |         Rebase memory total = totals[token];
 252 |     |         if (share == 0) {
 253 |     |             // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)
 254 |     |             share = total.toBase(amount, true);
 255 |     |         } else {
 256 |     |             // amount may be lower than the value of share due to rounding, that's ok
 257 |     |             amount = total.toElastic(share, false);
 258 |     |         }
 259 |     | 
 260 |     |         balanceOf[token][from] = balanceOf[token][from].sub(share);
 261 |     |         total.elastic = total.elastic.sub(amount.to128());
 262 |     |         total.base = total.base.sub(share.to128());
 263 |     |         // There have to be at least 1000 shares left to prevent reseting the share/amount ratio (unless it's fully emptied)
 264 |     |         require(total.base >= MINIMUM_SHARE_BALANCE || total.base == 0, "BentoBox: cannot empty");
 265 |     |         totals[token] = total;
 266 |     | 
 267 |     |         // Interactions
 268 |     |         if (token_ == USE_ETHEREUM) {
 269 |     |             // X2, X3: A revert or big gas usage in the WETH contract could block withdrawals, but WETH9 is fine.
 270 |     |             IWETH(address(wethToken)).withdraw(amount);
 271 |     |             // X2, X3: A revert or big gas usage could block, however, the to address is under control of the caller.
 272 |     |             (bool success, ) = to.call{value: amount}("");
 273 |     |             require(success, "BentoBox: ETH transfer failed");
 274 |     |         } else {
 275 |     |             // X2, X3: A malicious token could block withdrawal of just THAT token.
 276 |     |             //         masterContracts may want to take care not to rely on withdraw always succeeding.
 277 |     |             token.safeTransfer(to, amount);
 278 |     |         }
 279 |     |         emit LogWithdraw(token, from, to, amount, share);
 280 |     |         amountOut = amount;
 281 |     |         shareOut = share;
 282 |     |     }
 283 |     | 
 284 |     |     /// @notice Transfer shares from a user account to another one.
 285 |     |     /// @param token The ERC-20 token to transfer.
 286 |     |     /// @param from which user to pull the tokens.
 287 |     |     /// @param to which user to push the tokens.
 288 |     |     /// @param share The amount of `token` in shares.
 289 |     |     // Clones of master contracts can transfer from any account that has approved them
 290 |     |     // F3 - Can it be combined with another similar function?
 291 |     |     // F3: This isn't combined with transferMultiple for gas optimization
 292 |     |     function transfer(IERC20 token, address from, address to, uint256 share) public allowed(from) {
 293 |     |         // Checks
 294 |     |         require(to != address(0), "BentoBox: to not set"); // To avoid a bad UI from burning funds
 295 |     | 
 296 |     |         // Effects
 297 |     |         balanceOf[token][from] = balanceOf[token][from].sub(share);
 298 |     |         balanceOf[token][to] = balanceOf[token][to].add(share);
 299 |     | 
 300 |     |         emit LogTransfer(token, from, to, share);
 301 |     |     }
 302 |     | 
 303 |     |     /// @notice Transfer shares from a user account to multiple other ones.
 304 |     |     /// @param token The ERC-20 token to transfer.
 305 |     |     /// @param from which user to pull the tokens.
 306 |     |     /// @param tos The receivers of the tokens.
 307 |     |     /// @param shares The amount of `token` in shares for each receiver in `tos`.
 308 |     |     // F3 - Can it be combined with another similar function?
 309 |     |     // F3: This isn't combined with transfer for gas optimization
 310 |     |     function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) public allowed(from) {
 311 |     |         // Checks
 312 |     |         require(tos[0] != address(0), "BentoBox: to[0] not set"); // To avoid a bad UI from burning funds
 313 |     | 
 314 |     |         // Effects
 315 |     |         uint256 totalAmount;
 316 |     |         uint256 len = tos.length;
 317 |     |         for (uint256 i = 0; i < len; i++) {
 318 |     |             address to = tos[i];
 319 |     |             balanceOf[token][to] = balanceOf[token][to].add(shares[i]);
 320 |     |             totalAmount = totalAmount.add(shares[i]);
 321 |     |             emit LogTransfer(token, from, to, shares[i]);
 322 |     |         }
 323 |     |         balanceOf[token][from] = balanceOf[token][from].sub(totalAmount);
 324 |     |     }
 325 |     | 
 326 |     |     /// @notice Flashloan ability.
 327 |     |     /// @param borrower The address of the contract that implements and conforms to `IFlashBorrower` and handles the flashloan.
 328 |     |     /// @param receiver Address of the token receiver.
 329 |     |     /// @param token The address of the token to receive.
 330 |     |     /// @param amount of the tokens to receive.
 331 |     |     /// @param data The calldata to pass to the `borrower` contract.
 332 |     |     // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
 333 |     |     // F5: Not possible to follow this here, reentrancy has been reviewed
 334 |     |     // F6 - Check for front-running possibilities, such as the approve function (SWC-114)
 335 |     |     // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.
 336 |     |     function flashLoan(IFlashBorrower borrower, address receiver, IERC20 token, uint256 amount, bytes calldata data) public {
 337 |     |         uint256 fee = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;
 338 |     |         token.safeTransfer(receiver, amount);
 339 |     | 
 340 |     |         borrower.onFlashLoan(msg.sender, token, amount, fee, data);
 341 |     | 
 342 |     |         require(_tokenBalanceOf(token) >= totals[token].addElastic(fee.to128()), "BentoBox: Wrong amount");
 343 |     |         emit LogFlashLoan(address(borrower), token, amount, fee, receiver);
 344 |     |     }
 345 |     | 
 346 |     |     /// @notice Support for batched flashloans. Useful to request multiple different `tokens` in a single transaction.
 347 |     |     /// @param borrower The address of the contract that implements and conforms to `IBatchFlashBorrower` and handles the flashloan.
 348 |     |     /// @param receivers An array of the token receivers. A one-to-one mapping with `tokens` and `amounts`.
 349 |     |     /// @param tokens The addresses of the tokens.
 350 |     |     /// @param amounts of the tokens for each receiver.
 351 |     |     /// @param data The calldata to pass to the `borrower` contract.
 352 |     |     // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
 353 |     |     // F5: Not possible to follow this here, reentrancy has been reviewed
 354 |     |     // F6 - Check for front-running possibilities, such as the approve function (SWC-114)
 355 |     |     // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.
 356 |     |     function batchFlashLoan(
 357 |     |         IBatchFlashBorrower borrower,
 358 |     |         address[] calldata receivers,
 359 |     |         IERC20[] calldata tokens,
 360 |     |         uint256[] calldata amounts,
 361 |     |         bytes calldata data
 362 |     |     ) public {
 363 |     |         uint256[] memory fees = new uint256[](tokens.length);
 364 |     | 
 365 |     |         uint256 len = tokens.length;
 366 |     |         for (uint256 i = 0; i < len; i++) {
 367 |     |             uint256 amount = amounts[i];
 368 |     |             fees[i] = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;
 369 |     | 
 370 |     |             tokens[i].safeTransfer(receivers[i], amounts[i]);
 371 |     |         }
 372 |     | 
 373 |     |         borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data);
 374 |     | 
 375 |     |         for (uint256 i = 0; i < len; i++) {
 376 |     |             IERC20 token = tokens[i];
 377 |     |             require(_tokenBalanceOf(token) >= totals[token].addElastic(fees[i].to128()), "BentoBox: Wrong amount");
 378 |     |             emit LogFlashLoan(address(borrower), token, amounts[i], fees[i], receivers[i]);
 379 |     |         }
 380 |     |     }
 381 |     | 
 382 |     |     /// @notice Sets the target percentage of the strategy for `token`.
 383 |     |     /// @dev Only the owner of this contract is allowed to change this.
 384 |     |     /// @param token The address of the token that maps to a strategy to change.
 385 |     |     /// @param targetPercentage_ The new target in percent. Must be lesser or equal to `MAX_TARGET_PERCENTAGE`.
 386 |     |     function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) public onlyOwner {
 387 |     |         // Checks
 388 |     |         require(targetPercentage_ <= MAX_TARGET_PERCENTAGE, "StrategyManager: Target too high");
 389 |     | 
 390 |     |         // Effects
 391 |     |         strategyData[token].targetPercentage = targetPercentage_;
 392 |     |         emit LogStrategyTargetPercentage(token, targetPercentage_);
 393 |     |     }
 394 |     | 
 395 |     |     /// @notice Sets the contract address of a new strategy that conforms to `IStrategy` for `token`.
 396 |     |     /// Must be called twice with the same arguments.
 397 |     |     /// A new strategy becomes pending first and can be activated once `STRATEGY_DELAY` is over.
 398 |     |     /// @dev Only the owner of this contract is allowed to change this.
 399 |     |     /// @param token The address of the token that maps to a strategy to change.
 400 |     |     /// @param newStrategy The address of the contract that conforms to `IStrategy`.
 401 |     |     // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
 402 |     |     // F5: Total amount is updated AFTER interaction. But strategy is under our control.
 403 |     |     // C4 - Use block.timestamp only for long intervals (SWC-116)
 404 |     |     // C4: block.timestamp is used for a period of 2 weeks, which is long enough
 405 |     |     function setStrategy(IERC20 token, IStrategy newStrategy) public onlyOwner {
 406 |     |         StrategyData memory data = strategyData[token];
 407 |     |         IStrategy pending = pendingStrategy[token];
 408 |     |         if (data.strategyStartDate == 0 || pending != newStrategy) {
 409 |     |             pendingStrategy[token] = newStrategy;
 410 |     |             // C1 - All math done through BoringMath (SWC-101)
 411 |     |             // C1: Our sun will swallow the earth well before this overflows
 412 |     |             data.strategyStartDate = (block.timestamp + STRATEGY_DELAY).to64();
 413 |     |             emit LogStrategyQueued(token, newStrategy);
 414 |     |         } else {
 415 |     |             require(data.strategyStartDate != 0 && block.timestamp >= data.strategyStartDate, "StrategyManager: Too early");
 416 |     |             if (address(strategy[token]) != address(0)) {
 417 |     |                 int256 balanceChange = strategy[token].exit(data.balance);
 418 |     |                 // Effects
 419 |     |                 if (balanceChange > 0) {
 420 |     |                     uint256 add = uint256(balanceChange);
 421 |     |                     totals[token].addElastic(add);
 422 |     |                     emit LogStrategyProfit(token, add);
 423 |     |                 } else if (balanceChange < 0) {
 424 |     |                     uint256 sub = uint256(-balanceChange);
 425 |     |                     totals[token].subElastic(sub);
 426 |     |                     emit LogStrategyLoss(token, sub);
 427 |     |                 }
 428 |     | 
 429 |     |                 emit LogStrategyDivest(token, data.balance);
 430 |     |             }
 431 |     |             strategy[token] = pending;
 432 |     |             data.strategyStartDate = 0;
 433 |     |             data.balance = 0;
 434 |     |             pendingStrategy[token] = IStrategy(address(0));
 435 |     |             emit LogStrategySet(token, newStrategy);
 436 |     |         }
 437 |     |         strategyData[token] = data;
 438 |     |     }
 439 |     | 
 440 |     |     /// @notice The actual process of yield farming. Executes the strategy of `token`.
 441 |     |     /// Optionally does housekeeping if `balance` is true.
 442 |     |     /// `maxChangeAmount` is relevant for skimming or withdrawing if `balance` is true.
 443 |     |     /// @param token The address of the token for which a strategy is deployed.
 444 |     |     /// @param balance True if housekeeping should be done.
 445 |     |     /// @param maxChangeAmount The maximum amount for either pulling or pushing from/to the `IStrategy` contract.
 446 |     |     // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
 447 |     |     // F5: Total amount is updated AFTER interaction. But strategy is under our control.
 448 |     |     // F5: Not followed to prevent reentrancy issues with flashloans and BentoBox skims?
 449 |     |     function harvest(IERC20 token, bool balance, uint256 maxChangeAmount) public {
 450 |     |         StrategyData memory data = strategyData[token];
 451 |     |         IStrategy _strategy = strategy[token];
 452 |     |         int256 balanceChange = _strategy.harvest(data.balance, msg.sender);
 453 |     |         if (balanceChange == 0 && !balance) {
 454 |     |             return;
 455 |     |         }
 456 |     | 
 457 |     |         uint256 totalElastic = totals[token].elastic;
 458 |     | 
 459 |     |         if (balanceChange > 0) {
 460 |     |             uint256 add = uint256(balanceChange);
 461 |     |             totalElastic = totalElastic.add(add);
 462 |     |             totals[token].elastic = totalElastic.to128();
 463 |     |             emit LogStrategyProfit(token, add);
 464 |     |         } else if (balanceChange < 0) {
 465 |     |             // C1 - All math done through BoringMath (SWC-101)
 466 |     |             // C1: balanceChange could overflow if it's max negative int128.
 467 |     |             // But tokens with balances that large are not supported by the BentoBox.
 468 |     |             uint256 sub = uint256(-balanceChange);
 469 |     |             totalElastic = totalElastic.sub(sub);
 470 |     |             totals[token].elastic = totalElastic.to128();
 471 |     |             data.balance = data.balance.sub(sub.to128());
 472 |     |             emit LogStrategyLoss(token, sub);
 473 |     |         }
 474 |     | 
 475 |     |         if (balance) {
 476 |     |             uint256 targetBalance = totalElastic.mul(data.targetPercentage) / 100;
 477 |     |             // if data.balance == targetBalance there is nothing to update
 478 |     |             if (data.balance < targetBalance) {
 479 |     |                 uint256 amountOut = targetBalance.sub(data.balance);
 480 |     |                 if (maxChangeAmount != 0 && amountOut > maxChangeAmount) {
 481 |     |                     amountOut = maxChangeAmount;
 482 |     |                 }
 483 |     |                 token.safeTransfer(address(_strategy), amountOut);
 484 |     |                 data.balance = data.balance.add(amountOut.to128());
 485 |     |                 _strategy.skim(amountOut);
 486 |     |                 emit LogStrategyInvest(token, amountOut);
 487 |     |             } else if (data.balance > targetBalance) {
 488 |     |                 uint256 amountIn = data.balance.sub(targetBalance.to128());
 489 |     |                 if (maxChangeAmount != 0 && amountIn > maxChangeAmount) {
 490 |     |                     amountIn = maxChangeAmount;
 491 |     |                 }
 492 |     | 
 493 |     |                 uint256 actualAmountIn = _strategy.withdraw(amountIn);
 494 |     | 
 495 |     |                 data.balance = data.balance.sub(actualAmountIn.to128());
 496 |     |                 emit LogStrategyDivest(token, actualAmountIn);
 497 |     |             }
 498 |     |         }
 499 |     | 
 500 |     |         strategyData[token] = data;
 501 |     |     }
 502 |     | 
 503 |     |     // Contract should be able to receive ETH deposits to support deposit & skim
 504 |     |     // solhint-disable-next-line no-empty-blocks
 505 |     |     receive() external payable {}
 506 |     | 
 507 |     |     ////////////////////////////////////////////////////////////////////////////////////////
 508 |     |     /// EVENTS
 509 |     |     ////////////////////////////////////////////////////////////////////////////////////////
 510 |     |     function _onBeforeDeposit(IERC20 token, address from, address to, uint256 amount, uint256 share) internal virtual {
 511 |     | 
 512 |     |     }
 513 |     | }
 514 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastBox.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | // Copyright (c) 2021 BoringCrypto - All rights reserved
   3 |     | pragma solidity >=0.8.0;
   4 |     | 
   5 |     | import {DegenBox} from "/DegenBox.sol";
   6 |     | import {BlastYields} from "/blast/libraries/BlastYields.sol";
   7 |     | import {BlastPoints} from "/blast/libraries/BlastPoints.sol";
   8 |     | import {BlastTokenRegistry} from "/blast/BlastTokenRegistry.sol";
   9 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  10 |     | import {OperatableV3} from "mixins/OperatableV3.sol";
  11 |     | import {IWETH} from "interfaces/IWETH.sol";
  12 |     | 
  13 |     | contract BlastBox is DegenBox, OperatableV3 {
  14 |     |     event LogTokenDepositEnabled(address indexed token, bool enabled);
  15 |     |     event LogFeeToChanged(address indexed feeTo);
  16 |     | 
  17 |     |     error ErrZeroAddress();
  18 |     |     error ErrUnsupportedToken();
  19 |     | 
  20 |     |     BlastTokenRegistry public immutable registry;
  21 |     |     mapping(address => bool) public enabledTokens;
  22 |     |     address public feeTo;
  23 |     | 
  24 |     |     constructor(IERC20 weth_, BlastTokenRegistry registry_, address feeTo_) DegenBox(weth_) {
  25 |     |         if (feeTo_ == address(0)) {
  26 |     |             revert ErrZeroAddress();
  27 |     |         }
  28 |     |         if (address(registry_) == address(0)) {
  29 |     |             revert ErrZeroAddress();
  30 |     |         }
  31 |     | 
  32 |     |         registry = registry_;
  33 |     |         feeTo = feeTo_;
  34 |     |     }
  35 |     | 
  36 |     |     function _onBeforeDeposit(
  37 |     |         IERC20 token,
  38 |     |         address /*from*/,
  39 |     |         address /*to*/,
  40 |     |         uint256 /*amount*/,
  41 |     |         uint256 /*share*/
  42 |     |     ) internal view override {
  43 |     |         if (!enabledTokens[address(token)]) {
  44 |     |             revert ErrUnsupportedToken();
  45 |     |         }
  46 |     |     }
  47 |     | 
  48 |     |     //////////////////////////////////////////////////////////////////////////////////////
  49 |     |     /// OPERATORS
  50 |     |     //////////////////////////////////////////////////////////////////////////////////////
  51 |     | 
  52 |     |     function claimGasYields() external onlyOperators returns (uint256) {
  53 |     |         return BlastYields.claimMaxGasYields(feeTo);
  54 |     |     }
  55 |     | 
  56 |     |     function claimTokenYields(address token_) external onlyOperators returns (uint256 amount) {
  57 |     |         if (!registry.nativeYieldTokens(token_)) {
  58 |     |             revert ErrUnsupportedToken();
  59 |     |         }
  60 |     | 
  61 |     |         amount = BlastYields.claimAllTokenYields(token_, feeTo);
  62 |     |     }
  63 |     | 
  64 |     |     //////////////////////////////////////////////////////////////////////////////////////
  65 |     |     /// ADMIN
  66 |     |     //////////////////////////////////////////////////////////////////////////////////////
  67 |     | 
  68 |     |     function callBlastPrecompile(bytes calldata data) external onlyOwner {
  69 |     |         BlastYields.callPrecompile(data);
  70 |     |     }
  71 |     | 
  72 |     |     function setFeeTo(address feeTo_) external onlyOwner {
  73 |     |         if (feeTo_ == address(0)) {
  74 |     |             revert ErrZeroAddress();
  75 |     |         }
  76 |     | 
  77 |     |         feeTo = feeTo_;
  78 |     |         emit LogFeeToChanged(feeTo_);
  79 |     |     }
  80 |     | 
  81 |     |     function setTokenEnabled(address token, bool enabled) external onlyOwner {
  82 |     |         enabledTokens[token] = enabled;
  83 |     | 
  84 |     |         // enable native yields if token is recognized
  85 |     |         // no matter if it's enabled or not
  86 |     |         if (registry.nativeYieldTokens(token)) {
  87 |     |             BlastYields.enableTokenClaimable(token);
  88 |     |         }
  89 |     | 
  90 |     |         emit LogTokenDepositEnabled(token, enabled);
  91 |     |     }
  92 |     | 
  93 |     |     //////////////////////////////////////////////////////////////////////////////////////
  94 |     |     /// INTERNALS
  95 |     |     //////////////////////////////////////////////////////////////////////////////////////
  96 |     | 
  97 |     |     /// @dev Called on DegenBox's constructor
  98 |     |     function _configure() internal override {
  99 |     |         BlastYields.configureDefaultClaimables(address(this));
 100 |     |         BlastPoints.configure();
 101 |     |     }
 102 |     | 
 103 |     |     function isOwner(address _account) internal view override returns (bool) {
 104 |     |         return owner == _account;
 105 |     |     }
 106 |     | }
 107 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastCauldronV4.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | import {BlastYields} from "/blast/libraries/BlastYields.sol";
  6 |     | import {CauldronV4} from "cauldrons/CauldronV4.sol";
  7 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  8 |     | 
  9 |     | contract BlastCauldronV4 is CauldronV4 {
 10 |     |     error ErrZeroAddress();
 11 |     |     error ErrInvalidGovernorAddress();
 12 |     | 
 13 |     |     address private immutable _governor;
 14 |     | 
 15 |     |     constructor(address box_, address mim_, address governor_) CauldronV4(IBentoBoxV1(box_), IERC20(mim_)) {
 16 |     |         if (governor_ == address(0)) {
 17 |     |             revert ErrZeroAddress();
 18 |     |         }
 19 |     |         if (governor_ == address(this)) {
 20 |     |             revert ErrInvalidGovernorAddress();
 21 |     |         }
 22 |     | 
 23 |     |         _governor = governor_;
 24 |     |         _setupBlacklist();
 25 |     |     }
 26 |     | 
 27 |     |     function init(bytes calldata data) public payable override {
 28 |     |         if (_governor == address(this)) {
 29 |     |             revert ErrInvalidGovernorAddress();
 30 |     |         }
 31 |     | 
 32 |     |         _setupBlacklist();
 33 |     | 
 34 |     |         super.init(data);
 35 |     |         BlastYields.configureDefaultClaimables(_governor);
 36 |     |     }
 37 |     | 
 38 |     |     function _setupBlacklist() private {
 39 |     |         blacklistedCallees[address(BlastYields.BLAST_YIELD_PRECOMPILE)] = true;
 40 |     |     }
 41 |     | }
 42 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastFeeRateModel.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {BlastYields} from "/blast/libraries/BlastYields.sol";
  5 |     | import {FeeRateModel} from "/mimswap/auxiliary/FeeRateModel.sol";
  6 |     | import {FeeRateModelImpl} from "/mimswap/auxiliary/FeeRateModelImpl.sol";
  7 |     | 
  8 |     | contract BlastFeeRateModel is FeeRateModel {
  9 |     |     constructor(address maintainer_, address owner_, address governor_) FeeRateModel(maintainer_, owner_) {
 10 |     |         if (governor_ == address(0)) {
 11 |     |             revert ErrZeroAddress();
 12 |     |         }
 13 |     |         BlastYields.configureDefaultClaimables(governor_);
 14 |     |     }
 15 |     | }
 16 |     | 
 17 |     | contract BlastFeeRateModelImpl is FeeRateModelImpl {
 18 |     |     error ErrZeroAddress();
 19 |     | 
 20 |     |     constructor(address governor_) {
 21 |     |         if (governor_ == address(0)) {
 22 |     |             revert ErrZeroAddress();
 23 |     |         }
 24 |     |         BlastYields.configureDefaultClaimables(governor_);
 25 |     |     }
 26 |     | }
 27 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastGovernor.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {BlastYields} from "/blast/libraries/BlastYields.sol";
  5 |     | import {OperatableV2} from "mixins/OperatableV2.sol";
  6 |     | 
  7 |     | contract BlastGovernor is OperatableV2 {
  8 |     |     event LogFeeToChanged(address indexed feeTo);
  9 |     |     error ErrZeroAddress();
 10 |     | 
 11 |     |     address public feeTo;
 12 |     | 
 13 |     |     receive() external payable {}
 14 |     | 
 15 |     |     constructor(address feeTo_, address _owner) OperatableV2(_owner) {
 16 |     |         if (feeTo_ == address(0)) {
 17 |     |             revert ErrZeroAddress();
 18 |     |         }
 19 |     | 
 20 |     |         feeTo = feeTo_;
 21 |     |         BlastYields.configureDefaultClaimables(address(this));
 22 |     |     }
 23 |     | 
 24 |     |     //////////////////////////////////////////////////////////////////////////////////////
 25 |     |     /// OPERATORS
 26 |     |     //////////////////////////////////////////////////////////////////////////////////////
 27 |     | 
 28 |     |     function claimNativeYields(address contractAddress) external onlyOperators returns (uint256) {
 29 |     |         return BlastYields.claimAllNativeYields(contractAddress, feeTo);
 30 |     |     }
 31 |     | 
 32 |     |     function claimMaxGasYields(address contractAddress) external onlyOperators returns (uint256) {
 33 |     |         return BlastYields.claimMaxGasYields(contractAddress, feeTo);
 34 |     |     }
 35 |     | 
 36 |     |     //////////////////////////////////////////////////////////////////////////////////////
 37 |     |     /// ADMIN
 38 |     |     //////////////////////////////////////////////////////////////////////////////////////
 39 |     | 
 40 |     |     function setFeeTo(address _feeTo) external onlyOwner {
 41 |     |         if(_feeTo == address(0)) {
 42 |     |             revert ErrZeroAddress();
 43 |     |         }
 44 |     |         
 45 |     |         feeTo = _feeTo;
 46 |     |         emit LogFeeToChanged(_feeTo);
 47 |     |     }
 48 |     | 
 49 |     |     function callBlastPrecompile(bytes calldata data) external onlyOwner {
 50 |     |         BlastYields.callPrecompile(data);
 51 |     |     }
 52 |     | 
 53 |     |     function execute(address to, uint256 value, bytes calldata data) external onlyOwner returns (bool success, bytes memory result) {
 54 |     |         (success, result) = to.call{value: value}(data);
 55 |     |     }
 56 |     | }
 57 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastLockingMultiRewards.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | 
  3 |     | pragma solidity >=0.8.0;
  4 |     | 
  5 |     | import {LockingMultiRewards} from "staking/LockingMultiRewards.sol";
  6 |     | import {BlastYields} from "/blast/libraries/BlastYields.sol";
  7 |     | import {BlastPoints} from "/blast/libraries/BlastPoints.sol";
  8 |     | import {BlastTokenRegistry} from "/blast/BlastTokenRegistry.sol";
  9 |     | 
 10 |     | contract BlastLockingMultiRewards is LockingMultiRewards {
 11 |     |     event LogFeeToChanged(address indexed feeTo);
 12 |     | 
 13 |     |     error ErrNotNativeYieldToken();
 14 |     |     error ErrZeroAddress();
 15 |     | 
 16 |     |     BlastTokenRegistry public immutable registry;
 17 |     |     address public feeTo;
 18 |     | 
 19 |     |     constructor(
 20 |     |         BlastTokenRegistry registry_,
 21 |     |         address feeTo_,
 22 |     |         address _stakingToken,
 23 |     |         uint256 _lockingBoostMultiplerInBips,
 24 |     |         uint256 _rewardsDuration,
 25 |     |         uint256 _lockDuration,
 26 |     |         address _owner
 27 |     |     ) LockingMultiRewards(_stakingToken, _lockingBoostMultiplerInBips, _rewardsDuration, _lockDuration, _owner) {
 28 |     |         if (address(registry_) == address(0)) {
 29 |     |             revert ErrZeroAddress();
 30 |     |         }
 31 |     |         if (feeTo_ == address(0)) {
 32 |     |             revert ErrZeroAddress();
 33 |     |         }
 34 |     | 
 35 |     |         registry = registry_;
 36 |     |         feeTo = feeTo_;
 37 |     | 
 38 |     |         BlastYields.configureDefaultClaimables(address(this));
 39 |     |         BlastPoints.configure();
 40 |     | 
 41 |     |         if (registry.nativeYieldTokens(_stakingToken)) {
 42 |     |             BlastYields.enableTokenClaimable(_stakingToken);
 43 |     |         }
 44 |     |     }
 45 |     | 
 46 |     |     //////////////////////////////////////////////////////////////////////////////////////
 47 |     |     /// OPERATORS
 48 |     |     //////////////////////////////////////////////////////////////////////////////////////
 49 |     | 
 50 |     |     function claimGasYields() external onlyOperators returns (uint256) {
 51 |     |         return BlastYields.claimMaxGasYields(feeTo);
 52 |     |     }
 53 |     | 
 54 |     |     function claimTokenYields(address token) external onlyOperators returns (uint256 amount) {
 55 |     |         if (token != stakingToken && !_rewardData[token].exists) {
 56 |     |             revert ErrInvalidTokenAddress();
 57 |     |         }
 58 |     | 
 59 |     |         if (!registry.nativeYieldTokens(token)) {
 60 |     |             revert ErrNotNativeYieldToken();
 61 |     |         }
 62 |     | 
 63 |     |         return BlastYields.claimAllTokenYields(token, feeTo);
 64 |     |     }
 65 |     | 
 66 |     |     function updateTokenClaimables(address token) external onlyOperators {
 67 |     |         if (registry.nativeYieldTokens(token)) {
 68 |     |             BlastYields.enableTokenClaimable(token);
 69 |     |         }
 70 |     |     }
 71 |     | 
 72 |     |     //////////////////////////////////////////////////////////////////////////////////////
 73 |     |     /// ADMIN
 74 |     |     //////////////////////////////////////////////////////////////////////////////////////
 75 |     | 
 76 |     |     function addReward(address rewardToken) public override onlyOwner {
 77 |     |         _addReward(rewardToken);
 78 |     | 
 79 |     |         if (registry.nativeYieldTokens(rewardToken)) {
 80 |     |             BlastYields.enableTokenClaimable(rewardToken);
 81 |     |         }
 82 |     |     }
 83 |     | 
 84 |     |     function callBlastPrecompile(bytes calldata data) external onlyOwner {
 85 |     |         BlastYields.callPrecompile(data);
 86 |     |     }
 87 |     | 
 88 |     |     function setFeeTo(address feeTo_) external onlyOwner {
 89 |     |         if (feeTo_ == address(0)) {
 90 |     |             revert ErrZeroAddress();
 91 |     |         }
 92 |     | 
 93 |     |         feeTo = feeTo_;
 94 |     |         emit LogFeeToChanged(feeTo_);
 95 |     |     }
 96 |     | }
 97 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastLzIndirectOFTV2.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {LzIndirectOFTV2} from "tokens/LzIndirectOFTV2.sol";
  5 |     | import {BlastYields} from "/blast/libraries/BlastYields.sol";
  6 |     | import {IMintableBurnable} from "interfaces/IMintableBurnable.sol";
  7 |     | 
  8 |     | contract BlastLzIndirectOFTV2 is LzIndirectOFTV2 {
  9 |     |     error ErrZeroAddress();
 10 |     | 
 11 |     |     constructor(
 12 |     |         address _token,
 13 |     |         IMintableBurnable _minterBurner,
 14 |     |         uint8 _sharedDecimals,
 15 |     |         address _lzEndpoint,
 16 |     |         address _owner,
 17 |     |         address governor_
 18 |     |     ) LzIndirectOFTV2(_token, _minterBurner, _sharedDecimals, _lzEndpoint, _owner) {
 19 |     |         if (governor_ == address(0)) {
 20 |     |             revert ErrZeroAddress();
 21 |     |         }
 22 |     |         
 23 |     |         BlastYields.configureDefaultClaimables(governor_);
 24 |     |     }
 25 |     | }
 26 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastLzOFTV2FeeHandler.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {LzOFTV2FeeHandler} from "periphery/LzOFTV2FeeHandler.sol";
  5 |     | import {BlastYields} from "/blast/libraries/BlastYields.sol";
  6 |     | 
  7 |     | /// @dev This contract holds ETH from fees and accumulates
  8 |     | /// ETH yields to claim.
  9 |     | contract BlastLzOFTV2FeeHandler is LzOFTV2FeeHandler {
 10 |     |     error ErrZeroAddress();
 11 |     | 
 12 |     |     constructor(
 13 |     |         address _owner,
 14 |     |         uint256 _fixedNativeFee,
 15 |     |         address _oft,
 16 |     |         address _aggregator,
 17 |     |         address _feeTo,
 18 |     |         uint8 _quoteType,
 19 |     |         address governor_
 20 |     |     ) LzOFTV2FeeHandler(_owner, _fixedNativeFee, _oft, _aggregator, _feeTo, _quoteType) {
 21 |     |         if (governor_ == address(0)) {
 22 |     |             revert ErrZeroAddress();
 23 |     |         }
 24 |     | 
 25 |     |         BlastYields.configureDefaultClaimables(governor_);
 26 |     |     }
 27 |     | }
 28 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastMIMSwapFactory.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {BlastYields} from "/blast/libraries/BlastYields.sol";
  5 |     | import {Factory} from "/mimswap/periphery/Factory.sol";
  6 |     | import {IFeeRateModel} from "/mimswap/interfaces/IFeeRateModel.sol";
  7 |     | 
  8 |     | contract BlastMIMSwapFactory is Factory {
  9 |     |     constructor(
 10 |     |         address implementation_,
 11 |     |         IFeeRateModel maintainerFeeRateModel_,
 12 |     |         address owner_,
 13 |     |         address governor_
 14 |     |     ) Factory(implementation_, maintainerFeeRateModel_, owner_) {
 15 |     |         if (governor_ == address(0)) {
 16 |     |             revert ErrZeroAddress();
 17 |     |         }
 18 |     |         BlastYields.configureDefaultClaimables(governor_);
 19 |     |     }
 20 |     | }
 21 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastMIMSwapRouter.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {BlastYields} from "/blast/libraries/BlastYields.sol";
  5 |     | import {Router} from "/mimswap/periphery/Router.sol";
  6 |     | import {IWETH} from "interfaces/IWETH.sol";
  7 |     | import {IFactory} from "/mimswap/interfaces/IFactory.sol";
  8 |     | 
  9 |     | contract BlastMIMSwapRouter is Router {
 10 |     |     constructor(IWETH weth_, IFactory factory, address governor_) Router(weth_, factory) {
 11 |     |         if (governor_ == address(0)) {
 12 |     |             revert ErrZeroAddress();
 13 |     |         }
 14 |     |         BlastYields.configureDefaultClaimables(governor_);
 15 |     |     }
 16 |     | }
 17 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastMagicLP.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | 
   3 |     | pragma solidity >=0.8.0;
   4 |     | 
   5 |     | import {MagicLP} from "/mimswap/MagicLP.sol";
   6 |     | import {BlastYields} from "/blast/libraries/BlastYields.sol";
   7 |     | import {BlastPoints} from "/blast/libraries/BlastPoints.sol";
   8 |     | import {BlastTokenRegistry} from "/blast/BlastTokenRegistry.sol";
   9 |     | 
  10 |     | contract BlastMagicLP is MagicLP {
  11 |     |     event LogFeeToChanged(address indexed feeTo);
  12 |     | 
  13 |     |     BlastTokenRegistry public immutable registry;
  14 |     | 
  15 |     |     /// @dev Implementation storage
  16 |     |     address public feeTo;
  17 |     | 
  18 |     |     constructor(BlastTokenRegistry registry_, address feeTo_, address owner_) MagicLP(owner_) {
  19 |     |         if (feeTo_ == address(0)) {
  20 |     |             revert ErrZeroAddress();
  21 |     |         }
  22 |     |         if (address(registry_) == address(0)) {
  23 |     |             revert ErrZeroAddress();
  24 |     |         }
  25 |     | 
  26 |     |         registry = registry_;
  27 |     |         feeTo = feeTo_;
  28 |     |     }
  29 |     | 
  30 |     |     //////////////////////////////////////////////////////////////////////////////////////
  31 |     |     /// VIEWS
  32 |     |     //////////////////////////////////////////////////////////////////////////////////////
  33 |     | 
  34 |     |     function version() external pure override returns (string memory) {
  35 |     |         return "BlastMagicLP 1.0.0";
  36 |     |     }
  37 |     | 
  38 |     |     //////////////////////////////////////////////////////////////////////////////////////
  39 |     |     /// OPERATORS / CLONES ONLY - PROTOCOL LEVEL YIELDS ON ALL POOLS
  40 |     |     //////////////////////////////////////////////////////////////////////////////////////
  41 |     | 
  42 |     |     function claimGasYields() external onlyClones onlyImplementationOperators returns (uint256) {
  43 |     |         address feeTo_ = BlastMagicLP(address(implementation)).feeTo();
  44 |     | 
  45 |     |         return BlastYields.claimMaxGasYields(feeTo_);
  46 |     |     }
  47 |     | 
  48 |     |     function claimTokenYields() external onlyClones onlyImplementationOperators returns (uint256 token0Amount, uint256 token1Amount) {
  49 |     |         address feeTo_ = BlastMagicLP(address(implementation)).feeTo();
  50 |     | 
  51 |     |         if (registry.nativeYieldTokens(_BASE_TOKEN_)) {
  52 |     |             token0Amount = BlastYields.claimAllTokenYields(_BASE_TOKEN_, feeTo_);
  53 |     |         }
  54 |     |         if (registry.nativeYieldTokens(_QUOTE_TOKEN_)) {
  55 |     |             token1Amount = BlastYields.claimAllTokenYields(_QUOTE_TOKEN_, feeTo_);
  56 |     |         }
  57 |     |     }
  58 |     | 
  59 |     |     function updateTokenClaimables() external onlyClones onlyImplementationOperators {
  60 |     |         _updateTokenClaimables();
  61 |     |     }
  62 |     | 
  63 |     |     //////////////////////////////////////////////////////////////////////////////////////
  64 |     |     /// ADMIN / CLONES ONLY
  65 |     |     //////////////////////////////////////////////////////////////////////////////////////
  66 |     | 
  67 |     |     function callBlastPrecompile(bytes calldata data) external onlyClones onlyImplementationOwner {
  68 |     |         BlastYields.callPrecompile(data);
  69 |     |     }
  70 |     | 
  71 |     |     //////////////////////////////////////////////////////////////////////////////////////
  72 |     |     /// ADMIN / IMPLEMENTATION ONLY
  73 |     |     //////////////////////////////////////////////////////////////////////////////////////
  74 |     | 
  75 |     |     function setFeeTo(address feeTo_) external onlyImplementation onlyImplementationOwner {
  76 |     |         if (feeTo_ == address(0)) {
  77 |     |             revert ErrZeroAddress();
  78 |     |         }
  79 |     | 
  80 |     |         feeTo = feeTo_;
  81 |     |         emit LogFeeToChanged(feeTo_);
  82 |     |     }
  83 |     | 
  84 |     |     //////////////////////////////////////////////////////////////////////////////////////
  85 |     |     /// INTERNALS
  86 |     |     //////////////////////////////////////////////////////////////////////////////////////
  87 |     | 
  88 |     |     function _afterInitialized() internal override {
  89 |     |         BlastYields.configureDefaultClaimables(address(this));
  90 |     |         BlastPoints.configure();
  91 |     |         _updateTokenClaimables();
  92 |     |     }
  93 |     | 
  94 |     |     function _updateTokenClaimables() internal {
  95 |     |         if (registry.nativeYieldTokens(_BASE_TOKEN_)) {
  96 |     |             BlastYields.enableTokenClaimable(_BASE_TOKEN_);
  97 |     |         }
  98 |     | 
  99 |     |         if (registry.nativeYieldTokens(_QUOTE_TOKEN_)) {
 100 |     |             BlastYields.enableTokenClaimable(_QUOTE_TOKEN_);
 101 |     |         }
 102 |     |     }
 103 |     | }
 104 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastMintableBurnableERC20.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {MintableBurnableERC20} from "tokens/MintableBurnableERC20.sol";
  5 |     | import {BlastYields} from "/blast/libraries/BlastYields.sol";
  6 |     | 
  7 |     | contract BlastMintableBurnableERC20 is MintableBurnableERC20 {
  8 |     |     error ErrZeroAddress();
  9 |     | 
 10 |     |     constructor(
 11 |     |         address _owner,
 12 |     |         string memory name_,
 13 |     |         string memory symbol_,
 14 |     |         uint8 decimals_,
 15 |     |         address governor_
 16 |     |     ) MintableBurnableERC20(_owner, name_, symbol_, decimals_) {
 17 |     |         if (governor_ == address(0)) {
 18 |     |             revert ErrZeroAddress();
 19 |     |         }
 20 |     |         BlastYields.configureDefaultClaimables(governor_);
 21 |     |     }
 22 |     | }
 23 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastOnboarding.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {Owned} from "solmate/auth/Owned.sol";
   5 |     | import {BlastYields} from "/blast/libraries/BlastYields.sol";
   6 |     | import {BlastTokenRegistry} from "/blast/BlastTokenRegistry.sol";
   7 |     | import {Proxy} from "openzeppelin-contracts/proxy/Proxy.sol";
   8 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
   9 |     | import {BlastPoints} from "/blast/libraries/BlastPoints.sol";
  10 |     | import {Pausable} from "openzeppelin-contracts/security/Pausable.sol";
  11 |     | 
  12 |     | contract BlastOnboardingData is Owned, Pausable {
  13 |     |     error ErrZeroAddress();
  14 |     |     error ErrWrongState();
  15 |     |     error ErrUnsupportedToken();
  16 |     |     error ErrNotAllowed();
  17 |     | 
  18 |     |     enum State {
  19 |     |         Idle,
  20 |     |         Opened,
  21 |     |         Closed
  22 |     |     }
  23 |     | 
  24 |     |     struct Balances {
  25 |     |         uint256 unlocked;
  26 |     |         uint256 locked;
  27 |     |         uint256 total;
  28 |     |     }
  29 |     | 
  30 |     |     State public state;
  31 |     |     address public bootstrapper;
  32 |     |     address public feeTo;
  33 |     |     BlastTokenRegistry public registry;
  34 |     | 
  35 |     |     // Global
  36 |     |     mapping(address token => bool) public supportedTokens;
  37 |     |     mapping(address token => Balances) public totals;
  38 |     |     mapping(address token => uint256 cap) public caps;
  39 |     | 
  40 |     |     // Per-user
  41 |     |     mapping(address user => mapping(address token => Balances)) public balances;
  42 |     | 
  43 |     |     modifier onlyState(State _state) {
  44 |     |         if (state != _state) {
  45 |     |             revert ErrWrongState();
  46 |     |         }
  47 |     |         _;
  48 |     |     }
  49 |     | 
  50 |     |     modifier onlySupportedTokens(address token) {
  51 |     |         if (!supportedTokens[token]) {
  52 |     |             revert ErrUnsupportedToken();
  53 |     |         }
  54 |     | 
  55 |     |         _;
  56 |     |     }
  57 |     | 
  58 |     |     constructor() Owned(msg.sender) {
  59 |     |         BlastYields.configureDefaultClaimables(address(this));
  60 |     |         BlastPoints.configure();
  61 |     |     }
  62 |     | }
  63 |     | 
  64 |     | contract BlastOnboarding is BlastOnboardingData, Proxy {
  65 |     |     using SafeTransferLib for address;
  66 |     | 
  67 |     |     event LogBootstrapperChanged(address indexed bootstrapper);
  68 |     |     event LogTokenSupported(address indexed token, bool supported);
  69 |     |     event LogDeposit(address indexed user, address indexed token, uint256 amount, bool lock);
  70 |     |     event LogLock(address indexed user, address indexed token, uint256 amount);
  71 |     |     event LogFeeToChanged(address indexed feeTo);
  72 |     |     event LogWithdraw(address indexed user, address indexed token, uint256 amount);
  73 |     |     event LogTokenCapChanged(address indexed token, uint256 cap);
  74 |     |     event LogStateChange(State state);
  75 |     |     event LogTokenRescue(address indexed token, address indexed to, uint256 amount);
  76 |     | 
  77 |     |     error ErrUnsupported();
  78 |     |     error ErrCapReached();
  79 |     | 
  80 |     |     receive() external payable override {
  81 |     |         revert ErrUnsupported();
  82 |     |     }
  83 |     | 
  84 |     |     constructor(BlastTokenRegistry registry_, address feeTo_) {
  85 |     |         if (address(registry_) == address(0)) {
  86 |     |             revert ErrZeroAddress();
  87 |     |         }
  88 |     | 
  89 |     |         if (feeTo_ == address(0)) {
  90 |     |             revert ErrZeroAddress();
  91 |     |         }
  92 |     | 
  93 |     |         registry = registry_;
  94 |     |         feeTo = feeTo_;
  95 |     |     }
  96 |     | 
  97 |     |     //////////////////////////////////////////////////////////////////////////////////////
  98 |     |     /// PUBLIC
  99 |     |     //////////////////////////////////////////////////////////////////////////////////////
 100 |     | 
 101 |     |     function deposit(address token, uint256 amount, bool lock_) external whenNotPaused onlyState(State.Opened) onlySupportedTokens(token) {
 102 |     |         token.safeTransferFrom(msg.sender, address(this), amount);
 103 |     | 
 104 |     |         if (lock_) {
 105 |     |             totals[token].locked += amount;
 106 |     |             balances[msg.sender][token].locked += amount;
 107 |     |         } else {
 108 |     |             totals[token].unlocked += amount;
 109 |     |             balances[msg.sender][token].unlocked += amount;
 110 |     |         }
 111 |     | 
 112 |     |         totals[token].total += amount;
 113 |     | 
 114 |     |         if (caps[token] > 0 && totals[token].total > caps[token]) {
 115 |     |             revert ErrCapReached();
 116 |     |         }
 117 |     | 
 118 |     |         balances[msg.sender][token].total += amount;
 119 |     | 
 120 |     |         emit LogDeposit(msg.sender, token, amount, lock_);
 121 |     |     }
 122 |     | 
 123 |     |     function lock(address token, uint256 amount) external whenNotPaused onlyState(State.Opened) onlySupportedTokens(token) {
 124 |     |         balances[msg.sender][token].unlocked -= amount;
 125 |     |         balances[msg.sender][token].locked += amount;
 126 |     |         totals[token].unlocked -= amount;
 127 |     |         totals[token].locked += amount;
 128 |     | 
 129 |     |         emit LogLock(msg.sender, token, amount);
 130 |     |     }
 131 |     | 
 132 |     |     function withdraw(address token, uint256 amount) external whenNotPaused onlySupportedTokens(token) {
 133 |     |         balances[msg.sender][token].unlocked -= amount;
 134 |     |         balances[msg.sender][token].total -= amount;
 135 |     |         totals[token].unlocked -= amount;
 136 |     |         totals[token].total -= amount;
 137 |     | 
 138 |     |         token.safeTransfer(msg.sender, amount);
 139 |     | 
 140 |     |         emit LogWithdraw(msg.sender, token, amount);
 141 |     |     }
 142 |     | 
 143 |     |     //////////////////////////////////////////////////////////////////////////////////////
 144 |     |     /// ADMIN
 145 |     |     //////////////////////////////////////////////////////////////////////////////////////
 146 |     | 
 147 |     |     function setFeeTo(address feeTo_) external onlyOwner {
 148 |     |         if (feeTo_ == address(0)) {
 149 |     |             revert ErrZeroAddress();
 150 |     |         }
 151 |     | 
 152 |     |         feeTo = feeTo_;
 153 |     |         emit LogFeeToChanged(feeTo_);
 154 |     |     }
 155 |     | 
 156 |     |     function callBlastPrecompile(bytes calldata data) external onlyOwner {
 157 |     |         BlastYields.callPrecompile(data);
 158 |     |     }
 159 |     | 
 160 |     |     function claimGasYields() external onlyOwner returns (uint256) {
 161 |     |         return BlastYields.claimMaxGasYields(feeTo);
 162 |     |     }
 163 |     | 
 164 |     |     function claimTokenYields(address[] memory tokens) external onlyOwner {
 165 |     |         for (uint256 i = 0; i < tokens.length; i++) {
 166 |     |             if (!supportedTokens[tokens[i]]) {
 167 |     |                 revert ErrUnsupportedToken();
 168 |     |             }
 169 |     |             if (registry.nativeYieldTokens(tokens[i])) {
 170 |     |                 BlastYields.claimAllTokenYields(tokens[i], feeTo);
 171 |     |             }
 172 |     |         }
 173 |     |     }
 174 |     | 
 175 |     |     function setTokenSupported(address token, bool supported) external onlyOwner {
 176 |     |         supportedTokens[token] = supported;
 177 |     | 
 178 |     |         if (registry.nativeYieldTokens(token)) {
 179 |     |             BlastYields.enableTokenClaimable(token);
 180 |     |         }
 181 |     | 
 182 |     |         emit LogTokenSupported(token, supported);
 183 |     |     }
 184 |     | 
 185 |     |     function setCap(address token, uint256 cap) external onlyOwner onlySupportedTokens(token) {
 186 |     |         caps[token] = cap;
 187 |     |         emit LogTokenCapChanged(token, cap);
 188 |     |     }
 189 |     | 
 190 |     |     function setBootstrapper(address bootstrapper_) external onlyOwner {
 191 |     |         bootstrapper = bootstrapper_;
 192 |     |         emit LogBootstrapperChanged(bootstrapper_);
 193 |     |     }
 194 |     | 
 195 |     |     function open() external onlyOwner onlyState(State.Idle) {
 196 |     |         state = State.Opened;
 197 |     |         emit LogStateChange(State.Opened);
 198 |     |     }
 199 |     | 
 200 |     |     function close() external onlyOwner onlyState(State.Opened) {
 201 |     |         state = State.Closed;
 202 |     |         emit LogStateChange(State.Closed);
 203 |     |     }
 204 |     | 
 205 |     |     function rescue(address token, address to, uint256 amount) external onlyOwner {
 206 |     |         if (supportedTokens[token]) {
 207 |     |             revert ErrNotAllowed();
 208 |     |         }
 209 |     | 
 210 |     |         token.safeTransfer(to, amount);
 211 |     |         emit LogTokenRescue(token, to, amount);
 212 |     |     }
 213 |     | 
 214 |     |     function pause() external onlyOwner {
 215 |     |         _pause();
 216 |     |     }
 217 |     | 
 218 |     |     function unpause() external onlyOwner {
 219 |     |         _unpause();
 220 |     |     }
 221 |     | 
 222 |     |     //////////////////////////////////////////////////////////////////////////////////////
 223 |     |     /// PROXY IMPLEMENTATION
 224 |     |     //////////////////////////////////////////////////////////////////////////////////////
 225 |     | 
 226 |     |     function _implementation() internal view override returns (address) {
 227 |     |         return address(bootstrapper);
 228 |     |     }
 229 |     | }
 230 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastOnboardingBoot.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {BlastOnboarding} from "/blast/BlastOnboarding.sol";
   5 |     | import {BlastOnboardingData} from "/blast/BlastOnboarding.sol";
   6 |     | import {Router} from "/mimswap/periphery/Router.sol";
   7 |     | import {IFeeRateModel} from "/mimswap/interfaces/IFeeRateModel.sol";
   8 |     | import {IFactory} from "/mimswap/interfaces/IFactory.sol";
   9 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
  10 |     | import {DecimalMath} from "/mimswap/libraries/DecimalMath.sol";
  11 |     | import {BlastLockingMultiRewards} from "/blast/BlastLockingMultiRewards.sol";
  12 |     | import {IMagicLP} from "/mimswap/interfaces/IMagicLP.sol";
  13 |     | 
  14 |     | address constant USDB = 0x4300000000000000000000000000000000000003;
  15 |     | address constant MIM = 0x76DA31D7C9CbEAE102aff34D3398bC450c8374c1;
  16 |     | 
  17 |     | // Add a new data contract each bootstrap upgrade that involves
  18 |     | // adding new storage variables.
  19 |     | contract BlastOnboardingBootDataV1 is BlastOnboardingData {
  20 |     |     address public pool;
  21 |     |     Router public router;
  22 |     |     IFactory public factory;
  23 |     |     uint256 public totalPoolShares;
  24 |     |     bool public ready;
  25 |     |     BlastLockingMultiRewards public staking;
  26 |     |     mapping(address user => bool claimed) public claimed;
  27 |     |     mapping(address token => uint256 amount) public ownerDeposits;
  28 |     | }
  29 |     | 
  30 |     | /// @dev Functions are postfixed with the version number to avoid collisions
  31 |     | contract BlastOnboardingBoot is BlastOnboardingBootDataV1 {
  32 |     |     using SafeTransferLib for address;
  33 |     | 
  34 |     |     event LogReadyChanged(bool ready);
  35 |     |     event LogClaimed(address indexed user, uint256 shares, bool lock);
  36 |     |     event LogInitialized(Router indexed router);
  37 |     |     event LogLiquidityBootstrapped(address indexed pool, address indexed staking, uint256 amountOut);
  38 |     |     event LogStakingChanged(address indexed staking);
  39 |     |     event LogOwnerDeposit(address indexed token, uint256 amount);
  40 |     |     event LogOwnerWithdraw(address indexed token, uint256 amount);
  41 |     | 
  42 |     |     error ErrInsufficientAmountOut();
  43 |     |     error ErrNotReady();
  44 |     |     error ErrAlreadyClaimed();
  45 |     |     error ErrWrongFeeRateModel();
  46 |     |     error ErrAlreadyBootstrapped();
  47 |     |     error ErrNothingToClaim();
  48 |     |     error ErrCannotChangeOnceReady();
  49 |     |     error ErrNotInitialized();
  50 |     |     
  51 |     |     //////////////////////////////////////////////////////////////////////////////////////
  52 |     |     /// PUBLIC
  53 |     |     //////////////////////////////////////////////////////////////////////////////////////
  54 |     | 
  55 |     |     function claim(bool lock) external returns (uint256 shares) {
  56 |     |         if (!ready) {
  57 |     |             revert ErrNotReady();
  58 |     |         }
  59 |     |         if (claimed[msg.sender]) {
  60 |     |             revert ErrAlreadyClaimed();
  61 |     |         }
  62 |     | 
  63 |     |         shares = _claimable(msg.sender);
  64 |     |         if (shares == 0) {
  65 |     |             revert ErrNothingToClaim();
  66 |     |         }
  67 |     | 
  68 |     |         claimed[msg.sender] = true;
  69 |     |         staking.stakeFor(msg.sender, shares, lock);
  70 |     | 
  71 |     |         emit LogClaimed(msg.sender, shares, lock);
  72 |     |     }
  73 |     | 
  74 |     |     //////////////////////////////////////////////////////////////////////////////////////
  75 |     |     /// VIEWS
  76 |     |     //////////////////////////////////////////////////////////////////////////////////////
  77 |     | 
  78 |     |     function claimable(address user) external view returns (uint256 shares) {
  79 |     |         if (!ready || claimed[user]) {
  80 |     |             return 0;
  81 |     |         }
  82 |     | 
  83 |     |         return _claimable(user);
  84 |     |     }
  85 |     | 
  86 |     |     function previewTotalPoolShares(uint256 i) external view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {
  87 |     |         uint256 baseAmount = totals[MIM].locked;
  88 |     |         uint256 quoteAmount = totals[USDB].locked;
  89 |     |         return router.previewCreatePool(i, baseAmount, quoteAmount);
  90 |     |     }
  91 |     | 
  92 |     |     //////////////////////////////////////////////////////////////////////////////////////
  93 |     |     /// ADMIN
  94 |     |     //////////////////////////////////////////////////////////////////////////////////////
  95 |     | 
  96 |     |     /// @notice Allows the owner to deposit an arbitrary amount of tokens to balance out the pool
  97 |     |     function ownerDeposit(address token, uint256 amount) external onlyOwner onlyState(State.Closed) onlySupportedTokens(token) {
  98 |     |         token.safeTransferFrom(msg.sender, address(this), amount);
  99 |     | 
 100 |     |         balances[msg.sender][token].locked += amount;
 101 |     |         balances[msg.sender][token].total += amount;
 102 |     | 
 103 |     |         totals[token].locked += amount;
 104 |     |         totals[token].total += amount;
 105 |     | 
 106 |     |         emit LogOwnerDeposit(token, amount);
 107 |     |     }
 108 |     | 
 109 |     |     function ownerWithdraw(address token, uint256 amount) external onlyOwner onlyState(State.Closed) onlySupportedTokens(token) {
 110 |     |         balances[msg.sender][token].locked -= amount;
 111 |     |         balances[msg.sender][token].total -= amount;
 112 |     | 
 113 |     |         totals[token].locked -= amount;
 114 |     |         totals[token].total -= amount;
 115 |     | 
 116 |     |         token.safeTransfer(msg.sender, amount);
 117 |     | 
 118 |     |         emit LogOwnerWithdraw(token, amount);
 119 |     |     }
 120 |     | 
 121 |     |     /// @notice Example parameters:
 122 |     |     /// feeRate = 0.0005 ether; // 0.05%
 123 |     |     /// i = 0.998 ether; // 1 MIM = 0.998 USDB
 124 |     |     /// k = 0.00025 ether; // 0.00025, 1.25% price fluctuation, similar to A2000 in curve
 125 |     |     function bootstrap(uint256 minAmountOut, uint256 feeRate, uint256 i, uint256 k) external onlyOwner onlyState(State.Closed) returns (address, address, uint256) {
 126 |     |         if(address(router) == address(0)) {
 127 |     |             revert ErrNotInitialized();
 128 |     |         }
 129 |     |         if (pool != address(0)) {
 130 |     |             revert ErrAlreadyBootstrapped();
 131 |     |         }
 132 |     | 
 133 |     |         uint256 baseAmount = totals[MIM].locked;
 134 |     |         uint256 quoteAmount = totals[USDB].locked;
 135 |     |         MIM.safeApprove(address(router), type(uint256).max);
 136 |     |         USDB.safeApprove(address(router), type(uint256).max);
 137 |     | 
 138 |     |         (pool, totalPoolShares) = router.createPool(MIM, USDB, feeRate, i, k, address(this), baseAmount, quoteAmount, true);
 139 |     | 
 140 |     |         if (totalPoolShares < minAmountOut) {
 141 |     |             revert ErrInsufficientAmountOut();
 142 |     |         }
 143 |     | 
 144 |     |         // Create staking contract
 145 |     |         // 3x boosting for locker, 7 days reward duration, 13 weeks lp locking
 146 |     |         // make this contract temporary the owner the set it as an operator
 147 |     |         // for permissionned `stakeFor` during the claiming process and then
 148 |     |         // transfer the ownership to the onboarding owner.
 149 |     |         staking = new BlastLockingMultiRewards(registry, feeTo, pool, 30_000, 7 days, 13 weeks, address(this));
 150 |     |         staking.setOperator(address(this), true);
 151 |     |         staking.transferOwnership(owner);
 152 |     | 
 153 |     |         // Approve staking contract
 154 |     |         pool.safeApprove(address(staking), totalPoolShares);
 155 |     | 
 156 |     |         emit LogLiquidityBootstrapped(pool, address(staking), totalPoolShares);
 157 |     | 
 158 |     |         // Claim owner share
 159 |     |         uint256 shares = _claimable(msg.sender);
 160 |     |         if (shares > 0) {
 161 |     |             claimed[msg.sender] = true;
 162 |     |             pool.safeTransfer(msg.sender, shares);
 163 |     |         }
 164 |     | 
 165 |     |         IMagicLP(pool).setPaused(true);
 166 |     |         
 167 |     |         return (pool, address(staking), totalPoolShares);
 168 |     |     }
 169 |     | 
 170 |     |     function initialize(Router _router) external onlyOwner {
 171 |     |         router = Router(payable(_router));
 172 |     |         factory = IFactory(router.factory());
 173 |     |         emit LogInitialized(_router);
 174 |     |     }
 175 |     | 
 176 |     |     function setReady(bool _ready) external onlyOwner onlyState(State.Closed) {
 177 |     |         ready = _ready;
 178 |     |         emit LogReadyChanged(ready);
 179 |     |     }
 180 |     | 
 181 |     |     //////////////////////////////////////////////////////////////////////////////////////
 182 |     |     /// INTERNALS
 183 |     |     //////////////////////////////////////////////////////////////////////////////////////
 184 |     | 
 185 |     |     function _claimable(address user) internal view returns (uint256 shares) {
 186 |     |         uint256 totalLocked = totals[MIM].locked + totals[USDB].locked;
 187 |     | 
 188 |     |         if (totalLocked == 0) {
 189 |     |             return 0;
 190 |     |         }
 191 |     | 
 192 |     |         uint256 userLocked = balances[user][MIM].locked + balances[user][USDB].locked;
 193 |     |         return (userLocked * totalPoolShares) / totalLocked;
 194 |     |     }
 195 |     | }
 196 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/BlastTokenRegistry.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {Owned} from "solmate/auth/Owned.sol";
  5 |     | 
  6 |     | contract BlastTokenRegistry is Owned {
  7 |     |     event LogNativeYieldTokenEnabled(address indexed token, bool enabled);
  8 |     |     error ErrZeroAddress();
  9 |     | 
 10 |     |     mapping(address => bool) public nativeYieldTokens;
 11 |     | 
 12 |     |     constructor(address _owner) Owned(_owner) {}
 13 |     | 
 14 |     |     function setNativeYieldTokenEnabled(address token, bool enabled) external onlyOwner {
 15 |     |         if (token == address(0)) {
 16 |     |             revert ErrZeroAddress();
 17 |     |         }
 18 |     | 
 19 |     |         nativeYieldTokens[token] = enabled;
 20 |     |         emit LogNativeYieldTokenEnabled(token, enabled);
 21 |     |     }
 22 |     | }
 23 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/interfaces/IBlastBox.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | interface IBlastBox {
  5 |     |     function feeTo() external view returns (address);
  6 |     | 
  7 |     |     function registry() external view returns (address);
  8 |     | 
  9 |     |     function setTokenEnabled(address token, bool enabled) external;
 10 |     | 
 11 |     |     function claimGasYields() external returns (uint256);
 12 |     | 
 13 |     |     function claimTokenYields(address token_) external returns (uint256 amount);
 14 |     | 
 15 |     |     function setFeeTo(address feeTo_) external;
 16 |     | 
 17 |     |     function enabledTokens(address) external view returns (bool);
 18 |     | }
 19 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/libraries/BlastPoints.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IBlastPoints} from "interfaces/IBlast.sol";
  5 |     | 
  6 |     | library BlastPoints {
  7 |     |     address public constant BLAST_POINTS_OPERATOR = 0xD1025F1359422Ca16D9084908d629E0dBa60ff28;
  8 |     |     IBlastPoints public constant BLAST_POINTS = IBlastPoints(0x2536FE9ab3F511540F2f9e2eC2A805005C3Dd800);
  9 |     | 
 10 |     |     function configure() internal {
 11 |     |         BLAST_POINTS.configurePointsOperator(BLAST_POINTS_OPERATOR);
 12 |     |     }
 13 |     | }
 14 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/blast/libraries/BlastYields.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IBlast, IERC20Rebasing, YieldMode, GasMode} from "interfaces/IBlast.sol";
  5 |     | import {Address} from "openzeppelin-contracts/utils/Address.sol";
  6 |     | 
  7 |     | library BlastYields {
  8 |     |     event LogBlastGasClaimed(address indexed recipient, uint256 amount);
  9 |     |     event LogBlastETHClaimed(address indexed recipient, uint256 amount);
 10 |     |     event LogBlastTokenClaimed(address indexed recipient, address indexed token, uint256 amount);
 11 |     |     event LogBlastTokenClaimableEnabled(address indexed contractAddress, address indexed token);
 12 |     |     event LogBlastNativeClaimableEnabled(address indexed contractAddress);
 13 |     | 
 14 |     |     IBlast constant BLAST_YIELD_PRECOMPILE = IBlast(0x4300000000000000000000000000000000000002);
 15 |     | 
 16 |     |     //////////////////////////////////////////////////////////////////////////////////////
 17 |     |     // CONFIGURATION
 18 |     |     //////////////////////////////////////////////////////////////////////////////////////
 19 |     | 
 20 |     |     function enableTokenClaimable(address token) internal {
 21 |     |         if (IERC20Rebasing(token).getConfiguration(address(this)) == YieldMode.CLAIMABLE) {
 22 |     |             return;
 23 |     |         }
 24 |     | 
 25 |     |         IERC20Rebasing(token).configure(YieldMode.CLAIMABLE);
 26 |     |         emit LogBlastTokenClaimableEnabled(address(this), token);
 27 |     |     }
 28 |     | 
 29 |     |     function configureDefaultClaimables(address governor_) internal {
 30 |     |         BLAST_YIELD_PRECOMPILE.configure(YieldMode.CLAIMABLE, GasMode.CLAIMABLE, governor_);
 31 |     |         emit LogBlastNativeClaimableEnabled(address(this));
 32 |     |     }
 33 |     | 
 34 |     |     //////////////////////////////////////////////////////////////////////////////////////
 35 |     |     // GAS CLAIMING
 36 |     |     //////////////////////////////////////////////////////////////////////////////////////
 37 |     |     
 38 |     |     function claimMaxGasYields(address recipient) internal returns (uint256) {
 39 |     |         return claimMaxGasYields(address(this), recipient);
 40 |     |     }
 41 |     | 
 42 |     |     function claimMaxGasYields(address contractAddress, address recipient) internal returns (uint256 amount) {
 43 |     |         amount = BLAST_YIELD_PRECOMPILE.claimMaxGas(contractAddress, recipient);
 44 |     |         emit LogBlastGasClaimed(recipient, amount);
 45 |     |     }
 46 |     | 
 47 |     |     //////////////////////////////////////////////////////////////////////////////////////
 48 |     |     // NATIVE CLAIMING
 49 |     |     //////////////////////////////////////////////////////////////////////////////////////<
 50 |     | 
 51 |     |     function claimAllNativeYields(address recipient) internal returns (uint256 amount) {
 52 |     |         return claimAllNativeYields(address(this), recipient);
 53 |     |     }
 54 |     | 
 55 |     |     function claimAllNativeYields(address contractAddress, address recipient) internal returns (uint256 amount) {
 56 |     |         amount = BLAST_YIELD_PRECOMPILE.claimAllYield(contractAddress, recipient);
 57 |     |         emit LogBlastETHClaimed(recipient, amount);
 58 |     |     }
 59 |     | 
 60 |     |     function claimNativeYields(address contractAddress, uint256 amount, address recipient) internal returns (uint256) {
 61 |     |         amount = BLAST_YIELD_PRECOMPILE.claimYield(contractAddress, recipient, amount);
 62 |     |         emit LogBlastETHClaimed(recipient, amount);
 63 |     |         return amount;
 64 |     |     }
 65 |     | 
 66 |     |     //////////////////////////////////////////////////////////////////////////////////////
 67 |     |     // TOKENS CLAIMING
 68 |     |     //////////////////////////////////////////////////////////////////////////////////////
 69 |     | 
 70 |     |     function claimAllTokenYields(address token, address recipient) internal returns (uint256 amount) {
 71 |     |         amount = IERC20Rebasing(token).claim(recipient, IERC20Rebasing(token).getClaimableAmount(address(this)));
 72 |     |         emit LogBlastTokenClaimed(recipient, address(token), amount);
 73 |     |     }
 74 |     | 
 75 |     |     function claimTokenYields(address token, uint256 amount, address recipient) internal returns (uint256) {
 76 |     |         amount = IERC20Rebasing(token).claim(recipient, amount);
 77 |     |         emit LogBlastTokenClaimed(recipient, address(token), amount);
 78 |     |         return amount;
 79 |     |     }
 80 |     | 
 81 |     |     //////////////////////////////////////////////////////////////////////////////////////
 82 |     |     // ARBITRARY PRECOMPILE CALLS
 83 |     |     // Meant to be used for any other calls to the precompile not covered by the above
 84 |     |     //////////////////////////////////////////////////////////////////////////////////////
 85 |     | 
 86 |     |     function callPrecompile(bytes calldata data) internal {
 87 |     |         Address.functionCall(address(BLAST_YIELD_PRECOMPILE), data);
 88 |     |     }
 89 |     | }
 90 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/cauldrons/CauldronV4.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | 
   3 |     | // Cauldron
   4 |     | 
   5 |     | //    (                (   (
   6 |     | //    )\      )    (   )\  )\ )  (
   7 |     | //  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
   8 |     | //  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
   9 |     | // ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
  10 |     | //  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
  11 |     | //   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|
  12 |     | 
  13 |     | pragma solidity >=0.8.0;
  14 |     | import {Owned} from "solmate/auth/Owned.sol";
  15 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  16 |     | import {IOracle} from "interfaces/IOracle.sol";
  17 |     | import {ISwapperV2} from "interfaces/ISwapperV2.sol";
  18 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  19 |     | import {IMasterContract} from "BoringSolidity/interfaces/IMasterContract.sol";
  20 |     | import {RebaseLibrary, Rebase} from "BoringSolidity/libraries/BoringRebase.sol";
  21 |     | import {BoringMath, BoringMath128} from "BoringSolidity/libraries/BoringMath.sol";
  22 |     | 
  23 |     | // solhint-disable avoid-low-level-calls
  24 |     | // solhint-disable no-inline-assembly
  25 |     | 
  26 |     | /// @title Cauldron
  27 |     | /// @dev This contract allows contract calls to any contract (except BentoBox)
  28 |     | /// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
  29 |     | contract CauldronV4 is Owned, IMasterContract {
  30 |     |     using BoringMath for uint256;
  31 |     |     using BoringMath128 for uint128;
  32 |     |     using RebaseLibrary for Rebase;
  33 |     | 
  34 |     |     event LogExchangeRate(uint256 rate);
  35 |     |     event LogAccrue(uint128 accruedAmount);
  36 |     |     event LogAddCollateral(address indexed from, address indexed to, uint256 share);
  37 |     |     event LogRemoveCollateral(address indexed from, address indexed to, uint256 share);
  38 |     |     event LogBorrow(address indexed from, address indexed to, uint256 amount, uint256 part);
  39 |     |     event LogRepay(address indexed from, address indexed to, uint256 amount, uint256 part);
  40 |     |     event LogFeeTo(address indexed newFeeTo);
  41 |     |     event LogWithdrawFees(address indexed feeTo, uint256 feesEarnedFraction);
  42 |     |     event LogInterestChange(uint64 oldInterestRate, uint64 newInterestRate);
  43 |     |     event LogChangeBorrowLimit(uint128 newLimit, uint128 perAddressPart);
  44 |     |     event LogChangeBlacklistedCallee(address indexed account, bool blacklisted);
  45 |     |     event LogLiquidationMultiplierChanged(uint256 previous, uint256 current);
  46 |     |     event LogBorrowOpeningFeeChanged(uint256 previous, uint256 current);
  47 |     |     event LogCollateralizationRateChanged(uint256 previous, uint256 current);
  48 |     |     
  49 |     |     event LogLiquidation(
  50 |     |         address indexed from,
  51 |     |         address indexed user,
  52 |     |         address indexed to,
  53 |     |         uint256 collateralShare,
  54 |     |         uint256 borrowAmount,
  55 |     |         uint256 borrowPart
  56 |     |     );
  57 |     | 
  58 |     |     error ErrNotClone();
  59 |     | 
  60 |     |     // Immutables (for MasterContract and all clones)
  61 |     |     IBentoBoxV1 public immutable bentoBox;
  62 |     |     CauldronV4 public immutable masterContract;
  63 |     |     IERC20 public immutable magicInternetMoney;
  64 |     | 
  65 |     |     // MasterContract variables
  66 |     |     address public feeTo;
  67 |     | 
  68 |     |     // Per clone variables
  69 |     |     // Clone init settings
  70 |     |     IERC20 public collateral;
  71 |     |     IOracle public oracle;
  72 |     |     bytes public oracleData;
  73 |     | 
  74 |     |     struct BorrowCap {
  75 |     |         uint128 total;
  76 |     |         uint128 borrowPartPerAddress;
  77 |     |     }
  78 |     | 
  79 |     |     BorrowCap public borrowLimit;
  80 |     | 
  81 |     |     // Total amounts
  82 |     |     uint256 public totalCollateralShare; // Total collateral supplied
  83 |     |     Rebase public totalBorrow; // elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers
  84 |     | 
  85 |     |     // User balances
  86 |     |     mapping(address => uint256) public userCollateralShare;
  87 |     |     mapping(address => uint256) public userBorrowPart;
  88 |     | 
  89 |     |     // Callee restrictions
  90 |     |     mapping(address => bool) public blacklistedCallees;
  91 |     | 
  92 |     |     /// @notice Exchange and interest rate tracking.
  93 |     |     /// This is 'cached' here because calls to Oracles can be very expensive.
  94 |     |     uint256 public exchangeRate;
  95 |     | 
  96 |     |     struct AccrueInfo {
  97 |     |         uint64 lastAccrued;
  98 |     |         uint128 feesEarned;
  99 |     |         uint64 INTEREST_PER_SECOND;
 100 |     |     }
 101 |     | 
 102 |     |     AccrueInfo public accrueInfo;
 103 |     | 
 104 |     |     uint64 internal constant ONE_PERCENT_RATE = 317097920;
 105 |     | 
 106 |     |     // Settings
 107 |     |     uint256 public COLLATERIZATION_RATE;
 108 |     |     uint256 internal constant COLLATERIZATION_RATE_PRECISION = 1e5; // Must be less than EXCHANGE_RATE_PRECISION (due to optimization in math)
 109 |     | 
 110 |     |     uint256 internal constant EXCHANGE_RATE_PRECISION = 1e18;
 111 |     | 
 112 |     |     uint256 public LIQUIDATION_MULTIPLIER; 
 113 |     |     uint256 internal constant LIQUIDATION_MULTIPLIER_PRECISION = 1e5;
 114 |     | 
 115 |     |     uint256 public BORROW_OPENING_FEE;
 116 |     |     uint256 internal constant BORROW_OPENING_FEE_PRECISION = 1e5;
 117 |     | 
 118 |     |     uint256 internal constant DISTRIBUTION_PART = 10;
 119 |     |     uint256 internal constant DISTRIBUTION_PRECISION = 100;
 120 |     | 
 121 |     |     modifier onlyMasterContractOwner() {
 122 |     |         require(msg.sender == masterContract.owner(), "Caller is not the owner");
 123 |     |         _;
 124 |     |     }
 125 |     | 
 126 |     |     modifier onlyClones() {
 127 |     |         if (address(this) == address(masterContract)) {
 128 |     |             revert ErrNotClone();
 129 |     |         }
 130 |     |         _;
 131 |     |     }
 132 |     | 
 133 |     |     /// @notice The constructor is only used for the initial master contract. Subsequent clones are initialised via `init`.
 134 |     |     constructor(IBentoBoxV1 bentoBox_, IERC20 magicInternetMoney_) Owned(msg.sender) {
 135 |     |         bentoBox = bentoBox_;
 136 |     |         magicInternetMoney = magicInternetMoney_;
 137 |     |         masterContract = this;
 138 |     |         
 139 |     |         blacklistedCallees[address(bentoBox)] = true;
 140 |     |         blacklistedCallees[address(this)] = true;
 141 |     |         blacklistedCallees[Owned(address(bentoBox)).owner()] = true;
 142 |     |     }
 143 |     | 
 144 |     |     /// @notice Serves as the constructor for clones, as clones can't have a regular constructor
 145 |     |     /// @dev `data` is abi encoded in the format: (IERC20 collateral, IERC20 asset, IOracle oracle, bytes oracleData)
 146 |     |     function init(bytes calldata data) public virtual onlyClones payable override {
 147 |     |         require(address(collateral) == address(0), "Cauldron: already initialized");
 148 |     |         (collateral, oracle, oracleData, accrueInfo.INTEREST_PER_SECOND, LIQUIDATION_MULTIPLIER, COLLATERIZATION_RATE, BORROW_OPENING_FEE) = abi.decode(data, (IERC20, IOracle, bytes, uint64, uint256, uint256, uint256));
 149 |     |         borrowLimit = BorrowCap(type(uint128).max, type(uint128).max);
 150 |     |         require(address(collateral) != address(0), "Cauldron: bad pair");
 151 |     | 
 152 |     |         magicInternetMoney.approve(address(bentoBox), type(uint256).max);
 153 |     | 
 154 |     |         blacklistedCallees[address(bentoBox)] = true;
 155 |     |         blacklistedCallees[address(this)] = true;
 156 |     |         blacklistedCallees[Owned(address(bentoBox)).owner()] = true;
 157 |     | 
 158 |     |         (, exchangeRate) = oracle.get(oracleData);
 159 |     | 
 160 |     |         accrue();
 161 |     |     }
 162 |     | 
 163 |     |     /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.
 164 |     |     function accrue() public {
 165 |     |         AccrueInfo memory _accrueInfo = accrueInfo;
 166 |     |         // Number of seconds since accrue was called
 167 |     |         uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;
 168 |     |         if (elapsedTime == 0) {
 169 |     |             return;
 170 |     |         }
 171 |     |         _accrueInfo.lastAccrued = uint64(block.timestamp);
 172 |     | 
 173 |     |         Rebase memory _totalBorrow = totalBorrow;
 174 |     |         if (_totalBorrow.base == 0) {
 175 |     |             accrueInfo = _accrueInfo;
 176 |     |             return;
 177 |     |         }
 178 |     | 
 179 |     |         // Accrue interest
 180 |     |         uint128 extraAmount = (uint256(_totalBorrow.elastic).mul(_accrueInfo.INTEREST_PER_SECOND).mul(elapsedTime) / 1e18).to128();
 181 |     |         _totalBorrow.elastic = _totalBorrow.elastic.add(extraAmount);
 182 |     | 
 183 |     |         _accrueInfo.feesEarned = _accrueInfo.feesEarned.add(extraAmount);
 184 |     |         totalBorrow = _totalBorrow;
 185 |     |         accrueInfo = _accrueInfo;
 186 |     | 
 187 |     |         emit LogAccrue(extraAmount);
 188 |     |     }
 189 |     | 
 190 |     |     /// @notice Concrete implementation of `isSolvent`. Includes a third parameter to allow caching `exchangeRate`.
 191 |     |     /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.
 192 |     |     function _isSolvent(address user, uint256 _exchangeRate) virtual internal view returns (bool) {
 193 |     |         // accrue must have already been called!
 194 |     |         uint256 borrowPart = userBorrowPart[user];
 195 |     |         if (borrowPart == 0) return true;
 196 |     |         uint256 collateralShare = userCollateralShare[user];
 197 |     |         if (collateralShare == 0) return false;
 198 |     | 
 199 |     |         Rebase memory _totalBorrow = totalBorrow;
 200 |     | 
 201 |     |         return
 202 |     |             bentoBox.toAmount(
 203 |     |                 collateral,
 204 |     |                 collateralShare.mul(EXCHANGE_RATE_PRECISION / COLLATERIZATION_RATE_PRECISION).mul(COLLATERIZATION_RATE),
 205 |     |                 false
 206 |     |             ) >=
 207 |     |             // Moved exchangeRate here instead of dividing the other side to preserve more precision
 208 |     |             borrowPart.mul(_totalBorrow.elastic).mul(_exchangeRate) / _totalBorrow.base;
 209 |     |     }
 210 |     | 
 211 |     |     function isSolvent(address user) public view returns (bool) {
 212 |     |         return _isSolvent(user, exchangeRate);
 213 |     |     }
 214 |     |     
 215 |     |     /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.
 216 |     |     modifier solvent() {
 217 |     |         _;
 218 |     |         (, uint256 _exchangeRate) = updateExchangeRate();
 219 |     |         require(_isSolvent(msg.sender, _exchangeRate), "Cauldron: user insolvent");
 220 |     |     }
 221 |     | 
 222 |     |     /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.
 223 |     |     /// This function is supposed to be invoked if needed because Oracle queries can be expensive.
 224 |     |     /// @return updated True if `exchangeRate` was updated.
 225 |     |     /// @return rate The new exchange rate.
 226 |     |     function updateExchangeRate() public returns (bool updated, uint256 rate) {
 227 |     |         (updated, rate) = oracle.get(oracleData);
 228 |     | 
 229 |     |         if (updated) {
 230 |     |             exchangeRate = rate;
 231 |     |             emit LogExchangeRate(rate);
 232 |     |         } else {
 233 |     |             // Return the old rate if fetching wasn't successful
 234 |     |             rate = exchangeRate;
 235 |     |         }
 236 |     |     }
 237 |     | 
 238 |     |     /// @dev Helper function to move tokens.
 239 |     |     /// @param token The ERC-20 token.
 240 |     |     /// @param share The amount in shares to add.
 241 |     |     /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.
 242 |     |     /// Only used for accounting checks.
 243 |     |     /// @param skim If True, only does a balance check on this contract.
 244 |     |     /// False if tokens from msg.sender in `bentoBox` should be transferred.
 245 |     |     function _addTokens(
 246 |     |         IERC20 token,
 247 |     |         uint256 share,
 248 |     |         uint256 total,
 249 |     |         bool skim
 250 |     |     ) internal {
 251 |     |         if (skim) {
 252 |     |             require(share <= bentoBox.balanceOf(token, address(this)).sub(total), "Cauldron: Skim too much");
 253 |     |         } else {
 254 |     |             bentoBox.transfer(token, msg.sender, address(this), share);
 255 |     |         }
 256 |     |     }
 257 |     | 
 258 |     |     function _afterAddCollateral(address user, uint256 collateralShare) internal virtual {}
 259 |     | 
 260 |     |     /// @notice Adds `collateral` from msg.sender to the account `to`.
 261 |     |     /// @param to The receiver of the tokens.
 262 |     |     /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.x
 263 |     |     /// False if tokens from msg.sender in `bentoBox` should be transferred.
 264 |     |     /// @param share The amount of shares to add for `to`.
 265 |     |     function addCollateral(
 266 |     |         address to,
 267 |     |         bool skim,
 268 |     |         uint256 share
 269 |     |     ) public virtual {
 270 |     |         userCollateralShare[to] = userCollateralShare[to].add(share);
 271 |     |         uint256 oldTotalCollateralShare = totalCollateralShare;
 272 |     |         totalCollateralShare = oldTotalCollateralShare.add(share);
 273 |     |         _addTokens(collateral, share, oldTotalCollateralShare, skim);
 274 |     |         _afterAddCollateral(to, share);
 275 |     |         emit LogAddCollateral(skim ? address(bentoBox) : msg.sender, to, share);
 276 |     |     }
 277 |     | 
 278 |     |     function _afterRemoveCollateral(address from, address to, uint256 collateralShare) internal virtual {}
 279 |     | 
 280 |     |     /// @dev Concrete implementation of `removeCollateral`.
 281 |     |     function _removeCollateral(address to, uint256 share) internal virtual {
 282 |     |         userCollateralShare[msg.sender] = userCollateralShare[msg.sender].sub(share);
 283 |     |         totalCollateralShare = totalCollateralShare.sub(share);
 284 |     |         _afterRemoveCollateral(msg.sender, to, share);
 285 |     |         emit LogRemoveCollateral(msg.sender, to, share);
 286 |     |         bentoBox.transfer(collateral, address(this), to, share);
 287 |     |     }
 288 |     | 
 289 |     |     /// @notice Removes `share` amount of collateral and transfers it to `to`.
 290 |     |     /// @param to The receiver of the shares.
 291 |     |     /// @param share Amount of shares to remove.
 292 |     |     function removeCollateral(address to, uint256 share) public solvent {
 293 |     |         // accrue must be called because we check solvency
 294 |     |         accrue();
 295 |     |         _removeCollateral(to, share);
 296 |     |     }
 297 |     | 
 298 |     |     function _preBorrowAction(address to, uint256 amount, uint256 newBorrowPart, uint256 part) internal virtual {
 299 |     | 
 300 |     |     }
 301 |     | 
 302 |     |     /// @dev Concrete implementation of `borrow`.
 303 |     |     function _borrow(address to, uint256 amount) internal returns (uint256 part, uint256 share) {
 304 |     |         uint256 feeAmount = amount.mul(BORROW_OPENING_FEE) / BORROW_OPENING_FEE_PRECISION; // A flat % fee is charged for any borrow
 305 |     |         (totalBorrow, part) = totalBorrow.add(amount.add(feeAmount), true);
 306 |     | 
 307 |     |         BorrowCap memory cap =  borrowLimit;
 308 |     | 
 309 |     |         require(totalBorrow.elastic <= cap.total, "Borrow Limit reached");
 310 |     | 
 311 |     |         accrueInfo.feesEarned = accrueInfo.feesEarned.add(uint128(feeAmount));
 312 |     |         
 313 |     |         uint256 newBorrowPart = userBorrowPart[msg.sender].add(part);
 314 |     |         require(newBorrowPart <= cap.borrowPartPerAddress, "Borrow Limit reached");
 315 |     |         _preBorrowAction(to, amount, newBorrowPart, part);
 316 |     | 
 317 |     |         userBorrowPart[msg.sender] = newBorrowPart;
 318 |     | 
 319 |     |         // As long as there are tokens on this contract you can 'mint'... this enables limiting borrows
 320 |     |         share = bentoBox.toShare(magicInternetMoney, amount, false);
 321 |     |         bentoBox.transfer(magicInternetMoney, address(this), to, share);
 322 |     | 
 323 |     |         emit LogBorrow(msg.sender, to, amount.add(feeAmount), part);
 324 |     |     }
 325 |     | 
 326 |     |     /// @notice Sender borrows `amount` and transfers it to `to`.
 327 |     |     /// @return part Total part of the debt held by borrowers.
 328 |     |     /// @return share Total amount in shares borrowed.
 329 |     |     function borrow(address to, uint256 amount) public solvent returns (uint256 part, uint256 share) {
 330 |     |         accrue();
 331 |     |         (part, share) = _borrow(to, amount);
 332 |     |     }
 333 |     | 
 334 |     |     /// @dev Concrete implementation of `repay`.
 335 |     |     function _repay(
 336 |     |         address to,
 337 |     |         bool skim,
 338 |     |         uint256 part
 339 |     |     ) internal returns (uint256 amount) {
 340 |     |         (totalBorrow, amount) = totalBorrow.sub(part, true);
 341 |     |         userBorrowPart[to] = userBorrowPart[to].sub(part);
 342 |     | 
 343 |     |         uint256 share = bentoBox.toShare(magicInternetMoney, amount, true);
 344 |     |         bentoBox.transfer(magicInternetMoney, skim ? address(bentoBox) : msg.sender, address(this), share);
 345 |     |         emit LogRepay(skim ? address(bentoBox) : msg.sender, to, amount, part);
 346 |     |     }
 347 |     | 
 348 |     |     /// @notice Repays a loan.
 349 |     |     /// @param to Address of the user this payment should go.
 350 |     |     /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.
 351 |     |     /// False if tokens from msg.sender in `bentoBox` should be transferred.
 352 |     |     /// @param part The amount to repay. See `userBorrowPart`.
 353 |     |     /// @return amount The total amount repayed.
 354 |     |     function repay(
 355 |     |         address to,
 356 |     |         bool skim,
 357 |     |         uint256 part
 358 |     |     ) public returns (uint256 amount) {
 359 |     |         accrue();
 360 |     |         amount = _repay(to, skim, part);
 361 |     |     }
 362 |     | 
 363 |     |     // Functions that need accrue to be called
 364 |     |     uint8 internal constant ACTION_REPAY = 2;
 365 |     |     uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;
 366 |     |     uint8 internal constant ACTION_BORROW = 5;
 367 |     |     uint8 internal constant ACTION_GET_REPAY_SHARE = 6;
 368 |     |     uint8 internal constant ACTION_GET_REPAY_PART = 7;
 369 |     |     uint8 internal constant ACTION_ACCRUE = 8;
 370 |     | 
 371 |     |     // Functions that don't need accrue to be called
 372 |     |     uint8 internal constant ACTION_ADD_COLLATERAL = 10;
 373 |     |     uint8 internal constant ACTION_UPDATE_EXCHANGE_RATE = 11;
 374 |     | 
 375 |     |     // Function on BentoBox
 376 |     |     uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
 377 |     |     uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
 378 |     |     uint8 internal constant ACTION_BENTO_TRANSFER = 22;
 379 |     |     uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
 380 |     |     uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;
 381 |     | 
 382 |     |     // Any external call (except to BentoBox)
 383 |     |     uint8 internal constant ACTION_CALL = 30;
 384 |     |     uint8 internal constant ACTION_LIQUIDATE = 31;
 385 |     | 
 386 |     |     // Custom cook actions
 387 |     |     uint8 internal constant ACTION_CUSTOM_START_INDEX = 100;
 388 |     | 
 389 |     |     int256 internal constant USE_VALUE1 = -1;
 390 |     |     int256 internal constant USE_VALUE2 = -2;
 391 |     | 
 392 |     |     /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
 393 |     |     function _num(
 394 |     |         int256 inNum,
 395 |     |         uint256 value1,
 396 |     |         uint256 value2
 397 |     |     ) internal pure returns (uint256 outNum) {
 398 |     |         outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
 399 |     |     }
 400 |     | 
 401 |     |     /// @dev Helper function for depositing into `bentoBox`.
 402 |     |     function _bentoDeposit(
 403 |     |         bytes memory data,
 404 |     |         uint256 value,
 405 |     |         uint256 value1,
 406 |     |         uint256 value2
 407 |     |     ) internal returns (uint256, uint256) {
 408 |     |         (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
 409 |     |         amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
 410 |     |         share = int256(_num(share, value1, value2));
 411 |     |         return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
 412 |     |     }
 413 |     | 
 414 |     |     /// @dev Helper function to withdraw from the `bentoBox`.
 415 |     |     function _bentoWithdraw(
 416 |     |         bytes memory data,
 417 |     |         uint256 value1,
 418 |     |         uint256 value2
 419 |     |     ) internal returns (uint256, uint256) {
 420 |     |         (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
 421 |     |         return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
 422 |     |     }
 423 |     | 
 424 |     |     /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
 425 |     |     /// Calls to `bentoBox` are not allowed for obvious security reasons.
 426 |     |     /// This also means that calls made from this contract shall *not* be trusted.
 427 |     |     function _call(
 428 |     |         uint256 value,
 429 |     |         bytes memory data,
 430 |     |         uint256 value1,
 431 |     |         uint256 value2
 432 |     |     ) internal returns (bytes memory, uint8) {
 433 |     |         (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) =
 434 |     |             abi.decode(data, (address, bytes, bool, bool, uint8));
 435 |     | 
 436 |     |         if (useValue1 && !useValue2) {
 437 |     |             callData = abi.encodePacked(callData, value1);
 438 |     |         } else if (!useValue1 && useValue2) {
 439 |     |             callData = abi.encodePacked(callData, value2);
 440 |     |         } else if (useValue1 && useValue2) {
 441 |     |             callData = abi.encodePacked(callData, value1, value2);
 442 |     |         }
 443 |     | 
 444 |     |         require(!blacklistedCallees[callee], "Cauldron: can't call");
 445 |     | 
 446 |     |         (bool success, bytes memory returnData) = callee.call{value: value}(callData);
 447 |     |         require(success, "Cauldron: call failed");
 448 |     |         return (returnData, returnValues);
 449 |     |     }
 450 |     | 
 451 |     |     struct CookStatus {
 452 |     |         bool needsSolvencyCheck;
 453 |     |         bool hasAccrued;
 454 |     |     }
 455 |     | 
 456 |     |     function _additionalCookAction(uint8 action, CookStatus memory, uint256 value, bytes memory data, uint256 value1, uint256 value2) internal virtual returns (bytes memory, uint8, CookStatus memory) {}
 457 |     | 
 458 |     |     /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
 459 |     |     /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
 460 |     |     /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
 461 |     |     /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
 462 |     |     /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
 463 |     |     /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
 464 |     |     /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
 465 |     |     function cook(
 466 |     |         uint8[] calldata actions,
 467 |     |         uint256[] calldata values,
 468 |     |         bytes[] calldata datas
 469 |     |     ) external payable returns (uint256 value1, uint256 value2) {
 470 |     |         CookStatus memory status;
 471 |     | 
 472 |     |         for (uint256 i = 0; i < actions.length; i++) {
 473 |     |             uint8 action = actions[i];
 474 |     |             if (!status.hasAccrued && action < 10) {
 475 |     |                 accrue();
 476 |     |                 status.hasAccrued = true;
 477 |     |             }
 478 |     |             if (action == ACTION_ADD_COLLATERAL) {
 479 |     |                 (int256 share, address to, bool skim) = abi.decode(datas[i], (int256, address, bool));
 480 |     |                 addCollateral(to, skim, _num(share, value1, value2));
 481 |     |             } else if (action == ACTION_REPAY) {
 482 |     |                 (int256 part, address to, bool skim) = abi.decode(datas[i], (int256, address, bool));
 483 |     |                 _repay(to, skim, _num(part, value1, value2));
 484 |     |             } else if (action == ACTION_REMOVE_COLLATERAL) {
 485 |     |                 (int256 share, address to) = abi.decode(datas[i], (int256, address));
 486 |     |                 _removeCollateral(to, _num(share, value1, value2));
 487 |     |                 status.needsSolvencyCheck = true;
 488 |     |             } else if (action == ACTION_BORROW) {
 489 |     |                 (int256 amount, address to) = abi.decode(datas[i], (int256, address));
 490 |     |                 (value1, value2) = _borrow(to, _num(amount, value1, value2));
 491 |     |                 status.needsSolvencyCheck = true;
 492 |     |             } else if (action == ACTION_UPDATE_EXCHANGE_RATE) {
 493 |     |                 (bool must_update, uint256 minRate, uint256 maxRate) = abi.decode(datas[i], (bool, uint256, uint256));
 494 |     |                 (bool updated, uint256 rate) = updateExchangeRate();
 495 |     |                 require((!must_update || updated) && rate > minRate && (maxRate == 0 || rate < maxRate), "Cauldron: rate not ok");
 496 |     |             } else if (action == ACTION_BENTO_SETAPPROVAL) {
 497 |     |                 (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) =
 498 |     |                     abi.decode(datas[i], (address, address, bool, uint8, bytes32, bytes32));
 499 |     |                 bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
 500 |     |             } else if (action == ACTION_BENTO_DEPOSIT) {
 501 |     |                 (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
 502 |     |             } else if (action == ACTION_BENTO_WITHDRAW) {
 503 |     |                 (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
 504 |     |             } else if (action == ACTION_BENTO_TRANSFER) {
 505 |     |                 (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
 506 |     |                 bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
 507 |     |             } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
 508 |     |                 (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
 509 |     |                 bentoBox.transferMultiple(token, msg.sender, tos, shares);
 510 |     |             } else if (action == ACTION_CALL) {
 511 |     |                 (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);
 512 |     | 
 513 |     |                 if (returnValues == 1) {
 514 |     |                     (value1) = abi.decode(returnData, (uint256));
 515 |     |                 } else if (returnValues == 2) {
 516 |     |                     (value1, value2) = abi.decode(returnData, (uint256, uint256));
 517 |     |                 }
 518 |     |             } else if (action == ACTION_GET_REPAY_SHARE) {
 519 |     |                 int256 part = abi.decode(datas[i], (int256));
 520 |     |                 value1 = bentoBox.toShare(magicInternetMoney, totalBorrow.toElastic(_num(part, value1, value2), true), true);
 521 |     |             } else if (action == ACTION_GET_REPAY_PART) {
 522 |     |                 int256 amount = abi.decode(datas[i], (int256));
 523 |     |                 value1 = totalBorrow.toBase(_num(amount, value1, value2), false);
 524 |     |             } else if (action == ACTION_LIQUIDATE) {
 525 |     |                 _cookActionLiquidate(datas[i]);
 526 |     |             } else {
 527 |     |                 (bytes memory returnData, uint8 returnValues, CookStatus memory returnStatus) = _additionalCookAction(action, status, values[i], datas[i], value1, value2);
 528 |     |                 status = returnStatus;
 529 |     |                 
 530 |     |                 if (returnValues == 1) {
 531 |     |                     (value1) = abi.decode(returnData, (uint256));
 532 |     |                 } else if (returnValues == 2) {
 533 |     |                     (value1, value2) = abi.decode(returnData, (uint256, uint256));
 534 |     |                 }
 535 |     |             }
 536 |     |         }
 537 |     | 
 538 |     |         if (status.needsSolvencyCheck) {
 539 |     |             (, uint256 _exchangeRate) = updateExchangeRate();
 540 |     |             require(_isSolvent(msg.sender, _exchangeRate), "Cauldron: user insolvent");
 541 |     |         }
 542 |     |     }
 543 |     | 
 544 |     |     function _cookActionLiquidate(bytes calldata data) internal {
 545 |     |          (address[] memory users, uint256[] memory maxBorrowParts, address to, ISwapperV2 swapper, bytes memory swapperData) = abi.decode(data, (address[], uint256[], address, ISwapperV2, bytes));
 546 |     |         liquidate(users, maxBorrowParts, to, swapper, swapperData);
 547 |     |     }
 548 |     | 
 549 |     |     function _beforeUsersLiquidated(address[] memory users, uint256[] memory maxBorrowPart) internal virtual {}
 550 |     | 
 551 |     |     function _beforeUserLiquidated(address user, uint256 borrowPart, uint256 borrowAmount, uint256 collateralShare) internal virtual {}
 552 |     | 
 553 |     |     function _afterUserLiquidated(address user, uint256 collateralShare) internal virtual {}
 554 |     | 
 555 |     |     /// @notice Handles the liquidation of users' balances, once the users' amount of collateral is too low.
 556 |     |     /// @param users An array of user addresses.
 557 |     |     /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.
 558 |     |     /// @param to Address of the receiver in open liquidations if `swapper` is zero.
 559 |     |     function liquidate(
 560 |     |         address[] memory users,
 561 |     |         uint256[] memory maxBorrowParts,
 562 |     |         address to,
 563 |     |         ISwapperV2 swapper,
 564 |     |         bytes memory swapperData
 565 |     |     ) public virtual {
 566 |     |         // Oracle can fail but we still need to allow liquidations
 567 |     |         (, uint256 _exchangeRate) = updateExchangeRate();
 568 |     |         accrue();
 569 |     | 
 570 |     |         uint256 allCollateralShare;
 571 |     |         uint256 allBorrowAmount;
 572 |     |         uint256 allBorrowPart;
 573 |     |         Rebase memory bentoBoxTotals = bentoBox.totals(collateral);
 574 |     |         _beforeUsersLiquidated(users, maxBorrowParts);
 575 |     | 
 576 |     |         for (uint256 i = 0; i < users.length; i++) {
 577 |     |             address user = users[i];
 578 |     |             if (!_isSolvent(user, _exchangeRate)) {
 579 |     |                 uint256 borrowPart;
 580 |     |                 uint256 availableBorrowPart = userBorrowPart[user];
 581 |     |                 borrowPart = maxBorrowParts[i] > availableBorrowPart ? availableBorrowPart : maxBorrowParts[i];
 582 |     | 
 583 |     |                 uint256 borrowAmount = totalBorrow.toElastic(borrowPart, false);
 584 |     |                 uint256 collateralShare =
 585 |     |                     bentoBoxTotals.toBase(
 586 |     |                         borrowAmount.mul(LIQUIDATION_MULTIPLIER).mul(_exchangeRate) /
 587 |     |                             (LIQUIDATION_MULTIPLIER_PRECISION * EXCHANGE_RATE_PRECISION),
 588 |     |                         false
 589 |     |                     );
 590 |     | 
 591 |     |                 _beforeUserLiquidated(user, borrowPart, borrowAmount, collateralShare);
 592 |     |                 userBorrowPart[user] = availableBorrowPart.sub(borrowPart);
 593 |     |                 userCollateralShare[user] = userCollateralShare[user].sub(collateralShare);
 594 |     |                 _afterUserLiquidated(user, collateralShare);
 595 |     | 
 596 |     |                 emit LogRemoveCollateral(user, to, collateralShare);
 597 |     |                 emit LogRepay(msg.sender, user, borrowAmount, borrowPart);
 598 |     |                 emit LogLiquidation(msg.sender, user, to, collateralShare, borrowAmount, borrowPart);
 599 |     | 
 600 |     |                 // Keep totals
 601 |     |                 allCollateralShare = allCollateralShare.add(collateralShare);
 602 |     |                 allBorrowAmount = allBorrowAmount.add(borrowAmount);
 603 |     |                 allBorrowPart = allBorrowPart.add(borrowPart);
 604 |     |             }
 605 |     |         }
 606 |     |         require(allBorrowAmount != 0, "Cauldron: all are solvent");
 607 |     |         totalBorrow.elastic = totalBorrow.elastic.sub(allBorrowAmount.to128());
 608 |     |         totalBorrow.base = totalBorrow.base.sub(allBorrowPart.to128());
 609 |     |         totalCollateralShare = totalCollateralShare.sub(allCollateralShare);
 610 |     | 
 611 |     |         // Apply a percentual fee share to sSpell holders
 612 |     |         
 613 |     |         {
 614 |     |             uint256 distributionAmount = (allBorrowAmount.mul(LIQUIDATION_MULTIPLIER) / LIQUIDATION_MULTIPLIER_PRECISION).sub(allBorrowAmount).mul(DISTRIBUTION_PART) / DISTRIBUTION_PRECISION; // Distribution Amount
 615 |     |             allBorrowAmount = allBorrowAmount.add(distributionAmount);
 616 |     |             accrueInfo.feesEarned = accrueInfo.feesEarned.add(distributionAmount.to128());
 617 |     |         }
 618 |     | 
 619 |     |         uint256 allBorrowShare = bentoBox.toShare(magicInternetMoney, allBorrowAmount, true);
 620 |     | 
 621 |     |         // Swap using a swapper freely chosen by the caller
 622 |     |         // Open (flash) liquidation: get proceeds first and provide the borrow after
 623 |     |         bentoBox.transfer(collateral, address(this), to, allCollateralShare);
 624 |     |         if (swapper != ISwapperV2(address(0))) {
 625 |     |             swapper.swap(address(collateral), address(magicInternetMoney), msg.sender, allBorrowShare, allCollateralShare, swapperData);
 626 |     |         }
 627 |     | 
 628 |     |         allBorrowShare = bentoBox.toShare(magicInternetMoney, allBorrowAmount, true);
 629 |     |         bentoBox.transfer(magicInternetMoney, msg.sender, address(this), allBorrowShare);
 630 |     |     }
 631 |     | 
 632 |     |     /// @notice Withdraws the fees accumulated.
 633 |     |     function withdrawFees() public {
 634 |     |         accrue();
 635 |     |         address _feeTo = masterContract.feeTo();
 636 |     |         uint256 _feesEarned = accrueInfo.feesEarned;
 637 |     |         uint256 share = bentoBox.toShare(magicInternetMoney, _feesEarned, false);
 638 |     |         bentoBox.transfer(magicInternetMoney, address(this), _feeTo, share);
 639 |     |         accrueInfo.feesEarned = 0;
 640 |     | 
 641 |     |         emit LogWithdrawFees(_feeTo, _feesEarned);
 642 |     |     }
 643 |     | 
 644 |     |     /// @notice Sets the beneficiary of interest accrued.
 645 |     |     /// MasterContract Only Admin function.
 646 |     |     /// @param newFeeTo The address of the receiver.
 647 |     |     function setFeeTo(address newFeeTo) public onlyOwner {
 648 |     |         feeTo = newFeeTo;
 649 |     |         emit LogFeeTo(newFeeTo);
 650 |     |     }
 651 |     | 
 652 |     |     /// @notice reduces the supply of MIM
 653 |     |     /// @param amount amount to reduce supply by
 654 |     |     function reduceSupply(uint256 amount) public onlyMasterContractOwner {
 655 |     |         uint256 maxAmount = bentoBox.toAmount(magicInternetMoney, bentoBox.balanceOf(magicInternetMoney, address(this)), false);
 656 |     |         amount = maxAmount > amount ? amount : maxAmount;
 657 |     |         bentoBox.withdraw(magicInternetMoney, address(this), msg.sender, amount, 0);
 658 |     |     }
 659 |     | 
 660 |     |     /// @notice allows to change the interest rate
 661 |     |     /// @param newInterestRate new interest rate
 662 |     |     function changeInterestRate(uint64 newInterestRate) public onlyMasterContractOwner {
 663 |     |         accrue();
 664 |     |         emit LogInterestChange(accrueInfo.INTEREST_PER_SECOND, newInterestRate);
 665 |     |         accrueInfo.INTEREST_PER_SECOND = newInterestRate;
 666 |     |     }
 667 |     | 
 668 |     |     /// @notice allows to change the borrow limit
 669 |     |     /// @param newBorrowLimit new borrow limit
 670 |     |     /// @param perAddressPart new borrow limit per address
 671 |     |     function changeBorrowLimit(uint128 newBorrowLimit, uint128 perAddressPart) public onlyMasterContractOwner {
 672 |     |         borrowLimit = BorrowCap(newBorrowLimit, perAddressPart);
 673 |     |         emit LogChangeBorrowLimit(newBorrowLimit, perAddressPart);
 674 |     |     }
 675 |     | 
 676 |     |     /// @notice allows to change blacklisted callees
 677 |     |     /// @param callee callee to blacklist or not
 678 |     |     /// @param blacklisted true when the callee cannot be used in call cook action
 679 |     |     function setBlacklistedCallee(address callee, bool blacklisted) public onlyMasterContractOwner {
 680 |     |         require(callee != address(bentoBox) && callee != address(this), "invalid callee");
 681 |     | 
 682 |     |         blacklistedCallees[callee] = blacklisted;
 683 |     |         emit LogChangeBlacklistedCallee(callee, blacklisted);
 684 |     |     }
 685 |     | 
 686 |     |     /// Allows to change the liquidation multiplier
 687 |     |     /// @param _liquidationMultiplier new liquidation multiplier.
 688 |     |     /// To convert from bips: liquidationFeeBips * 1e1 + 1e5
 689 |     |     function setLiquidationMultiplier(uint256 _liquidationMultiplier) public onlyMasterContractOwner {
 690 |     |         emit LogLiquidationMultiplierChanged(LIQUIDATION_MULTIPLIER, _liquidationMultiplier);
 691 |     |         LIQUIDATION_MULTIPLIER = _liquidationMultiplier;
 692 |     |     }
 693 |     | 
 694 |     |     /// Allows to change the borrow opening fee
 695 |     |     /// @param _borrowOpeningFee new borrow opening fee.
 696 |     |     /// To convert from bips: borrowOpeningFeeBips * 1e1
 697 |     |     function setBorrowOpeningFee(uint256 _borrowOpeningFee) public onlyMasterContractOwner {
 698 |     |         emit LogBorrowOpeningFeeChanged(BORROW_OPENING_FEE, _borrowOpeningFee);
 699 |     |         BORROW_OPENING_FEE = _borrowOpeningFee;
 700 |     |     }
 701 |     | 
 702 |     |     /// Allows to change the collateralization rate
 703 |     |     /// @param _collateralizationRate new collateralization rate.
 704 |     |     /// To convert from bips: collateralizationRateBips * 1e1
 705 |     |     function setCollateralizationRate(uint256 _collateralizationRate) public onlyMasterContractOwner {
 706 |     |         emit LogCollateralizationRateChanged(COLLATERIZATION_RATE, _collateralizationRate);
 707 |     |         COLLATERIZATION_RATE = _collateralizationRate;
 708 |     |     }
 709 |     | }
 710 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/cauldrons/GmxV2CauldronV4.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {RebaseLibrary, Rebase} from "BoringSolidity/libraries/BoringRebase.sol";
   5 |     | import {ISwapperV2} from "interfaces/ISwapperV2.sol";
   6 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   7 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
   8 |     | import {CauldronV4} from "cauldrons/CauldronV4.sol";
   9 |     | import {BoringMath, BoringMath128} from "BoringSolidity/libraries/BoringMath.sol";
  10 |     | import {ICauldronV4GmxV2} from "interfaces/ICauldronV4GmxV2.sol";
  11 |     | import {GmRouterOrderParams, IGmRouterOrder, IGmCauldronOrderAgent} from "periphery/GmxV2CauldronOrderAgent.sol";
  12 |     | 
  13 |     | /// @notice Cauldron with both whitelisting and checkpointing token rewards on add/remove/liquidate collateral
  14 |     | contract GmxV2CauldronV4 is CauldronV4 {
  15 |     |     using BoringMath for uint256;
  16 |     |     using BoringMath128 for uint128;
  17 |     |     using RebaseLibrary for Rebase;
  18 |     | 
  19 |     |     event LogOrderAgentChanged(address indexed previous, address indexed current);
  20 |     |     event LogOrderCreated(address indexed user, address indexed order);
  21 |     |     event LogWithdrawFromOrder(address indexed user, address indexed token, address indexed to, uint256 amount, bool close);
  22 |     |     event LogOrderCanceled(address indexed user, address indexed order);
  23 |     | 
  24 |     |     error ErrOrderAlreadyExists();
  25 |     |     error ErrOrderDoesNotExist();
  26 |     |     error ErrOrderNotFromUser();
  27 |     |     error ErrWhitelistedBorrowExceeded();
  28 |     | 
  29 |     |     // ACTION no < 10 to ensure ACCRUE is triggered
  30 |     |     uint8 public constant ACTION_WITHDRAW_FROM_ORDER = 9;
  31 |     | 
  32 |     |     uint8 public constant ACTION_CREATE_ORDER = 3;
  33 |     |     uint8 public constant ACTION_CANCEL_ORDER = ACTION_CUSTOM_START_INDEX + 2;
  34 |     | 
  35 |     |     IGmCauldronOrderAgent public orderAgent;
  36 |     |     mapping(address => IGmRouterOrder) public orders;
  37 |     | 
  38 |     |     constructor(IBentoBoxV1 box, IERC20 mim) CauldronV4(box, mim) {}
  39 |     | 
  40 |     |     function setOrderAgent(IGmCauldronOrderAgent _orderAgent) public onlyMasterContractOwner {
  41 |     |         emit LogOrderAgentChanged(address(orderAgent), address(_orderAgent));
  42 |     |         orderAgent = _orderAgent;
  43 |     |     }
  44 |     | 
  45 |     |     /// @notice Concrete implementation of `isSolvent`. Includes a second parameter to allow caching `exchangeRate`.
  46 |     |     /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.
  47 |     |     function _isSolvent(address user, uint256 _exchangeRate) internal view override returns (bool) {
  48 |     |         // accrue must have already been called!
  49 |     |         uint256 borrowPart = userBorrowPart[user];
  50 |     |         if (borrowPart == 0) return true;
  51 |     |         uint256 collateralShare = userCollateralShare[user];
  52 |     |         if (collateralShare == 0 && orders[user] == IGmRouterOrder(address(0))) return false;
  53 |     | 
  54 |     |         Rebase memory _totalBorrow = totalBorrow;
  55 |     | 
  56 |     |         uint256 amountToAdd;
  57 |     | 
  58 |     |         if (orders[user] != IGmRouterOrder(address(0))) {
  59 |     |             amountToAdd = orders[user].orderValueInCollateral();
  60 |     |         }
  61 |     | 
  62 |     |         return
  63 |     |             bentoBox
  64 |     |                 .toAmount(collateral, collateralShare, false)
  65 |     |                 .add(amountToAdd)
  66 |     |                 .mul(EXCHANGE_RATE_PRECISION / COLLATERIZATION_RATE_PRECISION)
  67 |     |                 .mul(COLLATERIZATION_RATE) >=
  68 |     |             // Moved exchangeRate here instead of dividing the other side to preserve more precision
  69 |     |             borrowPart.mul(_totalBorrow.elastic).mul(_exchangeRate) / _totalBorrow.base;
  70 |     |     }
  71 |     | 
  72 |     |     function _additionalCookAction(
  73 |     |         uint8 action,
  74 |     |         CookStatus memory status,
  75 |     |         uint256 value,
  76 |     |         bytes memory data,
  77 |     |         uint256,
  78 |     |         uint256
  79 |     |     ) internal virtual override returns (bytes memory, uint8, CookStatus memory) {
  80 |     |         if (action == ACTION_WITHDRAW_FROM_ORDER) {
  81 |     |             (address token, address to, uint256 amount, bool close) = abi.decode(data, (address, address, uint256, bool));
  82 |     | 
  83 |     |             if (orders[msg.sender] == IGmRouterOrder(address(0))) {
  84 |     |                 revert ErrOrderDoesNotExist();
  85 |     |             }
  86 |     |             orders[msg.sender].withdrawFromOrder(token, to, amount, close);
  87 |     |             status.needsSolvencyCheck = true;
  88 |     |             emit LogWithdrawFromOrder(msg.sender, token, to, amount, close);
  89 |     |         } else if (action == ACTION_CREATE_ORDER) {
  90 |     |             if (orders[msg.sender] != IGmRouterOrder(address(0))) {
  91 |     |                 revert ErrOrderAlreadyExists();
  92 |     |             }
  93 |     |             GmRouterOrderParams memory params = abi.decode(data, (GmRouterOrderParams));
  94 |     |             orders[msg.sender] = IGmRouterOrder(orderAgent.createOrder{value: value}(msg.sender, params));
  95 |     |             blacklistedCallees[address(orders[msg.sender])] = true;
  96 |     |             status.needsSolvencyCheck = true;
  97 |     |             emit LogChangeBlacklistedCallee(address(orders[msg.sender]), true);
  98 |     |             emit LogOrderCreated(msg.sender, address(orders[msg.sender]));
  99 |     |         } else if (action == ACTION_CANCEL_ORDER) {
 100 |     |             if (orders[msg.sender] == IGmRouterOrder(address(0))) {
 101 |     |                 revert ErrOrderDoesNotExist();
 102 |     |             }
 103 |     |             orders[msg.sender].cancelOrder();
 104 |     |             emit LogOrderCanceled(msg.sender, address(orders[msg.sender]));
 105 |     |         }
 106 |     | 
 107 |     |         return ("", 0, status);
 108 |     |     }
 109 |     | 
 110 |     |     /// @notice Handles the liquidation of users' balances, once the users' amount of collateral is too low.
 111 |     |     /// @param users An array of user addresses.
 112 |     |     /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.
 113 |     |     /// @param to Address of the receiver in open liquidations if `swapper` is zero.
 114 |     |     function liquidate(
 115 |     |         address[] memory users,
 116 |     |         uint256[] memory maxBorrowParts,
 117 |     |         address to,
 118 |     |         ISwapperV2 swapper,
 119 |     |         bytes memory swapperData
 120 |     |     ) public virtual override {
 121 |     |         // Oracle can fail but we still need to allow liquidations
 122 |     |         (, uint256 _exchangeRate) = updateExchangeRate();
 123 |     |         accrue();
 124 |     | 
 125 |     |         uint256 allCollateralShare;
 126 |     |         uint256 allBorrowAmount;
 127 |     |         uint256 allBorrowPart;
 128 |     |         Rebase memory bentoBoxTotals = bentoBox.totals(collateral);
 129 |     |         _beforeUsersLiquidated(users, maxBorrowParts);
 130 |     | 
 131 |     |         for (uint256 i = 0; i < users.length; i++) {
 132 |     |             address user = users[i];
 133 |     |             if (!_isSolvent(user, _exchangeRate)) {
 134 |     |                 // the user has an active order, cancel it before allowing liquidation
 135 |     |                 if (orders[user] != IGmRouterOrder(address(0)) && orders[user].isActive()) {
 136 |     |                     orders[user].cancelOrder();
 137 |     |                     emit LogOrderCanceled(user, address(orders[user]));
 138 |     |                 }
 139 |     |                 uint256 borrowPart;
 140 |     |                 uint256 availableBorrowPart = userBorrowPart[user];
 141 |     |                 borrowPart = maxBorrowParts[i] > availableBorrowPart ? availableBorrowPart : maxBorrowParts[i];
 142 |     | 
 143 |     |                 uint256 borrowAmount = totalBorrow.toElastic(borrowPart, false);
 144 |     |                 uint256 collateralShare = bentoBoxTotals.toBase(
 145 |     |                     borrowAmount.mul(LIQUIDATION_MULTIPLIER).mul(_exchangeRate) /
 146 |     |                         (LIQUIDATION_MULTIPLIER_PRECISION * EXCHANGE_RATE_PRECISION),
 147 |     |                     false
 148 |     |                 );
 149 |     | 
 150 |     |                 _beforeUserLiquidated(user, borrowPart, borrowAmount, collateralShare);
 151 |     |                 userBorrowPart[user] = availableBorrowPart.sub(borrowPart);
 152 |     |                 if (collateralShare > userCollateralShare[user] && orders[user] != IGmRouterOrder(address(0))) {
 153 |     |                     orders[user].sendValueInCollateral(to, collateralShare - userCollateralShare[user]);
 154 |     |                     collateralShare = userCollateralShare[user];
 155 |     |                 }
 156 |     | 
 157 |     |                 userCollateralShare[user] = userCollateralShare[user].sub(collateralShare);
 158 |     |                 _afterUserLiquidated(user, collateralShare);
 159 |     | 
 160 |     |                 emit LogRemoveCollateral(user, to, collateralShare);
 161 |     |                 emit LogRepay(msg.sender, user, borrowAmount, borrowPart);
 162 |     |                 emit LogLiquidation(msg.sender, user, to, collateralShare, borrowAmount, borrowPart);
 163 |     | 
 164 |     |                 // Keep totals
 165 |     |                 allCollateralShare = allCollateralShare.add(collateralShare);
 166 |     |                 allBorrowAmount = allBorrowAmount.add(borrowAmount);
 167 |     |                 allBorrowPart = allBorrowPart.add(borrowPart);
 168 |     |             }
 169 |     |         }
 170 |     | 
 171 |     |         require(allBorrowAmount != 0, "Cauldron: all are solvent");
 172 |     |         totalBorrow.elastic = totalBorrow.elastic.sub(allBorrowAmount.to128());
 173 |     |         totalBorrow.base = totalBorrow.base.sub(allBorrowPart.to128());
 174 |     |         totalCollateralShare = totalCollateralShare.sub(allCollateralShare);
 175 |     |         // Apply a percentual fee share to sSpell holders
 176 |     |         {
 177 |     |             uint256 distributionAmount = (allBorrowAmount.mul(LIQUIDATION_MULTIPLIER) / LIQUIDATION_MULTIPLIER_PRECISION)
 178 |     |                 .sub(allBorrowAmount)
 179 |     |                 .mul(DISTRIBUTION_PART) / DISTRIBUTION_PRECISION; // Distribution Amount
 180 |     |             allBorrowAmount = allBorrowAmount.add(distributionAmount);
 181 |     |             accrueInfo.feesEarned = accrueInfo.feesEarned.add(distributionAmount.to128());
 182 |     |         }
 183 |     | 
 184 |     |         uint256 allBorrowShare = bentoBox.toShare(magicInternetMoney, allBorrowAmount, true);
 185 |     | 
 186 |     |         // Swap using a swapper freely chosen by the caller
 187 |     |         // Open (flash) liquidation: get proceeds first and provide the borrow after
 188 |     |         bentoBox.transfer(collateral, address(this), to, allCollateralShare);
 189 |     |         if (swapper != ISwapperV2(address(0))) {
 190 |     |             swapper.swap(address(collateral), address(magicInternetMoney), msg.sender, allBorrowShare, allCollateralShare, swapperData);
 191 |     |         }
 192 |     | 
 193 |     |         allBorrowShare = bentoBox.toShare(magicInternetMoney, allBorrowAmount, true);
 194 |     |         bentoBox.transfer(magicInternetMoney, msg.sender, address(this), allBorrowShare);
 195 |     |     }
 196 |     | 
 197 |     |     function closeOrder(address user) public {
 198 |     |         if (msg.sender != address(orders[user])) {
 199 |     |             revert ErrOrderNotFromUser();
 200 |     |         }
 201 |     |         blacklistedCallees[address(orders[user])] = false;
 202 |     |         orders[user] = IGmRouterOrder(address(0));
 203 |     |     }
 204 |     | }
 205 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/cauldrons/PrivilegedCauldronV4.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  6 |     | import {CauldronV4} from "cauldrons/CauldronV4.sol";
  7 |     | import {RebaseLibrary, Rebase} from "BoringSolidity/libraries/BoringRebase.sol";
  8 |     | 
  9 |     | contract PrivilegedCauldronV4 is CauldronV4 {
 10 |     |     using RebaseLibrary for Rebase;
 11 |     | 
 12 |     |     constructor(IBentoBoxV1 bentoBox_, IERC20 magicInternetMoney_) CauldronV4(bentoBox_, magicInternetMoney_) {}
 13 |     | 
 14 |     |     /// @dev masterContract Owner should call updateExchangeRate() before single or multiple call to this function
 15 |     |     function addBorrowPosition(address to, uint256 amount) external onlyMasterContractOwner returns (uint256 part) {
 16 |     |         (totalBorrow, part) = totalBorrow.add(amount, true);
 17 |     | 
 18 |     |         userBorrowPart[to] = userBorrowPart[to] + part;
 19 |     | 
 20 |     |         emit LogBorrow(msg.sender, to, amount, part);
 21 |     | 
 22 |     |         require(_isSolvent(to, exchangeRate), "Cauldron: user insolvent");
 23 |     |     }
 24 |     | }
 25 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/cauldrons/ProtocolOwnedDebtCauldron.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {RebaseLibrary, Rebase} from "BoringSolidity/libraries/BoringRebase.sol";
  5 |     | import {BoringERC20, IERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  6 |     | import {BoringMath} from "BoringSolidity/libraries/BoringMath.sol";
  7 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  8 |     | import {IOracle} from "interfaces/IOracle.sol";
  9 |     | 
 10 |     | contract ProtocolOwnedDebtCauldron {
 11 |     |     using RebaseLibrary for Rebase;
 12 |     |     using BoringMath for uint256;
 13 |     |     using BoringERC20 for IERC20;
 14 |     | 
 15 |     |     error ErrNotAllowed();
 16 |     |     event LogBorrow(address indexed from, address indexed to, uint256 amount, uint256 part);
 17 |     |     event LogRepay(address indexed from, address indexed to, uint256 amount, uint256 part);
 18 |     | 
 19 |     |     address public constant multisig = 0x5f0DeE98360d8200b20812e174d139A1a633EDd2;
 20 |     |     address public constant safe = 0xDF2C270f610Dc35d8fFDA5B453E74db5471E126B;
 21 |     |     IERC20 public constant magicInternetMoney = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);
 22 |     |     address public immutable masterContract;
 23 |     |     IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);
 24 |     | 
 25 |     |     /// @dev compatibility with Cauldron interface
 26 |     |     IERC20 public constant collateral = magicInternetMoney;
 27 |     |     IOracle public constant oracle = IOracle(address(0));
 28 |     |     bytes public constant oracleData = "";
 29 |     |     uint256 public constant totalCollateralShare = 0;
 30 |     |     mapping(address => uint256) public userCollateralShare;
 31 |     |     uint256 public constant exchangeRate = 0;
 32 |     | 
 33 |     |     mapping(address => uint256) public userBorrowPart;
 34 |     |     Rebase public totalBorrow;
 35 |     | 
 36 |     |     modifier onlySafe() {
 37 |     |         if (msg.sender != safe) {
 38 |     |             revert ErrNotAllowed();
 39 |     |         }
 40 |     |         _;
 41 |     |     }
 42 |     | 
 43 |     |     constructor() {
 44 |     |         masterContract = address(this);
 45 |     |     }
 46 |     | 
 47 |     |     function accrueInfo() external pure returns (uint64 /*lastAccrued*/, uint128 /*feesEarned*/, uint64 /*INTEREST_PER_SECOND*/) {
 48 |     |         return (0, 0, 0);
 49 |     |     }
 50 |     | 
 51 |     |     function borrow(uint256 amount) external onlySafe returns (uint256 part) {
 52 |     |         (totalBorrow, part) = totalBorrow.add(amount, false);
 53 |     |         userBorrowPart[safe] = userBorrowPart[safe].add(part);
 54 |     | 
 55 |     |         magicInternetMoney.safeTransferFrom(multisig, safe, amount);
 56 |     | 
 57 |     |         emit LogBorrow(safe, safe, amount, part);
 58 |     |     }
 59 |     | 
 60 |     |     function repay(uint256 part) external onlySafe returns (uint256 amount) {
 61 |     |         (totalBorrow, amount) = totalBorrow.sub(part, false);
 62 |     |         userBorrowPart[safe] = userBorrowPart[safe].sub(part);
 63 |     | 
 64 |     |         magicInternetMoney.safeTransferFrom(safe, multisig, amount);
 65 |     | 
 66 |     |         emit LogRepay(safe, safe, amount, part);
 67 |     |     }
 68 |     | }
 69 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/cauldrons/WhitelistedCauldronV4.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | import {CauldronV4} from "cauldrons/CauldronV4.sol";
  6 |     | import {IWhitelister} from "interfaces/IWhitelister.sol";
  7 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  8 |     | import {RebaseLibrary, Rebase} from "BoringSolidity/libraries/BoringRebase.sol";
  9 |     | 
 10 |     | contract WhitelistedCauldronV4 is CauldronV4 {
 11 |     |     using RebaseLibrary for Rebase;
 12 |     | 
 13 |     |     error ErrWhitelistedBorrowExceeded();
 14 |     | 
 15 |     |     uint8 public constant ACTION_SET_MAX_BORROW = ACTION_CUSTOM_START_INDEX + 1;
 16 |     | 
 17 |     |     IWhitelister public whitelister;
 18 |     | 
 19 |     |     constructor(IBentoBoxV1 bentoBox_, IERC20 magicInternetMoney_) CauldronV4(bentoBox_, magicInternetMoney_) {}
 20 |     | 
 21 |     |     event LogChangeWhitelister(IWhitelister indexed newWhiteLister);
 22 |     | 
 23 |     |     function _preBorrowAction(address, uint256, uint256 newBorrowPart, uint256) internal view override {
 24 |     |         if (whitelister != IWhitelister(address(0)) && !whitelister.isBorrowingAllowed(msg.sender, newBorrowPart)) {
 25 |     |             revert ErrWhitelistedBorrowExceeded();
 26 |     |         }
 27 |     |     }
 28 |     | 
 29 |     |     function _additionalCookAction(
 30 |     |         uint8 action,
 31 |     |         CookStatus memory status,
 32 |     |         uint256 /*value*/,
 33 |     |         bytes memory data,
 34 |     |         uint256 /*value1*/,
 35 |     |         uint256 /*value2*/
 36 |     |     ) internal virtual override returns (bytes memory /*returnData*/, uint8 /*returnValues*/, CookStatus memory /*updatedStatus*/) {
 37 |     |         if (action == ACTION_SET_MAX_BORROW) {
 38 |     |             (address user, uint256 maxBorrow, bytes32[] memory merkleProof) = abi.decode(data, (address, uint256, bytes32[]));
 39 |     |             whitelister.setMaxBorrow(user, maxBorrow, merkleProof);
 40 |     |         }
 41 |     | 
 42 |     |         return ("", 0, status);
 43 |     |     }
 44 |     | 
 45 |     |     /// @notice allows to change the whitelister
 46 |     |     /// @param newWhiteLister new whitelisting address
 47 |     |     function changeWhitelister(IWhitelister newWhiteLister) public onlyMasterContractOwner {
 48 |     |         whitelister = newWhiteLister;
 49 |     |         emit LogChangeWhitelister(newWhiteLister);
 50 |     |     }
 51 |     | }
 52 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/Fuzz.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./FuzzFactory.sol";
  5 |     | import "./FuzzRouter.sol";
  6 |     | import "./FuzzMagicLP.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title Fuzz
 10 |     |  * @author 0xScourgedev
 11 |     |  * @notice Composite contract for all of the handlers
 12 |     |  */
 13 | *r  | contract Fuzz is FuzzFactory, FuzzRouter, FuzzMagicLP {
 14 |     |     constructor() payable {
 15 |     |         setup();
 16 |     |         setupActors();
 17 |     |     }
 18 |     | }
 19 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/FuzzFactory.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./FuzzSetup.sol";
  5 |     | import "./helper/preconditions/PreconditionsFactory.sol";
  6 |     | import "./helper/postconditions/PostconditionsFactory.sol";
  7 |     | import "./util/FunctionCalls.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title FuzzFactory
 11 |     |  * @author 0xScourgedev
 12 |     |  * @notice Fuzz handlers for Factory
 13 |     |  */
 14 |     | contract FuzzFactory is PreconditionsFactory, PostconditionsFactory {
 15 | *   |     function fuzz_create(uint8 baseToken_, uint8 quoteToken_, uint256 lpFeeRate_, uint256 i_, uint256 k_) public setCurrentActor {
 16 | *   |         CreateParams memory params = createPreconditions(baseToken_, quoteToken_, lpFeeRate_, i_, k_);
 17 |     | 
 18 | *   |         address[] memory actorsToUpdate = new address[](1);
 19 | *   |         actorsToUpdate[0] = currentActor;
 20 |     | 
 21 | *   |         address[] memory poolsToUpdate = new address[](1);
 22 |     | 
 23 | *   |         _before(actorsToUpdate, poolsToUpdate);
 24 |     | 
 25 | *   |         (bool success, bytes memory returnData) = _createCall(
 26 | *   |             params.baseToken_,
 27 | *   |             params.quoteToken_,
 28 | *   |             params.lpFeeRate_,
 29 | *   |             params.i_,
 30 | *   |             params.k_
 31 |     |         );
 32 |     | 
 33 | *   |         createPostconditions(success, returnData, actorsToUpdate, poolsToUpdate, params.baseToken_, params.quoteToken_);
 34 |     |     }
 35 |     | }
 36 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/FuzzMagicLP.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./FuzzSetup.sol";
   5 |     | import "./helper/preconditions/PreconditionsMagicLP.sol";
   6 |     | import "./helper/postconditions/PostconditionsMagicLP.sol";
   7 |     | import "./util/FunctionCalls.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @title FuzzMagicLP
  11 |     |  * @author 0xScourgedev
  12 |     |  * @notice Fuzz handlers for MagicLP
  13 |     |  */
  14 |     | contract FuzzMagicLP is PreconditionsMagicLP, PostconditionsMagicLP {
  15 | *   |     function fuzz_buyShares(uint8 lp) public setCurrentActor {
  16 | *   |         address lpAddr = buySharesPreconditions(lp);
  17 |     | 
  18 | *   |         address[] memory actorsToUpdate = new address[](1);
  19 | *   |         actorsToUpdate[0] = currentActor;
  20 |     | 
  21 | *   |         address[] memory poolsToUpdate = new address[](1);
  22 | *   |         poolsToUpdate[0] = lpAddr;
  23 |     | 
  24 | *   |         _before(actorsToUpdate, poolsToUpdate);
  25 |     | 
  26 | *   |         (bool success, bytes memory returnData) = _buySharesCall(lpAddr, currentActor);
  27 |     | 
  28 | *   |         buySharesPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);
  29 |     |     }
  30 |     | 
  31 | *   |     function fuzz_correctRState(uint8 lp) public setCurrentActor {
  32 | *   |         address lpAddr = correctRStatePreconditions(lp);
  33 |     | 
  34 | *   |         address[] memory actorsToUpdate = new address[](1);
  35 | *   |         actorsToUpdate[0] = currentActor;
  36 |     | 
  37 | *   |         address[] memory poolsToUpdate = new address[](1);
  38 | *   |         poolsToUpdate[0] = lpAddr;
  39 |     | 
  40 | *   |         _before(actorsToUpdate, poolsToUpdate);
  41 |     | 
  42 | *   |         (bool success, bytes memory returnData) = _correctRStateCall(lpAddr);
  43 |     | 
  44 | *   |         correctRStatePostconditions(success, returnData, actorsToUpdate, poolsToUpdate);
  45 |     |     }
  46 |     | 
  47 | *   |     function fuzz_sellBase(uint8 lp) public setCurrentActor {
  48 | *   |         address lpAddr = sellBasePreconditions(lp);
  49 |     | 
  50 | *   |         address[] memory actorsToUpdate = new address[](1);
  51 | *   |         actorsToUpdate[0] = currentActor;
  52 |     | 
  53 | *   |         address[] memory poolsToUpdate = new address[](1);
  54 | *   |         poolsToUpdate[0] = lpAddr;
  55 |     | 
  56 | *   |         _before(actorsToUpdate, poolsToUpdate);
  57 |     | 
  58 | *   |         (bool success, bytes memory returnData) = _sellBaseCall(lpAddr, currentActor);
  59 |     | 
  60 |     |         sellBasePostconditions(success, returnData, actorsToUpdate, poolsToUpdate);
  61 |     |     }
  62 |     | 
  63 | *   |     function fuzz_sellQuote(uint8 lp) public setCurrentActor {
  64 | *   |         address lpAddr = sellQuotePreconditions(lp);
  65 |     | 
  66 | *   |         address[] memory actorsToUpdate = new address[](1);
  67 | *   |         actorsToUpdate[0] = currentActor;
  68 |     | 
  69 | *   |         address[] memory poolsToUpdate = new address[](1);
  70 | *   |         poolsToUpdate[0] = lpAddr;
  71 |     | 
  72 | *   |         _before(actorsToUpdate, poolsToUpdate);
  73 |     | 
  74 | *   |         (bool success, bytes memory returnData) = _sellQuoteCall(lpAddr, currentActor);
  75 |     | 
  76 |     |         sellQuotePostconditions(success, returnData, actorsToUpdate, poolsToUpdate);
  77 |     |     }
  78 |     | 
  79 | *   |     function fuzz_sellShares(
  80 |     |         uint256 shareAmount,
  81 |     |         uint8 lp,
  82 |     |         uint256 baseMinAmount,
  83 |     |         uint256 quoteMinAmount,
  84 |     |         uint256 deadline
  85 |     |     ) public setCurrentActor {
  86 | *   |         SellSharesParams memory params = sellSharesPreconditions(shareAmount, lp, baseMinAmount, quoteMinAmount, deadline);
  87 |     | 
  88 | *   |         address[] memory actorsToUpdate = new address[](1);
  89 | *   |         actorsToUpdate[0] = currentActor;
  90 |     | 
  91 | *   |         address[] memory poolsToUpdate = new address[](1);
  92 | *   |         poolsToUpdate[0] = params.lpAddr;
  93 |     | 
  94 | *   |         _before(actorsToUpdate, poolsToUpdate);
  95 |     | 
  96 | *   |         (bool success, bytes memory returnData) = _sellSharesCall(
  97 | *   |             params.lpAddr,
  98 | *   |             params.shareAmount,
  99 | *   |             currentActor,
 100 | *   |             params.baseMinAmount,
 101 | *   |             params.quoteMinAmount,
 102 |     |             "",
 103 | *   |             params.deadline
 104 |     |         );
 105 |     | 
 106 | *   |         sellSharesPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);
 107 |     |     }
 108 |     | 
 109 | *   |     function fuzz_sync(uint8 lp) public setCurrentActor {
 110 | *   |         address lpAddr = syncPreconditions(lp);
 111 |     | 
 112 | *   |         address[] memory actorsToUpdate = new address[](1);
 113 | *   |         actorsToUpdate[0] = currentActor;
 114 |     | 
 115 | *   |         address[] memory poolsToUpdate = new address[](1);
 116 | *   |         poolsToUpdate[0] = lpAddr;
 117 |     | 
 118 | *   |         _before(actorsToUpdate, poolsToUpdate);
 119 |     | 
 120 | *   |         (bool success, bytes memory returnData) = _syncCall(lpAddr);
 121 |     | 
 122 | *   |         syncPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);
 123 |     |     }
 124 |     | 
 125 | *   |     function fuzz_transferSharesToLp(uint8 lp, uint256 amount) public setCurrentActor {
 126 | *   |         TransferParams memory params = transferSharesToLpPreconditions(lp, amount);
 127 |     | 
 128 | *   |         address[] memory actorsToUpdate = new address[](1);
 129 | *   |         actorsToUpdate[0] = currentActor;
 130 |     | 
 131 | *   |         address[] memory poolsToUpdate = new address[](1);
 132 | *   |         poolsToUpdate[0] = params.lpAddr;
 133 |     | 
 134 | *   |         _before(actorsToUpdate, poolsToUpdate);
 135 |     | 
 136 | *   |         (bool success, bytes memory returnData) = _transferCall(params.lpAddr, params.lpAddr, params.amount);
 137 |     | 
 138 | *   |         transferPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);
 139 |     |     }
 140 |     | 
 141 | *   |     function fuzz_transferTokensToLp(uint8 lp, bool transferQuote, uint256 amount) public setCurrentActor {
 142 | *   |         TransferTokensToLpParams memory params = transferTokensToLpPreconditions(lp, transferQuote, amount);
 143 |     | 
 144 | *   |         address[] memory actorsToUpdate = new address[](1);
 145 | *   |         actorsToUpdate[0] = currentActor;
 146 |     | 
 147 | *   |         address[] memory poolsToUpdate = new address[](1);
 148 | *   |         poolsToUpdate[0] = params.lpAddr;
 149 |     | 
 150 | *   |         _before(actorsToUpdate, poolsToUpdate);
 151 |     | 
 152 | *   |         (bool success, bytes memory returnData) = _transferCall(params.token, params.lpAddr, params.amount);
 153 |     | 
 154 |     |         transferPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);
 155 |     |     }
 156 |     | }
 157 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/FuzzRouter.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./FuzzSetup.sol";
   5 |     | import "./helper/preconditions/PreconditionsRouter.sol";
   6 |     | import "./helper/postconditions/PostconditionsRouter.sol";
   7 |     | import "./util/FunctionCalls.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @title FuzzRouter
  11 |     |  * @author 0xScourgedev
  12 |     |  * @notice Fuzz handlers for Router
  13 |     |  */
  14 |     | contract FuzzRouter is PreconditionsRouter, PostconditionsRouter {
  15 | *   |     function fuzz_addLiquidity(uint8 lp, uint256 baseInAmount, uint256 quoteInAmount, uint256 minimumShares) public setCurrentActor {
  16 | *   |         AddLiquidityParams memory params = addLiquidityPreconditions(lp, baseInAmount, quoteInAmount, minimumShares);
  17 |     | 
  18 | *   |         address[] memory actorsToUpdate = new address[](1);
  19 | *   |         actorsToUpdate[0] = currentActor;
  20 |     | 
  21 | *   |         address[] memory poolsToUpdate = new address[](1);
  22 | *   |         poolsToUpdate[0] = params.lpAddr;
  23 |     | 
  24 | *   |         _before(actorsToUpdate, poolsToUpdate);
  25 |     | 
  26 | *   |         (, , uint256 previewShares) = router.previewAddLiquidity(params.lpAddr, params.baseInAmount, params.quoteInAmount);
  27 |     | 
  28 | *   |         (bool success, bytes memory returnData) = _addLiquidityCall(
  29 | *   |             params.lpAddr,
  30 | *   |             currentActor,
  31 | *   |             params.baseInAmount,
  32 | *   |             params.quoteInAmount,
  33 | *   |             params.minimumShares,
  34 | *   |             type(uint32).max
  35 |     |         );
  36 |     | 
  37 | *   |         addLiquidityPostconditions(success, returnData, actorsToUpdate, poolsToUpdate, previewShares);
  38 |     |     }
  39 |     | 
  40 | *   |     function fuzz_addLiquidityETH(uint8 lp, uint256 tokenInAmount, uint256 value, uint256 minimumShares) public setCurrentActor {
  41 | *   |         AddLiquidityETHParams memory params = addLiquidityETHPreconditions(lp, tokenInAmount, value, minimumShares);
  42 |     | 
  43 |     |         address[] memory actorsToUpdate = new address[](1);
  44 |     |         actorsToUpdate[0] = currentActor;
  45 |     | 
  46 |     |         address[] memory poolsToUpdate = new address[](1);
  47 |     |         poolsToUpdate[0] = params.lpAddr;
  48 |     | 
  49 |     |         _before(actorsToUpdate, poolsToUpdate);
  50 |     | 
  51 |     |         address token = IMagicLP(params.lpAddr)._BASE_TOKEN_();
  52 |     |         uint256 previewShares;
  53 |     |         if (token == address(weth)) {
  54 |     |             (, , previewShares) = router.previewAddLiquidity(params.lpAddr, params.value, params.tokenInAmount);
  55 |     |         } else {
  56 |     |             (, , previewShares) = router.previewAddLiquidity(params.lpAddr, params.tokenInAmount, params.value);
  57 |     |         }
  58 |     | 
  59 |     |         (bool success, bytes memory returnData) = _addLiquidityETHCall(
  60 |     |             params.lpAddr,
  61 |     |             currentActor,
  62 |     |             currentActor,
  63 |     |             params.tokenInAmount,
  64 |     |             params.value,
  65 |     |             params.minimumShares,
  66 |     |             type(uint32).max
  67 |     |         );
  68 |     | 
  69 |     |         addLiquidityETHPostconditions(success, returnData, actorsToUpdate, poolsToUpdate, previewShares);
  70 |     |     }
  71 |     | 
  72 | *   |     function fuzz_addLiquidityETHUnsafe(uint8 lp, uint256 tokenInAmount, uint256 value, uint256 minimumShares) public setCurrentActor {
  73 | *   |         AddLiquidityETHUnsafeParams memory params = addLiquidityETHUnsafePreconditions(lp, tokenInAmount, value, minimumShares);
  74 |     | 
  75 |     |         address[] memory actorsToUpdate = new address[](1);
  76 |     |         actorsToUpdate[0] = currentActor;
  77 |     | 
  78 |     |         address[] memory poolsToUpdate = new address[](1);
  79 |     |         poolsToUpdate[0] = params.lpAddr;
  80 |     | 
  81 |     |         _before(actorsToUpdate, poolsToUpdate);
  82 |     | 
  83 |     |         address token = IMagicLP(params.lpAddr)._BASE_TOKEN_();
  84 |     |         uint256 previewShares;
  85 |     |         if (token == address(weth)) {
  86 |     |             (, , previewShares) = router.previewAddLiquidity(params.lpAddr, params.value, params.tokenInAmount);
  87 |     |         } else {
  88 |     |             (, , previewShares) = router.previewAddLiquidity(params.lpAddr, params.tokenInAmount, params.value);
  89 |     |         }
  90 |     | 
  91 |     |         (bool success, bytes memory returnData) = _addLiquidityETHUnsafeCall(
  92 |     |             params.lpAddr,
  93 |     |             currentActor,
  94 |     |             params.tokenInAmount,
  95 |     |             params.value,
  96 |     |             params.minimumShares,
  97 |     |             type(uint32).max
  98 |     |         );
  99 |     | 
 100 |     |         addLiquidityETHUnsafePostconditions(success, returnData, actorsToUpdate, poolsToUpdate, previewShares);
 101 |     |     }
 102 |     | 
 103 | *   |     function fuzz_addLiquidityUnsafe(uint8 lp, uint256 baseInAmount, uint256 quoteInAmount, uint256 minimumShares) public setCurrentActor {
 104 | *   |         AddLiquidityUnsafeParams memory params = addLiquidityUnsafePreconditions(lp, baseInAmount, quoteInAmount, minimumShares);
 105 |     | 
 106 | *   |         address[] memory actorsToUpdate = new address[](1);
 107 | *   |         actorsToUpdate[0] = currentActor;
 108 |     | 
 109 | *   |         address[] memory poolsToUpdate = new address[](1);
 110 | *   |         poolsToUpdate[0] = params.lpAddr;
 111 |     | 
 112 | *   |         _before(actorsToUpdate, poolsToUpdate);
 113 |     | 
 114 | *   |         (, , uint256 previewShares) = router.previewAddLiquidity(params.lpAddr, params.baseInAmount, params.quoteInAmount);
 115 |     | 
 116 | *   |         (bool success, bytes memory returnData) = _addLiquidityUnsafeCall(
 117 | *   |             params.lpAddr,
 118 | *   |             currentActor,
 119 | *   |             params.baseInAmount,
 120 | *   |             params.quoteInAmount,
 121 | *   |             params.minimumShares,
 122 | *   |             type(uint32).max
 123 |     |         );
 124 |     | 
 125 | *   |         addLiquidityUnsafePostconditions(success, returnData, actorsToUpdate, poolsToUpdate, previewShares);
 126 |     |     }
 127 |     | 
 128 | *   |     function fuzz_createPool(
 129 |     |         uint8 baseToken,
 130 |     |         uint8 quoteToken,
 131 |     |         uint256 lpFeeRate,
 132 |     |         uint256 i,
 133 |     |         uint256 k,
 134 |     |         uint256 baseInAmount,
 135 |     |         uint256 quoteInAmount
 136 |     |     ) public setCurrentActor {
 137 | *   |         CreatePoolParams memory params = createPoolPreconditions(baseToken, quoteToken, lpFeeRate, i, k, baseInAmount, quoteInAmount);
 138 |     | 
 139 | *   |         address[] memory actorsToUpdate = new address[](1);
 140 | *   |         actorsToUpdate[0] = currentActor;
 141 |     | 
 142 | *   |         address[] memory poolsToUpdate = new address[](1);
 143 |     | 
 144 | *   |         _before(actorsToUpdate, poolsToUpdate);
 145 |     | 
 146 | *   |         (bool success, bytes memory returnData) = _createPoolCall(
 147 | *   |             params.baseToken,
 148 | *   |             params.quoteToken,
 149 | *   |             params.lpFeeRate,
 150 | *   |             params.i,
 151 | *   |             params.k,
 152 | *   |             currentActor,
 153 | *   |             params.baseInAmount,
 154 | *   |             params.quoteInAmount
 155 |     |         );
 156 |     | 
 157 | *   |         createPoolPostconditions(success, returnData, actorsToUpdate, poolsToUpdate, params.baseToken, params.quoteToken);
 158 |     |     }
 159 |     | 
 160 | *   |     function fuzz_createPoolETH(
 161 |     |         uint8 token,
 162 |     |         bool useTokenAsQuote,
 163 |     |         uint256 lpFeeRate,
 164 |     |         uint256 i,
 165 |     |         uint256 k,
 166 |     |         uint256 tokenInAmount,
 167 |     |         uint256 value
 168 | *   |     ) public setCurrentActor {
 169 | *   |         CreatePoolETHParams memory params = createPoolETHPreconditions(token, useTokenAsQuote, lpFeeRate, i, k, tokenInAmount, value);
 170 |     | 
 171 | *   |         address[] memory actorsToUpdate = new address[](1);
 172 | *   |         actorsToUpdate[0] = currentActor;
 173 |     | 
 174 | *   |         address[] memory poolsToUpdate = new address[](1);
 175 |     | 
 176 | *   |         _before(actorsToUpdate, poolsToUpdate);
 177 |     | 
 178 | *   |         (bool success, bytes memory returnData) = _createPoolETHCall(
 179 | *   |             params.token,
 180 | *   |             params.useTokenAsQuote,
 181 | *   |             params.lpFeeRate,
 182 | *   |             params.i,
 183 | *   |             params.k,
 184 | *   |             currentActor,
 185 | *   |             params.tokenInAmount,
 186 | *   |             params.value
 187 |     |         );
 188 |     | 
 189 | *   |         createPoolETHPostconditions(success, returnData, actorsToUpdate, poolsToUpdate, params.token);
 190 |     |     }
 191 |     | 
 192 | *   |     function fuzz_removeLiquidity(
 193 |     |         uint8 lp,
 194 |     |         uint256 sharesIn,
 195 |     |         uint256 minimumBaseAmount,
 196 |     |         uint256 minimumQuoteAmount
 197 | *   |     ) public setCurrentActor {
 198 | *   |         RemoveLiquidityParams memory params = removeLiquidityPreconditions(lp, sharesIn, minimumBaseAmount, minimumQuoteAmount);
 199 |     | 
 200 | *   |         address[] memory actorsToUpdate = new address[](1);
 201 | *   |         actorsToUpdate[0] = currentActor;
 202 |     | 
 203 | *   |         address[] memory poolsToUpdate = new address[](1);
 204 | *   |         poolsToUpdate[0] = params.lpAddr;
 205 |     | 
 206 | *   |         _before(actorsToUpdate, poolsToUpdate);
 207 |     | 
 208 | *r  |         (uint256 previewBase, uint256 previewQuote) = router.previewRemoveLiquidity(params.lpAddr, params.sharesIn);
 209 |     | 
 210 | *   |         (bool success, bytes memory returnData) = _removeLiquidityCall(
 211 | *   |             params.lpAddr,
 212 | *   |             currentActor,
 213 | *   |             params.sharesIn,
 214 | *   |             params.minimumBaseAmount,
 215 | *   |             params.minimumQuoteAmount,
 216 | *   |             type(uint32).max
 217 |     |         );
 218 |     | 
 219 | *   |         removeLiquidityPostconditions(success, returnData, actorsToUpdate, poolsToUpdate, params.sharesIn, previewBase, previewQuote);
 220 |     |     }
 221 |     | 
 222 | *   |     function fuzz_removeLiquidityETH(
 223 |     |         uint8 lp,
 224 |     |         uint256 sharesIn,
 225 |     |         uint256 minimumETHAmount,
 226 |     |         uint256 minimumTokenAmount
 227 |     |     ) public setCurrentActor {
 228 | *   |         RemoveLiquidityETHParams memory params = removeLiquidityETHPreconditions(lp, sharesIn, minimumETHAmount, minimumTokenAmount);
 229 |     | 
 230 |     |         address[] memory actorsToUpdate = new address[](1);
 231 |     |         actorsToUpdate[0] = currentActor;
 232 |     | 
 233 |     |         address[] memory poolsToUpdate = new address[](1);
 234 |     |         poolsToUpdate[0] = params.lpAddr;
 235 |     | 
 236 |     |         _before(actorsToUpdate, poolsToUpdate);
 237 |     | 
 238 |     |         (bool success, bytes memory returnData) = _removeLiquidityETHCall(
 239 |     |             params.lpAddr,
 240 |     |             currentActor,
 241 |     |             params.sharesIn,
 242 |     |             params.minimumETHAmount,
 243 |     |             params.minimumTokenAmount,
 244 |     |             type(uint32).max
 245 |     |         );
 246 |     | 
 247 |     |         removeLiquidityETHPostconditions(success, returnData, actorsToUpdate, poolsToUpdate, params.sharesIn);
 248 |     |     }
 249 |     | 
 250 | *   |     function fuzz_previewAddLiquidity(uint8 lp, uint256 baseInAmount, uint256 quoteInAmount) public setCurrentActor {
 251 | *   |         PreviewAddLiquidityParams memory params = previewAddLiquidityPreconditions(lp, baseInAmount, quoteInAmount);
 252 |     | 
 253 | *   |         (bool success, bytes memory returnData) = _previewAddLiquidityCall(params.lpAddr, params.baseInAmount, params.quoteInAmount);
 254 |     | 
 255 | *   |         previewAddLiquidityPostconditions(success, returnData);
 256 |     |     }
 257 |     | 
 258 | *   |     function fuzz_previewRemoveLiquidity(uint8 lp, uint256 sharesIn) public setCurrentActor {
 259 | *   |         PreviewRemoveLiquidityParams memory params = previewRemoveLiquidityPreconditions(lp, sharesIn);
 260 |     | 
 261 | *   |         (bool success, bytes memory returnData) = _previewRemoveLiquidityCall(params.lpAddr, params.sharesIn);
 262 |     | 
 263 | *   |         previewRemoveLiquidityPostconditions(success, returnData, params.lpAddr);
 264 |     |     }
 265 |     | 
 266 | *   |     function fuzz_sellBaseETHForTokens(uint8 lp, uint256 minimumOut, uint256 value) public setCurrentActor {
 267 | *   |         SellBaseETHForTokensParams memory params = sellBaseETHForTokensPreconditions(lp, minimumOut, value);
 268 |     | 
 269 |     |         address[] memory actorsToUpdate = new address[](1);
 270 |     |         actorsToUpdate[0] = currentActor;
 271 |     | 
 272 |     |         address[] memory poolsToUpdate = new address[](1);
 273 |     |         poolsToUpdate[0] = params.lpAddr;
 274 |     | 
 275 |     |         _before(actorsToUpdate, poolsToUpdate);
 276 |     | 
 277 |     |         (bool success, bytes memory returnData) = _sellBaseETHForTokensCall(
 278 |     |             params.lpAddr,
 279 |     |             currentActor,
 280 |     |             params.minimumOut,
 281 |     |             type(uint32).max,
 282 |     |             params.value
 283 |     |         );
 284 |     | 
 285 |     |         sellBaseETHForTokensPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);
 286 |     |     }
 287 |     | 
 288 | *   |     function fuzz_sellBaseTokensForETH(uint8 lp, uint256 amountIn, uint256 minimumOut) public setCurrentActor {
 289 | *   |         SellBaseTokensForETHParams memory params = sellBaseTokensForETHPreconditions(lp, amountIn, minimumOut);
 290 |     | 
 291 |     |         address[] memory actorsToUpdate = new address[](1);
 292 |     |         actorsToUpdate[0] = currentActor;
 293 |     | 
 294 |     |         address[] memory poolsToUpdate = new address[](1);
 295 |     |         poolsToUpdate[0] = params.lpAddr;
 296 |     | 
 297 |     |         _before(actorsToUpdate, poolsToUpdate);
 298 |     | 
 299 |     |         (bool success, bytes memory returnData) = _sellBaseTokensForETHCall(
 300 |     |             params.lpAddr,
 301 |     |             currentActor,
 302 |     |             params.amountIn,
 303 |     |             params.minimumOut,
 304 |     |             type(uint32).max
 305 |     |         );
 306 |     | 
 307 |     |         sellBaseTokensForETHPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);
 308 |     |     }
 309 |     | 
 310 | *   |     function fuzz_sellBaseTokensForTokens(uint8 lp, uint256 amountIn, uint256 minimumOut) public setCurrentActor {
 311 | *   |         SellBaseTokensForTokensParams memory params = sellBaseTokensForTokensPreconditions(lp, amountIn, minimumOut);
 312 |     | 
 313 | *   |         address[] memory actorsToUpdate = new address[](1);
 314 | *   |         actorsToUpdate[0] = currentActor;
 315 |     | 
 316 | *   |         address[] memory poolsToUpdate = new address[](1);
 317 | *   |         poolsToUpdate[0] = params.lpAddr;
 318 |     | 
 319 | *   |         _before(actorsToUpdate, poolsToUpdate);
 320 |     | 
 321 | *   |         (bool success, bytes memory returnData) = _sellBaseTokensForTokensCall(
 322 | *   |             params.lpAddr,
 323 | *   |             currentActor,
 324 | *   |             params.amountIn,
 325 | *   |             params.minimumOut,
 326 | *   |             type(uint32).max
 327 |     |         );
 328 |     | 
 329 |     |         sellBaseTokensForTokensPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);
 330 |     |     }
 331 |     | 
 332 | *   |     function fuzz_sellQuoteETHForTokens(uint8 lp, uint256 minimumOut, uint256 value) public setCurrentActor {
 333 | *   |         SellQuoteETHForTokensParams memory params = sellQuoteETHForTokensPreconditions(lp, minimumOut, value);
 334 |     | 
 335 |     |         address[] memory actorsToUpdate = new address[](1);
 336 |     |         actorsToUpdate[0] = currentActor;
 337 |     | 
 338 |     |         address[] memory poolsToUpdate = new address[](1);
 339 |     |         poolsToUpdate[0] = params.lpAddr;
 340 |     | 
 341 |     |         _before(actorsToUpdate, poolsToUpdate);
 342 |     | 
 343 |     |         (bool success, bytes memory returnData) = _sellQuoteETHForTokensCall(
 344 |     |             params.lpAddr,
 345 |     |             currentActor,
 346 |     |             params.minimumOut,
 347 |     |             type(uint32).max,
 348 |     |             params.value
 349 |     |         );
 350 |     | 
 351 |     |         sellQuoteETHForTokensPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);
 352 |     |     }
 353 |     | 
 354 | *   |     function fuzz_sellQuoteTokensForETH(uint8 lp, uint256 amountIn, uint256 minimumOut) public setCurrentActor {
 355 | *   |         SellQuoteTokensForETHParams memory params = sellQuoteTokensForETHPreconditions(lp, amountIn, minimumOut);
 356 |     | 
 357 |     |         address[] memory actorsToUpdate = new address[](1);
 358 |     |         actorsToUpdate[0] = currentActor;
 359 |     | 
 360 |     |         address[] memory poolsToUpdate = new address[](1);
 361 |     |         poolsToUpdate[0] = params.lpAddr;
 362 |     | 
 363 |     |         _before(actorsToUpdate, poolsToUpdate);
 364 |     | 
 365 |     |         (bool success, bytes memory returnData) = _sellQuoteTokensForETHCall(
 366 |     |             params.lpAddr,
 367 |     |             currentActor,
 368 |     |             params.amountIn,
 369 |     |             params.minimumOut,
 370 |     |             type(uint32).max
 371 |     |         );
 372 |     | 
 373 |     |         sellQuoteTokensForETHPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);
 374 |     |     }
 375 |     | 
 376 | *   |     function fuzz_sellQuoteTokensForTokens(uint8 lp, uint256 amountIn, uint256 minimumOut) public setCurrentActor {
 377 | *   |         SellQuoteTokensForTokensParams memory params = sellQuoteTokensForTokensPreconditions(lp, amountIn, minimumOut);
 378 |     | 
 379 | *   |         address[] memory actorsToUpdate = new address[](1);
 380 | *   |         actorsToUpdate[0] = currentActor;
 381 |     | 
 382 | *   |         address[] memory poolsToUpdate = new address[](1);
 383 | *   |         poolsToUpdate[0] = params.lpAddr;
 384 |     | 
 385 | *   |         _before(actorsToUpdate, poolsToUpdate);
 386 |     | 
 387 | *   |         (bool success, bytes memory returnData) = _sellQuoteTokensForTokensCall(
 388 | *   |             params.lpAddr,
 389 | *   |             currentActor,
 390 | *   |             params.amountIn,
 391 | *   |             params.minimumOut,
 392 | *   |             type(uint32).max
 393 |     |         );
 394 |     | 
 395 | *   |         sellQuoteTokensForTokensPostconditions(success, returnData, actorsToUpdate, poolsToUpdate);
 396 |     |     }
 397 |     | 
 398 | *   |     function fuzz_swapETHForTokens(
 399 |     |         uint8 entropy,
 400 |     |         uint8 pathLength,
 401 |     |         uint256 directions,
 402 |     |         uint256 minimumOut,
 403 |     |         uint256 value
 404 |     |     ) public setCurrentActor {
 405 | *   |         SwapETHForTokensParams memory params = swapETHForTokensPreconditions(entropy, pathLength, directions, minimumOut, value);
 406 |     | 
 407 |     |         address[] memory actorsToUpdate = new address[](1);
 408 |     |         actorsToUpdate[0] = currentActor;
 409 |     | 
 410 |     |         _before(actorsToUpdate, params.path);
 411 |     | 
 412 |     |         (bool success, bytes memory returnData) = _swapETHForTokensCall(
 413 |     |             currentActor,
 414 |     |             params.path,
 415 |     |             params.directions,
 416 |     |             params.minimumOut,
 417 |     |             type(uint32).max,
 418 |     |             params.value
 419 |     |         );
 420 |     | 
 421 |     |         swapETHForTokensPostconditions(success, returnData, actorsToUpdate, params.path, params.directions, params.minimumOut);
 422 |     |     }
 423 |     | 
 424 | *   |     function fuzz_swapTokensForETH(
 425 |     |         uint256 amountIn,
 426 |     |         uint8 entropy,
 427 |     |         uint8 pathLength,
 428 |     |         uint256 directions,
 429 |     |         uint256 minimumOut
 430 |     |     ) public setCurrentActor {
 431 | *   |         SwapTokensForETHParams memory params = swapTokensForETHPreconditions(amountIn, entropy, pathLength, directions, minimumOut);
 432 |     | 
 433 |     |         address[] memory actorsToUpdate = new address[](1);
 434 |     |         actorsToUpdate[0] = currentActor;
 435 |     | 
 436 |     |         _before(actorsToUpdate, params.path);
 437 |     | 
 438 |     |         (bool success, bytes memory returnData) = _swapTokensForETHCall(
 439 |     |             currentActor,
 440 |     |             params.amountIn,
 441 |     |             params.path,
 442 |     |             params.directions,
 443 |     |             params.minimumOut,
 444 |     |             type(uint32).max
 445 |     |         );
 446 |     | 
 447 |     |         swapTokensForETHPostconditions(success, returnData, actorsToUpdate, params.path, params.directions, params.minimumOut);
 448 |     |     }
 449 |     | 
 450 | *   |     function fuzz_swapTokensForTokens(
 451 |     |         uint8 startingToken,
 452 |     |         uint256 amountIn,
 453 |     |         uint8 entropy,
 454 |     |         uint8 pathLength,
 455 |     |         uint256 directions,
 456 |     |         uint256 minimumOut
 457 |     |     ) public setCurrentActor {
 458 | *   |         SwapTokensForTokensParams memory params = swapTokensForTokensPreconditions(
 459 | *   |             startingToken,
 460 | *   |             amountIn,
 461 | *   |             entropy,
 462 | *   |             pathLength,
 463 | *   |             directions,
 464 | *   |             minimumOut
 465 |     |         );
 466 |     | 
 467 |     |         address[] memory actorsToUpdate = new address[](1);
 468 |     |         actorsToUpdate[0] = currentActor;
 469 |     | 
 470 |     |         _before(actorsToUpdate, params.path);
 471 |     | 
 472 |     |         (bool success, bytes memory returnData) = _swapTokensForTokensCall(
 473 |     |             currentActor,
 474 |     |             params.amountIn,
 475 |     |             params.path,
 476 |     |             params.directions,
 477 |     |             params.minimumOut,
 478 |     |             type(uint32).max
 479 |     |         );
 480 |     | 
 481 |     |         swapTokensForTokensPostconditions(success, returnData, actorsToUpdate, params.path, params.directions, params.minimumOut);
 482 |     |     }
 483 |     | }
 484 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/FuzzSetup.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "fuzzlib/FuzzBase.sol";
  5 |     | 
  6 |     | import "./helper/FuzzStorageVariables.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title FuzzSetup
 10 |     |  * @author 0xScourgedev
 11 |     |  * @notice Setup for the fuzzing suite
 12 |     |  */
 13 |     | contract FuzzSetup is FuzzBase, FuzzStorageVariables {
 14 |     |     function setup() internal {
 15 |     |         weth = new MockWETH("Wrapped ETH", "WETH");
 16 |     | 
 17 |     |         feeRateModelImpl = new FeeRateModelImpl();
 18 |     |         feeRateModel = new FeeRateModel(address(this), address(this));
 19 |     |         marketImpl = new MagicLP(address(this));
 20 |     |         factory = new Factory(address(marketImpl), IFeeRateModel(address(feeRateModel)), address(this));
 21 |     |         router = new Router(IWETH(address(weth)), IFactory(address(factory)));
 22 |     | 
 23 |     |         tokenA18 = new MockERC20("TokenA18", "TKA18", 18);
 24 |     |         tokenB18 = new MockERC20("TokenB18", "TKB18", 18);
 25 |     |         tokenA6 = new MockERC20("TokenA6", "TKA6", 6);
 26 |     |         tokenB6 = new MockERC20("TokenB6", "TKB6", 6);
 27 |     |         tokenA8 = new MockERC20("TokenA8", "TKA8", 8);
 28 |     |         tokenB8 = new MockERC20("TokenB8", "TKB8", 8);
 29 |     |         tokenA24 = new MockERC20("tokenA24", "TKA24", 24);
 30 |     |         tokenB24 = new MockERC20("tokenB24", "TKB24", 24);
 31 |     |     }
 32 |     | 
 33 |     |     function setupActors() internal {
 34 |     |         bool success;
 35 |     |         address[] memory targets = new address[](2);
 36 |     |         targets[0] = address(factory);
 37 |     |         targets[1] = address(router);
 38 |     | 
 39 |     |         tokens.push(tokenA18);
 40 |     |         tokens.push(tokenB18);
 41 |     |         tokens.push(tokenA6);
 42 |     |         tokens.push(tokenB6);
 43 |     |         tokens.push(tokenA8);
 44 |     |         tokens.push(tokenB8);
 45 |     |         tokens.push(tokenA24);
 46 |     |         tokens.push(tokenB24);
 47 |     | 
 48 |     |         (success, ) = address(weth).call{value: INITIAL_WETH_BALANCE * USERS.length}("");
 49 |     |         assert(success);
 50 |     | 
 51 |     |         for (uint8 i = 0; i < USERS.length; i++) {
 52 |     |             address user = USERS[i];
 53 |     |             (success, ) = address(user).call{value: INITIAL_BALANCE}("");
 54 |     |             assert(success);
 55 |     |             weth.transfer(user, INITIAL_WETH_BALANCE);
 56 |     | 
 57 |     |             for (uint8 j = 0; j < tokens.length; j++) {
 58 |     |                 tokens[j].mint(user, INITIAL_TOKEN_BALANCE * (10 ** tokens[j].decimals()));
 59 |     |                 for (uint8 k = 0; k < targets.length; k++) {
 60 |     |                     vm.prank(user);
 61 |     |                     tokens[j].approve(targets[k], type(uint128).max);
 62 |     |                     vm.prank(user);
 63 |     |                     weth.approve(targets[k], INITIAL_WETH_BALANCE);
 64 |     |                 }
 65 |     |             }
 66 |     |         }
 67 |     | 
 68 |     |         tokens.push(weth);
 69 |     |     }
 70 |     | }
 71 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/BeforeAfter.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../FuzzSetup.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title BeforeAfter
  8 |     |  * @author 0xScourgedev
  9 |     |  * @notice Contains the states of the system before and after calls
 10 |     |  */
 11 |     | abstract contract BeforeAfter is FuzzSetup {
 12 |     |     mapping(uint8 => State) states;
 13 |     | 
 14 |     |     struct State {
 15 |     |         // actor => actorStates
 16 |     |         mapping(address => ActorStates) actorStates;
 17 |     |         mapping(address => PoolStates) poolStates;
 18 |     |     }
 19 |     | 
 20 |     |     struct ActorStates {
 21 |     |         mapping(address => uint256) tokenBalances;
 22 |     |         uint256 ethBalance;
 23 |     |     }
 24 |     | 
 25 |     |     struct PoolStates {
 26 |     |         uint256 baseBalance;
 27 |     |         uint256 quoteBalance;
 28 |     |         uint256 baseReserve;
 29 |     |         uint256 quoteReserve;
 30 |     |         uint256 baseTarget;
 31 |     |         uint256 quoteTarget;
 32 |     |         uint256 RState;
 33 |     |         uint256 lpTotalSupply;
 34 |     |         uint256 addressZeroBal;
 35 |     |         uint256 poolLpTokenBal;
 36 |     |     }
 37 |     | 
 38 | *   |     function _before(address[] memory actors, address[] memory poolsToUpdate) internal {
 39 | *   |         _setStates(0, actors, poolsToUpdate);
 40 |     |     }
 41 |     | 
 42 | *   |     function _after(address[] memory actors, address[] memory poolsToUpdate) internal {
 43 | *   |         _setStates(1, actors, poolsToUpdate);
 44 |     |     }
 45 |     | 
 46 | *   |     function _setStates(uint8 callNum, address[] memory actors, address[] memory poolsToUpdate) internal {
 47 | *   |         for (uint256 i = 0; i < actors.length; i++) {
 48 | *   |             _setActorState(callNum, actors[i]);
 49 |     |         }
 50 |     | 
 51 | *   |         for (uint256 i = 0; i < poolsToUpdate.length; i++) {
 52 | *   |             if (poolsToUpdate[i] == address(0)) {
 53 | *   |                 break;
 54 |     |             }
 55 | *   |             _setPoolState(callNum, poolsToUpdate[i]);
 56 |     |         }
 57 |     |     }
 58 |     | 
 59 | *   |     function _setPoolState(uint8 callNum, address pool) internal {
 60 | *   |         states[callNum].poolStates[pool].baseBalance = IERC20(MagicLP(pool)._BASE_TOKEN_()).balanceOf(pool);
 61 | *   |         states[callNum].poolStates[pool].quoteBalance = IERC20(MagicLP(pool)._QUOTE_TOKEN_()).balanceOf(pool);
 62 | *   |         states[callNum].poolStates[pool].baseReserve = MagicLP(pool)._BASE_RESERVE_();
 63 | *   |         states[callNum].poolStates[pool].quoteReserve = MagicLP(pool)._QUOTE_RESERVE_();
 64 | *   |         states[callNum].poolStates[pool].baseTarget = MagicLP(pool)._BASE_TARGET_();
 65 | *   |         states[callNum].poolStates[pool].quoteTarget = MagicLP(pool)._QUOTE_TARGET_();
 66 | *   |         states[callNum].poolStates[pool].RState = MagicLP(pool)._RState_();
 67 | *   |         states[callNum].poolStates[pool].lpTotalSupply = IERC20(pool).totalSupply();
 68 | *   |         states[callNum].poolStates[pool].addressZeroBal = IERC20(pool).balanceOf(address(0));
 69 | *   |         states[callNum].poolStates[pool].poolLpTokenBal = IERC20(pool).balanceOf(pool);
 70 |     |     }
 71 |     | 
 72 | *   |     function _setActorState(uint8 callNum, address actor) internal {
 73 | *   |         states[callNum].actorStates[actor].ethBalance = actor.balance;
 74 | *   |         for (uint256 i = 0; i < tokens.length; i++) {
 75 | *   |             states[callNum].actorStates[actor].tokenBalances[address(tokens[i])] = IERC20(address(tokens[i])).balanceOf(actor);
 76 |     |         }
 77 | *   |         for (uint256 i = 0; i < allPools.length; i++) {
 78 | *   |             states[callNum].actorStates[actor].tokenBalances[allPools[i]] = IERC20(allPools[i]).balanceOf(actor);
 79 |     |         }
 80 |     |     }
 81 |     | }
 82 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/FuzzStorageVariables.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../util/FuzzConstants.sol";
  5 |     | import "../mocks/MockWETH.sol";
  6 |     | import "../../mimswap/periphery/Factory.sol";
  7 |     | import "../../mimswap/periphery/Router.sol";
  8 |     | import "../../mimswap/MagicLP.sol";
  9 |     | import "../../mimswap/auxiliary/FeeRateModelImpl.sol";
 10 |     | import "../../mimswap/auxiliary/FeeRateModel.sol";
 11 |     | 
 12 |     | /**
 13 |     |  * @title FuzzStorageVariables
 14 |     |  * @author 0xScourgedev
 15 |     |  * @notice Contains all of the storage variables for the fuzzing suite
 16 |     |  */
 17 |     | abstract contract FuzzStorageVariables is FuzzConstants {
 18 |     |     // Echidna settings
 19 |     |     bool internal _setActor = true;
 20 |     | 
 21 |     |     // All of the deployed contracts
 22 |     |     Factory internal factory;
 23 |     |     Router internal router;
 24 |     |     MagicLP[] internal markets;
 25 |     |     MagicLP internal marketImpl;
 26 |     |     FeeRateModelImpl internal feeRateModelImpl;
 27 |     |     FeeRateModel internal feeRateModel;
 28 |     | 
 29 |     |     MockWETH internal weth;
 30 |     |     MockERC20 internal tokenA18;
 31 |     |     MockERC20 internal tokenB18;
 32 |     |     MockERC20 internal tokenA6;
 33 |     |     MockERC20 internal tokenB6;
 34 |     |     MockERC20 internal tokenA8;
 35 |     |     MockERC20 internal tokenB8;
 36 |     |     MockERC20 internal tokenA24;
 37 |     |     MockERC20 internal tokenB24;
 38 |     | 
 39 |     |     MockERC20[] internal tokens;
 40 |     | 
 41 |     |     // baseToken => quoteToken => pool
 42 |     |     mapping(address => mapping(address => address)) internal pools;
 43 |     |     // baseToken => array of possible quoteTokens
 44 |     |     mapping(address => address[]) internal availablePools;
 45 |     |     address[] internal allPools;
 46 |     | 
 47 |     |     address internal currentActor;
 48 |     | }
 49 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/postconditions/PostconditionsBase.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../../properties/Properties.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title PostconditionsBase
  8 |     |  * @author 0xScourgedev
  9 |     |  * @notice Contains general postconditions used across all postcondition contracts
 10 |     |  */
 11 |     | abstract contract PostconditionsBase is Properties {
 12 | *   |     function onSuccessInvariantsGeneral(address[] memory poolsToUpdate) internal {
 13 | *   |         for (uint256 i = 0; i < poolsToUpdate.length; i++) {
 14 | *   |             invariant_RES_01(poolsToUpdate[i]);
 15 | *   |             invariant_RES_02(poolsToUpdate[i]);
 16 | *   |             invariant_RES_03(poolsToUpdate[i]);
 17 | *   |             invariant_POOL_01(poolsToUpdate[i]);
 18 | *   |             invariant_POOL_04(poolsToUpdate[i]);
 19 |     |         }
 20 |     |     }
 21 |     | 
 22 | *   |     function onFailInvariantsGeneral(bytes memory returnData) internal {
 23 | *   |         invariant_GENERAL_01(returnData);
 24 |     |     }
 25 |     | }
 26 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/postconditions/PostconditionsFactory.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../../properties/Properties.sol";
  5 |     | import "./PostconditionsBase.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @title PostconditionsFactory
  9 |     |  * @author 0xScourgedev
 10 |     |  * @notice Contains all postconditions for Factory
 11 |     |  */
 12 |     | abstract contract PostconditionsFactory is PostconditionsBase {
 13 | *   |     function createPostconditions(
 14 |     |         bool success,
 15 |     |         bytes memory returnData,
 16 |     |         address[] memory actorsToUpdate,
 17 |     |         address[] memory poolsToUpdate,
 18 |     |         address baseToken,
 19 |     |         address quoteToken
 20 |     |     ) internal {
 21 | *   |         if (success) {
 22 | *   |             address pool = abi.decode(returnData, (address));
 23 | *   |             allPools.push(pool);
 24 | *   |             pools[baseToken][quoteToken] = pool;
 25 | *   |             pools[quoteToken][baseToken] = pool;
 26 | *   |             availablePools[quoteToken].push(pool);
 27 | *   |             availablePools[baseToken].push(pool);
 28 | *   |             poolsToUpdate[0] = pool;
 29 |     | 
 30 | *   |             _after(actorsToUpdate, poolsToUpdate);
 31 | *   |             onSuccessInvariantsGeneral(poolsToUpdate);
 32 |     |         } else {
 33 |     |             onFailInvariantsGeneral(returnData);
 34 |     |         }
 35 |     |     }
 36 |     | }
 37 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/postconditions/PostconditionsMagicLP.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "../../properties/Properties.sol";
   5 |     | import "./PostconditionsBase.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title PostconditionsMagicLP
   9 |     |  * @author 0xScourgedev
  10 |     |  * @notice Contains all postconditions for MagicLP
  11 |     |  */
  12 |     | abstract contract PostconditionsMagicLP is PostconditionsBase {
  13 |     |     function buySharesPostconditions(
  14 |     |         bool success,
  15 |     |         bytes memory returnData,
  16 |     |         address[] memory actorsToUpdate,
  17 |     |         address[] memory poolsToUpdate
  18 |     |     ) internal {
  19 |     |         if (success) {
  20 |     |             _after(actorsToUpdate, poolsToUpdate);
  21 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
  22 |     |         } else {
  23 |     |             onFailInvariantsGeneral(returnData);
  24 |     |         }
  25 |     |     }
  26 |     | 
  27 | *   |     function correctRStatePostconditions(
  28 |     |         bool success,
  29 |     |         bytes memory returnData,
  30 |     |         address[] memory actorsToUpdate,
  31 |     |         address[] memory poolsToUpdate
  32 |     |     ) internal {
  33 | *   |         if (success) {
  34 | *   |             _after(actorsToUpdate, poolsToUpdate);
  35 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
  36 |     |         } else {
  37 |     |             invariant_POOL_03();
  38 |     |             onFailInvariantsGeneral(returnData);
  39 |     |         }
  40 |     |     }
  41 |     | 
  42 |     |     function sellBasePostconditions(
  43 |     |         bool success,
  44 |     |         bytes memory returnData,
  45 |     |         address[] memory actorsToUpdate,
  46 |     |         address[] memory poolsToUpdate
  47 |     |     ) internal {
  48 |     |         if (success) {
  49 |     |             _after(actorsToUpdate, poolsToUpdate);
  50 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
  51 |     |         } else {
  52 |     |             onFailInvariantsGeneral(returnData);
  53 |     |         }
  54 |     |     }
  55 |     | 
  56 |     |     function sellQuotePostconditions(
  57 |     |         bool success,
  58 |     |         bytes memory returnData,
  59 |     |         address[] memory actorsToUpdate,
  60 |     |         address[] memory poolsToUpdate
  61 |     |     ) internal {
  62 |     |         if (success) {
  63 |     |             _after(actorsToUpdate, poolsToUpdate);
  64 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
  65 |     |         } else {
  66 |     |             onFailInvariantsGeneral(returnData);
  67 |     |         }
  68 |     |     }
  69 |     | 
  70 |     |     function sellSharesPostconditions(
  71 |     |         bool success,
  72 |     |         bytes memory returnData,
  73 |     |         address[] memory actorsToUpdate,
  74 |     |         address[] memory poolsToUpdate
  75 |     |     ) internal {
  76 |     |         if (success) {
  77 |     |             _after(actorsToUpdate, poolsToUpdate);
  78 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
  79 |     |         } else {
  80 |     |             onFailInvariantsGeneral(returnData);
  81 |     |         }
  82 |     |     }
  83 |     | 
  84 | *   |     function syncPostconditions(
  85 |     |         bool success,
  86 |     |         bytes memory returnData,
  87 |     |         address[] memory actorsToUpdate,
  88 |     |         address[] memory poolsToUpdate
  89 |     |     ) internal {
  90 | *   |         if (success) {
  91 | *   |             _after(actorsToUpdate, poolsToUpdate);
  92 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
  93 |     |         } else {
  94 | *   |             invariant_POOL_02();
  95 |     |             onFailInvariantsGeneral(returnData);
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 |     |     function transferPostconditions(
 100 |     |         bool success,
 101 |     |         bytes memory returnData,
 102 |     |         address[] memory actorsToUpdate,
 103 |     |         address[] memory poolsToUpdate
 104 |     |     ) internal {
 105 |     |         if (success) {
 106 |     |             _after(actorsToUpdate, poolsToUpdate);
 107 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
 108 |     |         } else {
 109 |     |             onFailInvariantsGeneral(returnData);
 110 |     |         }
 111 |     |     }
 112 |     | }
 113 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/postconditions/PostconditionsRouter.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "../../properties/Properties.sol";
   5 |     | import "./PostconditionsBase.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title PostconditionsRouter
   9 |     |  * @author 0xScourgedev
  10 |     |  * @notice Contains all postconditions for Router
  11 |     |  */
  12 |     | abstract contract PostconditionsRouter is PostconditionsBase {
  13 | *   |     function addLiquidityPostconditions(
  14 |     |         bool success,
  15 |     |         bytes memory returnData,
  16 |     |         address[] memory actorsToUpdate,
  17 |     |         address[] memory poolsToUpdate,
  18 |     |         uint256 previewShares
  19 |     |     ) internal {
  20 | *   |         if (success) {
  21 | *   |             (, , uint256 actualShares) = abi.decode(returnData, (uint256, uint256, uint256));
  22 | *   |             _after(actorsToUpdate, poolsToUpdate);
  23 | *   |             invariant_LIQ_01(poolsToUpdate[0]);
  24 | *   |             invariant_LIQ_02(poolsToUpdate[0], false);
  25 | *   |             invariant_LIQ_03(poolsToUpdate[0]);
  26 | *   |             invariant_LIQ_04(poolsToUpdate[0]);
  27 | *   |             invariant_LIQ_12(previewShares, actualShares);
  28 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
  29 |     |         } else {
  30 |     |             onFailInvariantsGeneral(returnData);
  31 |     |         }
  32 |     |     }
  33 |     | 
  34 |     |     function addLiquidityETHPostconditions(
  35 |     |         bool success,
  36 |     |         bytes memory returnData,
  37 |     |         address[] memory actorsToUpdate,
  38 |     |         address[] memory poolsToUpdate,
  39 |     |         uint256 previewShares
  40 |     |     ) internal {
  41 |     |         if (success) {
  42 |     |             (, , uint256 actualShares) = abi.decode(returnData, (uint256, uint256, uint256));
  43 |     |             _after(actorsToUpdate, poolsToUpdate);
  44 |     |             invariant_LIQ_01(poolsToUpdate[0]);
  45 |     |             invariant_LIQ_02(poolsToUpdate[0], true);
  46 |     |             invariant_LIQ_03(poolsToUpdate[0]);
  47 |     |             invariant_LIQ_04(poolsToUpdate[0]);
  48 |     |             invariant_LIQ_12(previewShares, actualShares);
  49 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
  50 |     |         } else {
  51 |     |             onFailInvariantsGeneral(returnData);
  52 |     |         }
  53 |     |     }
  54 |     | 
  55 |     |     function addLiquidityETHUnsafePostconditions(
  56 |     |         bool success,
  57 |     |         bytes memory returnData,
  58 |     |         address[] memory actorsToUpdate,
  59 |     |         address[] memory poolsToUpdate,
  60 |     |         uint256 previewShares
  61 |     |     ) internal {
  62 |     |         if (success) {
  63 |     |             uint256 actualShares = abi.decode(returnData, (uint256));
  64 |     |             _after(actorsToUpdate, poolsToUpdate);
  65 |     |             invariant_LIQ_01(poolsToUpdate[0]);
  66 |     |             invariant_LIQ_02(poolsToUpdate[0], true);
  67 |     |             invariant_LIQ_03(poolsToUpdate[0]);
  68 |     |             invariant_LIQ_04(poolsToUpdate[0]);
  69 |     |             invariant_LIQ_13(previewShares, actualShares);
  70 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
  71 |     |         } else {
  72 |     |             onFailInvariantsGeneral(returnData);
  73 |     |         }
  74 |     |     }
  75 |     | 
  76 | *   |     function addLiquidityUnsafePostconditions(
  77 |     |         bool success,
  78 |     |         bytes memory returnData,
  79 |     |         address[] memory actorsToUpdate,
  80 |     |         address[] memory poolsToUpdate,
  81 |     |         uint256 previewShares
  82 |     |     ) internal {
  83 | *   |         if (success) {
  84 | *   |             uint256 actualShares = abi.decode(returnData, (uint256));
  85 | *   |             _after(actorsToUpdate, poolsToUpdate);
  86 | *   |             invariant_LIQ_01(poolsToUpdate[0]);
  87 | *   |             invariant_LIQ_02(poolsToUpdate[0], false);
  88 | *   |             invariant_LIQ_03(poolsToUpdate[0]);
  89 | *   |             invariant_LIQ_04(poolsToUpdate[0]);
  90 | *   |             invariant_LIQ_13(previewShares, actualShares);
  91 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
  92 |     |         } else {
  93 |     |             onFailInvariantsGeneral(returnData);
  94 |     |         }
  95 |     |     }
  96 |     | 
  97 | *   |     function createPoolPostconditions(
  98 |     |         bool success,
  99 |     |         bytes memory returnData,
 100 |     |         address[] memory actorsToUpdate,
 101 |     |         address[] memory poolsToUpdate,
 102 |     |         address baseToken,
 103 |     |         address quoteToken
 104 |     |     ) internal {
 105 | *   |         if (success) {
 106 |     |             (address pool, ) = abi.decode(returnData, (address, uint256));
 107 |     |             allPools.push(pool);
 108 |     |             pools[baseToken][quoteToken] = pool;
 109 |     |             pools[quoteToken][baseToken] = pool;
 110 |     |             availablePools[quoteToken].push(pool);
 111 |     |             availablePools[baseToken].push(pool);
 112 |     |             poolsToUpdate[0] = pool;
 113 |     | 
 114 |     |             _after(actorsToUpdate, poolsToUpdate);
 115 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
 116 |     |         } else {
 117 |     |             onFailInvariantsGeneral(returnData);
 118 |     |         }
 119 |     |     }
 120 |     | 
 121 | *   |     function createPoolETHPostconditions(
 122 |     |         bool success,
 123 |     |         bytes memory returnData,
 124 |     |         address[] memory actorsToUpdate,
 125 |     |         address[] memory poolsToUpdate,
 126 |     |         address baseToken
 127 |     |     ) internal {
 128 | *   |         if (success) {
 129 |     |             (address pool, ) = abi.decode(returnData, (address, uint256));
 130 |     |             allPools.push(pool);
 131 |     |             pools[baseToken][address(weth)] = pool;
 132 |     |             pools[address(weth)][baseToken] = pool;
 133 |     |             availablePools[address(weth)].push(baseToken);
 134 |     |             availablePools[baseToken].push(address(weth));
 135 |     |             poolsToUpdate[0] = pool;
 136 |     | 
 137 | *   |             _after(actorsToUpdate, poolsToUpdate);
 138 | *   |             onSuccessInvariantsGeneral(poolsToUpdate);
 139 |     |         } else {
 140 | *   |             onFailInvariantsGeneral(returnData);
 141 |     |         }
 142 |     |     }
 143 |     | 
 144 | *   |     function removeLiquidityPostconditions(
 145 |     |         bool success,
 146 |     |         bytes memory returnData,
 147 |     |         address[] memory actorsToUpdate,
 148 |     |         address[] memory poolsToUpdate,
 149 |     |         uint256 sharesIn,
 150 |     |         uint256 previewBase,
 151 |     |         uint256 previewQuote
 152 |     |     ) internal {
 153 | *   |         if (success) {
 154 |     |             (uint256 actualBase, uint256 actualQuote) = abi.decode(returnData, (uint256, uint256));
 155 |     |             _after(actorsToUpdate, poolsToUpdate);
 156 |     |             invariant_LIQ_05(poolsToUpdate[0]);
 157 |     |             invariant_LIQ_06(poolsToUpdate[0], false);
 158 |     |             invariant_LIQ_07(poolsToUpdate[0], sharesIn);
 159 |     |             invariant_LIQ_08(poolsToUpdate[0], sharesIn);
 160 |     |             invariant_LIQ_09(poolsToUpdate[0], sharesIn);
 161 |     |             invariant_LIQ_14(previewBase, previewQuote, actualBase, actualQuote);
 162 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
 163 |     |         } else {
 164 | *   |             onFailInvariantsGeneral(returnData);
 165 |     |         }
 166 |     |     }
 167 |     | 
 168 |     |     function removeLiquidityETHPostconditions(
 169 |     |         bool success,
 170 |     |         bytes memory returnData,
 171 |     |         address[] memory actorsToUpdate,
 172 |     |         address[] memory poolsToUpdate,
 173 |     |         uint256 sharesIn
 174 |     |     ) internal {
 175 |     |         if (success) {
 176 |     |             _after(actorsToUpdate, poolsToUpdate);
 177 |     |             invariant_LIQ_05(poolsToUpdate[0]);
 178 |     |             invariant_LIQ_06(poolsToUpdate[0], true);
 179 |     |             invariant_LIQ_07(poolsToUpdate[0], sharesIn);
 180 |     |             invariant_LIQ_08(poolsToUpdate[0], sharesIn);
 181 |     |             invariant_LIQ_09(poolsToUpdate[0], sharesIn);
 182 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
 183 |     |         } else {
 184 |     |             onFailInvariantsGeneral(returnData);
 185 |     |         }
 186 |     |     }
 187 |     | 
 188 | *   |     function previewAddLiquidityPostconditions(bool success, bytes memory returnData) internal {
 189 | *   |         if (success) {
 190 | *   |             onSuccessInvariantsGeneral(new address[](0));
 191 |     |         } else {
 192 |     |             invariant_LIQ_10();
 193 |     |             onFailInvariantsGeneral(returnData);
 194 |     |         }
 195 |     |     }
 196 |     | 
 197 | *   |     function previewRemoveLiquidityPostconditions(bool success, bytes memory returnData, address pool) internal {
 198 | *   |         if (success) {
 199 | *   |             onSuccessInvariantsGeneral(new address[](0));
 200 |     |         } else {
 201 | *   |             invariant_LIQ_11(pool);
 202 | *   |             onFailInvariantsGeneral(returnData);
 203 |     |         }
 204 |     |     }
 205 |     | 
 206 |     |     function sellBaseETHForTokensPostconditions(
 207 |     |         bool success,
 208 |     |         bytes memory returnData,
 209 |     |         address[] memory actorsToUpdate,
 210 |     |         address[] memory poolsToUpdate
 211 |     |     ) internal {
 212 |     |         if (success) {
 213 |     |             _after(actorsToUpdate, poolsToUpdate);
 214 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
 215 |     |         } else {
 216 |     |             onFailInvariantsGeneral(returnData);
 217 |     |         }
 218 |     |     }
 219 |     | 
 220 |     |     function sellBaseTokensForETHPostconditions(
 221 |     |         bool success,
 222 |     |         bytes memory returnData,
 223 |     |         address[] memory actorsToUpdate,
 224 |     |         address[] memory poolsToUpdate
 225 |     |     ) internal {
 226 |     |         if (success) {
 227 |     |             _after(actorsToUpdate, poolsToUpdate);
 228 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
 229 |     |         } else {
 230 |     |             onFailInvariantsGeneral(returnData);
 231 |     |         }
 232 |     |     }
 233 |     | 
 234 |     |     function sellBaseTokensForTokensPostconditions(
 235 |     |         bool success,
 236 |     |         bytes memory returnData,
 237 |     |         address[] memory actorsToUpdate,
 238 |     |         address[] memory poolsToUpdate
 239 |     |     ) internal {
 240 |     |         if (success) {
 241 |     |             _after(actorsToUpdate, poolsToUpdate);
 242 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
 243 |     |         } else {
 244 |     |             onFailInvariantsGeneral(returnData);
 245 |     |         }
 246 |     |     }
 247 |     | 
 248 |     |     function sellQuoteETHForTokensPostconditions(
 249 |     |         bool success,
 250 |     |         bytes memory returnData,
 251 |     |         address[] memory actorsToUpdate,
 252 |     |         address[] memory poolsToUpdate
 253 |     |     ) internal {
 254 |     |         if (success) {
 255 |     |             _after(actorsToUpdate, poolsToUpdate);
 256 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
 257 |     |         } else {
 258 |     |             onFailInvariantsGeneral(returnData);
 259 |     |         }
 260 |     |     }
 261 |     | 
 262 |     |     function sellQuoteTokensForETHPostconditions(
 263 |     |         bool success,
 264 |     |         bytes memory returnData,
 265 |     |         address[] memory actorsToUpdate,
 266 |     |         address[] memory poolsToUpdate
 267 |     |     ) internal {
 268 |     |         if (success) {
 269 |     |             _after(actorsToUpdate, poolsToUpdate);
 270 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
 271 |     |         } else {
 272 |     |             onFailInvariantsGeneral(returnData);
 273 |     |         }
 274 |     |     }
 275 |     | 
 276 | *   |     function sellQuoteTokensForTokensPostconditions(
 277 |     |         bool success,
 278 |     |         bytes memory returnData,
 279 |     |         address[] memory actorsToUpdate,
 280 |     |         address[] memory poolsToUpdate
 281 |     |     ) internal {
 282 | *   |         if (success) {
 283 | *   |             _after(actorsToUpdate, poolsToUpdate);
 284 | *   |             onSuccessInvariantsGeneral(poolsToUpdate);
 285 |     |         } else {
 286 | *   |             onFailInvariantsGeneral(returnData);
 287 |     |         }
 288 |     |     }
 289 |     | 
 290 |     |     function swapETHForTokensPostconditions(
 291 |     |         bool success,
 292 |     |         bytes memory returnData,
 293 |     |         address[] memory actorsToUpdate,
 294 |     |         address[] memory poolsToUpdate,
 295 |     |         uint256 directions,
 296 |     |         uint256 minimumOut
 297 |     |     ) internal {
 298 |     |         if (success) {
 299 |     |             uint256 actualOut = abi.decode(returnData, (uint256));
 300 |     |             _after(actorsToUpdate, poolsToUpdate);
 301 |     | 
 302 |     |             // Get the final token out address
 303 |     |             directions >>= poolsToUpdate.length - 1;
 304 |     |             address tokenAddr;
 305 |     |             if (directions & 1 == 0) {
 306 |     |                 tokenAddr = IMagicLP(poolsToUpdate[poolsToUpdate.length - 1])._BASE_TOKEN_();
 307 |     |             } else {
 308 |     |                 tokenAddr = IMagicLP(poolsToUpdate[poolsToUpdate.length - 1])._QUOTE_TOKEN_();
 309 |     |             }
 310 |     | 
 311 |     |             invariant_SWAP_01(address(0), address(weth), true);
 312 |     |             invariant_SWAP_02(address(0), tokenAddr, false);
 313 |     |             invariant_SWAP_03(actualOut, minimumOut);
 314 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
 315 |     |         } else {
 316 |     |             onFailInvariantsGeneral(returnData);
 317 |     |         }
 318 |     |     }
 319 |     | 
 320 |     |     function swapTokensForETHPostconditions(
 321 |     |         bool success,
 322 |     |         bytes memory returnData,
 323 |     |         address[] memory actorsToUpdate,
 324 |     |         address[] memory poolsToUpdate,
 325 |     |         uint256 directions,
 326 |     |         uint256 minimumOut
 327 |     |     ) internal {
 328 | *   |         if (success) {
 329 |     |             uint256 actualOut = abi.decode(returnData, (uint256));
 330 |     |             _after(actorsToUpdate, poolsToUpdate);
 331 |     | 
 332 |     |             // Get the token in address
 333 |     |             address tokenAddr;
 334 |     |             if (directions & 1 == 0) {
 335 |     |                 tokenAddr = IMagicLP(poolsToUpdate[0])._BASE_TOKEN_();
 336 |     |             } else {
 337 |     |                 tokenAddr = IMagicLP(poolsToUpdate[0])._QUOTE_TOKEN_();
 338 |     |             }
 339 |     | 
 340 |     |             invariant_SWAP_01(tokenAddr, address(0), false);
 341 |     |             invariant_SWAP_02(address(weth), address(weth), true);
 342 |     |             invariant_SWAP_03(actualOut, minimumOut);
 343 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
 344 |     |         } else {
 345 | *   |             onFailInvariantsGeneral(returnData);
 346 |     |         }
 347 |     |     }
 348 |     | 
 349 |     |     function swapTokensForTokensPostconditions(
 350 |     |         bool success,
 351 |     |         bytes memory returnData,
 352 |     |         address[] memory actorsToUpdate,
 353 |     |         address[] memory poolsToUpdate,
 354 |     |         uint256 directions,
 355 |     |         uint256 minimumOut
 356 |     |     ) internal {
 357 |     |         if (success) {
 358 |     |             uint256 actualOut = abi.decode(returnData, (uint256));
 359 |     |             _after(actorsToUpdate, poolsToUpdate);
 360 |     | 
 361 |     |             // Get the token in address
 362 |     |             address tokenInAddr;
 363 |     |             if (directions & 1 == 0) {
 364 |     |                 tokenInAddr = IMagicLP(poolsToUpdate[0])._BASE_TOKEN_();
 365 |     |                 log("post token for token swap base", tokenInAddr);
 366 |     |             } else {
 367 |     |                 tokenInAddr = IMagicLP(poolsToUpdate[0])._QUOTE_TOKEN_();
 368 |     |                 log("post token for token swap quote", tokenInAddr);
 369 |     |             }
 370 |     |             directions >>= poolsToUpdate.length - 1;
 371 |     | 
 372 |     |             address tokenOutAddr;
 373 |     |             // Get the token out address
 374 |     |             if (directions & 1 == 0) {
 375 |     |                 tokenOutAddr = IMagicLP(poolsToUpdate[poolsToUpdate.length - 1])._QUOTE_TOKEN_();
 376 |     |                 log("post token for token swap quote out", tokenOutAddr);
 377 |     |             } else {
 378 |     |                 tokenOutAddr = IMagicLP(poolsToUpdate[poolsToUpdate.length - 1])._BASE_TOKEN_();
 379 |     |                 log("post token for token swap base out", tokenOutAddr);
 380 |     |             }
 381 |     | 
 382 |     |             invariant_SWAP_01(tokenInAddr, tokenOutAddr, false);
 383 |     |             invariant_SWAP_02(tokenInAddr, tokenOutAddr, false);
 384 |     |             invariant_SWAP_03(actualOut, minimumOut);
 385 |     | 
 386 |     |             onSuccessInvariantsGeneral(poolsToUpdate);
 387 |     |         } else {
 388 |     |             onFailInvariantsGeneral(returnData);
 389 |     |         }
 390 |     |     }
 391 |     | }
 392 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/preconditions/PreconditionsBase.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../../util/FunctionCalls.sol";
  5 |     | import "../BeforeAfter.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @title PreconditionsBase
  9 |     |  * @author 0xScourgedev
 10 |     |  * @notice Contains the base for all preconditions
 11 |     |  */
 12 |     | abstract contract PreconditionsBase is FunctionCalls, BeforeAfter {
 13 |     |     modifier setCurrentActor() {
 14 | *   |         if (_setActor) {
 15 | *   |             currentActor = msg.sender;
 16 |     |         }
 17 |     |         _;
 18 |     |     }
 19 |     | }
 20 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/preconditions/PreconditionsFactory.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PreconditionsBase.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title PreconditionsFactory
  8 |     |  * @author 0xScourgedev
  9 |     |  * @notice Contains all preconditions for Factory
 10 |     |  */
 11 |     | abstract contract PreconditionsFactory is PreconditionsBase {
 12 |     |     struct CreateParams {
 13 |     |         address baseToken_;
 14 |     |         address quoteToken_;
 15 |     |         uint256 lpFeeRate_;
 16 |     |         uint256 i_;
 17 |     |         uint256 k_;
 18 |     |     }
 19 |     | 
 20 | *   |     function createPreconditions(
 21 |     |         uint8 baseToken_,
 22 |     |         uint8 quoteToken_,
 23 |     |         uint256 lpFeeRate_,
 24 |     |         uint256 i_,
 25 |     |         uint256 k_
 26 | *   |     ) internal returns (CreateParams memory) {
 27 | *   |         require(allPools.length < MAX_POOLS, "Maximum number of pools reached");
 28 |     | 
 29 | *   |         address baseToken = address(tokens[baseToken_ % tokens.length]);
 30 | *   |         address quoteToken = address(tokens[quoteToken_ % tokens.length]);
 31 | *   |         if(baseToken == quoteToken) {
 32 | *   |             quoteToken = address(tokens[(quoteToken_ + 1) % tokens.length]);
 33 |     |         }
 34 |     |         
 35 | *   |         lpFeeRate_ = clampBetween(lpFeeRate_, MIN_LP_FEE_RATE, MAX_LP_FEE_RATE);
 36 | *   |         i_ = clampBetween(i_, 1, MAX_I);
 37 | *   |         k_ = clampBetween(k_, 0, MAX_K);
 38 |     | 
 39 | *   |         return CreateParams(baseToken, quoteToken, lpFeeRate_, i_, k_);
 40 |     |     }
 41 |     | }
 42 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/preconditions/PreconditionsMagicLP.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./PreconditionsBase.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * @title PreconditionsMagicLP
   8 |     |  * @author 0xScourgedev
   9 |     |  * @notice Contains all preconditions for MagicLP
  10 |     |  */
  11 |     | abstract contract PreconditionsMagicLP is PreconditionsBase {
  12 |     |     struct SellSharesParams {
  13 |     |         uint256 shareAmount;
  14 |     |         address lpAddr;
  15 |     |         uint256 baseMinAmount;
  16 |     |         uint256 quoteMinAmount;
  17 |     |         uint256 deadline;
  18 |     |     }
  19 |     | 
  20 |     |     struct TransferParams {
  21 |     |         address lpAddr;
  22 |     |         uint256 amount;
  23 |     |     }
  24 |     | 
  25 |     |     struct TransferTokensToLpParams {
  26 |     |         address token;
  27 |     |         address lpAddr;
  28 |     |         uint256 amount;
  29 |     |     }
  30 |     | 
  31 | *   |     function buySharesPreconditions(uint8 lp) internal view returns (address) {
  32 | *   |         require(allPools.length > 0, "There are no available pools");
  33 | *   |         return allPools[lp % allPools.length];
  34 |     |     }
  35 |     | 
  36 |     |     function correctRStatePreconditions(uint8 lp) internal view returns (address) {
  37 |     |         require(allPools.length > 0, "There are no available pools");
  38 |     |         return allPools[lp % allPools.length];
  39 |     |     }
  40 |     | 
  41 |     |     function sellBasePreconditions(uint8 lp) internal view returns (address) {
  42 |     |         require(allPools.length > 0, "There are no available pools");
  43 |     |         return allPools[lp % allPools.length];
  44 |     |     }
  45 |     | 
  46 |     |     function sellQuotePreconditions(uint8 lp) internal view returns (address) {
  47 |     |         require(allPools.length > 0, "There are no available pools");
  48 |     |         return allPools[lp % allPools.length];
  49 |     |     }
  50 |     | 
  51 | *   |     function sellSharesPreconditions(
  52 |     |         uint256 shareAmount,
  53 |     |         uint8 lp,
  54 |     |         uint256 baseMinAmount,
  55 |     |         uint256 quoteMinAmount,
  56 |     |         uint256 deadline
  57 | *   |     ) internal view returns (SellSharesParams memory) {
  58 | *   |         require(allPools.length > 0, "There are no available pools");
  59 |     | 
  60 | *   |         address lpAddr = allPools[lp % allPools.length];
  61 | *   |         return SellSharesParams(shareAmount, lpAddr, baseMinAmount, quoteMinAmount, deadline);
  62 |     |     }
  63 |     | 
  64 |     |     function syncPreconditions(uint8 lp) internal view returns (address) {
  65 |     |         require(allPools.length > 0, "There are no available pools");
  66 |     | 
  67 |     |         return allPools[lp % allPools.length];
  68 |     |     }
  69 |     | 
  70 | *   |     function transferSharesToLpPreconditions(uint8 lp, uint256 amount) internal returns (TransferParams memory) {
  71 | *   |         require(allPools.length > 0, "There are no available pools");
  72 |     | 
  73 | *   |         address lpAddr = allPools[lp % allPools.length];
  74 |     | 
  75 | *   |         amount = clampBetween(amount, 0, IERC20(lpAddr).balanceOf(address(currentActor)));
  76 |     | 
  77 | *   |         vm.prank(currentActor);
  78 | *   |         IERC20(lpAddr).approve(lpAddr, amount);
  79 |     | 
  80 | *   |         return TransferParams(lpAddr, amount);
  81 |     |     }
  82 |     | 
  83 | *   |     function transferTokensToLpPreconditions(
  84 |     |         uint8 lp,
  85 |     |         bool transferQuote,
  86 |     |         uint256 amount
  87 |     |     ) internal returns (TransferTokensToLpParams memory) {
  88 | *   |         require(allPools.length > 0, "There are no available pools");
  89 |     | 
  90 | *   |         address lpAddr = allPools[lp % allPools.length];
  91 |     |         address token;
  92 | *   |         if (transferQuote) {
  93 | *   |             token = MagicLP(lpAddr)._QUOTE_TOKEN_();
  94 |     |         } else {
  95 | *   |             token = MagicLP(lpAddr)._BASE_TOKEN_();
  96 |     |         }
  97 |     | 
  98 | *   |         amount = clampBetween(amount, 0, IERC20(token).balanceOf(address(currentActor)));
  99 |     | 
 100 | *   |         vm.prank(currentActor);
 101 | *   |         IERC20(token).approve(lpAddr, amount);
 102 |     | 
 103 | *   |         return TransferTokensToLpParams(token, lpAddr, amount);
 104 |     |     }
 105 |     | }
 106 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/helper/preconditions/PreconditionsRouter.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./PreconditionsBase.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * @title PreconditionsRouter
   8 |     |  * @author 0xScourgedev
   9 |     |  * @notice Contains all preconditions for Router
  10 |     |  */
  11 |     | abstract contract PreconditionsRouter is PreconditionsBase {
  12 |     |     struct AddLiquidityParams {
  13 |     |         address lpAddr;
  14 |     |         uint256 baseInAmount;
  15 |     |         uint256 quoteInAmount;
  16 |     |         uint256 minimumShares;
  17 |     |     }
  18 |     | 
  19 |     |     struct AddLiquidityETHParams {
  20 |     |         address lpAddr;
  21 |     |         uint256 tokenInAmount;
  22 |     |         uint256 value;
  23 |     |         uint256 minimumShares;
  24 |     |     }
  25 |     | 
  26 |     |     struct AddLiquidityETHUnsafeParams {
  27 |     |         address lpAddr;
  28 |     |         uint256 tokenInAmount;
  29 |     |         uint256 value;
  30 |     |         uint256 minimumShares;
  31 |     |     }
  32 |     | 
  33 |     |     struct AddLiquidityUnsafeParams {
  34 |     |         address lpAddr;
  35 |     |         uint256 baseInAmount;
  36 |     |         uint256 quoteInAmount;
  37 |     |         uint256 minimumShares;
  38 |     |     }
  39 |     | 
  40 |     |     struct CreatePoolParams {
  41 |     |         address baseToken;
  42 |     |         address quoteToken;
  43 |     |         uint256 lpFeeRate;
  44 |     |         uint256 i;
  45 |     |         uint256 k;
  46 |     |         address to;
  47 |     |         uint256 baseInAmount;
  48 |     |         uint256 quoteInAmount;
  49 |     |     }
  50 |     | 
  51 |     |     struct CreatePoolETHParams {
  52 |     |         address token;
  53 |     |         bool useTokenAsQuote;
  54 |     |         uint256 lpFeeRate;
  55 |     |         uint256 i;
  56 |     |         uint256 k;
  57 |     |         address to;
  58 |     |         uint256 tokenInAmount;
  59 |     |         uint256 value;
  60 |     |     }
  61 |     | 
  62 |     |     struct RemoveLiquidityParams {
  63 |     |         address lpAddr;
  64 |     |         uint256 sharesIn;
  65 |     |         uint256 minimumBaseAmount;
  66 |     |         uint256 minimumQuoteAmount;
  67 |     |     }
  68 |     | 
  69 |     |     struct RemoveLiquidityETHParams {
  70 |     |         address lpAddr;
  71 |     |         uint256 sharesIn;
  72 |     |         uint256 minimumETHAmount;
  73 |     |         uint256 minimumTokenAmount;
  74 |     |     }
  75 |     | 
  76 |     |     struct PreviewAddLiquidityParams {
  77 |     |         address lpAddr;
  78 |     |         uint256 baseInAmount;
  79 |     |         uint256 quoteInAmount;
  80 |     |     }
  81 |     | 
  82 |     |     struct PreviewRemoveLiquidityParams {
  83 |     |         address lpAddr;
  84 |     |         uint256 sharesIn;
  85 |     |     }
  86 |     | 
  87 |     |     struct SellBaseETHForTokensParams {
  88 |     |         address lpAddr;
  89 |     |         uint256 minimumOut;
  90 |     |         uint256 value;
  91 |     |     }
  92 |     | 
  93 |     |     struct SellBaseTokensForETHParams {
  94 |     |         address lpAddr;
  95 |     |         uint256 amountIn;
  96 |     |         uint256 minimumOut;
  97 |     |     }
  98 |     | 
  99 |     |     struct SellBaseTokensForTokensParams {
 100 |     |         address lpAddr;
 101 |     |         uint256 amountIn;
 102 |     |         uint256 minimumOut;
 103 |     |     }
 104 |     | 
 105 |     |     struct SellQuoteETHForTokensParams {
 106 |     |         address lpAddr;
 107 |     |         uint256 minimumOut;
 108 |     |         uint256 value;
 109 |     |     }
 110 |     | 
 111 |     |     struct SellQuoteTokensForETHParams {
 112 |     |         address lpAddr;
 113 |     |         uint256 amountIn;
 114 |     |         uint256 minimumOut;
 115 |     |     }
 116 |     | 
 117 |     |     struct SellQuoteTokensForTokensParams {
 118 |     |         address lpAddr;
 119 |     |         uint256 amountIn;
 120 |     |         uint256 minimumOut;
 121 |     |     }
 122 |     | 
 123 |     |     struct SwapETHForTokensParams {
 124 |     |         address[] path;
 125 |     |         uint256 directions;
 126 |     |         uint256 minimumOut;
 127 |     |         uint256 value;
 128 |     |     }
 129 |     | 
 130 |     |     struct SwapTokensForETHParams {
 131 |     |         uint256 amountIn;
 132 |     |         address[] path;
 133 |     |         uint256 directions;
 134 |     |         uint256 minimumOut;
 135 |     |     }
 136 |     | 
 137 |     |     struct SwapTokensForTokensParams {
 138 |     |         uint256 amountIn;
 139 |     |         address[] path;
 140 |     |         uint256 directions;
 141 |     |         uint256 minimumOut;
 142 |     |     }
 143 |     | 
 144 |     |     function addLiquidityPreconditions(
 145 |     |         uint8 lp,
 146 |     |         uint256 baseInAmount,
 147 |     |         uint256 quoteInAmount,
 148 |     |         uint256 minimumShares
 149 |     |     ) internal returns (AddLiquidityParams memory) {
 150 |     |         require(allPools.length > 0, "There are no available pools");
 151 |     | 
 152 |     |         address lpAddr = address(allPools[lp % allPools.length]);
 153 |     | 
 154 |     |         baseInAmount = clampBetween(baseInAmount, 0, IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).balanceOf(address(currentActor)));
 155 |     |         quoteInAmount = clampBetween(quoteInAmount, 0, IERC20(MagicLP(lpAddr)._QUOTE_TOKEN_()).balanceOf(address(currentActor)));
 156 |     | 
 157 |     |         return AddLiquidityParams(lpAddr, baseInAmount, quoteInAmount, minimumShares);
 158 |     |     }
 159 |     | 
 160 |     |     function addLiquidityETHPreconditions(
 161 |     |         uint8 lp,
 162 |     |         uint256 tokenInAmount,
 163 |     |         uint256 value,
 164 |     |         uint256 minimumShares
 165 |     |     ) internal returns (AddLiquidityETHParams memory) {
 166 |     |         require(availablePools[address(weth)].length > 0, "There are no available pools with WETH");
 167 |     | 
 168 |     |         address quoteToken = availablePools[address(weth)][lp % availablePools[address(weth)].length];
 169 |     |         address lpAddr = pools[address(weth)][quoteToken];
 170 |     | 
 171 |     |         value = clampBetween(value, 0, currentActor.balance);
 172 |     | 
 173 |     |         if (MagicLP(lpAddr)._BASE_TOKEN_() == address(weth)) {
 174 |     |             tokenInAmount = clampBetween(tokenInAmount, 0, IERC20(MagicLP(lpAddr)._QUOTE_TOKEN_()).balanceOf(address(currentActor)));
 175 |     |         } else {
 176 |     |             tokenInAmount = clampBetween(tokenInAmount, 0, IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).balanceOf(address(currentActor)));
 177 |     |         }
 178 |     | 
 179 |     |         return AddLiquidityETHParams(lpAddr, tokenInAmount, value, minimumShares);
 180 |     |     }
 181 |     | 
 182 | *   |     function addLiquidityETHUnsafePreconditions(
 183 |     |         uint8 lp,
 184 |     |         uint256 tokenInAmount,
 185 |     |         uint256 value,
 186 |     |         uint256 minimumShares
 187 | *   |     ) internal returns (AddLiquidityETHUnsafeParams memory) {
 188 | *   |         require(availablePools[address(weth)].length > 0, "There are no available pools with WETH");
 189 |     | 
 190 | *   |         address quoteToken = availablePools[address(weth)][lp % availablePools[address(weth)].length];
 191 | *   |         address lpAddr = pools[address(weth)][quoteToken];
 192 |     | 
 193 | *   |         value = clampBetween(value, 0, currentActor.balance);
 194 |     | 
 195 | *   |         if (MagicLP(lpAddr)._BASE_TOKEN_() == address(weth)) {
 196 |     |             tokenInAmount = clampBetween(tokenInAmount, 0, IERC20(MagicLP(lpAddr)._QUOTE_TOKEN_()).balanceOf(address(currentActor)));
 197 |     |         } else {
 198 |     |             tokenInAmount = clampBetween(tokenInAmount, 0, IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).balanceOf(address(currentActor)));
 199 |     |         }
 200 |     | 
 201 |     |         return AddLiquidityETHUnsafeParams(lpAddr, tokenInAmount, value, minimumShares);
 202 |     |     }
 203 |     | 
 204 | *   |     function addLiquidityUnsafePreconditions(
 205 |     |         uint8 lp,
 206 |     |         uint256 baseInAmount,
 207 |     |         uint256 quoteInAmount,
 208 |     |         uint256 minimumShares
 209 | *   |     ) internal returns (AddLiquidityUnsafeParams memory) {
 210 | *   |         require(allPools.length > 0, "There are no available pools");
 211 |     | 
 212 | *   |         address lpAddr = address(allPools[lp % allPools.length]);
 213 |     | 
 214 | *   |         baseInAmount = clampBetween(baseInAmount, 0, IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).balanceOf(address(currentActor)));
 215 | *   |         quoteInAmount = clampBetween(quoteInAmount, 0, IERC20(MagicLP(lpAddr)._QUOTE_TOKEN_()).balanceOf(address(currentActor)));
 216 |     | 
 217 | *   |         return AddLiquidityUnsafeParams(lpAddr, baseInAmount, quoteInAmount, minimumShares);
 218 |     |     }
 219 |     | 
 220 | *   |     function createPoolPreconditions(
 221 |     |         uint8 baseToken,
 222 |     |         uint8 quoteToken,
 223 |     |         uint256 lpFeeRate,
 224 |     |         uint256 i,
 225 |     |         uint256 k,
 226 |     |         uint256 baseInAmount,
 227 |     |         uint256 quoteInAmount
 228 | *   |     ) internal returns (CreatePoolParams memory) {
 229 | *   |         require(allPools.length < MAX_POOLS, "Maximum number of pools reached");
 230 |     | 
 231 | *   |         address baseTokenAddr = address(tokens[baseToken % tokens.length]);
 232 | *   |         address quoteTokenAddr = address(tokens[quoteToken % tokens.length]);
 233 | *   |         if (baseTokenAddr == quoteTokenAddr) {
 234 | *   |             quoteTokenAddr = address(tokens[(quoteToken + 1) % tokens.length]);
 235 |     |         }
 236 |     | 
 237 | *   |         lpFeeRate = clampBetween(lpFeeRate, MIN_LP_FEE_RATE, MAX_LP_FEE_RATE);
 238 | *   |         i = clampBetween(i, 1, MAX_I);
 239 | *   |         k = clampBetween(k, 0, MAX_K);
 240 |     | 
 241 | *   |         return CreatePoolParams(baseTokenAddr, quoteTokenAddr, lpFeeRate, i, k, currentActor, baseInAmount, quoteInAmount);
 242 |     |     }
 243 |     | 
 244 | *   |     function createPoolETHPreconditions(
 245 |     |         uint8 token,
 246 |     |         bool useTokenAsQuote,
 247 |     |         uint256 lpFeeRate,
 248 |     |         uint256 i,
 249 |     |         uint256 k,
 250 |     |         uint256 tokenInAmount,
 251 |     |         uint256 value
 252 | *   |     ) internal returns (CreatePoolETHParams memory) {
 253 | *   |         require(allPools.length < MAX_POOLS, "Maximum number of pools reached");
 254 |     | 
 255 | *   |         address tokenAddr = address(tokens[token % tokens.length]);
 256 | *   |         if (tokenAddr == address(weth)) {
 257 | *   |             tokenAddr = address(tokens[(token + 1) % tokens.length]);
 258 |     |         }
 259 | *   |         lpFeeRate = clampBetween(lpFeeRate, MIN_LP_FEE_RATE, MAX_LP_FEE_RATE);
 260 | *   |         i = clampBetween(i, 1, MAX_I);
 261 | *   |         k = clampBetween(k, 0, MAX_K);
 262 | *   |         tokenInAmount = clampBetween(tokenInAmount, 0, IERC20(tokenAddr).balanceOf(address(currentActor)));
 263 | *   |         value = clampBetween(value, 0, currentActor.balance);
 264 | *   |         return CreatePoolETHParams(tokenAddr, useTokenAsQuote, lpFeeRate, i, k, currentActor, tokenInAmount, value);
 265 |     |     }
 266 |     | 
 267 | *   |     function removeLiquidityPreconditions(
 268 |     |         uint8 lp,
 269 |     |         uint256 sharesIn,
 270 |     |         uint256 minimumBaseAmount,
 271 |     |         uint256 minimumQuoteAmount
 272 | *   |     ) internal returns (RemoveLiquidityParams memory) {
 273 | *r  |         require(allPools.length > 0, "There are no available pools");
 274 |     | 
 275 | *   |         address lpAddr = address(allPools[lp % allPools.length]);
 276 |     | 
 277 | *   |         sharesIn = clampBetween(sharesIn, 0, MagicLP(lpAddr).balanceOf(address(currentActor)));
 278 |     | 
 279 | *   |         return RemoveLiquidityParams(lpAddr, sharesIn, minimumBaseAmount, minimumQuoteAmount);
 280 |     |     }
 281 |     | 
 282 | *   |     function removeLiquidityETHPreconditions(
 283 |     |         uint8 lp,
 284 |     |         uint256 sharesIn,
 285 |     |         uint256 minimumETHAmount,
 286 |     |         uint256 minimumTokenAmount
 287 | *   |     ) internal returns (RemoveLiquidityETHParams memory) {
 288 | *   |         require(availablePools[address(weth)].length > 0, "There are no available pools with WETH");
 289 |     | 
 290 | *   |         address quoteToken = availablePools[address(weth)][lp % availablePools[address(weth)].length];
 291 | *   |         address lpAddr = pools[address(weth)][quoteToken];
 292 |     | 
 293 | *   |         sharesIn = clampBetween(sharesIn, 0, MagicLP(lpAddr).balanceOf(address(currentActor)));
 294 |     | 
 295 |     |         return RemoveLiquidityETHParams(lpAddr, sharesIn, minimumETHAmount, minimumTokenAmount);
 296 |     |     }
 297 |     | 
 298 | *   |     function previewAddLiquidityPreconditions(
 299 |     |         uint8 lp,
 300 |     |         uint256 baseInAmount,
 301 |     |         uint256 quoteInAmount
 302 | *   |     ) internal returns (PreviewAddLiquidityParams memory) {
 303 | *   |         require(allPools.length > 0, "There are no available pools");
 304 |     | 
 305 | *   |         address lpAddr = address(allPools[lp % allPools.length]);
 306 |     | 
 307 | *   |         baseInAmount = clampBetween(baseInAmount, 0, REASONABLE_PREVIEW_AMOUNT);
 308 | *   |         quoteInAmount = clampBetween(quoteInAmount, 0, REASONABLE_PREVIEW_AMOUNT);
 309 |     | 
 310 | *   |         return PreviewAddLiquidityParams(lpAddr, baseInAmount, quoteInAmount);
 311 |     |     }
 312 |     | 
 313 | *   |     function previewRemoveLiquidityPreconditions(uint8 lp, uint256 sharesIn) internal returns (PreviewRemoveLiquidityParams memory) {
 314 | *   |         require(allPools.length > 0, "There are no available pools");
 315 |     | 
 316 | *   |         address lpAddr = address(allPools[lp % allPools.length]);
 317 |     | 
 318 | *   |         sharesIn = clampBetween(sharesIn, 0, REASONABLE_PREVIEW_AMOUNT);
 319 |     | 
 320 | *   |         return PreviewRemoveLiquidityParams(lpAddr, sharesIn);
 321 |     |     }
 322 |     | 
 323 | *   |     function sellBaseETHForTokensPreconditions(
 324 |     |         uint8 lp,
 325 |     |         uint256 minimumOut,
 326 |     |         uint256 value
 327 | *   |     ) internal returns (SellBaseETHForTokensParams memory) {
 328 | *   |         require(availablePools[address(weth)].length > 0, "There are no available pools with WETH");
 329 |     | 
 330 | *   |         address quoteToken = availablePools[address(weth)][lp % availablePools[address(weth)].length];
 331 | *   |         address lpAddr = pools[address(weth)][quoteToken];
 332 |     | 
 333 | *   |         require(MagicLP(lpAddr)._BASE_TOKEN_() == address(weth), "The base token of the pool is not WETH");
 334 |     | 
 335 |     |         value = clampBetween(value, 0, currentActor.balance);
 336 |     | 
 337 |     |         return SellBaseETHForTokensParams(lpAddr, minimumOut, value);
 338 |     |     }
 339 |     | 
 340 | *   |     function sellBaseTokensForETHPreconditions(
 341 |     |         uint8 lp,
 342 |     |         uint256 amountIn,
 343 |     |         uint256 minimumOut
 344 | *   |     ) internal returns (SellBaseTokensForETHParams memory) {
 345 | *   |         require(availablePools[address(weth)].length > 0, "There are no available pools with WETH");
 346 |     | 
 347 | *   |         address quoteToken = availablePools[address(weth)][lp % availablePools[address(weth)].length];
 348 | *   |         address lpAddr = pools[address(weth)][quoteToken];
 349 |     | 
 350 | *   |         require(MagicLP(lpAddr)._QUOTE_TOKEN_() == address(weth), "The quote token of the pool is not WETH");
 351 |     | 
 352 |     |         amountIn = clampBetween(amountIn, 0, IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).balanceOf(address(currentActor)));
 353 |     | 
 354 |     |         vm.prank(currentActor);
 355 |     |         IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).approve(address(router), amountIn);
 356 |     | 
 357 |     |         return SellBaseTokensForETHParams(lpAddr, amountIn, minimumOut);
 358 |     |     }
 359 |     | 
 360 | *   |     function sellBaseTokensForTokensPreconditions(
 361 |     |         uint8 lp,
 362 |     |         uint256 amountIn,
 363 |     |         uint256 minimumOut
 364 | *   |     ) internal returns (SellBaseTokensForTokensParams memory) {
 365 | *   |         require(allPools.length > 0, "There are no available pools");
 366 |     | 
 367 | *   |         address lpAddr = address(allPools[lp % allPools.length]);
 368 |     | 
 369 | *   |         amountIn = clampBetween(amountIn, 0, IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).balanceOf(address(currentActor)));
 370 |     | 
 371 | *   |         vm.prank(currentActor);
 372 | *   |         IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).approve(address(router), amountIn);
 373 |     | 
 374 |     |         return SellBaseTokensForTokensParams(lpAddr, amountIn, minimumOut);
 375 |     |     }
 376 |     | 
 377 | *   |     function sellQuoteETHForTokensPreconditions(
 378 |     |         uint8 lp,
 379 |     |         uint256 minimumOut,
 380 |     |         uint256 value
 381 | *   |     ) internal returns (SellQuoteETHForTokensParams memory) {
 382 | *   |         require(availablePools[address(weth)].length > 0, "There are no available pools with WETH");
 383 |     | 
 384 | *   |         address quoteToken = availablePools[address(weth)][lp % availablePools[address(weth)].length];
 385 | *   |         address lpAddr = pools[address(weth)][quoteToken];
 386 |     | 
 387 | *   |         require(MagicLP(lpAddr)._QUOTE_TOKEN_() == address(weth), "The base token of the pool is not WETH");
 388 |     | 
 389 |     |         value = clampBetween(value, 0, currentActor.balance);
 390 |     | 
 391 |     |         return SellQuoteETHForTokensParams(lpAddr, minimumOut, value);
 392 |     |     }
 393 |     | 
 394 | *   |     function sellQuoteTokensForETHPreconditions(
 395 |     |         uint8 lp,
 396 |     |         uint256 amountIn,
 397 |     |         uint256 minimumOut
 398 | *   |     ) internal returns (SellQuoteTokensForETHParams memory) {
 399 | *   |         require(availablePools[address(weth)].length > 0, "There are no available pools with WETH");
 400 |     | 
 401 | *   |         address quoteToken = availablePools[address(weth)][lp % availablePools[address(weth)].length];
 402 | *   |         address lpAddr = pools[address(weth)][quoteToken];
 403 |     | 
 404 | *   |         require(MagicLP(lpAddr)._BASE_TOKEN_() == address(weth), "The quote token of the pool is not WETH");
 405 |     | 
 406 |     |         amountIn = clampBetween(amountIn, 0, IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).balanceOf(address(currentActor)));
 407 |     | 
 408 |     |         vm.prank(currentActor);
 409 |     |         IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).approve(address(router), amountIn);
 410 |     | 
 411 |     |         return SellQuoteTokensForETHParams(lpAddr, amountIn, minimumOut);
 412 |     |     }
 413 |     | 
 414 | *   |     function sellQuoteTokensForTokensPreconditions(
 415 |     |         uint8 lp,
 416 |     |         uint256 amountIn,
 417 |     |         uint256 minimumOut
 418 | *   |     ) internal returns (SellQuoteTokensForTokensParams memory) {
 419 | *   |         require(allPools.length > 0, "There are no available pools");
 420 |     | 
 421 | *   |         address lpAddr = address(allPools[lp % allPools.length]);
 422 |     | 
 423 | *   |         amountIn = clampBetween(amountIn, 0, IERC20(MagicLP(lpAddr)._BASE_TOKEN_()).balanceOf(address(currentActor)));
 424 |     | 
 425 | *   |         vm.prank(currentActor);
 426 | *   |         IERC20(MagicLP(lpAddr)._QUOTE_TOKEN_()).approve(address(router), amountIn);
 427 |     | 
 428 | *   |         return SellQuoteTokensForTokensParams(lpAddr, amountIn, minimumOut);
 429 |     |     }
 430 |     | 
 431 | *   |     function swapETHForTokensPreconditions(
 432 |     |         uint8 entropy,
 433 |     |         uint8 pathLength,
 434 |     |         uint256 directions,
 435 |     |         uint256 minimumOut,
 436 |     |         uint256 value
 437 | *   |     ) internal returns (SwapETHForTokensParams memory) {
 438 | *   |         require(allPools.length > 0, "There are no available pools");
 439 |     | 
 440 | *   |         address currentToken = address(weth);
 441 | *   |         pathLength = uint8(clampBetween(pathLength, 1, MAX_PATH_LENGTH));
 442 | *   |         address[] memory tempPath = new address[](pathLength);
 443 | *   |         uint8 constructedPathLength = 0;
 444 |     | 
 445 | *   |         for (uint8 i = 0; i < pathLength; i++) {
 446 | *   |             address nextPool = fetchPoolForToken(entropy, currentToken);
 447 | *   |             if (nextPool == address(0)) {
 448 | *   |                 break;
 449 |     |             }
 450 |     |             tempPath[i] = nextPool;
 451 |     |             if (currentToken == MagicLP(nextPool)._QUOTE_TOKEN_()) {
 452 |     |                 currentToken = MagicLP(nextPool)._BASE_TOKEN_();
 453 |     |             } else {
 454 |     |                 currentToken = MagicLP(nextPool)._QUOTE_TOKEN_();
 455 |     |             }
 456 |     |             constructedPathLength++;
 457 |     |         }
 458 | *   |         require(constructedPathLength > 0, "No valid path constructed");
 459 |     | 
 460 |     |         address[] memory path = new address[](constructedPathLength);
 461 |     |         for (uint8 i = 0; i < constructedPathLength; i++) {
 462 |     |             path[i] = tempPath[i];
 463 |     |         }
 464 |     | 
 465 |     |         value = clampBetween(value, 0, currentActor.balance);
 466 |     | 
 467 |     |         return SwapETHForTokensParams(path, directions, minimumOut, value);
 468 |     |     }
 469 |     | 
 470 |     |     event Path(address[] path);
 471 |     | 
 472 | *   |     function swapTokensForETHPreconditions(
 473 |     |         uint256 amountIn,
 474 |     |         uint8 entropy,
 475 |     |         uint8 pathLength,
 476 |     |         uint256 directions,
 477 |     |         uint256 minimumOut
 478 | *   |     ) internal returns (SwapTokensForETHParams memory) {
 479 | *   |         require(allPools.length > 0, "There are no available pools");
 480 |     | 
 481 | *   |         address currentToken = address(weth);
 482 | *   |         pathLength = uint8(clampBetween(pathLength, 1, MAX_PATH_LENGTH));
 483 | *   |         address[] memory tempPath = new address[](pathLength);
 484 | *   |         uint8 constructedPathLength = 0;
 485 |     | 
 486 | *   |         for (uint8 i = pathLength - 1; i >= 0; i--) {
 487 | *   |             address nextPool = fetchPoolForToken(entropy, currentToken);
 488 | *   |             if (nextPool == address(0)) {
 489 | *   |                 break;
 490 |     |             }
 491 |     |             tempPath[i] = nextPool;
 492 |     |             if (currentToken == MagicLP(nextPool)._QUOTE_TOKEN_()) {
 493 |     |                 currentToken = MagicLP(nextPool)._BASE_TOKEN_();
 494 |     |             } else {
 495 |     |                 currentToken = MagicLP(nextPool)._QUOTE_TOKEN_();
 496 |     |             }
 497 |     |             constructedPathLength++;
 498 |     |         }
 499 | *   |         require(constructedPathLength > 0, "No valid path constructed");
 500 |     | 
 501 |     |         address[] memory path = new address[](constructedPathLength);
 502 |     |         for (uint8 i = 0; i < constructedPathLength; i++) {
 503 |     |             path[i] = tempPath[i + (pathLength - constructedPathLength)];
 504 |     |         }
 505 |     | 
 506 |     |         if (directions & 1 == 0) {
 507 |     |             amountIn = clampBetween(amountIn, 0, IERC20(IMagicLP(path[0])._BASE_TOKEN_()).balanceOf(address(currentActor)));
 508 |     |             IERC20(IMagicLP(path[0])._BASE_TOKEN_()).approve(path[0], amountIn);
 509 |     |         } else {
 510 |     |             amountIn = clampBetween(amountIn, 0, IERC20(IMagicLP(path[0])._QUOTE_TOKEN_()).balanceOf(address(currentActor)));
 511 |     |             IERC20(IMagicLP(path[0])._QUOTE_TOKEN_()).approve(path[0], amountIn);
 512 |     |         }
 513 |     | 
 514 |     |         return SwapTokensForETHParams(amountIn, path, directions, minimumOut);
 515 |     |     }
 516 |     | 
 517 | *   |     function swapTokensForTokensPreconditions(
 518 |     |         uint8 startingToken,
 519 |     |         uint256 amountIn,
 520 |     |         uint8 entropy,
 521 |     |         uint8 pathLength,
 522 |     |         uint256 directions,
 523 |     |         uint256 minimumOut
 524 | *   |     ) internal returns (SwapTokensForTokensParams memory) {
 525 | *   |         require(allPools.length > 0, "There are no available pools");
 526 |     | 
 527 | *   |         address currentToken = address(tokens[startingToken % tokens.length]);
 528 | *   |         pathLength = uint8(clampBetween(pathLength, 1, MAX_PATH_LENGTH));
 529 | *   |         address[] memory tempPath = new address[](pathLength);
 530 | *   |         uint8 constructedPathLength = 0;
 531 |     | 
 532 | *   |         for (uint8 i = 0; i < pathLength; i++) {
 533 | *   |             address nextPool = fetchPoolForToken(entropy, currentToken);
 534 | *   |             if (nextPool == address(0)) {
 535 | *   |                 break;
 536 |     |             }
 537 |     |             tempPath[i] = nextPool;
 538 |     |             if (currentToken == MagicLP(nextPool)._QUOTE_TOKEN_()) {
 539 |     |                 currentToken = MagicLP(nextPool)._BASE_TOKEN_();
 540 |     |             } else {
 541 |     |                 currentToken = MagicLP(nextPool)._QUOTE_TOKEN_();
 542 |     |             }
 543 |     |             constructedPathLength++;
 544 |     |         }
 545 | *   |         require(constructedPathLength > 0, "No valid path constructed");
 546 |     | 
 547 |     |         address[] memory path = new address[](constructedPathLength);
 548 |     |         for (uint8 i = 0; i < constructedPathLength; i++) {
 549 |     |             path[i] = tempPath[i];
 550 |     |         }
 551 |     | 
 552 |     |         if (directions & 1 == 0) {
 553 |     |             amountIn = clampBetween(amountIn, 0, IERC20(IMagicLP(path[0])._BASE_TOKEN_()).balanceOf(address(currentActor)));
 554 |     |             IERC20(IMagicLP(path[0])._BASE_TOKEN_()).approve(path[0], amountIn);
 555 |     |         } else {
 556 |     |             amountIn = clampBetween(amountIn, 0, IERC20(IMagicLP(path[0])._QUOTE_TOKEN_()).balanceOf(address(currentActor)));
 557 |     |             IERC20(IMagicLP(path[0])._QUOTE_TOKEN_()).approve(path[0], amountIn);
 558 |     |         }
 559 |     | 
 560 |     |         return SwapTokensForTokensParams(amountIn, path, directions, minimumOut);
 561 |     |     }
 562 |     | 
 563 | *   |     function fetchPoolForToken(uint8 entropy, address token) internal returns (address) {
 564 | *   |         uint8 index = uint8(uint256(keccak256(abi.encode(entropy))));
 565 | *   |         index = uint8(clampBetween(index, 0, availablePools[token].length - 1));
 566 | *   |         address quoteToken = availablePools[token][index];
 567 | *   |         return pools[token][quoteToken];
 568 |     |     }
 569 |     | }
 570 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/mocks/MockERC20.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import {ERC20} from "openzeppelin-contracts/token/ERC20/ERC20.sol";
  5 |     | 
  6 | *   | contract MockERC20 is ERC20 {
  7 |     |     uint8 private _decimals;
  8 |     | 
  9 |     |     constructor(string memory name, string memory symbol, uint8 dec) ERC20(name, symbol) {
 10 |     |         _decimals = dec;
 11 |     |     }
 12 |     | 
 13 | *   |     function decimals() public view virtual override(ERC20) returns (uint8) {
 14 | *   |         return _decimals;
 15 |     |     }
 16 |     | 
 17 | *   |     function mint(address account, uint256 amount) external {
 18 |     |         _mint(account, amount);
 19 |     |     }
 20 |     | 
 21 |     |     function burn(address account, uint256 amount) external {
 22 |     |         _burn(account, amount);
 23 |     |     }
 24 |     | }
 25 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/mocks/MockWETH.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import {MockERC20} from "./MockERC20.sol";
  5 |     | 
  6 | *   | contract MockWETH is MockERC20 {
  7 |     |     event Deposit(address indexed dst, uint wad);
  8 |     |     event Withdrawal(address indexed src, uint wad);
  9 |     | 
 10 |     |     constructor(string memory name, string memory symbol) MockERC20(name, symbol, 18) {}
 11 |     | 
 12 |     |     receive() external payable {
 13 | *   |         deposit();
 14 |     |     }
 15 |     | 
 16 | *   |     function deposit() public payable {
 17 | *   |         _mint(msg.sender, msg.value);
 18 |     | 
 19 | *   |         emit Deposit(msg.sender, msg.value);
 20 |     |     }
 21 |     | 
 22 |     |     function withdraw(uint256 wad) public {
 23 |     |         _burn(msg.sender, wad);
 24 |     | 
 25 |     |         payable(msg.sender).transfer(wad);
 26 |     | 
 27 |     |         emit Withdrawal(msg.sender, wad);
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/properties/Properties.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./Properties_LIQ.sol";
  5 |     | import "./Properties_RES.sol";
  6 |     | import "./Properties_POOL.sol";
  7 |     | import "./Properties_SWAP.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title Properties
 11 |     |  * @author 0xScourgedev
 12 |     |  * @notice Composite contract for all of the properties, and contains general invariants
 13 |     |  */
 14 |     | abstract contract Properties is Properties_LIQ, Properties_RES, Properties_POOL, Properties_SWAP {
 15 | *   |     function invariant_GENERAL_01(bytes memory returnData) internal {
 16 | *   |         gte(returnData.length, 4, GENERAL_01);
 17 |     |     }
 18 |     | }
 19 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/properties/PropertiesBase.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "fuzzlib/FuzzBase.sol";
  5 |     | import "fuzzlib/AssertWrapper.sol";
  6 |     | import "./PropertiesDescriptions.sol";
  7 |     | import "../helper/BeforeAfter.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title PropertiesBase
 11 |     |  * @author 0xScourgedev
 12 |     |  * @notice Composite contract for all of the dependencies of the properties
 13 |     |  */
 14 |     | abstract contract PropertiesBase is FuzzBase, BeforeAfter, PropertiesDescriptions {
 15 |     | 
 16 |     | }
 17 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/properties/PropertiesDescriptions.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title PropertiesDescriptions
  6 |     |  * @author 0xScourgedev
  7 |     |  * @notice Descriptions strings for the invariants
  8 |     |  */
  9 |     | abstract contract PropertiesDescriptions {
 10 |     |     string constant GENERAL_01 = "GENERAL-01: Does not silent revert";
 11 |     | 
 12 |     |     string constant LIQ_01 =
 13 |     |         "LIQ-01: If the base and quote token balance is 0, the amount of base tokens and quote tokens in the pool is always strictly increasing after adding liquidity";
 14 |     |     string constant LIQ_02 =
 15 |     |         "LIQ-02: If the base and quote token balance is 0, the amount of base and quote tokens of the user is always strictly decreasing after adding liquidity";
 16 |     |     string constant LIQ_03 = "LIQ-03: The total supply of lp tokens is always strictly increasing after adding liquidity";
 17 |     |     string constant LIQ_04 = "LIQ-04: The lp token balance of the user is always strictly increasing after adding liquidity";
 18 |     | 
 19 |     |     string constant LIQ_05 = "LIQ-05: The amount of base tokens and quote tokens in the pool is always decreasing after removing liquidity";
 20 |     |     string constant LIQ_06 = "LIQ-06: The amount of base and quote tokens of the user is always increasing after removing liquidity";
 21 |     |     string constant LIQ_07 = "LIQ-07: The total supply of lp tokens is always strictly decreasing after removing liquidity";
 22 |     |     string constant LIQ_08 = "LIQ-08: The lp token balance of the user is always strictly decreasing after removing liquidity";
 23 |     |     string constant LIQ_09 = "LIQ-09: Base and quote tokens are never transfered to the user for free when removing liquidity";
 24 |     | 
 25 |     |     string constant LIQ_10 = "LIQ-10: previewAddLiquidity() never reverts for reasonable values";
 26 |     |     string constant LIQ_11 =
 27 |     |         "LIQ-11: previewRemoveLiquidity() never reverts for reasonable values if the total supply of lp tokens is greater than 0";
 28 |     |     string constant LIQ_12 = "LIQ-12: Adding liquidity must provide less or equal shares to the user predicted by previewAddLiquidity()";
 29 |     |     string constant LIQ_13 = "LIQ-13: Adding liquidity unsafe must provide exact shares to the user predicted by previewAddLiquidity()";
 30 |     |     string constant LIQ_14 =
 31 |     |         "LIQ-14: Removing liquidity must provide the same amount of base and quote tokens to the user predicted by previewRemoveLiquidity()";
 32 |     | 
 33 |     |     string constant RES_01 = "RES-01: If the quote reserve and base reserve of a pool is 0, then the lp total supply must be 0";
 34 |     |     string constant RES_02 = "RES-02: The base reserve of a pool is always less than or equal to the pool base balance";
 35 |     |     string constant RES_03 = "RES-03: The quote reserve of a pool is always less than or equal to the pool quote balance";
 36 |     | 
 37 |     |     string constant POOL_01 =
 38 |     |         "POOL-01: The sum of the LP token balances held by each user is always equal to the total supply of LP tokens";
 39 |     |     string constant POOL_02 = "POOL-02: sync() must never revert";
 40 |     |     string constant POOL_03 = "POOL-03: correctRState() must never revert";
 41 |     |     string constant POOL_04 = "POOL-04: The total supply of LP tokens is either 0 or always greater or equal to 1001";
 42 |     | 
 43 |     |     string constant SWAP_01 = "SWAP-01: Swap must decrease the input token balance of the user if the input and output token are different";
 44 |     |     string constant SWAP_02 =
 45 |     |         "SWAP-02: Swap must increase the output token balance of the user if the input and output token are different";
 46 |     |     string constant SWAP_03 =
 47 |     |         "SWAP-03: The swap must credit the user with an amount of the output token that is equal to or greater than the specified minimumOut";
 48 |     | }
 49 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/properties/Properties_LIQ.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./PropertiesBase.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * @title Properties_LIQ
   8 |     |  * @author 0xScourgedev
   9 |     |  * @notice Contains all LIQ invariants
  10 |     |  */
  11 |     | abstract contract Properties_LIQ is PropertiesBase {
  12 | *   |     function invariant_LIQ_01(address pool) internal {
  13 | *   |         if (states[0].poolStates[pool].baseBalance > 0 || states[0].poolStates[pool].quoteBalance > 0) {
  14 |     |             return;
  15 |     |         }
  16 | *   |         gt(states[1].poolStates[pool].baseBalance, states[0].poolStates[pool].baseBalance, LIQ_01);
  17 | *   |         gt(states[1].poolStates[pool].quoteBalance, states[0].poolStates[pool].quoteBalance, LIQ_01);
  18 |     |     }
  19 |     | 
  20 | *   |     function invariant_LIQ_02(address pool, bool supplyETH) internal {
  21 | *   |         if (states[0].poolStates[pool].baseBalance > 0 || states[0].poolStates[pool].quoteBalance > 0) {
  22 |     |             return;
  23 |     |         }
  24 |     | 
  25 | *   |         if (supplyETH) {
  26 |     |             address tokenToCheck;
  27 |     |             if (MagicLP(pool)._BASE_TOKEN_() == address(weth)) {
  28 |     |                 tokenToCheck = MagicLP(pool)._QUOTE_TOKEN_();
  29 |     |             } else {
  30 |     |                 tokenToCheck = MagicLP(pool)._BASE_TOKEN_();
  31 |     |             }
  32 |     | 
  33 |     |             lt(
  34 |     |                 states[1].actorStates[currentActor].tokenBalances[tokenToCheck],
  35 |     |                 states[0].actorStates[currentActor].tokenBalances[tokenToCheck],
  36 |     |                 LIQ_02
  37 |     |             );
  38 |     |             lt(states[1].actorStates[currentActor].ethBalance, states[0].actorStates[currentActor].ethBalance, LIQ_02);
  39 |     |         } else {
  40 | *   |             lt(
  41 | *   |                 states[1].actorStates[currentActor].tokenBalances[MagicLP(pool)._BASE_TOKEN_()],
  42 | *   |                 states[0].actorStates[currentActor].tokenBalances[MagicLP(pool)._BASE_TOKEN_()],
  43 | *   |                 LIQ_02
  44 |     |             );
  45 | *   |             lt(
  46 | *   |                 states[1].actorStates[currentActor].tokenBalances[MagicLP(pool)._QUOTE_TOKEN_()],
  47 | *   |                 states[0].actorStates[currentActor].tokenBalances[MagicLP(pool)._QUOTE_TOKEN_()],
  48 |     |                 LIQ_02
  49 |     |             );
  50 |     |         }
  51 |     |     }
  52 |     | 
  53 | *   |     function invariant_LIQ_03(address pool) internal {
  54 | *   |         gt(states[1].poolStates[pool].lpTotalSupply, states[0].poolStates[pool].lpTotalSupply, LIQ_03);
  55 |     |     }
  56 |     | 
  57 | *   |     function invariant_LIQ_04(address pool) internal {
  58 | *   |         gt(states[1].actorStates[currentActor].tokenBalances[pool], states[0].actorStates[currentActor].tokenBalances[pool], LIQ_04);
  59 |     |     }
  60 |     | 
  61 | *   |     function invariant_LIQ_05(address pool) internal {
  62 |     |         lte(states[1].poolStates[pool].baseBalance, states[0].poolStates[pool].baseBalance, LIQ_05);
  63 | *   |         lte(states[1].poolStates[pool].quoteBalance, states[0].poolStates[pool].quoteBalance, LIQ_05);
  64 |     |     }
  65 |     | 
  66 |     |     function invariant_LIQ_06(address pool, bool supplyETH) internal {
  67 |     |         if (supplyETH) {
  68 |     |             address tokenToCheck;
  69 |     |             if (MagicLP(pool)._BASE_TOKEN_() == address(weth)) {
  70 |     |                 tokenToCheck = MagicLP(pool)._QUOTE_TOKEN_();
  71 |     |             } else {
  72 |     |                 tokenToCheck = MagicLP(pool)._BASE_TOKEN_();
  73 |     |             }
  74 |     | 
  75 |     |             gte(
  76 |     |                 states[1].actorStates[currentActor].tokenBalances[tokenToCheck],
  77 |     |                 states[0].actorStates[currentActor].tokenBalances[tokenToCheck],
  78 |     |                 LIQ_06
  79 |     |             );
  80 |     |             gte(states[1].actorStates[currentActor].ethBalance, states[0].actorStates[currentActor].ethBalance, LIQ_06);
  81 |     |         } else {
  82 |     |             gte(
  83 |     |                 states[1].actorStates[currentActor].tokenBalances[MagicLP(pool)._BASE_TOKEN_()],
  84 |     |                 states[0].actorStates[currentActor].tokenBalances[MagicLP(pool)._BASE_TOKEN_()],
  85 |     |                 LIQ_06
  86 |     |             );
  87 |     |             gte(
  88 |     |                 states[1].actorStates[currentActor].tokenBalances[MagicLP(pool)._QUOTE_TOKEN_()],
  89 |     |                 states[0].actorStates[currentActor].tokenBalances[MagicLP(pool)._QUOTE_TOKEN_()],
  90 |     |                 LIQ_06
  91 |     |             );
  92 |     |         }
  93 |     |     }
  94 |     | 
  95 |     |     function invariant_LIQ_07(address pool, uint256 sharesIn) internal {
  96 |     |         if (sharesIn > 0) {
  97 |     |             lt(states[1].poolStates[pool].lpTotalSupply, states[0].poolStates[pool].lpTotalSupply, LIQ_07);
  98 |     |         }
  99 |     |     }
 100 |     | 
 101 |     |     function invariant_LIQ_08(address pool, uint256 sharesIn) internal {
 102 |     |         if (sharesIn > 0) {
 103 |     |             lt(states[1].actorStates[currentActor].tokenBalances[pool], states[0].actorStates[currentActor].tokenBalances[pool], LIQ_08);
 104 |     |         }
 105 |     |     }
 106 |     | 
 107 |     |     function invariant_LIQ_09(address pool, uint256 sharesIn) internal {
 108 |     |         if (sharesIn == 0) {
 109 |     |             eq(
 110 |     |                 states[1].actorStates[currentActor].tokenBalances[MagicLP(pool)._BASE_TOKEN_()],
 111 |     |                 states[0].actorStates[currentActor].tokenBalances[MagicLP(pool)._BASE_TOKEN_()],
 112 |     |                 LIQ_09
 113 |     |             );
 114 |     |             eq(
 115 |     |                 states[1].actorStates[currentActor].tokenBalances[MagicLP(pool)._QUOTE_TOKEN_()],
 116 |     |                 states[0].actorStates[currentActor].tokenBalances[MagicLP(pool)._QUOTE_TOKEN_()],
 117 |     |                 LIQ_09
 118 |     |             );
 119 |     |             eq(states[1].actorStates[currentActor].ethBalance, states[0].actorStates[currentActor].ethBalance, LIQ_09);
 120 |     |         }
 121 |     |     }
 122 |     | 
 123 |     |     function invariant_LIQ_10() internal {
 124 |     |         t(false, LIQ_10);
 125 |     |     }
 126 |     | 
 127 | *   |     function invariant_LIQ_11(address pool) internal {
 128 | *   |         if (MagicLP(pool).totalSupply() > 0) {
 129 |     |             t(false, LIQ_11);
 130 |     |         }
 131 |     |     }
 132 |     | 
 133 | *   |     function invariant_LIQ_12(uint256 preview, uint256 actual) internal {
 134 | *   |         gte(preview, actual, LIQ_12);
 135 |     |     }
 136 |     | 
 137 | *   |     function invariant_LIQ_13(uint256 preview, uint256 actual) internal {
 138 | *   |         eq(preview, actual, LIQ_13);
 139 |     |     }
 140 |     | 
 141 |     |     function invariant_LIQ_14(uint256 previewBase, uint256 previewQuote, uint256 actualBase, uint256 actualQuote) internal {
 142 |     |         eq(previewBase, actualBase, LIQ_14);
 143 |     |         eq(previewQuote, actualQuote, LIQ_14);
 144 |     |     }
 145 |     | }
 146 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/properties/Properties_POOL.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PropertiesBase.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title Properties_POOL
  8 |     |  * @author 0xScourgedev
  9 |     |  * @notice Contains all POOL invariants
 10 |     |  */
 11 |     | abstract contract Properties_POOL is PropertiesBase {
 12 | *   |     function invariant_POOL_01(address pool) internal {
 13 | *   |         uint256 sum = 0;
 14 | *   |         for (uint8 i = 0; i < USERS.length; i++) {
 15 | *   |             sum += states[1].actorStates[USERS[i]].tokenBalances[pool];
 16 |     |         }
 17 | *   |         sum += states[1].poolStates[pool].addressZeroBal;
 18 | *   |         sum += states[1].poolStates[pool].poolLpTokenBal;
 19 | *   |         eq(sum, states[1].poolStates[pool].lpTotalSupply, POOL_01);
 20 |     |     }
 21 |     | 
 22 | *   |     function invariant_POOL_02() internal {
 23 | *   |         t(false, POOL_02);
 24 |     |     }
 25 |     | 
 26 |     |     function invariant_POOL_03() internal {
 27 |     |         t(false, POOL_03);
 28 |     |     }
 29 |     | 
 30 | *   |     function invariant_POOL_04(address pool) internal {
 31 | *   |         bool isZero = states[1].poolStates[pool].lpTotalSupply == 0;
 32 | *   |         bool gte1001 = states[1].poolStates[pool].lpTotalSupply >= 1001;
 33 | *   |         t(isZero || gte1001, POOL_04);
 34 |     |     }
 35 |     | }
 36 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/properties/Properties_RES.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PropertiesBase.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title Properties_RES
  8 |     |  * @author 0xScourgedev
  9 |     |  * @notice Contains all RES invariants
 10 |     |  */
 11 |     | abstract contract Properties_RES is PropertiesBase {
 12 | *   |     function invariant_RES_01(address pool) internal {
 13 | *   |         if (states[1].poolStates[pool].baseReserve == 0 && states[1].poolStates[pool].quoteReserve == 0) {
 14 | *   |             eq(states[1].poolStates[pool].lpTotalSupply, 0, RES_01);
 15 |     |         }
 16 |     |     }
 17 |     | 
 18 | *   |     function invariant_RES_02(address pool) internal {
 19 | *   |         lte(states[1].poolStates[pool].baseReserve, states[1].poolStates[pool].baseBalance, RES_02);
 20 |     |     }
 21 |     | 
 22 | *   |     function invariant_RES_03(address pool) internal {
 23 | *   |         lte(states[1].poolStates[pool].quoteReserve, states[1].poolStates[pool].quoteBalance, RES_03);
 24 |     |     }
 25 |     | }
 26 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/properties/Properties_SWAP.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PropertiesBase.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title Properties_SWAP
  8 |     |  * @author 0xScourgedev
  9 |     |  * @notice Contains all SWAP invariants
 10 |     |  */
 11 |     | abstract contract Properties_SWAP is PropertiesBase {
 12 |     |     function invariant_SWAP_01(address inputToken, address outputToken, bool isEth) internal {
 13 |     |         if (isEth) {
 14 |     |             lte(states[1].actorStates[currentActor].ethBalance, states[0].actorStates[currentActor].ethBalance, SWAP_01);
 15 |     |         } else {
 16 |     |             if (inputToken == outputToken) {
 17 |     |                 return;
 18 |     |             }
 19 |     |             lte(
 20 |     |                 states[1].actorStates[currentActor].tokenBalances[inputToken],
 21 |     |                 states[0].actorStates[currentActor].tokenBalances[inputToken],
 22 |     |                 SWAP_01
 23 |     |             );
 24 |     |         }
 25 |     |     }
 26 |     | 
 27 |     |     function invariant_SWAP_02(address inputToken, address outputToken, bool isEth) internal {
 28 |     |         if (isEth) {
 29 |     |             gte(states[1].actorStates[currentActor].ethBalance, states[0].actorStates[currentActor].ethBalance, SWAP_02);
 30 |     |         } else {
 31 |     |             if (inputToken == outputToken) {
 32 |     |                 return;
 33 |     |             }
 34 |     |             gte(
 35 |     |                 states[1].actorStates[currentActor].tokenBalances[outputToken],
 36 |     |                 states[0].actorStates[currentActor].tokenBalances[outputToken],
 37 |     |                 SWAP_02
 38 |     |             );
 39 |     |         }
 40 |     |     }
 41 |     | 
 42 |     |     function invariant_SWAP_03(uint256 actualOut, uint256 minimumOut) internal {
 43 |     |         gte(actualOut, minimumOut, SWAP_03);
 44 |     |     }
 45 |     | }
 46 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/util/FunctionCalls.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "fuzzlib/FuzzBase.sol";
   5 |     | 
   6 |     | import "../helper/FuzzStorageVariables.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @title FunctionCalls
  10 |     |  * @author 0xScourgedev
  11 |     |  * @notice Contains the function calls for all of the handlers
  12 |     |  */
  13 |     | abstract contract FunctionCalls is FuzzBase, FuzzStorageVariables {
  14 |     |     event CreateCall(address baseToken_, address quoteToken_, uint256 lpFeeRate_, uint256 i_, uint256 k_);
  15 |     |     event BuySharesCall(address to);
  16 |     |     event CorrectRStateCall();
  17 |     |     event SellBaseCall(address to);
  18 |     |     event SellQuoteCall(address to);
  19 |     |     event SellSharesCall(uint256 shareAmount, address to, uint256 baseMinAmount, uint256 quoteMinAmount, bytes data, uint256 deadline);
  20 |     |     event SyncCall();
  21 |     |     event TransferCall(address to, uint256 amount);
  22 |     |     event AddLiquidityCall(address lp, address to, uint256 baseInAmount, uint256 quoteInAmount, uint256 minimumShares, uint256 deadline);
  23 |     |     event AddLiquidityETHCall(
  24 |     |         address lp,
  25 |     |         address to,
  26 |     |         address refundTo,
  27 |     |         uint256 tokenInAmount,
  28 |     |         uint256 value,
  29 |     |         uint256 minimumShares,
  30 |     |         uint256 deadline
  31 |     |     );
  32 |     |     event AddLiquidityETHUnsafeCall(address lp, address to, uint256 tokenInAmount, uint256 value, uint256 minimumShares, uint256 deadline);
  33 |     |     event AddLiquidityUnsafeCall(
  34 |     |         address lp,
  35 |     |         address to,
  36 |     |         uint256 baseInAmount,
  37 |     |         uint256 quoteInAmount,
  38 |     |         uint256 minimumShares,
  39 |     |         uint256 deadline
  40 |     |     );
  41 |     |     event CreatePoolCall(
  42 |     |         address baseToken,
  43 |     |         address quoteToken,
  44 |     |         uint256 lpFeeRate,
  45 |     |         uint256 i,
  46 |     |         uint256 k,
  47 |     |         address to,
  48 |     |         uint256 baseInAmount,
  49 |     |         uint256 quoteInAmount
  50 |     |     );
  51 |     |     event CreatePoolETHCall(
  52 |     |         address token,
  53 |     |         bool useTokenAsQuote,
  54 |     |         uint256 lpFeeRate,
  55 |     |         uint256 i,
  56 |     |         uint256 k,
  57 |     |         address to,
  58 |     |         uint256 tokenInAmount
  59 |     |     );
  60 |     |     event RemoveLiquidityCall(
  61 |     |         address lp,
  62 |     |         address to,
  63 |     |         uint256 sharesIn,
  64 |     |         uint256 minimumBaseAmount,
  65 |     |         uint256 minimumQuoteAmount,
  66 |     |         uint256 deadline
  67 |     |     );
  68 |     |     event RemoveLiquidityETHCall(
  69 |     |         address lp,
  70 |     |         address to,
  71 |     |         uint256 sharesIn,
  72 |     |         uint256 minimumETHAmount,
  73 |     |         uint256 minimumTokenAmount,
  74 |     |         uint256 deadline
  75 |     |     );
  76 |     |     event PreviewAddLiquidityCall(address lp, uint256 baseInAmount, uint256 quoteInAmount);
  77 |     |     event PreviewRemoveLiquidityCall(address lp, uint256 sharesIn);
  78 |     |     event SellBaseETHForTokensCall(address lp, address to, uint256 minimumOut, uint256 deadline);
  79 |     |     event SellBaseTokensForETHCall(address lp, address to, uint256 amountIn, uint256 minimumOut, uint256 deadline);
  80 |     |     event SellBaseTokensForTokensCall(address lp, address to, uint256 amountIn, uint256 minimumOut, uint256 deadline);
  81 |     |     event SellQuoteETHForTokensCall(address lp, address to, uint256 minimumOut, uint256 deadline);
  82 |     |     event SellQuoteTokensForETHCall(address lp, address to, uint256 amountIn, uint256 minimumOut, uint256 deadline);
  83 |     |     event SellQuoteTokensForTokensCall(address lp, address to, uint256 amountIn, uint256 minimumOut, uint256 deadline);
  84 |     |     event SwapETHForTokensCall(address to, address[] path, uint256 directions, uint256 minimumOut, uint256 deadline);
  85 |     |     event SwapTokensForETHCall(address to, uint256 amountIn, address[] path, uint256 directions, uint256 minimumOut, uint256 deadline);
  86 |     |     event SwapTokensForTokensCall(address to, uint256 amountIn, address[] path, uint256 directions, uint256 minimumOut, uint256 deadline);
  87 |     | 
  88 | *   |     function _createCall(
  89 |     |         address baseToken_,
  90 |     |         address quoteToken_,
  91 |     |         uint256 lpFeeRate_,
  92 |     |         uint256 i_,
  93 |     |         uint256 k_
  94 | *   |     ) internal returns (bool success, bytes memory returnData) {
  95 | *   |         emit CreateCall(baseToken_, quoteToken_, lpFeeRate_, i_, k_);
  96 |     | 
  97 | *   |         vm.prank(currentActor);
  98 | *   |         (success, returnData) = address(factory).call{gas: 1000000}(
  99 | *   |             abi.encodeWithSelector(factory.create.selector, baseToken_, quoteToken_, lpFeeRate_, i_, k_, false)
 100 |     |         );
 101 |     |     }
 102 |     | 
 103 | *   |     function _buySharesCall(address pool, address to) internal returns (bool success, bytes memory returnData) {
 104 | *   |         emit BuySharesCall(to);
 105 |     | 
 106 | *   |         vm.prank(currentActor);
 107 | *   |         (success, returnData) = address(pool).call{gas: 1000000}(abi.encodeWithSelector(marketImpl.buyShares.selector, to));
 108 |     |     }
 109 |     | 
 110 | *   |     function _correctRStateCall(address pool) internal returns (bool success, bytes memory returnData) {
 111 | *   |         emit CorrectRStateCall();
 112 |     | 
 113 | *   |         vm.prank(currentActor);
 114 | *   |         (success, returnData) = address(pool).call{gas: 1000000}(abi.encodeWithSelector(marketImpl.correctRState.selector));
 115 |     |     }
 116 |     | 
 117 | *   |     function _sellBaseCall(address pool, address to) internal returns (bool success, bytes memory returnData) {
 118 | *   |         emit SellBaseCall(to);
 119 |     | 
 120 | *   |         vm.prank(currentActor);
 121 | *   |         (success, returnData) = address(pool).call{gas: 1000000}(abi.encodeWithSelector(marketImpl.sellBase.selector, to));
 122 |     |     }
 123 |     | 
 124 | *   |     function _sellQuoteCall(address pool, address to) internal returns (bool success, bytes memory returnData) {
 125 | *   |         emit SellQuoteCall(to);
 126 |     | 
 127 | *   |         vm.prank(currentActor);
 128 | *   |         (success, returnData) = address(pool).call{gas: 1000000}(abi.encodeWithSelector(marketImpl.sellQuote.selector, to));
 129 |     |     }
 130 |     | 
 131 | *   |     function _sellSharesCall(
 132 |     |         address pool,
 133 |     |         uint256 shareAmount,
 134 |     |         address to,
 135 |     |         uint256 baseMinAmount,
 136 |     |         uint256 quoteMinAmount,
 137 |     |         bytes memory data,
 138 |     |         uint256 deadline
 139 | *   |     ) internal returns (bool success, bytes memory returnData) {
 140 | *   |         emit SellSharesCall(shareAmount, to, baseMinAmount, quoteMinAmount, data, deadline);
 141 |     | 
 142 | *   |         vm.prank(currentActor);
 143 | *   |         (success, returnData) = address(pool).call{gas: 1000000}(
 144 | *   |             abi.encodeWithSelector(marketImpl.sellShares.selector, shareAmount, to, baseMinAmount, quoteMinAmount, data, deadline)
 145 |     |         );
 146 |     |     }
 147 |     | 
 148 | *   |     function _syncCall(address pool) internal returns (bool success, bytes memory returnData) {
 149 | *   |         emit SyncCall();
 150 |     | 
 151 | *   |         vm.prank(currentActor);
 152 | *   |         (success, returnData) = address(pool).call{gas: 1000000}(abi.encodeWithSelector(marketImpl.sync.selector));
 153 |     |     }
 154 |     | 
 155 | *   |     function _transferCall(address token, address to, uint256 amount) internal returns (bool success, bytes memory returnData) {
 156 | *   |         emit TransferCall(to, amount);
 157 |     | 
 158 | *   |         vm.prank(currentActor);
 159 | *   |         (success, returnData) = address(token).call{gas: 1000000}(abi.encodeWithSelector(marketImpl.transfer.selector, to, amount));
 160 |     |     }
 161 |     | 
 162 | *   |     function _addLiquidityCall(
 163 |     |         address lp,
 164 |     |         address to,
 165 |     |         uint256 baseInAmount,
 166 |     |         uint256 quoteInAmount,
 167 |     |         uint256 minimumShares,
 168 |     |         uint256 deadline
 169 | *   |     ) internal returns (bool success, bytes memory returnData) {
 170 | *   |         emit AddLiquidityCall(lp, to, baseInAmount, quoteInAmount, minimumShares, deadline);
 171 |     | 
 172 | *   |         vm.prank(currentActor);
 173 | *   |         (success, returnData) = address(router).call{gas: 1000000}(
 174 | *   |             abi.encodeWithSelector(router.addLiquidity.selector, lp, to, baseInAmount, quoteInAmount, minimumShares, deadline)
 175 |     |         );
 176 |     |     }
 177 |     | 
 178 |     |     function _addLiquidityETHCall(
 179 |     |         address lp,
 180 |     |         address to,
 181 |     |         address refundTo,
 182 |     |         uint256 tokenInAmount,
 183 |     |         uint256 value,
 184 |     |         uint256 minimumShares,
 185 |     |         uint256 deadline
 186 |     |     ) internal returns (bool success, bytes memory returnData) {
 187 |     |         emit AddLiquidityETHCall(lp, to, refundTo, tokenInAmount, value, minimumShares, deadline);
 188 |     | 
 189 |     |         vm.prank(currentActor);
 190 |     |         (success, returnData) = address(router).call{value: value, gas: 1000000}(
 191 |     |             abi.encodeWithSelector(router.addLiquidityETH.selector, lp, to, refundTo, tokenInAmount, minimumShares, deadline)
 192 |     |         );
 193 |     |     }
 194 |     | 
 195 |     |     function _addLiquidityETHUnsafeCall(
 196 |     |         address lp,
 197 |     |         address to,
 198 |     |         uint256 tokenInAmount,
 199 |     |         uint256 value,
 200 |     |         uint256 minimumShares,
 201 |     |         uint256 deadline
 202 |     |     ) internal returns (bool success, bytes memory returnData) {
 203 |     |         emit AddLiquidityETHUnsafeCall(lp, to, tokenInAmount, value, minimumShares, deadline);
 204 |     | 
 205 |     |         vm.prank(currentActor);
 206 |     |         (success, returnData) = address(router).call{value: value, gas: 1000000}(
 207 |     |             abi.encodeWithSelector(router.addLiquidityETHUnsafe.selector, lp, to, tokenInAmount, minimumShares, deadline)
 208 |     |         );
 209 |     |     }
 210 |     | 
 211 | *   |     function _addLiquidityUnsafeCall(
 212 |     |         address lp,
 213 |     |         address to,
 214 |     |         uint256 baseInAmount,
 215 |     |         uint256 quoteInAmount,
 216 |     |         uint256 minimumShares,
 217 |     |         uint256 deadline
 218 | *   |     ) internal returns (bool success, bytes memory returnData) {
 219 | *   |         emit AddLiquidityUnsafeCall(lp, to, baseInAmount, quoteInAmount, minimumShares, deadline);
 220 |     | 
 221 | *   |         vm.prank(currentActor);
 222 | *   |         (success, returnData) = address(router).call{gas: 1000000}(
 223 | *   |             abi.encodeWithSelector(router.addLiquidityUnsafe.selector, lp, to, baseInAmount, quoteInAmount, minimumShares, deadline)
 224 |     |         );
 225 |     |     }
 226 |     | 
 227 | *   |     function _createPoolCall(
 228 |     |         address baseToken,
 229 |     |         address quoteToken,
 230 |     |         uint256 lpFeeRate,
 231 |     |         uint256 i,
 232 |     |         uint256 k,
 233 |     |         address to,
 234 |     |         uint256 baseInAmount,
 235 |     |         uint256 quoteInAmount
 236 | *   |     ) internal returns (bool success, bytes memory returnData) {
 237 | *   |         emit CreatePoolCall(baseToken, quoteToken, lpFeeRate, i, k, to, baseInAmount, quoteInAmount);
 238 |     | 
 239 | *   |         vm.prank(currentActor);
 240 | *   |         (success, returnData) = address(router).call{gas: 1000000}(
 241 | *   |             abi.encodeWithSelector(
 242 |     |                 router.createPool.selector,
 243 |     |                 baseToken,
 244 |     |                 quoteToken,
 245 |     |                 lpFeeRate,
 246 |     |                 i,
 247 |     |                 k,
 248 |     |                 to,
 249 |     |                 baseInAmount,
 250 |     |                 quoteInAmount,
 251 |     |                 false
 252 |     |             )
 253 |     |         );
 254 |     |     }
 255 |     | 
 256 | *   |     function _createPoolETHCall(
 257 |     |         address token,
 258 |     |         bool useTokenAsQuote,
 259 |     |         uint256 lpFeeRate,
 260 |     |         uint256 i,
 261 |     |         uint256 k,
 262 |     |         address to,
 263 |     |         uint256 tokenInAmount,
 264 |     |         uint256 value
 265 | *   |     ) internal returns (bool success, bytes memory returnData) {
 266 | *   |         emit CreatePoolETHCall(token, useTokenAsQuote, lpFeeRate, i, k, to, tokenInAmount);
 267 |     | 
 268 | *   |         vm.prank(currentActor);
 269 | *   |         (success, returnData) = address(router).call{value: value, gas: 1000000}(
 270 | *   |             abi.encodeWithSelector(router.createPoolETH.selector, token, useTokenAsQuote, lpFeeRate, i, k, to, tokenInAmount, false)
 271 |     |         );
 272 |     |     }
 273 |     | 
 274 | *   |     function _removeLiquidityCall(
 275 |     |         address lp,
 276 |     |         address to,
 277 |     |         uint256 sharesIn,
 278 |     |         uint256 minimumBaseAmount,
 279 |     |         uint256 minimumQuoteAmount,
 280 |     |         uint256 deadline
 281 | *   |     ) internal returns (bool success, bytes memory returnData) {
 282 | *   |         emit RemoveLiquidityCall(lp, to, sharesIn, minimumBaseAmount, minimumQuoteAmount, deadline);
 283 |     | 
 284 | *   |         vm.prank(currentActor);
 285 | *   |         (success, returnData) = address(lp).call{gas: 1000000}(
 286 | *   |             abi.encodeWithSelector(marketImpl.approve.selector, address(router), sharesIn)
 287 |     |         );
 288 |     | 
 289 | *   |         vm.prank(currentActor);
 290 | *   |         (success, returnData) = address(router).call{gas: 1000000}(
 291 | *   |             abi.encodeWithSelector(router.removeLiquidity.selector, lp, to, sharesIn, minimumBaseAmount, minimumQuoteAmount, deadline)
 292 |     |         );
 293 |     |     }
 294 |     | 
 295 |     |     function _removeLiquidityETHCall(
 296 |     |         address lp,
 297 |     |         address to,
 298 |     |         uint256 sharesIn,
 299 |     |         uint256 minimumETHAmount,
 300 |     |         uint256 minimumTokenAmount,
 301 |     |         uint256 deadline
 302 |     |     ) internal returns (bool success, bytes memory returnData) {
 303 |     |         emit RemoveLiquidityETHCall(lp, to, sharesIn, minimumETHAmount, minimumTokenAmount, deadline);
 304 |     | 
 305 |     |         vm.prank(currentActor);
 306 |     |         (success, returnData) = address(lp).call{gas: 1000000}(
 307 |     |             abi.encodeWithSelector(marketImpl.approve.selector, address(router), sharesIn)
 308 |     |         );
 309 |     | 
 310 |     |         vm.prank(currentActor);
 311 |     |         (success, returnData) = address(router).call{gas: 1000000}(
 312 |     |             abi.encodeWithSelector(router.removeLiquidityETH.selector, lp, to, sharesIn, minimumETHAmount, minimumTokenAmount, deadline)
 313 |     |         );
 314 |     |     }
 315 |     | 
 316 | *   |     function _previewAddLiquidityCall(
 317 |     |         address lp,
 318 |     |         uint256 baseInAmount,
 319 |     |         uint256 quoteInAmount
 320 | *   |     ) internal returns (bool success, bytes memory returnData) {
 321 | *   |         emit PreviewAddLiquidityCall(lp, baseInAmount, quoteInAmount);
 322 |     | 
 323 | *   |         (success, returnData) = address(router).staticcall(
 324 | *   |             abi.encodeWithSelector(router.previewAddLiquidity.selector, lp, baseInAmount, quoteInAmount)
 325 |     |         );
 326 |     |     }
 327 |     | 
 328 | *   |     function _previewRemoveLiquidityCall(address lp, uint256 sharesIn) internal returns (bool success, bytes memory returnData) {
 329 | *   |         emit PreviewRemoveLiquidityCall(lp, sharesIn);
 330 |     | 
 331 | *   |         (success, returnData) = address(router).staticcall(abi.encodeWithSelector(router.previewRemoveLiquidity.selector, lp, sharesIn));
 332 |     |     }
 333 |     | 
 334 |     |     function _sellBaseETHForTokensCall(
 335 |     |         address lp,
 336 |     |         address to,
 337 |     |         uint256 minimumOut,
 338 |     |         uint256 deadline,
 339 |     |         uint256 value
 340 |     |     ) internal returns (bool success, bytes memory returnData) {
 341 |     |         emit SellBaseETHForTokensCall(lp, to, minimumOut, deadline);
 342 |     | 
 343 |     |         vm.prank(currentActor);
 344 |     |         (success, returnData) = address(router).call{value: value, gas: 1000000}(
 345 |     |             abi.encodeWithSelector(router.sellBaseETHForTokens.selector, lp, to, minimumOut, deadline)
 346 |     |         );
 347 |     |     }
 348 |     | 
 349 |     |     function _sellBaseTokensForETHCall(
 350 |     |         address lp,
 351 |     |         address to,
 352 |     |         uint256 amountIn,
 353 |     |         uint256 minimumOut,
 354 |     |         uint256 deadline
 355 |     |     ) internal returns (bool success, bytes memory returnData) {
 356 |     |         emit SellBaseTokensForETHCall(lp, to, amountIn, minimumOut, deadline);
 357 |     | 
 358 |     |         vm.prank(currentActor);
 359 |     |         (success, returnData) = address(router).call{gas: 1000000}(
 360 |     |             abi.encodeWithSelector(router.sellBaseTokensForETH.selector, lp, to, amountIn, minimumOut, deadline)
 361 |     |         );
 362 |     |     }
 363 |     | 
 364 | *   |     function _sellBaseTokensForTokensCall(
 365 |     |         address lp,
 366 |     |         address to,
 367 |     |         uint256 amountIn,
 368 |     |         uint256 minimumOut,
 369 |     |         uint256 deadline
 370 | *   |     ) internal returns (bool success, bytes memory returnData) {
 371 | *   |         emit SellBaseTokensForTokensCall(lp, to, amountIn, minimumOut, deadline);
 372 |     | 
 373 | *   |         vm.prank(currentActor);
 374 | *   |         (success, returnData) = address(router).call{gas: 1000000}(
 375 | *   |             abi.encodeWithSelector(router.sellBaseTokensForTokens.selector, lp, to, amountIn, minimumOut, deadline)
 376 |     |         );
 377 |     |     }
 378 |     | 
 379 |     |     function _sellQuoteETHForTokensCall(
 380 |     |         address lp,
 381 |     |         address to,
 382 |     |         uint256 minimumOut,
 383 |     |         uint256 deadline,
 384 |     |         uint256 value
 385 |     |     ) internal returns (bool success, bytes memory returnData) {
 386 |     |         emit SellQuoteETHForTokensCall(lp, to, minimumOut, deadline);
 387 |     | 
 388 |     |         vm.prank(currentActor);
 389 |     |         (success, returnData) = address(router).call{value: value, gas: 1000000}(
 390 |     |             abi.encodeWithSelector(router.sellQuoteETHForTokens.selector, lp, to, minimumOut, deadline)
 391 |     |         );
 392 |     |     }
 393 |     | 
 394 |     |     function _sellQuoteTokensForETHCall(
 395 |     |         address lp,
 396 |     |         address to,
 397 |     |         uint256 amountIn,
 398 |     |         uint256 minimumOut,
 399 |     |         uint256 deadline
 400 |     |     ) internal returns (bool success, bytes memory returnData) {
 401 |     |         emit SellQuoteTokensForETHCall(lp, to, amountIn, minimumOut, deadline);
 402 |     | 
 403 |     |         vm.prank(currentActor);
 404 |     |         (success, returnData) = address(router).call{gas: 1000000}(
 405 |     |             abi.encodeWithSelector(router.sellQuoteTokensForETH.selector, lp, to, amountIn, minimumOut, deadline)
 406 |     |         );
 407 |     |     }
 408 |     | 
 409 | *   |     function _sellQuoteTokensForTokensCall(
 410 |     |         address lp,
 411 |     |         address to,
 412 |     |         uint256 amountIn,
 413 |     |         uint256 minimumOut,
 414 |     |         uint256 deadline
 415 | *   |     ) internal returns (bool success, bytes memory returnData) {
 416 | *   |         emit SellQuoteTokensForTokensCall(lp, to, amountIn, minimumOut, deadline);
 417 |     | 
 418 | *   |         vm.prank(currentActor);
 419 | *   |         (success, returnData) = address(router).call{gas: 1000000}(
 420 | *   |             abi.encodeWithSelector(router.sellQuoteTokensForTokens.selector, lp, to, amountIn, minimumOut, deadline)
 421 |     |         );
 422 |     |     }
 423 |     | 
 424 |     |     function _swapETHForTokensCall(
 425 |     |         address to,
 426 |     |         address[] memory path,
 427 |     |         uint256 directions,
 428 |     |         uint256 minimumOut,
 429 |     |         uint256 deadline,
 430 |     |         uint256 value
 431 |     |     ) internal returns (bool success, bytes memory returnData) {
 432 |     |         emit SwapETHForTokensCall(to, path, directions, minimumOut, deadline);
 433 |     | 
 434 |     |         vm.prank(currentActor);
 435 |     |         (success, returnData) = address(router).call{value: value, gas: 1000000}(
 436 |     |             abi.encodeWithSelector(router.swapETHForTokens.selector, to, path, directions, minimumOut, deadline)
 437 |     |         );
 438 |     |     }
 439 |     | 
 440 |     |     function _swapTokensForETHCall(
 441 |     |         address to,
 442 |     |         uint256 amountIn,
 443 |     |         address[] memory path,
 444 |     |         uint256 directions,
 445 |     |         uint256 minimumOut,
 446 |     |         uint256 deadline
 447 |     |     ) internal returns (bool success, bytes memory returnData) {
 448 |     |         emit SwapTokensForETHCall(to, amountIn, path, directions, minimumOut, deadline);
 449 |     | 
 450 |     |         vm.prank(currentActor);
 451 |     |         (success, returnData) = address(router).call{gas: 1000000}(
 452 |     |             abi.encodeWithSelector(router.swapTokensForETH.selector, to, amountIn, path, directions, minimumOut, deadline)
 453 |     |         );
 454 |     |     }
 455 |     | 
 456 |     |     function _swapTokensForTokensCall(
 457 |     |         address to,
 458 |     |         uint256 amountIn,
 459 |     |         address[] memory path,
 460 |     |         uint256 directions,
 461 |     |         uint256 minimumOut,
 462 |     |         uint256 deadline
 463 |     |     ) internal returns (bool success, bytes memory returnData) {
 464 |     |         emit SwapTokensForTokensCall(to, amountIn, path, directions, minimumOut, deadline);
 465 |     | 
 466 |     |         vm.prank(currentActor);
 467 |     |         (success, returnData) = address(router).call{gas: 1000000}(
 468 |     |             abi.encodeWithSelector(router.swapTokensForTokens.selector, to, amountIn, path, directions, minimumOut, deadline)
 469 |     |         );
 470 |     |     }
 471 |     | }
 472 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/fuzzing/util/FuzzConstants.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "fuzzlib/IHevm.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title FuzzConstants
  8 |     |  * @author 0xScourgedev
  9 |     |  * @notice Constants and assumptions for the fuzzing suite
 10 |     |  */
 11 |     | abstract contract FuzzConstants {
 12 |     |     bool internal constant DEBUG = false;
 13 |     | 
 14 |     |     address internal constant USER1 = address(0x10000);
 15 |     |     address internal constant USER2 = address(0x20000);
 16 |     |     address internal constant USER3 = address(0x30000);
 17 |     |     address[] internal USERS = [USER1, USER2, USER3];
 18 |     | 
 19 |     |     uint256 internal constant INITIAL_BALANCE = 500_000 ether; // 1 Billion USD worth of ETH at $2000/ETH
 20 |     |     uint256 internal constant INITIAL_WETH_BALANCE = 500_000 ether; // 1 Billion USD worth of WETH at $2000/ETH
 21 |     |     uint256 internal constant INITIAL_TOKEN_BALANCE = 5_000_000_000_000; // 5 trillion tokens, to be multiplied by decimals in setup
 22 | *   |     uint256 internal constant REASONABLE_PREVIEW_AMOUNT = type(uint96).max; // 1 Billion USD as the upper bound of reasonable amount
 23 |     | 
 24 | *   |     uint256 internal constant MAX_POOLS = 16;
 25 | *   |     uint8 internal constant MAX_PATH_LENGTH = 5;
 26 |     | 
 27 |     |     // MagicLP constants
 28 | *   |     uint256 internal constant MAX_I = 10 ** 36;
 29 | *   |     uint256 internal constant MAX_K = 10 ** 18;
 30 | *   |     uint256 internal constant MIN_LP_FEE_RATE = 1e14; // 0.01%
 31 | *   |     uint256 internal constant MAX_LP_FEE_RATE = 1e16; // 1%
 32 |     | }
 33 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IAggregator.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | interface IAggregator {
  5 |     |     function decimals() external view returns (uint8);
  6 |     | 
  7 |     |     function latestAnswer() external view returns (int256 answer);
  8 |     | 
  9 |     |     function latestRoundData()
 10 |     |         external
 11 |     |         view
 12 |     |         returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);
 13 |     | }
 14 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IAnyswapERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | interface IAnyswapERC20 {
   5 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
   6 |     | 
   7 |     |     function PERMIT_TYPEHASH() external view returns (bytes32);
   8 |     | 
   9 |     |     function Swapin(bytes32 txhash, address account, uint256 amount) external returns (bool);
  10 |     | 
  11 |     |     function Swapout(uint256 amount, address bindaddr) external returns (bool);
  12 |     | 
  13 |     |     function TRANSFER_TYPEHASH() external view returns (bytes32);
  14 |     | 
  15 |     |     function allowance(address, address) external view returns (uint256);
  16 |     | 
  17 |     |     function applyMinter() external;
  18 |     | 
  19 |     |     function applyVault() external;
  20 |     | 
  21 |     |     function approve(address spender, uint256 value) external returns (bool);
  22 |     | 
  23 |     |     function approveAndCall(address spender, uint256 value, bytes memory data) external returns (bool);
  24 |     | 
  25 |     |     function balanceOf(address) external view returns (uint256);
  26 |     | 
  27 |     |     function burn(address from, uint256 amount) external returns (bool);
  28 |     | 
  29 |     |     function changeMPCOwner(address newVault) external returns (bool);
  30 |     | 
  31 |     |     function changeVault(address newVault) external returns (bool);
  32 |     | 
  33 |     |     function decimals() external view returns (uint8);
  34 |     | 
  35 |     |     function delay() external view returns (uint256);
  36 |     | 
  37 |     |     function delayDelay() external view returns (uint256);
  38 |     | 
  39 |     |     function delayMinter() external view returns (uint256);
  40 |     | 
  41 |     |     function delayVault() external view returns (uint256);
  42 |     | 
  43 |     |     function deposit(uint256 amount, address to) external returns (uint256);
  44 |     | 
  45 |     |     function deposit(uint256 amount) external returns (uint256);
  46 |     | 
  47 |     |     function deposit() external returns (uint256);
  48 |     | 
  49 |     |     function depositVault(uint256 amount, address to) external returns (uint256);
  50 |     | 
  51 |     |     function depositWithPermit(
  52 |     |         address target,
  53 |     |         uint256 value,
  54 |     |         uint256 deadline,
  55 |     |         uint8 v,
  56 |     |         bytes32 r,
  57 |     |         bytes32 s,
  58 |     |         address to
  59 |     |     ) external returns (uint256);
  60 |     | 
  61 |     |     function depositWithTransferPermit(
  62 |     |         address target,
  63 |     |         uint256 value,
  64 |     |         uint256 deadline,
  65 |     |         uint8 v,
  66 |     |         bytes32 r,
  67 |     |         bytes32 s,
  68 |     |         address to
  69 |     |     ) external returns (uint256);
  70 |     | 
  71 |     |     function getAllMinters() external view returns (address[] memory);
  72 |     | 
  73 |     |     function initVault(address _vault) external;
  74 |     | 
  75 |     |     function isMinter(address) external view returns (bool);
  76 |     | 
  77 |     |     function mint(address to, uint256 amount) external returns (bool);
  78 |     | 
  79 |     |     function minters(uint256) external view returns (address);
  80 |     | 
  81 |     |     function mpc() external view returns (address);
  82 |     | 
  83 |     |     function name() external view returns (string memory);
  84 |     | 
  85 |     |     function nonces(address) external view returns (uint256);
  86 |     | 
  87 |     |     function owner() external view returns (address);
  88 |     | 
  89 |     |     function pendingDelay() external view returns (uint256);
  90 |     | 
  91 |     |     function pendingMinter() external view returns (address);
  92 |     | 
  93 |     |     function pendingVault() external view returns (address);
  94 |     | 
  95 |     |     function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
  96 |     | 
  97 |     |     function revokeMinter(address _auth) external;
  98 |     | 
  99 |     |     function setMinter(address _auth) external;
 100 |     | 
 101 |     |     function setVault(address _vault) external;
 102 |     | 
 103 |     |     function setVaultOnly(bool enabled) external;
 104 |     | 
 105 |     |     function symbol() external view returns (string memory);
 106 |     | 
 107 |     |     function totalSupply() external view returns (uint256);
 108 |     | 
 109 |     |     function transfer(address to, uint256 value) external returns (bool);
 110 |     | 
 111 |     |     function transferAndCall(address to, uint256 value, bytes memory data) external returns (bool);
 112 |     | 
 113 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool);
 114 |     | 
 115 |     |     function transferWithPermit(
 116 |     |         address target,
 117 |     |         address to,
 118 |     |         uint256 value,
 119 |     |         uint256 deadline,
 120 |     |         uint8 v,
 121 |     |         bytes32 r,
 122 |     |         bytes32 s
 123 |     |     ) external returns (bool);
 124 |     | 
 125 |     |     function underlying() external view returns (address);
 126 |     | 
 127 |     |     function vault() external view returns (address);
 128 |     | 
 129 |     |     function withdraw(uint256 amount, address to) external returns (uint256);
 130 |     | 
 131 |     |     function withdraw(uint256 amount) external returns (uint256);
 132 |     | 
 133 |     |     function withdraw() external returns (uint256);
 134 |     | 
 135 |     |     function withdrawVault(address from, uint256 amount, address to) external returns (uint256);
 136 |     | }
 137 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IApeCoinStaking.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | interface IApeCoinStaking {
   5 |     |     struct PairNft {
   6 |     |         uint128 mainTokenId;
   7 |     |         uint128 bakcTokenId;
   8 |     |     }
   9 |     | 
  10 |     |     struct PairNftDepositWithAmount {
  11 |     |         uint32 mainTokenId;
  12 |     |         uint32 bakcTokenId;
  13 |     |         uint184 amount;
  14 |     |     }
  15 |     | 
  16 |     |     struct SingleNft {
  17 |     |         uint32 tokenId;
  18 |     |         uint224 amount;
  19 |     |     }
  20 |     | 
  21 |     |     struct DashboardStake {
  22 |     |         uint256 poolId;
  23 |     |         uint256 tokenId;
  24 |     |         uint256 deposited;
  25 |     |         uint256 unclaimed;
  26 |     |         uint256 rewards24hr;
  27 |     |         DashboardPair pair;
  28 |     |     }
  29 |     | 
  30 |     |     struct DashboardPair {
  31 |     |         uint256 mainTokenId;
  32 |     |         uint256 mainTypePoolId;
  33 |     |     }
  34 |     | 
  35 |     |     struct PoolUI {
  36 |     |         uint256 poolId;
  37 |     |         uint256 stakedAmount;
  38 |     |         TimeRange currentTimeRange;
  39 |     |     }
  40 |     | 
  41 |     |     struct TimeRange {
  42 |     |         uint48 startTimestampHour;
  43 |     |         uint48 endTimestampHour;
  44 |     |         uint96 rewardsPerHour;
  45 |     |         uint96 capPerPosition;
  46 |     |     }
  47 |     | 
  48 |     |     struct PairNftWithdrawWithAmount {
  49 |     |         uint32 mainTokenId;
  50 |     |         uint32 bakcTokenId;
  51 |     |         uint184 amount;
  52 |     |         bool isUncommit;
  53 |     |     }
  54 |     | 
  55 |     |     event ClaimRewards(address indexed user, uint256 amount, address recipient);
  56 |     |     event ClaimRewardsNft(address indexed user, uint256 indexed poolId, uint256 amount, uint256 tokenId);
  57 |     |     event ClaimRewardsPairNft(address indexed user, uint256 amount, uint256 mainTypePoolId, uint256 mainTokenId, uint256 bakcTokenId);
  58 |     |     event Deposit(address indexed user, uint256 amount, address recipient);
  59 |     |     event DepositNft(address indexed user, uint256 indexed poolId, uint256 amount, uint256 tokenId);
  60 |     |     event DepositPairNft(address indexed user, uint256 amount, uint256 mainTypePoolId, uint256 mainTokenId, uint256 bakcTokenId);
  61 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  62 |     |     event UpdatePool(uint256 indexed poolId, uint256 lastRewardedBlock, uint256 stakedAmount, uint256 accumulatedRewardsPerShare);
  63 |     |     event Withdraw(address indexed user, uint256 amount, address recipient);
  64 |     |     event WithdrawNft(address indexed user, uint256 indexed poolId, uint256 amount, address recipient, uint256 tokenId);
  65 |     |     event WithdrawPairNft(address indexed user, uint256 amount, uint256 mainTypePoolId, uint256 mainTokenId, uint256 bakcTokenId);
  66 |     | 
  67 |     |     function addTimeRange(
  68 |     |         uint256 _poolId,
  69 |     |         uint256 _amount,
  70 |     |         uint256 _startTimestamp,
  71 |     |         uint256 _endTimeStamp,
  72 |     |         uint256 _capPerPosition
  73 |     |     ) external;
  74 |     | 
  75 |     |     function addressPosition(address) external view returns (uint256 stakedAmount, int256 rewardsDebt);
  76 |     | 
  77 |     |     function apeCoin() external view returns (address);
  78 |     | 
  79 |     |     function bakcToMain(uint256, uint256) external view returns (uint248 tokenId, bool isPaired);
  80 |     | 
  81 |     |     function claimApeCoin(address _recipient) external;
  82 |     | 
  83 |     |     function claimBAKC(PairNft[] memory _baycPairs, PairNft[] memory _maycPairs, address _recipient) external;
  84 |     | 
  85 |     |     function claimBAYC(uint256[] memory _nfts, address _recipient) external;
  86 |     | 
  87 |     |     function claimMAYC(uint256[] memory _nfts, address _recipient) external;
  88 |     | 
  89 |     |     function claimSelfApeCoin() external;
  90 |     | 
  91 |     |     function claimSelfBAKC(PairNft[] memory _baycPairs, PairNft[] memory _maycPairs) external;
  92 |     | 
  93 |     |     function claimSelfBAYC(uint256[] memory _nfts) external;
  94 |     | 
  95 |     |     function claimSelfMAYC(uint256[] memory _nfts) external;
  96 |     | 
  97 |     |     function depositApeCoin(uint256 _amount, address _recipient) external;
  98 |     | 
  99 |     |     function depositBAKC(PairNftDepositWithAmount[] memory _baycPairs, PairNftDepositWithAmount[] memory _maycPairs) external;
 100 |     | 
 101 |     |     function depositBAYC(SingleNft[] memory _nfts) external;
 102 |     | 
 103 |     |     function depositMAYC(SingleNft[] memory _nfts) external;
 104 |     | 
 105 |     |     function depositSelfApeCoin(uint256 _amount) external;
 106 |     | 
 107 |     |     function getAllStakes(address _address) external view returns (DashboardStake[] memory);
 108 |     | 
 109 |     |     function getApeCoinStake(address _address) external view returns (DashboardStake memory);
 110 |     | 
 111 |     |     function getBakcStakes(address _address) external view returns (DashboardStake[] memory);
 112 |     | 
 113 |     |     function getBaycStakes(address _address) external view returns (DashboardStake[] memory);
 114 |     | 
 115 |     |     function getMaycStakes(address _address) external view returns (DashboardStake[] memory);
 116 |     | 
 117 |     |     function getPoolsUI() external view returns (PoolUI memory, PoolUI memory, PoolUI memory, PoolUI memory);
 118 |     | 
 119 |     |     function getSplitStakes(address _address) external view returns (DashboardStake[] memory);
 120 |     | 
 121 |     |     function getTimeRangeBy(uint256 _poolId, uint256 _index) external view returns (TimeRange memory);
 122 |     | 
 123 |     |     function mainToBakc(uint256, uint256) external view returns (uint248 tokenId, bool isPaired);
 124 |     | 
 125 |     |     function nftContracts(uint256) external view returns (address);
 126 |     | 
 127 |     |     function nftPosition(uint256, uint256) external view returns (uint256 stakedAmount, int256 rewardsDebt);
 128 |     | 
 129 |     |     function owner() external view returns (address);
 130 |     | 
 131 |     |     function pendingRewards(uint256 _poolId, address _address, uint256 _tokenId) external view returns (uint256);
 132 |     | 
 133 |     |     function pools(
 134 |     |         uint256
 135 |     |     )
 136 |     |         external
 137 |     |         view
 138 |     |         returns (uint48 lastRewardedTimestampHour, uint16 lastRewardsRangeIndex, uint96 stakedAmount, uint96 accumulatedRewardsPerShare);
 139 |     | 
 140 |     |     function removeLastTimeRange(uint256 _poolId) external;
 141 |     | 
 142 |     |     function renounceOwnership() external;
 143 |     | 
 144 |     |     function rewardsBy(uint256 _poolId, uint256 _from, uint256 _to) external view returns (uint256, uint256);
 145 |     | 
 146 |     |     function stakedTotal(address _address) external view returns (uint256);
 147 |     | 
 148 |     |     function transferOwnership(address newOwner) external;
 149 |     | 
 150 |     |     function updatePool(uint256 _poolId) external;
 151 |     | 
 152 |     |     function withdrawApeCoin(uint256 _amount, address _recipient) external;
 153 |     | 
 154 |     |     function withdrawBAKC(PairNftWithdrawWithAmount[] memory _baycPairs, PairNftWithdrawWithAmount[] memory _maycPairs) external;
 155 |     | 
 156 |     |     function withdrawBAYC(SingleNft[] memory _nfts, address _recipient) external;
 157 |     | 
 158 |     |     function withdrawMAYC(SingleNft[] memory _nfts, address _recipient) external;
 159 |     | 
 160 |     |     function withdrawSelfApeCoin(uint256 _amount) external;
 161 |     | 
 162 |     |     function withdrawSelfBAYC(SingleNft[] memory _nfts) external;
 163 |     | 
 164 |     |     function withdrawSelfMAYC(SingleNft[] memory _nfts) external;
 165 |     | }
 166 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IBentoBoxV1.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   5 |     | import {Rebase} from "BoringSolidity/libraries/BoringRebase.sol";
   6 |     | import {IStrategy} from "interfaces/IStrategy.sol";
   7 |     | 
   8 |     | interface IFlashBorrower {
   9 |     |     /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.
  10 |     |     /// @param sender The address of the invoker of this flashloan.
  11 |     |     /// @param token The address of the token that is loaned.
  12 |     |     /// @param amount of the `token` that is loaned.
  13 |     |     /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.
  14 |     |     /// @param data Additional data that was passed to the flashloan function.
  15 |     |     function onFlashLoan(
  16 |     |         address sender,
  17 |     |         IERC20 token,
  18 |     |         uint256 amount,
  19 |     |         uint256 fee,
  20 |     |         bytes calldata data
  21 |     |     ) external;
  22 |     | }
  23 |     | 
  24 |     | interface IBatchFlashBorrower {
  25 |     |     /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.
  26 |     |     /// @param sender The address of the invoker of this flashloan.
  27 |     |     /// @param tokens Array of addresses for ERC-20 tokens that is loaned.
  28 |     |     /// @param amounts A one-to-one map to `tokens` that is loaned.
  29 |     |     /// @param fees A one-to-one map to `tokens` that needs to be paid on top for each loan. Needs to be the same token.
  30 |     |     /// @param data Additional data that was passed to the flashloan function.
  31 |     |     function onBatchFlashLoan(
  32 |     |         address sender,
  33 |     |         IERC20[] calldata tokens,
  34 |     |         uint256[] calldata amounts,
  35 |     |         uint256[] calldata fees,
  36 |     |         bytes calldata data
  37 |     |     ) external;
  38 |     | }
  39 |     | 
  40 |     | interface IBentoBoxV1 {
  41 |     |     function balanceOf(IERC20, address) external view returns (uint256);
  42 |     | 
  43 |     |     function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);
  44 |     | 
  45 |     |     function batchFlashLoan(
  46 |     |         IBatchFlashBorrower borrower,
  47 |     |         address[] calldata receivers,
  48 |     |         IERC20[] calldata tokens,
  49 |     |         uint256[] calldata amounts,
  50 |     |         bytes calldata data
  51 |     |     ) external;
  52 |     | 
  53 |     |     function claimOwnership() external;
  54 |     | 
  55 |     |     function flashLoan(
  56 |     |         IFlashBorrower borrower,
  57 |     |         address receiver,
  58 |     |         IERC20 token,
  59 |     |         uint256 amount,
  60 |     |         bytes calldata data
  61 |     |     ) external;
  62 |     | 
  63 |     |     function deploy(
  64 |     |         address masterContract,
  65 |     |         bytes calldata data,
  66 |     |         bool useCreate2
  67 |     |     ) external payable returns (address);
  68 |     | 
  69 |     |     function deposit(
  70 |     |         IERC20 token_,
  71 |     |         address from,
  72 |     |         address to,
  73 |     |         uint256 amount,
  74 |     |         uint256 share
  75 |     |     ) external payable returns (uint256 amountOut, uint256 shareOut);
  76 |     | 
  77 |     |     function harvest(
  78 |     |         IERC20 token,
  79 |     |         bool balance,
  80 |     |         uint256 maxChangeAmount
  81 |     |     ) external;
  82 |     | 
  83 |     |     function masterContractApproved(address, address) external view returns (bool);
  84 |     | 
  85 |     |     function masterContractOf(address) external view returns (address);
  86 |     | 
  87 |     |     function nonces(address) external view returns (uint256);
  88 |     | 
  89 |     |     function owner() external view returns (address);
  90 |     | 
  91 |     |     function pendingOwner() external view returns (address);
  92 |     | 
  93 |     |     function pendingStrategy(IERC20) external view returns (IStrategy);
  94 |     | 
  95 |     |     function permitToken(
  96 |     |         IERC20 token,
  97 |     |         address from,
  98 |     |         address to,
  99 |     |         uint256 amount,
 100 |     |         uint256 deadline,
 101 |     |         uint8 v,
 102 |     |         bytes32 r,
 103 |     |         bytes32 s
 104 |     |     ) external;
 105 |     | 
 106 |     |     function registerProtocol() external;
 107 |     | 
 108 |     |     function setMasterContractApproval(
 109 |     |         address user,
 110 |     |         address masterContract,
 111 |     |         bool approved,
 112 |     |         uint8 v,
 113 |     |         bytes32 r,
 114 |     |         bytes32 s
 115 |     |     ) external;
 116 |     | 
 117 |     |     function setStrategy(IERC20 token, IStrategy newStrategy) external;
 118 |     | 
 119 |     |     function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;
 120 |     | 
 121 |     |     function strategy(IERC20) external view returns (IStrategy);
 122 |     | 
 123 |     |     function strategyData(IERC20)
 124 |     |         external
 125 |     |         view
 126 |     |         returns (
 127 |     |             uint64 strategyStartDate,
 128 |     |             uint64 targetPercentage,
 129 |     |             uint128 balance
 130 |     |         );
 131 |     | 
 132 |     |     function toAmount(
 133 |     |         IERC20 token,
 134 |     |         uint256 share,
 135 |     |         bool roundUp
 136 |     |     ) external view returns (uint256 amount);
 137 |     | 
 138 |     |     function toShare(
 139 |     |         IERC20 token,
 140 |     |         uint256 amount,
 141 |     |         bool roundUp
 142 |     |     ) external view returns (uint256 share);
 143 |     | 
 144 |     |     function totals(IERC20) external view returns (Rebase memory totals_);
 145 |     | 
 146 |     |     function transfer(
 147 |     |         IERC20 token,
 148 |     |         address from,
 149 |     |         address to,
 150 |     |         uint256 share
 151 |     |     ) external;
 152 |     | 
 153 |     |     function transferMultiple(
 154 |     |         IERC20 token,
 155 |     |         address from,
 156 |     |         address[] calldata tos,
 157 |     |         uint256[] calldata shares
 158 |     |     ) external;
 159 |     | 
 160 |     |     function transferOwnership(
 161 |     |         address newOwner,
 162 |     |         bool direct,
 163 |     |         bool renounce
 164 |     |     ) external;
 165 |     | 
 166 |     |     function whitelistMasterContract(address masterContract, bool approved) external;
 167 |     | 
 168 |     |     function whitelistedMasterContracts(address) external view returns (bool);
 169 |     | 
 170 |     |     function withdraw(
 171 |     |         IERC20 token_,
 172 |     |         address from,
 173 |     |         address to,
 174 |     |         uint256 amount,
 175 |     |         uint256 share
 176 |     |     ) external returns (uint256 amountOut, uint256 shareOut);
 177 |     | }
 178 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IBlast.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | enum YieldMode {
  5 |     |     AUTOMATIC,
  6 |     |     DISABLED,
  7 |     |     CLAIMABLE
  8 |     | }
  9 |     | 
 10 |     | enum GasMode {
 11 |     |     VOID,
 12 |     |     CLAIMABLE
 13 |     | }
 14 |     | 
 15 |     | interface IBlast {
 16 |     |     function governorMap(address) external view returns (address);
 17 |     | 
 18 |     |     // configure
 19 |     |     function configureContract(address contractAddress, YieldMode _yield, GasMode gasMode, address governor) external;
 20 |     | 
 21 |     |     function configure(YieldMode _yield, GasMode gasMode, address governor) external;
 22 |     | 
 23 |     |     // base configuration options
 24 |     |     function configureClaimableYield() external;
 25 |     | 
 26 |     |     function configureClaimableYieldOnBehalf(address contractAddress) external;
 27 |     | 
 28 |     |     function configureAutomaticYield() external;
 29 |     | 
 30 |     |     function configureAutomaticYieldOnBehalf(address contractAddress) external;
 31 |     | 
 32 |     |     function configureVoidYield() external;
 33 |     | 
 34 |     |     function configureVoidYieldOnBehalf(address contractAddress) external;
 35 |     | 
 36 |     |     function configureClaimableGas() external;
 37 |     | 
 38 |     |     function configureClaimableGasOnBehalf(address contractAddress) external;
 39 |     | 
 40 |     |     function configureVoidGas() external;
 41 |     | 
 42 |     |     function configureVoidGasOnBehalf(address contractAddress) external;
 43 |     | 
 44 |     |     function configureGovernor(address _governor) external;
 45 |     | 
 46 |     |     function configureGovernorOnBehalf(address _newGovernor, address contractAddress) external;
 47 |     | 
 48 |     |     // claim yield
 49 |     |     function claimYield(address contractAddress, address recipientOfYield, uint256 amount) external returns (uint256);
 50 |     | 
 51 |     |     function claimAllYield(address contractAddress, address recipientOfYield) external returns (uint256);
 52 |     | 
 53 |     |     // claim gas
 54 |     |     function claimAllGas(address contractAddress, address recipientOfGas) external returns (uint256);
 55 |     | 
 56 |     |     function claimGasAtMinClaimRate(address contractAddress, address recipientOfGas, uint256 minClaimRateBips) external returns (uint256);
 57 |     | 
 58 |     |     function claimMaxGas(address contractAddress, address recipientOfGas) external returns (uint256);
 59 |     | 
 60 |     |     function claimGas(
 61 |     |         address contractAddress,
 62 |     |         address recipientOfGas,
 63 |     |         uint256 gasToClaim,
 64 |     |         uint256 gasSecondsToConsume
 65 |     |     ) external returns (uint256);
 66 |     | 
 67 |     |     // read functions
 68 |     |     function readClaimableYield(address contractAddress) external view returns (uint256);
 69 |     | 
 70 |     |     function readYieldConfiguration(address contractAddress) external view returns (uint8);
 71 |     | 
 72 |     |     function readGasParams(
 73 |     |         address contractAddress
 74 |     |     ) external view returns (uint256 etherSeconds, uint256 etherBalance, uint256 lastUpdated, GasMode);
 75 |     | }
 76 |     | 
 77 |     | interface IERC20Rebasing {
 78 |     |     function getConfiguration(address account) external view returns (YieldMode);
 79 |     | 
 80 |     |     // changes the yield mode of the caller and update the balance
 81 |     |     // to reflect the configuration
 82 |     |     function configure(YieldMode) external returns (uint256);
 83 |     | 
 84 |     |     // "claimable" yield mode accounts can call this this claim their yield
 85 |     |     // to another address
 86 |     |     function claim(address recipient, uint256 amount) external returns (uint256);
 87 |     | 
 88 |     |     // read the claimable amount for an account
 89 |     |     function getClaimableAmount(address account) external view returns (uint256);
 90 |     | }
 91 |     | 
 92 |     | interface IBlastPoints {
 93 |     |     function configurePointsOperator(address operator) external;
 94 |     | }
 95 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ICauldronV1.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IOracle} from "interfaces/IOracle.sol";
  5 |     | 
  6 |     | interface ICauldronV1 {
  7 |     |     function accrue() external;
  8 |     | 
  9 |     |     function withdrawFees() external;
 10 |     | 
 11 |     |     function accrueInfo() external view returns (uint64, uint128);
 12 |     | 
 13 |     |     function setFeeTo(address newFeeTo) external;
 14 |     | 
 15 |     |     function feeTo() external view returns (address);
 16 |     | 
 17 |     |     function masterContract() external view returns (ICauldronV1);
 18 |     | 
 19 |     |     function bentoBox() external view returns (address);
 20 |     | 
 21 |     |     function exchangeRate() external view returns (uint256 rate);
 22 |     | 
 23 |     |     function updateExchangeRate() external returns (bool updated, uint256 rate);
 24 |     | 
 25 |     |     function oracle() external view returns (IOracle);
 26 |     | 
 27 |     |     function oracleData() external view returns (bytes memory);
 28 |     | }
 29 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ICauldronV2.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | import {IOracle} from "interfaces/IOracle.sol";
  6 |     | import {Rebase} from "BoringSolidity/libraries/BoringRebase.sol";
  7 |     | 
  8 |     | interface ICauldronV2 {
  9 |     |     function oracle() external view returns (IOracle);
 10 |     | 
 11 |     |     function oracleData() external view returns (bytes memory);
 12 |     | 
 13 |     |     function accrueInfo() external view returns (uint64, uint128, uint64);
 14 |     | 
 15 |     |     function BORROW_OPENING_FEE() external view returns (uint256);
 16 |     | 
 17 |     |     function COLLATERIZATION_RATE() external view returns (uint256);
 18 |     | 
 19 |     |     function LIQUIDATION_MULTIPLIER() external view returns (uint256);
 20 |     | 
 21 |     |     function totalCollateralShare() external view returns (uint256);
 22 |     | 
 23 |     |     function bentoBox() external view returns (address);
 24 |     | 
 25 |     |     function feeTo() external view returns (address);
 26 |     | 
 27 |     |     function masterContract() external view returns (ICauldronV2);
 28 |     | 
 29 |     |     function collateral() external view returns (IERC20);
 30 |     | 
 31 |     |     function setFeeTo(address newFeeTo) external;
 32 |     | 
 33 |     |     function accrue() external;
 34 |     | 
 35 |     |     function totalBorrow() external view returns (Rebase memory);
 36 |     | 
 37 |     |     function userBorrowPart(address account) external view returns (uint256);
 38 |     | 
 39 |     |     function userCollateralShare(address account) external view returns (uint256);
 40 |     | 
 41 |     |     function withdrawFees() external;
 42 |     | 
 43 |     |     function cook(
 44 |     |         uint8[] calldata actions,
 45 |     |         uint256[] calldata values,
 46 |     |         bytes[] calldata datas
 47 |     |     ) external payable returns (uint256 value1, uint256 value2);
 48 |     | 
 49 |     |     function addCollateral(address to, bool skim, uint256 share) external;
 50 |     | 
 51 |     |     function removeCollateral(address to, uint256 share) external;
 52 |     | 
 53 |     |     function borrow(address to, uint256 amount) external returns (uint256 part, uint256 share);
 54 |     | 
 55 |     |     function repay(address to, bool skim, uint256 part) external returns (uint256 amount);
 56 |     | 
 57 |     |     function reduceSupply(uint256 amount) external;
 58 |     | 
 59 |     |     function magicInternetMoney() external view returns (IERC20);
 60 |     | 
 61 |     |     function liquidate(address[] calldata users, uint256[] calldata maxBorrowParts, address to, address swapper) external;
 62 |     | 
 63 |     |     function updateExchangeRate() external returns (bool updated, uint256 rate);
 64 |     | 
 65 |     |     function exchangeRate() external view returns (uint256 rate);
 66 |     | 
 67 |     |     function init(bytes calldata data) external payable;
 68 |     | }
 69 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ICauldronV3.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {ICauldronV2} from "interfaces/ICauldronV2.sol";
  5 |     | 
  6 |     | interface ICauldronV3 is ICauldronV2 {
  7 |     |     function borrowLimit() external view returns (uint128 total, uint128 borrowPartPerAddres);
  8 |     | 
  9 |     |     function changeInterestRate(uint64 newInterestRate) external;
 10 |     | 
 11 |     |     function changeBorrowLimit(uint128 newBorrowLimit, uint128 perAddressPart) external;
 12 |     | 
 13 |     |     function liquidate(
 14 |     |         address[] calldata users,
 15 |     |         uint256[] calldata maxBorrowParts,
 16 |     |         address to,
 17 |     |         address swapper,
 18 |     |         bytes calldata swapperData
 19 |     |     ) external;
 20 |     | }
 21 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ICauldronV4.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {ICauldronV3} from "interfaces/ICauldronV3.sol";
  5 |     | 
  6 |     | interface ICauldronV4 is ICauldronV3 {
  7 |     |     function setBlacklistedCallee(address callee, bool blacklisted) external;
  8 |     | 
  9 |     |     function blacklistedCallees(address callee) external view returns (bool);
 10 |     | 
 11 |     |     function isSolvent(address user) external view returns (bool);
 12 |     | }
 13 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ICauldronV4GmxV2.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {ICauldronV4} from "interfaces/ICauldronV4.sol";
  5 |     | import {IGmCauldronOrderAgent, IGmRouterOrder} from "periphery/GmxV2CauldronOrderAgent.sol";
  6 |     | 
  7 |     | interface ICauldronV4GmxV2 is ICauldronV4 {
  8 |     |     function closeOrder(address user) external;
  9 |     | 
 10 |     |     function orders(address user) external view returns (IGmRouterOrder);
 11 |     | 
 12 |     |     function orderAgent() external view returns (IGmCauldronOrderAgent);
 13 |     | }
 14 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IConvexWrapper.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | interface IConvexWrapper {
   5 |     |     struct EarnedData {
   6 |     |         address token;
   7 |     |         uint256 amount;
   8 |     |     }
   9 |     | 
  10 |     |     function addRewards() external;
  11 |     | 
  12 |     |     function addTokenReward(address _token) external;
  13 |     | 
  14 |     |     function allowance(address owner, address spender) external view returns (uint256);
  15 |     | 
  16 |     |     function approve(address spender, uint256 amount) external returns (bool);
  17 |     | 
  18 |     |     function balanceOf(address account) external view returns (uint256);
  19 |     | 
  20 |     |     function cauldrons(uint256) external view returns (address);
  21 |     | 
  22 |     |     function cauldronsLength() external view returns (uint256);
  23 |     | 
  24 |     |     function collateralVault() external view returns (address);
  25 |     | 
  26 |     |     function convexBooster() external view returns (address);
  27 |     | 
  28 |     |     function convexPool() external view returns (address);
  29 |     | 
  30 |     |     function convexPoolId() external view returns (uint256);
  31 |     | 
  32 |     |     function convexToken() external view returns (address);
  33 |     | 
  34 |     |     function crv() external view returns (address);
  35 |     | 
  36 |     |     function curveToken() external view returns (address);
  37 |     | 
  38 |     |     function cvx() external view returns (address);
  39 |     | 
  40 |     |     function decimals() external view returns (uint8);
  41 |     | 
  42 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
  43 |     | 
  44 |     |     function deposit(uint256 _amount, address _to) external;
  45 |     | 
  46 |     |     function earmarkRewards() external returns (bool);
  47 |     | 
  48 |     |     function earned(address _account) external returns (EarnedData[] memory claimable);
  49 |     | 
  50 |     |     function factory() external view returns (address);
  51 |     | 
  52 |     |     function getReward(address _account, address _forwardTo) external;
  53 |     | 
  54 |     |     function getReward(address _account) external;
  55 |     | 
  56 |     |     function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
  57 |     | 
  58 |     |     function initialize(uint256 _poolId) external;
  59 |     | 
  60 |     |     function invalidateReward(address _token) external;
  61 |     | 
  62 |     |     function isInit() external view returns (bool);
  63 |     | 
  64 |     |     function isShutdown() external view returns (bool);
  65 |     | 
  66 |     |     function name() external view returns (string memory);
  67 |     | 
  68 |     |     function owner() external view returns (address);
  69 |     | 
  70 |     |     function registeredRewards(address) external view returns (uint256);
  71 |     | 
  72 |     |     function renounceOwnership() external;
  73 |     | 
  74 |     |     function rewardHook() external view returns (address);
  75 |     | 
  76 |     |     function rewardLength() external view returns (uint256);
  77 |     | 
  78 |     |     function rewardRedirect(address) external view returns (address);
  79 |     | 
  80 |     |     function rewards(
  81 |     |         uint256
  82 |     |     ) external view returns (address reward_token, address reward_pool, uint256 reward_integral, uint256 reward_remaining);
  83 |     | 
  84 |     |     function setApprovals() external;
  85 |     | 
  86 |     |     function setCauldron(address _cauldron) external;
  87 |     | 
  88 |     |     function setHook(address _hook) external;
  89 |     | 
  90 |     |     function setRewardRedirect(address _to) external;
  91 |     | 
  92 |     |     function shutdown() external;
  93 |     | 
  94 |     |     function stake(uint256 _amount, address _to) external;
  95 |     | 
  96 |     |     function symbol() external view returns (string memory);
  97 |     | 
  98 |     |     function totalBalanceOf(address _account) external view returns (uint256);
  99 |     | 
 100 |     |     function totalSupply() external view returns (uint256);
 101 |     | 
 102 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
 103 |     | 
 104 |     |     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
 105 |     | 
 106 |     |     function transferOwnership(address newOwner) external;
 107 |     | 
 108 |     |     function user_checkpoint(address _account) external returns (bool);
 109 |     | 
 110 |     |     function withdraw(uint256 _amount) external;
 111 |     | 
 112 |     |     function withdrawAndUnwrap(uint256 _amount) external;
 113 |     | }
 114 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IConvexWrapperFactory.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | interface IConvexWrapperFactory {
  5 |     |     function CreateWrapper(uint256 _pid) external returns (address);
  6 |     | 
  7 |     |     function acceptPendingOwner() external;
  8 |     | 
  9 |     |     function owner() external view returns (address);
 10 |     | 
 11 |     |     function pendingOwner() external view returns (address);
 12 |     | 
 13 |     |     function proxyFactory() external view returns (address);
 14 |     | 
 15 |     |     function setImplementation(address _imp) external;
 16 |     | 
 17 |     |     function setPendingOwner(address _po) external;
 18 |     | 
 19 |     |     function wrapperImplementation() external view returns (address);
 20 |     | }
 21 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ICurvePool.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // solhint-disable func-name-mixedcase, var-name-mixedcase
  3 |     | pragma solidity >=0.8.0;
  4 |     | 
  5 |     | enum CurvePoolInterfaceType {
  6 |     |     ICURVE_POOL,
  7 |     |     ICURVE_3POOL_ZAPPER,
  8 |     |     IFACTORY_POOL,
  9 |     |     ITRICRYPTO_POOL
 10 |     | }
 11 |     | 
 12 |     | interface ICurvePool {
 13 |     |     function decimals() external view returns (uint256);
 14 |     | 
 15 |     |     function coins(uint256 i) external view returns (address);
 16 |     | 
 17 |     |     function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);
 18 |     | 
 19 |     |     function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);
 20 |     | 
 21 |     |     function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external returns (uint256);
 22 |     | 
 23 |     |     function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256);
 24 |     | 
 25 |     |     function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);
 26 |     | 
 27 |     |     function approve(address _spender, uint256 _value) external returns (bool);
 28 |     | 
 29 |     |     function add_liquidity(uint256[2] memory amounts, uint256 _min_mint_amount) external;
 30 |     | 
 31 |     |     function add_liquidity(uint256[3] memory amounts, uint256 _min_mint_amount) external;
 32 |     | 
 33 |     |     function add_liquidity(uint256[4] memory amounts, uint256 _min_mint_amount) external;
 34 |     | 
 35 |     |     function remove_liquidity_one_coin(uint256 tokenAmount, int128 i, uint256 min_amount) external returns (uint256);
 36 |     | 
 37 |     |     function get_virtual_price() external view returns (uint256 price);
 38 |     | }
 39 |     | 
 40 |     | interface ICurve3PoolZapper {
 41 |     |     function add_liquidity(address _pool, uint256[4] memory _deposit_amounts, uint256 _min_mint_amount) external returns (uint256);
 42 |     | 
 43 |     |     function add_liquidity(
 44 |     |         address _pool,
 45 |     |         uint256[4] memory _deposit_amounts,
 46 |     |         uint256 _min_mint_amount,
 47 |     |         address _receiver
 48 |     |     ) external returns (uint256);
 49 |     | 
 50 |     |     function remove_liquidity(address _pool, uint256 _burn_amount, uint256[4] memory _min_amounts) external returns (uint256[4] memory);
 51 |     | 
 52 |     |     function remove_liquidity(
 53 |     |         address _pool,
 54 |     |         uint256 _burn_amount,
 55 |     |         uint256[4] memory _min_amounts,
 56 |     |         address _receiver
 57 |     |     ) external returns (uint256[4] memory);
 58 |     | 
 59 |     |     function remove_liquidity_one_coin(address _pool, uint256 _burn_amount, int128 i, uint256 _min_amount) external returns (uint256);
 60 |     | 
 61 |     |     function remove_liquidity_one_coin(
 62 |     |         address _pool,
 63 |     |         uint256 _burn_amount,
 64 |     |         int128 i,
 65 |     |         uint256 _min_amount,
 66 |     |         address _receiver
 67 |     |     ) external returns (uint256);
 68 |     | }
 69 |     | 
 70 |     | interface IFactoryPool is ICurvePool {
 71 |     |     function remove_liquidity_one_coin(uint256 tokenAmount, uint256 i, uint256 min_amount) external returns (uint256);
 72 |     | }
 73 |     | 
 74 |     | interface ITriCrypto is ICurvePool {
 75 |     |     function remove_liquidity_one_coin(uint256 tokenAmount, uint256 i, uint256 min_amount) external;
 76 |     | }
 77 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ICurveRewardGauge.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | interface ICurveRewardGauge {
  5 |     |     function claim_rewards(address account, address to) external;
  6 |     | 
  7 |     |     function deposit(uint256 amount, address account, bool claimRewards) external;
  8 |     | 
  9 |     |     function withdraw(uint256 amount) external;
 10 |     | 
 11 |     |     function balanceOf(address account) external view returns (uint256);
 12 |     | 
 13 |     |     function reward_count() external view returns (uint256);
 14 |     | 
 15 |     |     function reward_tokens() external view returns (address[] memory);
 16 |     | 
 17 |     |     function claimable_reward(address account, address rewardToken) external view returns (uint256);
 18 |     | }
 19 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ICurveStablePoolAggregator.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IAggregator} from "interfaces/IAggregator.sol";
  5 |     | 
  6 |     | interface ICurveStablePoolAggregator is IAggregator {
  7 |     |     function curvePool() external view returns (address);
  8 |     | }
  9 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IERC20Vault.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | 
  6 |     | interface IERC20Vault is IERC20 {
  7 |     |     function toAmount(uint256 shares) external view returns (uint256);
  8 |     | 
  9 |     |     function toShares(uint256 amount) external view returns (uint256);
 10 |     | 
 11 |     |     function underlying() external view returns (IERC20);
 12 |     | 
 13 |     |     function enter(uint256 amount) external returns (uint256 shares);
 14 |     | 
 15 |     |     function enterFor(uint256 amount, address recipient) external returns (uint256 shares);
 16 |     | 
 17 |     |     function leave(uint256 shares) external returns (uint256 amount);
 18 |     | 
 19 |     |     function leaveTo(uint256 shares, address receipient) external returns (uint256 amount);
 20 |     | 
 21 |     |     function leaveAll() external returns (uint256 amount);
 22 |     | 
 23 |     |     function leaveAllTo(address receipient) external returns (uint256 amount);
 24 |     | }
 25 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IERC4626.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | 
  6 |     | /// @notice Tokenized Vaults with a single underlying EIP-20 token.
  7 |     | interface IERC4626 {
  8 |     |     function decimals() external view returns (uint8 decimals);
  9 |     |     
 10 |     |     /// @notice The address of the underlying token used for the Vault for accounting, depositing, and withdrawing.
 11 |     |     function asset() external view returns (IERC20 assetTokenAddress);
 12 |     | 
 13 |     |     /// @notice Total amount of the underlying asset that is “managed” by Vault.
 14 |     |     function totalAssets() external view returns (uint256 totalManagedAssets);
 15 |     | 
 16 |     |     /// @notice The amount of shares that the Vault would exchange for the amount of assets provided, in an ideal scenario where all the conditions are met.
 17 |     |     function convertToShares(uint256 assets) external view returns (uint256 shares);
 18 |     | 
 19 |     |     /// @notice The amount of assets that the Vault would exchange for the amount of shares provided, in an ideal scenario where all the conditions are met.
 20 |     |     function convertToAssets(uint256 shares) external view returns (uint256 assets);
 21 |     | 
 22 |     |     /// @notice Maximum amount of the underlying asset that can be deposited into the Vault for the receiver, through a deposit call.
 23 |     |     function maxDeposit(address receiver) external view returns (uint256 maxAssets);
 24 |     | 
 25 |     |     /// @notice Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given current on-chain conditions.
 26 |     |     function previewDeposit(uint256 assets) external view returns (uint256 shares);
 27 |     | 
 28 |     |     /// @notice Mints shares Vault shares to receiver by depositing exactly assets of underlying tokens.
 29 |     |     function deposit(uint256 assets, address receiver) external returns (uint256 shares);
 30 |     | 
 31 |     |     /// @notice Maximum amount of shares that can be minted from the Vault for the receiver, through a mint call.
 32 |     |     function maxMint(address receiver) external view returns (uint256 maxShares);
 33 |     | 
 34 |     |     /// @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given current on-chain conditions.
 35 |     |     function previewMint(uint256 shares) external view returns (uint256 assets);
 36 |     | 
 37 |     |     /// @notice Mints exactly shares Vault shares to receiver by depositing assets of underlying tokens.
 38 |     |     function mint(uint256 shares, address receiver) external returns (uint256 assets);
 39 |     | 
 40 |     |     /// @notice Maximum amount of the underlying asset that can be withdrawn from the owner balance in the Vault, through a withdraw call.
 41 |     |     function maxWithdraw(address owner) external view returns (uint256 maxAssets);
 42 |     | 
 43 |     |     /// @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block, given current on-chain conditions.
 44 |     |     function previewWithdraw(uint256 assets) external view returns (uint256 shares);
 45 |     | 
 46 |     |     /// @notice Burns shares from owner and sends exactly assets of underlying tokens to receiver.
 47 |     |     function withdraw(
 48 |     |         uint256 assets,
 49 |     |         address receiver,
 50 |     |         address owner
 51 |     |     ) external returns (uint256 shares);
 52 |     | 
 53 |     |     /// @notice Maximum amount of Vault shares that can be redeemed from the owner balance in the Vault, through a redeem call.
 54 |     |     function maxRedeem(address owner) external view returns (uint256 maxShares);
 55 |     | 
 56 |     |     /// @notice Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block, given current on-chain conditions.
 57 |     |     function previewRedeem(uint256 shares) external view returns (uint256 assets);
 58 |     | 
 59 |     |     /// @notice Burns exactly shares from owner and sends assets of underlying tokens to receiver.
 60 |     |     function redeem(
 61 |     |         uint256 shares,
 62 |     |         address receiver,
 63 |     |         address owner
 64 |     |     ) external returns (uint256 assets);
 65 |     | 
 66 |     |     event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);
 67 |     |     event Withdraw(address indexed caller, address indexed receiver, address indexed owner, uint256 assets, uint256 shares);
 68 |     | }
 69 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IGmxV1.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   5 |     | 
   6 |     | interface IGmxVault {
   7 |     |     event BuyUSDG(address account, address token, uint256 tokenAmount, uint256 usdgAmount, uint256 feeBasisPoints);
   8 |     |     event ClosePosition(
   9 |     |         bytes32 key,
  10 |     |         uint256 size,
  11 |     |         uint256 collateral,
  12 |     |         uint256 averagePrice,
  13 |     |         uint256 entryFundingRate,
  14 |     |         uint256 reserveAmount,
  15 |     |         int256 realisedPnl
  16 |     |     );
  17 |     |     event CollectMarginFees(address token, uint256 feeUsd, uint256 feeTokens);
  18 |     |     event CollectSwapFees(address token, uint256 feeUsd, uint256 feeTokens);
  19 |     |     event DecreaseGuaranteedUsd(address token, uint256 amount);
  20 |     |     event DecreasePoolAmount(address token, uint256 amount);
  21 |     |     event DecreasePosition(
  22 |     |         bytes32 key,
  23 |     |         address account,
  24 |     |         address collateralToken,
  25 |     |         address indexToken,
  26 |     |         uint256 collateralDelta,
  27 |     |         uint256 sizeDelta,
  28 |     |         bool isLong,
  29 |     |         uint256 price,
  30 |     |         uint256 fee
  31 |     |     );
  32 |     |     event DecreaseReservedAmount(address token, uint256 amount);
  33 |     |     event DecreaseUsdgAmount(address token, uint256 amount);
  34 |     |     event DirectPoolDeposit(address token, uint256 amount);
  35 |     |     event IncreaseGuaranteedUsd(address token, uint256 amount);
  36 |     |     event IncreasePoolAmount(address token, uint256 amount);
  37 |     |     event IncreasePosition(
  38 |     |         bytes32 key,
  39 |     |         address account,
  40 |     |         address collateralToken,
  41 |     |         address indexToken,
  42 |     |         uint256 collateralDelta,
  43 |     |         uint256 sizeDelta,
  44 |     |         bool isLong,
  45 |     |         uint256 price,
  46 |     |         uint256 fee
  47 |     |     );
  48 |     |     event IncreaseReservedAmount(address token, uint256 amount);
  49 |     |     event IncreaseUsdgAmount(address token, uint256 amount);
  50 |     |     event LiquidatePosition(
  51 |     |         bytes32 key,
  52 |     |         address account,
  53 |     |         address collateralToken,
  54 |     |         address indexToken,
  55 |     |         bool isLong,
  56 |     |         uint256 size,
  57 |     |         uint256 collateral,
  58 |     |         uint256 reserveAmount,
  59 |     |         int256 realisedPnl,
  60 |     |         uint256 markPrice
  61 |     |     );
  62 |     |     event SellUSDG(address account, address token, uint256 usdgAmount, uint256 tokenAmount, uint256 feeBasisPoints);
  63 |     |     event Swap(
  64 |     |         address account,
  65 |     |         address tokenIn,
  66 |     |         address tokenOut,
  67 |     |         uint256 amountIn,
  68 |     |         uint256 amountOut,
  69 |     |         uint256 amountOutAfterFees,
  70 |     |         uint256 feeBasisPoints
  71 |     |     );
  72 |     |     event UpdateFundingRate(address token, uint256 fundingRate);
  73 |     |     event UpdatePnl(bytes32 key, bool hasProfit, uint256 delta);
  74 |     |     event UpdatePosition(
  75 |     |         bytes32 key,
  76 |     |         uint256 size,
  77 |     |         uint256 collateral,
  78 |     |         uint256 averagePrice,
  79 |     |         uint256 entryFundingRate,
  80 |     |         uint256 reserveAmount,
  81 |     |         int256 realisedPnl
  82 |     |     );
  83 |     | 
  84 |     |     function BASIS_POINTS_DIVISOR() external view returns (uint256);
  85 |     | 
  86 |     |     function FUNDING_RATE_PRECISION() external view returns (uint256);
  87 |     | 
  88 |     |     function MAX_FEE_BASIS_POINTS() external view returns (uint256);
  89 |     | 
  90 |     |     function MAX_FUNDING_RATE_FACTOR() external view returns (uint256);
  91 |     | 
  92 |     |     function MAX_LIQUIDATION_FEE_USD() external view returns (uint256);
  93 |     | 
  94 |     |     function MIN_FUNDING_RATE_INTERVAL() external view returns (uint256);
  95 |     | 
  96 |     |     function MIN_LEVERAGE() external view returns (uint256);
  97 |     | 
  98 |     |     function PRICE_PRECISION() external view returns (uint256);
  99 |     | 
 100 |     |     function USDG_DECIMALS() external view returns (uint256);
 101 |     | 
 102 |     |     function addRouter(address _router) external;
 103 |     | 
 104 |     |     function adjustForDecimals(uint256 _amount, address _tokenDiv, address _tokenMul) external view returns (uint256);
 105 |     | 
 106 |     |     function allWhitelistedTokens(uint256) external view returns (address);
 107 |     | 
 108 |     |     function allWhitelistedTokensLength() external view returns (uint256);
 109 |     | 
 110 |     |     function approvedRouters(address, address) external view returns (bool);
 111 |     | 
 112 |     |     function bufferAmounts(address) external view returns (uint256);
 113 |     | 
 114 |     |     function buyUSDG(address _token, address _receiver) external returns (uint256);
 115 |     | 
 116 |     |     function clearTokenConfig(address _token) external;
 117 |     | 
 118 |     |     function cumulativeFundingRates(address) external view returns (uint256);
 119 |     | 
 120 |     |     function decreasePosition(
 121 |     |         address _account,
 122 |     |         address _collateralToken,
 123 |     |         address _indexToken,
 124 |     |         uint256 _collateralDelta,
 125 |     |         uint256 _sizeDelta,
 126 |     |         bool _isLong,
 127 |     |         address _receiver
 128 |     |     ) external returns (uint256);
 129 |     | 
 130 |     |     function directPoolDeposit(address _token) external;
 131 |     | 
 132 |     |     function errorController() external view returns (address);
 133 |     | 
 134 |     |     function errors(uint256) external view returns (string memory);
 135 |     | 
 136 |     |     function feeReserves(address) external view returns (uint256);
 137 |     | 
 138 |     |     function fundingInterval() external view returns (uint256);
 139 |     | 
 140 |     |     function fundingRateFactor() external view returns (uint256);
 141 |     | 
 142 |     |     function getDelta(
 143 |     |         address _indexToken,
 144 |     |         uint256 _size,
 145 |     |         uint256 _averagePrice,
 146 |     |         bool _isLong,
 147 |     |         uint256 _lastIncreasedTime
 148 |     |     ) external view returns (bool, uint256);
 149 |     | 
 150 |     |     function getFeeBasisPoints(
 151 |     |         address _token,
 152 |     |         uint256 _usdgDelta,
 153 |     |         uint256 _feeBasisPoints,
 154 |     |         uint256 _taxBasisPoints,
 155 |     |         bool _increment
 156 |     |     ) external view returns (uint256);
 157 |     | 
 158 |     |     function getFundingFee(address _token, uint256 _size, uint256 _entryFundingRate) external view returns (uint256);
 159 |     | 
 160 |     |     function getGlobalShortDelta(address _token) external view returns (bool, uint256);
 161 |     | 
 162 |     |     function getMaxPrice(address _token) external view returns (uint256);
 163 |     | 
 164 |     |     function getMinPrice(address _token) external view returns (uint256);
 165 |     | 
 166 |     |     function getNextAveragePrice(
 167 |     |         address _indexToken,
 168 |     |         uint256 _size,
 169 |     |         uint256 _averagePrice,
 170 |     |         bool _isLong,
 171 |     |         uint256 _nextPrice,
 172 |     |         uint256 _sizeDelta,
 173 |     |         uint256 _lastIncreasedTime
 174 |     |     ) external view returns (uint256);
 175 |     | 
 176 |     |     function getNextFundingRate(address _token) external view returns (uint256);
 177 |     | 
 178 |     |     function getNextGlobalShortAveragePrice(address _indexToken, uint256 _nextPrice, uint256 _sizeDelta) external view returns (uint256);
 179 |     | 
 180 |     |     function getPosition(
 181 |     |         address _account,
 182 |     |         address _collateralToken,
 183 |     |         address _indexToken,
 184 |     |         bool _isLong
 185 |     |     ) external view returns (uint256, uint256, uint256, uint256, uint256, uint256, bool, uint256);
 186 |     | 
 187 |     |     function getPositionDelta(
 188 |     |         address _account,
 189 |     |         address _collateralToken,
 190 |     |         address _indexToken,
 191 |     |         bool _isLong
 192 |     |     ) external view returns (bool, uint256);
 193 |     | 
 194 |     |     function getPositionFee(uint256 _sizeDelta) external view returns (uint256);
 195 |     | 
 196 |     |     function getPositionKey(address _account, address _collateralToken, address _indexToken, bool _isLong) external pure returns (bytes32);
 197 |     | 
 198 |     |     function getPositionLeverage(
 199 |     |         address _account,
 200 |     |         address _collateralToken,
 201 |     |         address _indexToken,
 202 |     |         bool _isLong
 203 |     |     ) external view returns (uint256);
 204 |     | 
 205 |     |     function getRedemptionAmount(address _token, uint256 _usdgAmount) external view returns (uint256);
 206 |     | 
 207 |     |     function getRedemptionCollateral(address _token) external view returns (uint256);
 208 |     | 
 209 |     |     function getRedemptionCollateralUsd(address _token) external view returns (uint256);
 210 |     | 
 211 |     |     function getTargetUsdgAmount(address _token) external view returns (uint256);
 212 |     | 
 213 |     |     function getUtilisation(address _token) external view returns (uint256);
 214 |     | 
 215 |     |     function globalShortAveragePrices(address) external view returns (uint256);
 216 |     | 
 217 |     |     function globalShortSizes(address) external view returns (uint256);
 218 |     | 
 219 |     |     function gov() external view returns (address);
 220 |     | 
 221 |     |     function guaranteedUsd(address) external view returns (uint256);
 222 |     | 
 223 |     |     function hasDynamicFees() external view returns (bool);
 224 |     | 
 225 |     |     function inManagerMode() external view returns (bool);
 226 |     | 
 227 |     |     function inPrivateLiquidationMode() external view returns (bool);
 228 |     | 
 229 |     |     function includeAmmPrice() external view returns (bool);
 230 |     | 
 231 |     |     function increasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong) external;
 232 |     | 
 233 |     |     function initialize(
 234 |     |         address _router,
 235 |     |         address _usdg,
 236 |     |         address _priceFeed,
 237 |     |         uint256 _liquidationFeeUsd,
 238 |     |         uint256 _fundingRateFactor,
 239 |     |         uint256 _stableFundingRateFactor
 240 |     |     ) external;
 241 |     | 
 242 |     |     function isInitialized() external view returns (bool);
 243 |     | 
 244 |     |     function isLeverageEnabled() external view returns (bool);
 245 |     | 
 246 |     |     function isLiquidator(address) external view returns (bool);
 247 |     | 
 248 |     |     function isManager(address) external view returns (bool);
 249 |     | 
 250 |     |     function isSwapEnabled() external view returns (bool);
 251 |     | 
 252 |     |     function lastFundingTimes(address) external view returns (uint256);
 253 |     | 
 254 |     |     function liquidatePosition(
 255 |     |         address _account,
 256 |     |         address _collateralToken,
 257 |     |         address _indexToken,
 258 |     |         bool _isLong,
 259 |     |         address _feeReceiver
 260 |     |     ) external;
 261 |     | 
 262 |     |     function liquidationFeeUsd() external view returns (uint256);
 263 |     | 
 264 |     |     function marginFeeBasisPoints() external view returns (uint256);
 265 |     | 
 266 |     |     function maxGasPrice() external view returns (uint256);
 267 |     | 
 268 |     |     function maxLeverage() external view returns (uint256);
 269 |     | 
 270 |     |     function maxUsdgAmounts(address) external view returns (uint256);
 271 |     | 
 272 |     |     function minProfitBasisPoints(address) external view returns (uint256);
 273 |     | 
 274 |     |     function minProfitTime() external view returns (uint256);
 275 |     | 
 276 |     |     function mintBurnFeeBasisPoints() external view returns (uint256);
 277 |     | 
 278 |     |     function poolAmounts(address) external view returns (uint256);
 279 |     | 
 280 |     |     function positions(
 281 |     |         bytes32
 282 |     |     )
 283 |     |         external
 284 |     |         view
 285 |     |         returns (
 286 |     |             uint256 size,
 287 |     |             uint256 collateral,
 288 |     |             uint256 averagePrice,
 289 |     |             uint256 entryFundingRate,
 290 |     |             uint256 reserveAmount,
 291 |     |             int256 realisedPnl,
 292 |     |             uint256 lastIncreasedTime
 293 |     |         );
 294 |     | 
 295 |     |     function priceFeed() external view returns (address);
 296 |     | 
 297 |     |     function removeRouter(address _router) external;
 298 |     | 
 299 |     |     function reservedAmounts(address) external view returns (uint256);
 300 |     | 
 301 |     |     function router() external view returns (address);
 302 |     | 
 303 |     |     function sellUSDG(address _token, address _receiver) external returns (uint256);
 304 |     | 
 305 |     |     function setBufferAmount(address _token, uint256 _amount) external;
 306 |     | 
 307 |     |     function setError(uint256 _errorCode, string memory _error) external;
 308 |     | 
 309 |     |     function setErrorController(address _errorController) external;
 310 |     | 
 311 |     |     function setFees(
 312 |     |         uint256 _taxBasisPoints,
 313 |     |         uint256 _stableTaxBasisPoints,
 314 |     |         uint256 _mintBurnFeeBasisPoints,
 315 |     |         uint256 _swapFeeBasisPoints,
 316 |     |         uint256 _stableSwapFeeBasisPoints,
 317 |     |         uint256 _marginFeeBasisPoints,
 318 |     |         uint256 _liquidationFeeUsd,
 319 |     |         uint256 _minProfitTime,
 320 |     |         bool _hasDynamicFees
 321 |     |     ) external;
 322 |     | 
 323 |     |     function setFundingRate(uint256 _fundingInterval, uint256 _fundingRateFactor, uint256 _stableFundingRateFactor) external;
 324 |     | 
 325 |     |     function setGov(address _gov) external;
 326 |     | 
 327 |     |     function setInManagerMode(bool _inManagerMode) external;
 328 |     | 
 329 |     |     function setInPrivateLiquidationMode(bool _inPrivateLiquidationMode) external;
 330 |     | 
 331 |     |     function setIsLeverageEnabled(bool _isLeverageEnabled) external;
 332 |     | 
 333 |     |     function setIsSwapEnabled(bool _isSwapEnabled) external;
 334 |     | 
 335 |     |     function setLiquidator(address _liquidator, bool _isActive) external;
 336 |     | 
 337 |     |     function setManager(address _manager, bool _isManager) external;
 338 |     | 
 339 |     |     function setMaxGasPrice(uint256 _maxGasPrice) external;
 340 |     | 
 341 |     |     function setMaxLeverage(uint256 _maxLeverage) external;
 342 |     | 
 343 |     |     function setPriceFeed(address _priceFeed) external;
 344 |     | 
 345 |     |     function setTokenConfig(
 346 |     |         address _token,
 347 |     |         uint256 _tokenDecimals,
 348 |     |         uint256 _tokenWeight,
 349 |     |         uint256 _minProfitBps,
 350 |     |         uint256 _maxUsdgAmount,
 351 |     |         bool _isStable,
 352 |     |         bool _isShortable
 353 |     |     ) external;
 354 |     | 
 355 |     |     function setUsdgAmount(address _token, uint256 _amount) external;
 356 |     | 
 357 |     |     function shortableTokens(address) external view returns (bool);
 358 |     | 
 359 |     |     function stableFundingRateFactor() external view returns (uint256);
 360 |     | 
 361 |     |     function stableSwapFeeBasisPoints() external view returns (uint256);
 362 |     | 
 363 |     |     function stableTaxBasisPoints() external view returns (uint256);
 364 |     | 
 365 |     |     function stableTokens(address) external view returns (bool);
 366 |     | 
 367 |     |     function swap(address _tokenIn, address _tokenOut, address _receiver) external returns (uint256);
 368 |     | 
 369 |     |     function swapFeeBasisPoints() external view returns (uint256);
 370 |     | 
 371 |     |     function taxBasisPoints() external view returns (uint256);
 372 |     | 
 373 |     |     function tokenBalances(address) external view returns (uint256);
 374 |     | 
 375 |     |     function tokenDecimals(address) external view returns (uint256);
 376 |     | 
 377 |     |     function tokenToUsdMin(address _token, uint256 _tokenAmount) external view returns (uint256);
 378 |     | 
 379 |     |     function tokenWeights(address) external view returns (uint256);
 380 |     | 
 381 |     |     function totalTokenWeights() external view returns (uint256);
 382 |     | 
 383 |     |     function updateCumulativeFundingRate(address _token) external;
 384 |     | 
 385 |     |     function upgradeVault(address _newVault, address _token, uint256 _amount) external;
 386 |     | 
 387 |     |     function usdToToken(address _token, uint256 _usdAmount, uint256 _price) external view returns (uint256);
 388 |     | 
 389 |     |     function usdToTokenMax(address _token, uint256 _usdAmount) external view returns (uint256);
 390 |     | 
 391 |     |     function usdToTokenMin(address _token, uint256 _usdAmount) external view returns (uint256);
 392 |     | 
 393 |     |     function usdg() external view returns (address);
 394 |     | 
 395 |     |     function usdgAmounts(address) external view returns (uint256);
 396 |     | 
 397 |     |     function useSwapPricing() external view returns (bool);
 398 |     | 
 399 |     |     function validateLiquidation(
 400 |     |         address _account,
 401 |     |         address _collateralToken,
 402 |     |         address _indexToken,
 403 |     |         bool _isLong,
 404 |     |         bool _raise
 405 |     |     ) external view returns (uint256, uint256);
 406 |     | 
 407 |     |     function whitelistedTokenCount() external view returns (uint256);
 408 |     | 
 409 |     |     function whitelistedTokens(address) external view returns (bool);
 410 |     | 
 411 |     |     function withdrawFees(address _token, address _receiver) external returns (uint256);
 412 |     | }
 413 |     | 
 414 |     | interface IGmxVester {
 415 |     |     function rewardTracker() external view returns (address);
 416 |     | 
 417 |     |     function claimForAccount(address _account, address _receiver) external returns (uint256);
 418 |     | 
 419 |     |     function claimable(address _account) external view returns (uint256);
 420 |     | 
 421 |     |     function setHasMaxVestableAmount(bool _hasMaxVestableAmount) external;
 422 |     | 
 423 |     |     function cumulativeClaimAmounts(address _account) external view returns (uint256);
 424 |     | 
 425 |     |     function claimedAmounts(address _account) external view returns (uint256);
 426 |     | 
 427 |     |     function pairAmounts(address _account) external view returns (uint256);
 428 |     | 
 429 |     |     function getVestedAmount(address _account) external view returns (uint256);
 430 |     | 
 431 |     |     function transferredAverageStakedAmounts(address _account) external view returns (uint256);
 432 |     | 
 433 |     |     function transferredCumulativeRewards(address _account) external view returns (uint256);
 434 |     | 
 435 |     |     function cumulativeRewardDeductions(address _account) external view returns (uint256);
 436 |     | 
 437 |     |     function bonusRewards(address _account) external view returns (uint256);
 438 |     | 
 439 |     |     function transferStakeValues(address _sender, address _receiver) external;
 440 |     | 
 441 |     |     function setTransferredAverageStakedAmounts(address _account, uint256 _amount) external;
 442 |     | 
 443 |     |     function setTransferredCumulativeRewards(address _account, uint256 _amount) external;
 444 |     | 
 445 |     |     function setCumulativeRewardDeductions(address _account, uint256 _amount) external;
 446 |     | 
 447 |     |     function setBonusRewards(address _account, uint256 _amount) external;
 448 |     | 
 449 |     |     function getMaxVestableAmount(address _account) external view returns (uint256);
 450 |     | 
 451 |     |     function getCombinedAverageStakedAmount(address _account) external view returns (uint256);
 452 |     | 
 453 |     |     function deposit(uint256 _amount) external;
 454 |     | 
 455 |     |     function withdraw() external;
 456 |     | 
 457 |     |     function claim() external returns (uint256);
 458 |     | 
 459 |     |     function getTotalVested(address _account) external view returns (uint256);
 460 |     | 
 461 |     |     function balances(address account) external view returns (uint256);
 462 |     | }
 463 |     | 
 464 |     | interface IVaultPriceFeed {
 465 |     |     function adjustmentBasisPoints(address _token) external view returns (uint256);
 466 |     | 
 467 |     |     function isAdjustmentAdditive(address _token) external view returns (bool);
 468 |     | 
 469 |     |     function setAdjustment(address _token, bool _isAdditive, uint256 _adjustmentBps) external;
 470 |     | 
 471 |     |     function setUseV2Pricing(bool _useV2Pricing) external;
 472 |     | 
 473 |     |     function setIsAmmEnabled(bool _isEnabled) external;
 474 |     | 
 475 |     |     function setIsSecondaryPriceEnabled(bool _isEnabled) external;
 476 |     | 
 477 |     |     function setSpreadBasisPoints(address _token, uint256 _spreadBasisPoints) external;
 478 |     | 
 479 |     |     function setSpreadThresholdBasisPoints(uint256 _spreadThresholdBasisPoints) external;
 480 |     | 
 481 |     |     function setFavorPrimaryPrice(bool _favorPrimaryPrice) external;
 482 |     | 
 483 |     |     function setPriceSampleSpace(uint256 _priceSampleSpace) external;
 484 |     | 
 485 |     |     function setMaxStrictPriceDeviation(uint256 _maxStrictPriceDeviation) external;
 486 |     | 
 487 |     |     function getPrice(address _token, bool _maximise, bool _includeAmmPrice, bool _useSwapPricing) external view returns (uint256);
 488 |     | 
 489 |     |     function getAmmPrice(address _token) external view returns (uint256);
 490 |     | 
 491 |     |     function getPrimaryPrice(address _token, bool _maximise) external view returns (uint256);
 492 |     | }
 493 |     | 
 494 |     | interface IGmxRewardDistributor {
 495 |     |     function pendingRewards() external view returns (uint256);
 496 |     | 
 497 |     |     function distribute() external returns (uint256);
 498 |     | }
 499 |     | 
 500 |     | interface IGmxRewardRouterV2 {
 501 |     |     type VotingPowerType is uint8;
 502 |     | 
 503 |     |     event StakeGlp(address account, uint256 amount);
 504 |     |     event StakeGmx(address account, address token, uint256 amount);
 505 |     |     event UnstakeGlp(address account, uint256 amount);
 506 |     |     event UnstakeGmx(address account, address token, uint256 amount);
 507 |     | 
 508 |     |     function BASIS_POINTS_DIVISOR() external view returns (uint256);
 509 |     | 
 510 |     |     function acceptTransfer(address _sender) external;
 511 |     | 
 512 |     |     function batchCompoundForAccounts(address[] memory _accounts) external;
 513 |     | 
 514 |     |     function batchStakeGmxForAccount(address[] memory _accounts, uint256[] memory _amounts) external;
 515 |     | 
 516 |     |     function bnGmx() external view returns (address);
 517 |     | 
 518 |     |     function bonusGmxTracker() external view returns (address);
 519 |     | 
 520 |     |     function claim() external;
 521 |     | 
 522 |     |     function claimEsGmx() external;
 523 |     | 
 524 |     |     function claimFees() external;
 525 |     | 
 526 |     |     function compound() external;
 527 |     | 
 528 |     |     function compoundForAccount(address _account) external;
 529 |     | 
 530 |     |     function esGmx() external view returns (address);
 531 |     | 
 532 |     |     function feeGlpTracker() external view returns (address);
 533 |     | 
 534 |     |     function feeGmxTracker() external view returns (address);
 535 |     | 
 536 |     |     function glp() external view returns (address);
 537 |     | 
 538 |     |     function glpManager() external view returns (address);
 539 |     | 
 540 |     |     function glpVester() external view returns (address);
 541 |     | 
 542 |     |     function gmx() external view returns (address);
 543 |     | 
 544 |     |     function gmxVester() external view returns (address);
 545 |     | 
 546 |     |     function gov() external view returns (address);
 547 |     | 
 548 |     |     function govToken() external view returns (address);
 549 |     | 
 550 |     |     function handleRewards(
 551 |     |         bool shouldClaimGmx,
 552 |     |         bool shouldStakeGmx,
 553 |     |         bool shouldClaimEsGmx,
 554 |     |         bool shouldStakeEsGmx,
 555 |     |         bool shouldStakeMultiplierPoints,
 556 |     |         bool shouldClaimWeth,
 557 |     |         bool shouldConvertWethToEth
 558 |     |     ) external;
 559 |     | 
 560 |     |     function inStrictTransferMode() external view returns (bool);
 561 |     | 
 562 |     |     function initialize(
 563 |     |         address _weth,
 564 |     |         address _gmx,
 565 |     |         address _esGmx,
 566 |     |         address _bnGmx,
 567 |     |         address _glp,
 568 |     |         address _stakedGmxTracker,
 569 |     |         address _bonusGmxTracker,
 570 |     |         address _feeGmxTracker,
 571 |     |         address _feeGlpTracker,
 572 |     |         address _stakedGlpTracker,
 573 |     |         address _glpManager,
 574 |     |         address _gmxVester,
 575 |     |         address _glpVester,
 576 |     |         address _govToken
 577 |     |     ) external;
 578 |     | 
 579 |     |     function isInitialized() external view returns (bool);
 580 |     | 
 581 |     |     function maxBoostBasisPoints() external view returns (uint256);
 582 |     | 
 583 |     |     function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns (uint256);
 584 |     | 
 585 |     |     function mintAndStakeGlpETH(uint256 _minUsdg, uint256 _minGlp) external payable returns (uint256);
 586 |     | 
 587 |     |     function pendingReceivers(address) external view returns (address);
 588 |     | 
 589 |     |     function setGov(address _gov) external;
 590 |     | 
 591 |     |     function setInStrictTransferMode(bool _inStrictTransferMode) external;
 592 |     | 
 593 |     |     function setMaxBoostBasisPoints(uint256 _maxBoostBasisPoints) external;
 594 |     | 
 595 |     |     function setVotingPowerType(VotingPowerType _votingPowerType) external;
 596 |     | 
 597 |     |     function signalTransfer(address _receiver) external;
 598 |     | 
 599 |     |     function stakeEsGmx(uint256 _amount) external;
 600 |     | 
 601 |     |     function stakeGmx(uint256 _amount) external;
 602 |     | 
 603 |     |     function stakeGmxForAccount(address _account, uint256 _amount) external;
 604 |     | 
 605 |     |     function stakedGlpTracker() external view returns (address);
 606 |     | 
 607 |     |     function stakedGmxTracker() external view returns (address);
 608 |     | 
 609 |     |     function unstakeAndRedeemGlp(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);
 610 |     | 
 611 |     |     function unstakeAndRedeemGlpETH(uint256 _glpAmount, uint256 _minOut, address payable _receiver) external returns (uint256);
 612 |     | 
 613 |     |     function unstakeEsGmx(uint256 _amount) external;
 614 |     | 
 615 |     |     function unstakeGmx(uint256 _amount) external;
 616 |     | 
 617 |     |     function votingPowerType() external view returns (VotingPowerType);
 618 |     | 
 619 |     |     function weth() external view returns (address);
 620 |     | 
 621 |     |     function withdrawToken(address _token, address _account, uint256 _amount) external;
 622 |     | }
 623 |     | 
 624 |     | interface IGmxRewardTracker {
 625 |     |     function rewardToken() external view returns (address);
 626 |     | 
 627 |     |     function depositBalances(address _account, address _depositToken) external view returns (uint256);
 628 |     | 
 629 |     |     function stakedAmounts(address _account) external view returns (uint256);
 630 |     | 
 631 |     |     function updateRewards() external;
 632 |     | 
 633 |     |     function stake(address _depositToken, uint256 _amount) external;
 634 |     | 
 635 |     |     function stakeForAccount(address _fundingAccount, address _account, address _depositToken, uint256 _amount) external;
 636 |     | 
 637 |     |     function unstake(address _depositToken, uint256 _amount) external;
 638 |     | 
 639 |     |     function unstakeForAccount(address _account, address _depositToken, uint256 _amount, address _receiver) external;
 640 |     | 
 641 |     |     function tokensPerInterval() external view returns (uint256);
 642 |     | 
 643 |     |     function claim(address _receiver) external returns (uint256);
 644 |     | 
 645 |     |     function claimForAccount(address _account, address _receiver) external returns (uint256);
 646 |     | 
 647 |     |     function claimable(address _account) external view returns (uint256);
 648 |     | 
 649 |     |     function averageStakedAmounts(address _account) external view returns (uint256);
 650 |     | 
 651 |     |     function cumulativeRewards(address _account) external view returns (uint256);
 652 |     | }
 653 |     | 
 654 |     | interface IGmxStakedGlp {
 655 |     |     function allowance(address _owner, address _spender) external view returns (uint256);
 656 |     | 
 657 |     |     function allowances(address, address) external view returns (uint256);
 658 |     | 
 659 |     |     function approve(address _spender, uint256 _amount) external returns (bool);
 660 |     | 
 661 |     |     function balanceOf(address _account) external view returns (uint256);
 662 |     | 
 663 |     |     function decimals() external view returns (uint8);
 664 |     | 
 665 |     |     function feeGlpTracker() external view returns (address);
 666 |     | 
 667 |     |     function glp() external view returns (address);
 668 |     | 
 669 |     |     function glpManager() external view returns (address);
 670 |     | 
 671 |     |     function name() external view returns (string memory);
 672 |     | 
 673 |     |     function stakedGlpTracker() external view returns (address);
 674 |     | 
 675 |     |     function symbol() external view returns (string memory);
 676 |     | 
 677 |     |     function totalSupply() external view returns (uint256);
 678 |     | 
 679 |     |     function transfer(address _recipient, uint256 _amount) external returns (bool);
 680 |     | 
 681 |     |     function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool);
 682 |     | }
 683 |     | 
 684 |     | interface IGmxGlpRewardRouter {
 685 |     |     event StakeGlp(address account, uint256 amount);
 686 |     |     event StakeGmx(address account, address token, uint256 amount);
 687 |     |     event UnstakeGlp(address account, uint256 amount);
 688 |     |     event UnstakeGmx(address account, address token, uint256 amount);
 689 |     | 
 690 |     |     function acceptTransfer(address _sender) external;
 691 |     | 
 692 |     |     function batchCompoundForAccounts(address[] memory _accounts) external;
 693 |     | 
 694 |     |     function batchStakeGmxForAccount(address[] memory _accounts, uint256[] memory _amounts) external;
 695 |     | 
 696 |     |     function claim() external;
 697 |     | 
 698 |     |     function claimEsGmx() external;
 699 |     | 
 700 |     |     function claimFees() external;
 701 |     | 
 702 |     |     function compound() external;
 703 |     | 
 704 |     |     function compoundForAccount(address _account) external;
 705 |     | 
 706 |     |     function feeGlpTracker() external view returns (address);
 707 |     | 
 708 |     |     function glp() external view returns (address);
 709 |     | 
 710 |     |     function glpManager() external view returns (address);
 711 |     | 
 712 |     |     function gov() external view returns (address);
 713 |     | 
 714 |     |     function handleRewards(
 715 |     |         bool shouldClaimGmx,
 716 |     |         bool shouldStakeGmx,
 717 |     |         bool shouldClaimEsGmx,
 718 |     |         bool shouldStakeEsGmx,
 719 |     |         bool shouldStakeMultiplierPoints,
 720 |     |         bool shouldClaimWeth,
 721 |     |         bool shouldConvertWethToEth
 722 |     |     ) external;
 723 |     | 
 724 |     |     function initialize(
 725 |     |         address _weth,
 726 |     |         address _gmx,
 727 |     |         address _esGmx,
 728 |     |         address _bnGmx,
 729 |     |         address _glp,
 730 |     |         address _stakedGmxTracker,
 731 |     |         address _bonusGmxTracker,
 732 |     |         address _feeGmxTracker,
 733 |     |         address _feeGlpTracker,
 734 |     |         address _stakedGlpTracker,
 735 |     |         address _glpManager,
 736 |     |         address _gmxVester,
 737 |     |         address _glpVester
 738 |     |     ) external;
 739 |     | 
 740 |     |     function isInitialized() external view returns (bool);
 741 |     | 
 742 |     |     function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns (uint256);
 743 |     | 
 744 |     |     function mintAndStakeGlpETH(uint256 _minUsdg, uint256 _minGlp) external payable returns (uint256);
 745 |     | 
 746 |     |     function pendingReceivers(address) external view returns (address);
 747 |     | 
 748 |     |     function setGov(address _gov) external;
 749 |     | 
 750 |     |     function signalTransfer(address _receiver) external;
 751 |     | 
 752 |     |     function stakeEsGmx(uint256 _amount) external;
 753 |     | 
 754 |     |     function stakeGmx(uint256 _amount) external;
 755 |     | 
 756 |     |     function stakeGmxForAccount(address _account, uint256 _amount) external;
 757 |     | 
 758 |     |     function stakedGlpTracker() external view returns (address);
 759 |     | 
 760 |     |     function stakedGmxTracker() external view returns (address);
 761 |     | 
 762 |     |     function unstakeAndRedeemGlp(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);
 763 |     | 
 764 |     |     function unstakeAndRedeemGlpETH(uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);
 765 |     | 
 766 |     |     function unstakeEsGmx(uint256 _amount) external;
 767 |     | 
 768 |     |     function unstakeGmx(uint256 _amount) external;
 769 |     | 
 770 |     |     function withdrawToken(address _token, address _account, uint256 _amount) external;
 771 |     | }
 772 |     | 
 773 |     | interface IGmxGlpManager {
 774 |     |     event AddLiquidity(
 775 |     |         address account,
 776 |     |         address token,
 777 |     |         uint256 amount,
 778 |     |         uint256 aumInUsdg,
 779 |     |         uint256 glpSupply,
 780 |     |         uint256 usdgAmount,
 781 |     |         uint256 mintAmount
 782 |     |     );
 783 |     |     event RemoveLiquidity(
 784 |     |         address account,
 785 |     |         address token,
 786 |     |         uint256 glpAmount,
 787 |     |         uint256 aumInUsdg,
 788 |     |         uint256 glpSupply,
 789 |     |         uint256 usdgAmount,
 790 |     |         uint256 amountOut
 791 |     |     );
 792 |     | 
 793 |     |     function BASIS_POINTS_DIVISOR() external view returns (uint256);
 794 |     | 
 795 |     |     function GLP_PRECISION() external view returns (uint256);
 796 |     | 
 797 |     |     function MAX_COOLDOWN_DURATION() external view returns (uint256);
 798 |     | 
 799 |     |     function PRICE_PRECISION() external view returns (uint256);
 800 |     | 
 801 |     |     function USDG_DECIMALS() external view returns (uint256);
 802 |     | 
 803 |     |     function addLiquidity(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns (uint256);
 804 |     | 
 805 |     |     function addLiquidityForAccount(
 806 |     |         address _fundingAccount,
 807 |     |         address _account,
 808 |     |         address _token,
 809 |     |         uint256 _amount,
 810 |     |         uint256 _minUsdg,
 811 |     |         uint256 _minGlp
 812 |     |     ) external returns (uint256);
 813 |     | 
 814 |     |     function aumAddition() external view returns (uint256);
 815 |     | 
 816 |     |     function aumDeduction() external view returns (uint256);
 817 |     | 
 818 |     |     function cooldownDuration() external view returns (uint256);
 819 |     | 
 820 |     |     function getAum(bool maximise) external view returns (uint256);
 821 |     | 
 822 |     |     function getAumInUsdg(bool maximise) external view returns (uint256);
 823 |     | 
 824 |     |     function getAums() external view returns (uint256[] memory);
 825 |     | 
 826 |     |     function getGlobalShortAveragePrice(address _token) external view returns (uint256);
 827 |     | 
 828 |     |     function getGlobalShortDelta(address _token, uint256 _price, uint256 _size) external view returns (uint256, bool);
 829 |     | 
 830 |     |     function getPrice(bool _maximise) external view returns (uint256);
 831 |     | 
 832 |     |     function glp() external view returns (address);
 833 |     | 
 834 |     |     function gov() external view returns (address);
 835 |     | 
 836 |     |     function inPrivateMode() external view returns (bool);
 837 |     | 
 838 |     |     function isHandler(address) external view returns (bool);
 839 |     | 
 840 |     |     function lastAddedAt(address) external view returns (uint256);
 841 |     | 
 842 |     |     function removeLiquidity(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);
 843 |     | 
 844 |     |     function removeLiquidityForAccount(
 845 |     |         address _account,
 846 |     |         address _tokenOut,
 847 |     |         uint256 _glpAmount,
 848 |     |         uint256 _minOut,
 849 |     |         address _receiver
 850 |     |     ) external returns (uint256);
 851 |     | 
 852 |     |     function setAumAdjustment(uint256 _aumAddition, uint256 _aumDeduction) external;
 853 |     | 
 854 |     |     function setCooldownDuration(uint256 _cooldownDuration) external;
 855 |     | 
 856 |     |     function setGov(address _gov) external;
 857 |     | 
 858 |     |     function setHandler(address _handler, bool _isActive) external;
 859 |     | 
 860 |     |     function setInPrivateMode(bool _inPrivateMode) external;
 861 |     | 
 862 |     |     function setShortsTracker(address _shortsTracker) external;
 863 |     | 
 864 |     |     function setShortsTrackerAveragePriceWeight(uint256 _shortsTrackerAveragePriceWeight) external;
 865 |     | 
 866 |     |     function shortsTracker() external view returns (address);
 867 |     | 
 868 |     |     function shortsTrackerAveragePriceWeight() external view returns (uint256);
 869 |     | 
 870 |     |     function usdg() external view returns (address);
 871 |     | 
 872 |     |     function vault() external view returns (address);
 873 |     | }
 874 |     | 
 875 |     | interface IGmxGlpRewardHandler {
 876 |     |     function harvest() external;
 877 |     | 
 878 |     |     function swapRewards(
 879 |     |         uint256 amountOutMin,
 880 |     |         IERC20 rewardToken,
 881 |     |         IERC20 outputToken,
 882 |     |         address recipient,
 883 |     |         bytes calldata data
 884 |     |     ) external returns (uint256 amountOut);
 885 |     | 
 886 |     |     function setFeeParameters(address _feeCollector, uint8 _feePercent) external;
 887 |     | 
 888 |     |     function setRewardTokenEnabled(IERC20 token, bool enabled) external;
 889 |     | 
 890 |     |     function setSwappingTokenOutEnabled(IERC20 token, bool enabled) external;
 891 |     | 
 892 |     |     function setAllowedSwappingRecipient(address recipient, bool enabled) external;
 893 |     | 
 894 |     |     function setRewardRouter(IGmxRewardRouterV2 _rewardRouter) external;
 895 |     | 
 896 |     |     function setSwapper(address _swapper) external;
 897 |     | 
 898 |     |     function unstakeGmx(uint256 amount, uint256 amountTransferToFeeCollector) external;
 899 |     | 
 900 |     |     function unstakeEsGmxAndVest(uint256 amount, uint256 glpVesterDepositAmount, uint256 gmxVesterDepositAmount) external;
 901 |     | 
 902 |     |     function withdrawFromVesting(bool withdrawFromGlpVester, bool withdrawFromGmxVester, bool stake) external;
 903 |     | 
 904 |     |     function claimVestedGmx(bool withdrawFromGlpVester, bool withdrawFromGmxVester, bool stake, bool transferToFeeCollecter) external;
 905 |     | }
 906 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IGmxV2.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | // @title Deposit
   5 |     | // @dev Struct for deposits
   6 |     | interface IGmxV2Deposit {
   7 |     |     /** @dev CreateDepositParams struct used in createDeposit to avoid stack
   8 |     |      * too deep errors
   9 |     |      *
  10 |     |      * @param receiver the address to send the market tokens to
  11 |     |      * @param callbackContract the callback contract
  12 |     |      * @param uiFeeReceiver the ui fee receiver
  13 |     |      * @param market the market to deposit into
  14 |     |      * @param minMarketTokens the minimum acceptable number of liquidity tokens
  15 |     |      * @param shouldUnwrapNativeToken whether to unwrap the native token when
  16 |     |      * sending funds back to the user in case the deposit gets cancelled
  17 |     |      * @param executionFee the execution fee for keepers
  18 |     |      * @param callbackGasLimit the gas limit for the callbackContract
  19 |     |      */
  20 |     |     struct CreateDepositParams {
  21 |     |         address receiver;
  22 |     |         address callbackContract;
  23 |     |         address uiFeeReceiver;
  24 |     |         address market;
  25 |     |         address initialLongToken;
  26 |     |         address initialShortToken;
  27 |     |         address[] longTokenSwapPath;
  28 |     |         address[] shortTokenSwapPath;
  29 |     |         uint256 minMarketTokens;
  30 |     |         bool shouldUnwrapNativeToken;
  31 |     |         uint256 executionFee;
  32 |     |         uint256 callbackGasLimit;
  33 |     |     }
  34 |     | 
  35 |     |     // @dev there is a limit on the number of fields a struct can have when being passed
  36 |     |     // or returned as a memory variable which can cause "Stack too deep" errors
  37 |     |     // use sub-structs to avoid this issue
  38 |     |     // @param addresses address values
  39 |     |     // @param numbers number values
  40 |     |     // @param flags boolean values
  41 |     |     struct Props {
  42 |     |         Addresses addresses;
  43 |     |         Numbers numbers;
  44 |     |         Flags flags;
  45 |     |     }
  46 |     | 
  47 |     |     // @param account the account depositing liquidity
  48 |     |     // @param receiver the address to send the liquidity tokens to
  49 |     |     // @param callbackContract the callback contract
  50 |     |     // @param uiFeeReceiver the ui fee receiver
  51 |     |     // @param market the market to deposit to
  52 |     |     struct Addresses {
  53 |     |         address account;
  54 |     |         address receiver;
  55 |     |         address callbackContract;
  56 |     |         address uiFeeReceiver;
  57 |     |         address market;
  58 |     |         address initialLongToken;
  59 |     |         address initialShortToken;
  60 |     |         address[] longTokenSwapPath;
  61 |     |         address[] shortTokenSwapPath;
  62 |     |     }
  63 |     | 
  64 |     |     // @param initialLongTokenAmount the amount of long tokens to deposit
  65 |     |     // @param initialShortTokenAmount the amount of short tokens to deposit
  66 |     |     // @param minMarketTokens the minimum acceptable number of liquidity tokens
  67 |     |     // @param updatedAtBlock the block that the deposit was last updated at
  68 |     |     // sending funds back to the user in case the deposit gets cancelled
  69 |     |     // @param executionFee the execution fee for keepers
  70 |     |     // @param callbackGasLimit the gas limit for the callbackContract
  71 |     |     struct Numbers {
  72 |     |         uint256 initialLongTokenAmount;
  73 |     |         uint256 initialShortTokenAmount;
  74 |     |         uint256 minMarketTokens;
  75 |     |         uint256 updatedAtBlock;
  76 |     |         uint256 executionFee;
  77 |     |         uint256 callbackGasLimit;
  78 |     |     }
  79 |     | 
  80 |     |     // @param shouldUnwrapNativeToken whether to unwrap the native token when
  81 |     |     struct Flags {
  82 |     |         bool shouldUnwrapNativeToken;
  83 |     |     }
  84 |     | }
  85 |     | 
  86 |     | interface IGmxV2Withdrawal {
  87 |     |     /**
  88 |     |      * @param receiver The address that will receive the withdrawal tokens.
  89 |     |      * @param callbackContract The contract that will be called back.
  90 |     |      * @param market The market on which the withdrawal will be executed.
  91 |     |      * @param minLongTokenAmount The minimum amount of long tokens that must be withdrawn.
  92 |     |      * @param minShortTokenAmount The minimum amount of short tokens that must be withdrawn.
  93 |     |      * @param shouldUnwrapNativeToken Whether the native token should be unwrapped when executing the withdrawal.
  94 |     |      * @param executionFee The execution fee for the withdrawal.
  95 |     |      * @param callbackGasLimit The gas limit for calling the callback contract.
  96 |     |      */
  97 |     |     struct CreateWithdrawalParams {
  98 |     |         address receiver;
  99 |     |         address callbackContract;
 100 |     |         address uiFeeReceiver;
 101 |     |         address market;
 102 |     |         address[] longTokenSwapPath;
 103 |     |         address[] shortTokenSwapPath;
 104 |     |         uint256 minLongTokenAmount;
 105 |     |         uint256 minShortTokenAmount;
 106 |     |         bool shouldUnwrapNativeToken;
 107 |     |         uint256 executionFee;
 108 |     |         uint256 callbackGasLimit;
 109 |     |     }
 110 |     | 
 111 |     |     // @dev there is a limit on the number of fields a struct can have when being passed
 112 |     |     // or returned as a memory variable which can cause "Stack too deep" errors
 113 |     |     // use sub-structs to avoid this issue
 114 |     |     // @param addresses address values
 115 |     |     // @param numbers number values
 116 |     |     // @param flags boolean values
 117 |     |     struct Props {
 118 |     |         Addresses addresses;
 119 |     |         Numbers numbers;
 120 |     |         Flags flags;
 121 |     |     }
 122 |     | 
 123 |     |     // @param account The account to withdraw for.
 124 |     |     // @param receiver The address that will receive the withdrawn tokens.
 125 |     |     // @param callbackContract The contract that will be called back.
 126 |     |     // @param uiFeeReceiver The ui fee receiver.
 127 |     |     // @param market The market on which the withdrawal will be executed.
 128 |     |     struct Addresses {
 129 |     |         address account;
 130 |     |         address receiver;
 131 |     |         address callbackContract;
 132 |     |         address uiFeeReceiver;
 133 |     |         address market;
 134 |     |         address[] longTokenSwapPath;
 135 |     |         address[] shortTokenSwapPath;
 136 |     |     }
 137 |     | 
 138 |     |     // @param marketTokenAmount The amount of market tokens that will be withdrawn.
 139 |     |     // @param minLongTokenAmount The minimum amount of long tokens that must be withdrawn.
 140 |     |     // @param minShortTokenAmount The minimum amount of short tokens that must be withdrawn.
 141 |     |     // @param updatedAtBlock The block at which the withdrawal was last updated.
 142 |     |     // @param executionFee The execution fee for the withdrawal.
 143 |     |     // @param callbackGasLimit The gas limit for calling the callback contract.
 144 |     |     struct Numbers {
 145 |     |         uint256 marketTokenAmount;
 146 |     |         uint256 minLongTokenAmount;
 147 |     |         uint256 minShortTokenAmount;
 148 |     |         uint256 updatedAtBlock;
 149 |     |         uint256 executionFee;
 150 |     |         uint256 callbackGasLimit;
 151 |     |     }
 152 |     | 
 153 |     |     // @param shouldUnwrapNativeToken whether to unwrap the native token when
 154 |     |     struct Flags {
 155 |     |         bool shouldUnwrapNativeToken;
 156 |     |     }
 157 |     | }
 158 |     | 
 159 |     | interface IGmxV2EventUtils {
 160 |     |     struct EmitPositionDecreaseParams {
 161 |     |         bytes32 key;
 162 |     |         address account;
 163 |     |         address market;
 164 |     |         address collateralToken;
 165 |     |         bool isLong;
 166 |     |     }
 167 |     | 
 168 |     |     struct EventLogData {
 169 |     |         AddressItems addressItems;
 170 |     |         UintItems uintItems;
 171 |     |         IntItems intItems;
 172 |     |         BoolItems boolItems;
 173 |     |         Bytes32Items bytes32Items;
 174 |     |         BytesItems bytesItems;
 175 |     |         StringItems stringItems;
 176 |     |     }
 177 |     | 
 178 |     |     struct AddressItems {
 179 |     |         AddressKeyValue[] items;
 180 |     |         AddressArrayKeyValue[] arrayItems;
 181 |     |     }
 182 |     | 
 183 |     |     struct UintItems {
 184 |     |         UintKeyValue[] items;
 185 |     |         UintArrayKeyValue[] arrayItems;
 186 |     |     }
 187 |     | 
 188 |     |     struct IntItems {
 189 |     |         IntKeyValue[] items;
 190 |     |         IntArrayKeyValue[] arrayItems;
 191 |     |     }
 192 |     | 
 193 |     |     struct BoolItems {
 194 |     |         BoolKeyValue[] items;
 195 |     |         BoolArrayKeyValue[] arrayItems;
 196 |     |     }
 197 |     | 
 198 |     |     struct Bytes32Items {
 199 |     |         Bytes32KeyValue[] items;
 200 |     |         Bytes32ArrayKeyValue[] arrayItems;
 201 |     |     }
 202 |     | 
 203 |     |     struct BytesItems {
 204 |     |         BytesKeyValue[] items;
 205 |     |         BytesArrayKeyValue[] arrayItems;
 206 |     |     }
 207 |     | 
 208 |     |     struct StringItems {
 209 |     |         StringKeyValue[] items;
 210 |     |         StringArrayKeyValue[] arrayItems;
 211 |     |     }
 212 |     | 
 213 |     |     struct AddressKeyValue {
 214 |     |         string key;
 215 |     |         address value;
 216 |     |     }
 217 |     | 
 218 |     |     struct AddressArrayKeyValue {
 219 |     |         string key;
 220 |     |         address[] value;
 221 |     |     }
 222 |     | 
 223 |     |     struct UintKeyValue {
 224 |     |         string key;
 225 |     |         uint256 value;
 226 |     |     }
 227 |     | 
 228 |     |     struct UintArrayKeyValue {
 229 |     |         string key;
 230 |     |         uint256[] value;
 231 |     |     }
 232 |     | 
 233 |     |     struct IntKeyValue {
 234 |     |         string key;
 235 |     |         int256 value;
 236 |     |     }
 237 |     | 
 238 |     |     struct IntArrayKeyValue {
 239 |     |         string key;
 240 |     |         int256[] value;
 241 |     |     }
 242 |     | 
 243 |     |     struct BoolKeyValue {
 244 |     |         string key;
 245 |     |         bool value;
 246 |     |     }
 247 |     | 
 248 |     |     struct BoolArrayKeyValue {
 249 |     |         string key;
 250 |     |         bool[] value;
 251 |     |     }
 252 |     | 
 253 |     |     struct Bytes32KeyValue {
 254 |     |         string key;
 255 |     |         bytes32 value;
 256 |     |     }
 257 |     | 
 258 |     |     struct Bytes32ArrayKeyValue {
 259 |     |         string key;
 260 |     |         bytes32[] value;
 261 |     |     }
 262 |     | 
 263 |     |     struct BytesKeyValue {
 264 |     |         string key;
 265 |     |         bytes value;
 266 |     |     }
 267 |     | 
 268 |     |     struct BytesArrayKeyValue {
 269 |     |         string key;
 270 |     |         bytes[] value;
 271 |     |     }
 272 |     | 
 273 |     |     struct StringKeyValue {
 274 |     |         string key;
 275 |     |         string value;
 276 |     |     }
 277 |     | 
 278 |     |     struct StringArrayKeyValue {
 279 |     |         string key;
 280 |     |         string[] value;
 281 |     |     }
 282 |     | }
 283 |     | 
 284 |     | interface IGmxV2Market {
 285 |     |     // @param marketToken address of the market token for the market
 286 |     |     // @param indexToken address of the index token for the market
 287 |     |     // @param longToken address of the long token for the market
 288 |     |     // @param shortToken address of the short token for the market
 289 |     |     // @param data for any additional data
 290 |     |     struct Props {
 291 |     |         address marketToken;
 292 |     |         address indexToken;
 293 |     |         address longToken;
 294 |     |         address shortToken;
 295 |     |     }
 296 |     | }
 297 |     | 
 298 |     | // @title Price
 299 |     | // @dev Struct for prices
 300 |     | interface IGmxV2Price {
 301 |     |     // @param min the min price
 302 |     |     // @param max the max price
 303 |     |     struct Props {
 304 |     |         uint256 min;
 305 |     |         uint256 max;
 306 |     |     }
 307 |     | }
 308 |     | 
 309 |     | // @title MarketPoolInfo
 310 |     | interface IGmxV2MarketPoolValueInfo {
 311 |     |     // @dev struct to avoid stack too deep errors for the getPoolValue call
 312 |     |     // @param value the pool value
 313 |     |     // @param longTokenAmount the amount of long token in the pool
 314 |     |     // @param shortTokenAmount the amount of short token in the pool
 315 |     |     // @param longTokenUsd the USD value of the long tokens in the pool
 316 |     |     // @param shortTokenUsd the USD value of the short tokens in the pool
 317 |     |     // @param totalBorrowingFees the total pending borrowing fees for the market
 318 |     |     // @param borrowingFeePoolFactor the pool factor for borrowing fees
 319 |     |     // @param impactPoolAmount the amount of tokens in the impact pool
 320 |     |     // @param longPnl the pending pnl of long positions
 321 |     |     // @param shortPnl the pending pnl of short positions
 322 |     |     // @param netPnl the net pnl of long and short positions
 323 |     |     struct Props {
 324 |     |         int256 poolValue;
 325 |     |         int256 longPnl;
 326 |     |         int256 shortPnl;
 327 |     |         int256 netPnl;
 328 |     |         uint256 longTokenAmount;
 329 |     |         uint256 shortTokenAmount;
 330 |     |         uint256 longTokenUsd;
 331 |     |         uint256 shortTokenUsd;
 332 |     |         uint256 totalBorrowingFees;
 333 |     |         uint256 borrowingFeePoolFactor;
 334 |     |         uint256 impactPoolAmount;
 335 |     |     }
 336 |     | }
 337 |     | 
 338 |     | // @title IDepositCallbackReceiver
 339 |     | // @dev interface for a deposit callback contract
 340 |     | interface IGmxV2DepositCallbackReceiver {
 341 |     |     // @dev called after a deposit execution
 342 |     |     // @param key the key of the deposit
 343 |     |     // @param deposit the deposit that was executed
 344 |     |     function afterDepositExecution(
 345 |     |         bytes32 key,
 346 |     |         IGmxV2Deposit.Props memory deposit,
 347 |     |         IGmxV2EventUtils.EventLogData memory eventData
 348 |     |     ) external;
 349 |     | 
 350 |     |     // @dev called after a deposit cancellation
 351 |     |     // @param key the key of the deposit
 352 |     |     // @param deposit the deposit that was cancelled
 353 |     |     function afterDepositCancellation(
 354 |     |         bytes32 key,
 355 |     |         IGmxV2Deposit.Props memory deposit,
 356 |     |         IGmxV2EventUtils.EventLogData memory eventData
 357 |     |     ) external;
 358 |     | }
 359 |     | 
 360 |     | // @title IWithdrawalCallbackReceiver
 361 |     | // @dev interface for a withdrawal callback contract
 362 |     | interface IGmxV2WithdrawalCallbackReceiver {
 363 |     |     // @dev called after a withdrawal execution
 364 |     |     // @param key the key of the withdrawal
 365 |     |     // @param withdrawal the withdrawal that was executed
 366 |     |     function afterWithdrawalExecution(
 367 |     |         bytes32 key,
 368 |     |         IGmxV2Withdrawal.Props memory withdrawal,
 369 |     |         IGmxV2EventUtils.EventLogData memory eventData
 370 |     |     ) external;
 371 |     | 
 372 |     |     // @dev called after a withdrawal cancellation
 373 |     |     // @param key the key of the withdrawal
 374 |     |     // @param withdrawal the withdrawal that was cancelled
 375 |     |     function afterWithdrawalCancellation(
 376 |     |         bytes32 key,
 377 |     |         IGmxV2Withdrawal.Props memory withdrawal,
 378 |     |         IGmxV2EventUtils.EventLogData memory eventData
 379 |     |     ) external;
 380 |     | }
 381 |     | 
 382 |     | interface IGmxDataStore {
 383 |     |     function containsBytes32(bytes32 setKey, bytes32 value) external view returns (bool);
 384 |     | 
 385 |     |     function roleStore() external view returns (IGmxRoleStore);
 386 |     | 
 387 |     |     function getBool(bytes32 key) external view returns (bool);
 388 |     | }
 389 |     | 
 390 |     | interface IGmxRoleStore {
 391 |     |     function hasRole(address account, bytes32 roleKey) external view returns (bool);
 392 |     | }
 393 |     | 
 394 |     | interface IGmxReader {
 395 |     |     function getMarket(address dataStore, address key) external view returns (IGmxV2Market.Props memory);
 396 |     | 
 397 |     |     // @dev get the market token's price
 398 |     |     // @param dataStore DataStore
 399 |     |     // @param market the market to check
 400 |     |     // @param longTokenPrice the price of the long token
 401 |     |     // @param shortTokenPrice the price of the short token
 402 |     |     // @param indexTokenPrice the price of the index token
 403 |     |     // @param maximize whether to maximize or minimize the market token price
 404 |     |     // @return returns (the market token's price, MarketPoolValueInfo.Props)
 405 |     |     function getMarketTokenPrice(
 406 |     |         address dataStore,
 407 |     |         IGmxV2Market.Props memory market,
 408 |     |         IGmxV2Price.Props memory indexTokenPrice,
 409 |     |         IGmxV2Price.Props memory longTokenPrice,
 410 |     |         IGmxV2Price.Props memory shortTokenPrice,
 411 |     |         bytes32 pnlFactorType,
 412 |     |         bool maximize
 413 |     |     ) external view returns (int256, IGmxV2MarketPoolValueInfo.Props memory);
 414 |     | }
 415 |     | 
 416 |     | interface IGmxV2ExchangeRouter {
 417 |     |     function dataStore() external view returns (address);
 418 |     | 
 419 |     |     function sendWnt(address receiver, uint256 amount) external payable;
 420 |     | 
 421 |     |     function sendTokens(address token, address receiver, uint256 amount) external payable;
 422 |     | 
 423 |     |     function depositHandler() external view returns (address);
 424 |     | 
 425 |     |     function withdrawalHandler() external view returns (address);
 426 |     | 
 427 |     |     function createDeposit(IGmxV2Deposit.CreateDepositParams calldata params) external payable returns (bytes32);
 428 |     | 
 429 |     |     function createWithdrawal(IGmxV2Withdrawal.CreateWithdrawalParams calldata params) external payable returns (bytes32);
 430 |     | 
 431 |     |     function cancelWithdrawal(bytes32 key) external payable;
 432 |     | 
 433 |     |     function cancelDeposit(bytes32 key) external payable;
 434 |     | }
 435 |     | 
 436 |     | interface IGmxV2DepositHandler {
 437 |     |     function depositVault() external view returns (address);
 438 |     | 
 439 |     |     function dataStore() external view returns (address);
 440 |     | }
 441 |     | 
 442 |     | interface IGmxV2WithdrawalHandler {
 443 |     |     function withdrawalVault() external view returns (address);
 444 |     | }
 445 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ILPStaking.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | // solhint-disable func-name-mixedcase
  3 |     | pragma solidity >=0.7.0 <0.9.0;
  4 |     | 
  5 |     | interface ILPStaking {
  6 |     |     function BONUS_MULTIPLIER() external view returns (uint256);
  7 |     | 
  8 |     |     function add(uint256 _allocPoint, address _lpToken) external;
  9 |     | 
 10 |     |     function bonusEndBlock() external view returns (uint256);
 11 |     | 
 12 |     |     function deposit(uint256 _pid, uint256 _amount) external;
 13 |     | 
 14 |     |     function emergencyWithdraw(uint256 _pid) external;
 15 |     | 
 16 |     |     function getMultiplier(uint256 _from, uint256 _to) external view returns (uint256);
 17 |     | 
 18 |     |     function lpBalances(uint256) external view returns (uint256);
 19 |     | 
 20 |     |     function massUpdatePools() external;
 21 |     | 
 22 |     |     function owner() external view returns (address);
 23 |     | 
 24 |     |     function pendingStargate(uint256 _pid, address _user) external view returns (uint256);
 25 |     | 
 26 |     |     function poolInfo(uint256)
 27 |     |         external
 28 |     |         view
 29 |     |         returns (
 30 |     |             address lpToken,
 31 |     |             uint256 allocPoint,
 32 |     |             uint256 lastRewardBlock,
 33 |     |             uint256 accStargatePerShare
 34 |     |         );
 35 |     | 
 36 |     |     function poolLength() external view returns (uint256);
 37 |     | 
 38 |     |     function renounceOwnership() external;
 39 |     | 
 40 |     |     function set(uint256 _pid, uint256 _allocPoint) external;
 41 |     | 
 42 |     |     function setStargatePerBlock(uint256 _stargatePerBlock) external;
 43 |     | 
 44 |     |     function stargate() external view returns (address);
 45 |     | 
 46 |     |     function stargatePerBlock() external view returns (uint256);
 47 |     | 
 48 |     |     function startBlock() external view returns (uint256);
 49 |     | 
 50 |     |     function totalAllocPoint() external view returns (uint256);
 51 |     | 
 52 |     |     function transferOwnership(address newOwner) external;
 53 |     | 
 54 |     |     function updatePool(uint256 _pid) external;
 55 |     | 
 56 |     |     function userInfo(uint256, address) external view returns (uint256 amount, uint256 rewardDebt);
 57 |     | 
 58 |     |     function withdraw(uint256 _pid, uint256 _amount) external;
 59 |     | }

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ILayerZero.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {IERC165} from "openzeppelin-contracts/utils/introspection/IERC165.sol";
   5 |     | import {IAggregator} from "interfaces/IAggregator.sol";
   6 |     | 
   7 |     | interface ILzCommonOFT is IERC165 {
   8 |     |     struct LzCallParams {
   9 |     |         address payable refundAddress;
  10 |     |         address zroPaymentAddress;
  11 |     |         bytes adapterParams;
  12 |     |     }
  13 |     | 
  14 |     |     function estimateSendFee(
  15 |     |         uint16 _dstChainId,
  16 |     |         bytes32 _toAddress,
  17 |     |         uint _amount,
  18 |     |         bool _useZro,
  19 |     |         bytes calldata _adapterParams
  20 |     |     ) external view returns (uint nativeFee, uint zroFee);
  21 |     | 
  22 |     |     function estimateSendAndCallFee(
  23 |     |         uint16 _dstChainId,
  24 |     |         bytes32 _toAddress,
  25 |     |         uint _amount,
  26 |     |         bytes calldata _payload,
  27 |     |         uint64 _dstGasForCall,
  28 |     |         bool _useZro,
  29 |     |         bytes calldata _adapterParams
  30 |     |     ) external view returns (uint nativeFee, uint zroFee);
  31 |     | 
  32 |     |     function circulatingSupply() external view returns (uint);
  33 |     | 
  34 |     |     function token() external view returns (address);
  35 |     | }
  36 |     | 
  37 |     | interface ILzUserApplicationConfig {
  38 |     |     function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;
  39 |     | 
  40 |     |     function setSendVersion(uint16 _version) external;
  41 |     | 
  42 |     |     function setReceiveVersion(uint16 _version) external;
  43 |     | 
  44 |     |     function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;
  45 |     | }
  46 |     | 
  47 |     | interface ILzEndpoint is ILzUserApplicationConfig {
  48 |     |     function defaultSendLibrary() external view returns (address);
  49 |     | 
  50 |     |     function send(
  51 |     |         uint16 _dstChainId,
  52 |     |         bytes calldata _destination,
  53 |     |         bytes calldata _payload,
  54 |     |         address payable _refundAddress,
  55 |     |         address _zroPaymentAddress,
  56 |     |         bytes calldata _adapterParams
  57 |     |     ) external payable;
  58 |     | 
  59 |     |     function receivePayload(
  60 |     |         uint16 _srcChainId,
  61 |     |         bytes calldata _srcAddress,
  62 |     |         address _dstAddress,
  63 |     |         uint64 _nonce,
  64 |     |         uint _gasLimit,
  65 |     |         bytes calldata _payload
  66 |     |     ) external;
  67 |     | 
  68 |     |     function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);
  69 |     | 
  70 |     |     function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);
  71 |     | 
  72 |     |     function estimateFees(
  73 |     |         uint16 _dstChainId,
  74 |     |         address _userApplication,
  75 |     |         bytes calldata _payload,
  76 |     |         bool _payInZRO,
  77 |     |         bytes calldata _adapterParam
  78 |     |     ) external view returns (uint nativeFee, uint zroFee);
  79 |     | 
  80 |     |     function getChainId() external view returns (uint16);
  81 |     | 
  82 |     |     function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;
  83 |     | 
  84 |     |     function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);
  85 |     | 
  86 |     |     function getSendLibraryAddress(address _userApplication) external view returns (address);
  87 |     | 
  88 |     |     function getReceiveLibraryAddress(address _userApplication) external view returns (address);
  89 |     | 
  90 |     |     function isSendingPayload() external view returns (bool);
  91 |     | 
  92 |     |     function isReceivingPayload() external view returns (bool);
  93 |     | 
  94 |     |     function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);
  95 |     | 
  96 |     |     function getSendVersion(address _userApplication) external view returns (uint16);
  97 |     | 
  98 |     |     function getReceiveVersion(address _userApplication) external view returns (uint16);
  99 |     | 
 100 |     |     function defaultSendVersion() external view returns (uint16);
 101 |     | 
 102 |     |     function defaultReceiveVersion() external view returns (uint16);
 103 |     | 
 104 |     |     function defaultReceiveLibraryAddress() external view returns (address);
 105 |     | 
 106 |     |     function uaConfigLookup(
 107 |     |         address _address
 108 |     |     ) external view returns (uint16 sendVersion, uint16 receiveVersion, address receiveLibraryAddress, address sendLibrary);
 109 |     | }
 110 |     | 
 111 |     | interface ILzBaseOFTV2 {
 112 |     |     function sharedDecimals() external view returns (uint8);
 113 |     | 
 114 |     |     function innerToken() external view returns (address);
 115 |     | }
 116 |     | 
 117 |     | interface ILzApp {
 118 |     |     function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;
 119 |     | 
 120 |     |     function minDstGasLookup(uint16 _srcChainId, uint16 _dstChainId) external view returns (uint);
 121 |     | 
 122 |     |     function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external;
 123 |     | 
 124 |     |     function trustedRemoteLookup(uint16 _srcChainId) external view returns (bytes memory);
 125 |     | 
 126 |     |     function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;
 127 |     | 
 128 |     |     function lzEndpoint() external view returns (ILzEndpoint);
 129 |     | }
 130 |     | 
 131 |     | interface ILzFeeHandler {
 132 |     |     enum QuoteType {
 133 |     |         None,
 134 |     |         Oracle,
 135 |     |         Fixed
 136 |     |     }
 137 |     | 
 138 |     |     function getFee() external view returns (uint256);
 139 |     | }
 140 |     | 
 141 |     | interface ILzOFTV2 is ILzCommonOFT {
 142 |     |     function sendFrom(
 143 |     |         address _from,
 144 |     |         uint16 _dstChainId,
 145 |     |         bytes32 _toAddress,
 146 |     |         uint _amount,
 147 |     |         LzCallParams calldata _callParams
 148 |     |     ) external payable;
 149 |     | 
 150 |     |     function sendAndCall(
 151 |     |         address _from,
 152 |     |         uint16 _dstChainId,
 153 |     |         bytes32 _toAddress,
 154 |     |         uint _amount,
 155 |     |         bytes calldata _payload,
 156 |     |         uint64 _dstGasForCall,
 157 |     |         LzCallParams calldata _callParams
 158 |     |     ) external payable;
 159 |     | }
 160 |     | 
 161 |     | interface ILzOFTReceiverV2 {
 162 |     |     function onOFTReceived(
 163 |     |         uint16 _srcChainId,
 164 |     |         bytes calldata _srcAddress,
 165 |     |         uint64 _nonce,
 166 |     |         bytes32 _from,
 167 |     |         uint _amount,
 168 |     |         bytes calldata _payload
 169 |     |     ) external;
 170 |     | }
 171 |     | 
 172 |     | interface ILzUltraLightNodeV2 {
 173 |     |     function defaultAppConfig(
 174 |     |         uint16
 175 |     |     )
 176 |     |         external
 177 |     |         view
 178 |     |         returns (
 179 |     |             uint16 inboundProofLibraryVersion,
 180 |     |             uint64 inboundBlockConfirmations,
 181 |     |             address relayer,
 182 |     |             uint16 outboundProofType,
 183 |     |             uint64 outboundBlockConfirmations,
 184 |     |             address oracle
 185 |     |         );
 186 |     | 
 187 |     |     function appConfig(
 188 |     |         address,
 189 |     |         uint16
 190 |     |     )
 191 |     |         external
 192 |     |         view
 193 |     |         returns (
 194 |     |             uint16 inboundProofLibraryVersion,
 195 |     |             uint64 inboundBlockConfirmations,
 196 |     |             address relayer,
 197 |     |             uint16 outboundProofType,
 198 |     |             uint64 outboundBlockConfirmations,
 199 |     |             address oracle
 200 |     |         );
 201 |     | }
 202 |     | 
 203 |     | interface ILzReceiver {
 204 |     |     function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;
 205 |     | }
 206 |     | 
 207 |     | interface IOFTV2View {
 208 |     |     function lzReceive(uint16 _srcChainId, bytes32 _scrAddress, bytes memory _payload, uint _totalSupply) external view returns (uint);
 209 |     | 
 210 |     |     function getInboundNonce(uint16 _srcChainId) external view returns (uint64);
 211 |     | 
 212 |     |     function getCurrentState() external view returns (uint);
 213 |     | 
 214 |     |     function isProxy() external view returns (bool);
 215 |     | }
 216 |     | 
 217 |     | interface IOFTWrapper {
 218 |     |     event LogWrapperFeeWithdrawn(address to, uint256 amount);
 219 |     |     event LogDefaultExchangeRateChanged(uint256 oldExchangeRate, uint256 newExchangeRate);
 220 |     |     event LogOracleImplementationChange(IAggregator indexed oldOracle, IAggregator indexed newOracle);
 221 |     |     event LogDefaultQuoteTypeChanged(QUOTE_TYPE oldValue, QUOTE_TYPE newValue);
 222 |     |     event LogFeeToChange(address indexed oldAddress, address indexed newAddress);
 223 |     | 
 224 |     |     enum QUOTE_TYPE {
 225 |     |         ORACLE,
 226 |     |         FIXED_EXCHANGE_RATE
 227 |     |     }
 228 |     | 
 229 |     |     function sendOFTV2(
 230 |     |         uint16 _dstChainId,
 231 |     |         bytes32 _toAddress,
 232 |     |         uint _amount,
 233 |     |         ILzCommonOFT.LzCallParams calldata _callParams
 234 |     |     ) external payable;
 235 |     | 
 236 |     |     function sendProxyOFTV2(
 237 |     |         uint16 _dstChainId,
 238 |     |         bytes32 _toAddress,
 239 |     |         uint _amount,
 240 |     |         ILzCommonOFT.LzCallParams calldata _callParams
 241 |     |     ) external payable;
 242 |     | 
 243 |     |     function estimateSendFeeV2(
 244 |     |         uint16 _dstChainId,
 245 |     |         bytes32 _toAddress,
 246 |     |         uint _amount,
 247 |     |         bytes calldata _adapterParams
 248 |     |     ) external view returns (uint nativeFee, uint zroFee);
 249 |     | }
 250 |     | 
 251 |     | interface IPreCrimeView {
 252 |     |     struct Packet {
 253 |     |         uint16 srcChainId;
 254 |     |         bytes32 srcAddress;
 255 |     |         uint64 nonce;
 256 |     |         bytes payload;
 257 |     |     }
 258 |     | 
 259 |     |     struct SimulationResult {
 260 |     |         uint chainTotalSupply;
 261 |     |         bool isProxy;
 262 |     |     }
 263 |     | 
 264 |     |     function getConfig(Packet[] calldata _packets) external view returns (bytes memory);
 265 |     | 
 266 |     |     function precrime(Packet[] calldata _packets, bytes[] calldata _simulation) external view returns (uint16 code, bytes memory reason);
 267 |     | 
 268 |     |     function version() external view returns (uint16);
 269 |     | 
 270 |     |     function simulate(Packet[] calldata _packets) external view returns (uint16 code, bytes memory result);
 271 |     | }
 272 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ILevSwapperV2.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | interface ILevSwapperV2 {
  5 |     |     function swap(
  6 |     |         address recipient,
  7 |     |         uint256 shareToMin,
  8 |     |         uint256 shareFrom,
  9 |     |         bytes calldata data
 10 |     |     ) external returns (uint256 extraShare, uint256 shareReturned);
 11 |     | }
 12 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IMSpell.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity >=0.8.0;
 3 |     | 
 4 |     | interface IMSpell {
 5 |     |     function updateReward() external;
 6 |     | }
 7 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IMagicCurveLpRewardHandler.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | import {ICurveRewardGauge} from "interfaces/ICurveRewardGauge.sol";
  6 |     | 
  7 |     | interface IMagicCurveLpRewardHandler {
  8 |     |     function harvest(address to) external;
  9 |     | 
 10 |     |     function distributeRewards(uint256 amount) external;
 11 |     | 
 12 |     |     function stakeAsset(uint256 amount) external;
 13 |     | 
 14 |     |     function unstakeAsset(uint256 amount) external;
 15 |     | 
 16 |     |     function skimAssets() external returns (uint256, uint256);
 17 |     | 
 18 |     |     function staking() external view returns (ICurveRewardGauge staking);
 19 |     | 
 20 |     |     function setStaking(ICurveRewardGauge staking) external;
 21 |     | 
 22 |     |     function isPrivateDelegateFunction(bytes4 sig) external view returns (bool);
 23 |     | }
 24 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IMagicGlpRewardHandler.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | import {IGmxRewardRouterV2} from "interfaces/IGmxV1.sol";
  6 |     | 
  7 |     | interface IMagicGlpRewardHandler {
  8 |     |     function harvest() external;
  9 |     | 
 10 |     |     function setRewardRouter(IGmxRewardRouterV2 _rewardRouter) external;
 11 |     | 
 12 |     |     function distributeRewards(uint256 amount) external;
 13 |     | 
 14 |     |     function skimAssets() external returns (uint256);
 15 |     | 
 16 |     |     function unstakeGmx(
 17 |     |         uint256 amount,
 18 |     |         uint256 amountToTransferToSender,
 19 |     |         address recipient
 20 |     |     ) external;
 21 |     | 
 22 |     |     function unstakeEsGmxAndVest(
 23 |     |         uint256 amount,
 24 |     |         uint256 glpVesterDepositAmount,
 25 |     |         uint256 gmxVesterDepositAmount
 26 |     |     ) external;
 27 |     | 
 28 |     |     function withdrawFromVesting(
 29 |     |         bool withdrawFromGlpVester,
 30 |     |         bool withdrawFromGmxVester,
 31 |     |         bool stake
 32 |     |     ) external;
 33 |     | 
 34 |     |     function claimVestedGmx(
 35 |     |         bool withdrawFromGlpVester,
 36 |     |         bool withdrawFromGmxVester,
 37 |     |         bool stake,
 38 |     |         bool transferToFeeCollecter
 39 |     |     ) external;
 40 |     | }
 41 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IMintableBurnable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | interface IMintableBurnable {
  5 |     |     function burn(address from, uint256 amount) external returns (bool);
  6 |     | 
  7 |     |     function mint(address to, uint256 amount) external returns (bool);
  8 |     | }
  9 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IMultiRewardsStaking.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | interface IMultiRewardsStaking {
  5 |     |     struct Reward {
  6 |     |         uint256 rewardsDuration;
  7 |     |         uint256 periodFinish;
  8 |     |         uint256 rewardRate;
  9 |     |         uint256 lastUpdateTime;
 10 |     |         uint256 rewardPerTokenStored;
 11 |     |     }
 12 |     | 
 13 |     |     function addReward(address rewardToken, uint256 _rewardsDuration) external;
 14 |     | 
 15 |     |     function balanceOf(address user) external view returns (uint256 amount);
 16 |     | 
 17 |     |     function earned(address user, address rewardToken) external view returns (uint256);
 18 |     | 
 19 |     |     function exit() external;
 20 |     | 
 21 |     |     function getRewardForDuration(address rewardToken) external view returns (uint256);
 22 |     | 
 23 |     |     function getRewards() external;
 24 |     | 
 25 |     |     function lastTimeRewardApplicable(address rewardToken) external view returns (uint256);
 26 |     | 
 27 |     |     function notifyRewardAmount(address rewardToken, uint256 amount) external;
 28 |     | 
 29 |     |     function operators(address) external view returns (bool);
 30 |     | 
 31 |     |     function owner() external view returns (address);
 32 |     | 
 33 |     |     function pause() external;
 34 |     | 
 35 |     |     function paused() external view returns (bool);
 36 |     | 
 37 |     |     function recover(address tokenAddress, uint256 tokenAmount) external;
 38 |     | 
 39 |     |     function rewardData(address token) external view returns (Reward memory);
 40 |     | 
 41 |     |     function rewardPerToken(address rewardToken) external view returns (uint256);
 42 |     | 
 43 |     |     function rewardTokens(uint256) external view returns (address);
 44 |     | 
 45 |     |     function rewards(address user, address token) external view returns (uint256 amount);
 46 |     | 
 47 |     |     function setOperator(address operator, bool status) external;
 48 |     | 
 49 |     |     function setRewardsDuration(address rewardToken, uint256 _rewardsDuration) external;
 50 |     | 
 51 |     |     function stake(uint256 amount) external;
 52 |     | 
 53 |     |     function stakingToken() external view returns (address);
 54 |     | 
 55 |     |     function totalSupply() external view returns (uint256);
 56 |     | 
 57 |     |     function transferOwnership(address newOwner) external;
 58 |     | 
 59 |     |     function unpause() external;
 60 |     | 
 61 |     |     function userRewardPerTokenPaid(address user, address token) external view returns (uint256 amount);
 62 |     | 
 63 |     |     function getRewardTokenLength() external view returns (uint256);
 64 |     | 
 65 |     |     function isSupportedReward(address rewardToken) external view returns (bool);
 66 |     | 
 67 |     |     function withdraw(uint256 amount) external;
 68 |     | }
 69 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IOracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | interface IOracle {
  5 |     |     function decimals() external view returns (uint8);
  6 |     | 
  7 |     |     function get(bytes calldata data) external returns (bool success, uint256 rate);
  8 |     | 
  9 |     |     function peek(bytes calldata data) external view returns (bool success, uint256 rate);
 10 |     | 
 11 |     |     function peekSpot(bytes calldata data) external view returns (uint256 rate);
 12 |     | 
 13 |     |     function symbol(bytes calldata data) external view returns (string memory);
 14 |     | 
 15 |     |     function name(bytes calldata data) external view returns (string memory);
 16 |     | }
 17 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IStargate.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | // solhint-disable func-name-mixedcase
   3 |     | pragma solidity >=0.8.0;
   4 |     | 
   5 |     | interface IStargateLPStaking {
   6 |     |     function deposit(uint256 _pid, uint256 _amount) external;
   7 |     | 
   8 |     |     function emergencyWithdraw(uint256 _pid) external;
   9 |     | 
  10 |     |     function poolInfo(uint256) external view returns (address lpToken, uint256 allocPoint, uint256 lastReward, uint256 accEmissionPerShare);
  11 |     | 
  12 |     |     function userInfo(uint256, address) external view returns (uint256 amount, uint256 rewardDebt);
  13 |     | 
  14 |     |     function withdraw(uint256 _pid, uint256 _amount) external;
  15 |     | }
  16 |     | 
  17 |     | interface IStargatePool {
  18 |     |     function deltaCredit() external view returns (uint256);
  19 |     | 
  20 |     |     function totalLiquidity() external view returns (uint256);
  21 |     | 
  22 |     |     function totalSupply() external view returns (uint256);
  23 |     | 
  24 |     |     function decimals() external view returns (uint256);
  25 |     | 
  26 |     |     function poolId() external view returns (uint256);
  27 |     | 
  28 |     |     function localDecimals() external view returns (uint256);
  29 |     | 
  30 |     |     function token() external view returns (address);
  31 |     | 
  32 |     |     function balanceOf(address account) external view returns (uint256);
  33 |     | 
  34 |     |     function approve(address spender, uint256 value) external returns (bool);
  35 |     | }
  36 |     | 
  37 |     | interface IStargateRouter {
  38 |     |     struct lzTxObj {
  39 |     |         uint256 dstGasForCall;
  40 |     |         uint256 dstNativeAmount;
  41 |     |         bytes dstNativeAddr;
  42 |     |     }
  43 |     | 
  44 |     |     function addLiquidity(uint256 _poolId, uint256 _amountLD, address _to) external;
  45 |     | 
  46 |     |     function swap(
  47 |     |         uint16 _dstChainId,
  48 |     |         uint256 _srcPoolId,
  49 |     |         uint256 _dstPoolId,
  50 |     |         address payable _refundAddress,
  51 |     |         uint256 _amountLD,
  52 |     |         uint256 _minAmountLD,
  53 |     |         lzTxObj memory _lzTxParams,
  54 |     |         bytes calldata _to,
  55 |     |         bytes calldata _payload
  56 |     |     ) external payable;
  57 |     | 
  58 |     |     function redeemRemote(
  59 |     |         uint16 _dstChainId,
  60 |     |         uint256 _srcPoolId,
  61 |     |         uint256 _dstPoolId,
  62 |     |         address payable _refundAddress,
  63 |     |         uint256 _amountLP,
  64 |     |         uint256 _minAmountLD,
  65 |     |         bytes calldata _to,
  66 |     |         lzTxObj memory _lzTxParams
  67 |     |     ) external payable;
  68 |     | 
  69 |     |     function instantRedeemLocal(uint16 _srcPoolId, uint256 _amountLP, address _to) external returns (uint256);
  70 |     | 
  71 |     |     function redeemLocal(
  72 |     |         uint16 _dstChainId,
  73 |     |         uint256 _srcPoolId,
  74 |     |         uint256 _dstPoolId,
  75 |     |         address payable _refundAddress,
  76 |     |         uint256 _amountLP,
  77 |     |         bytes calldata _to,
  78 |     |         lzTxObj memory _lzTxParams
  79 |     |     ) external payable;
  80 |     | 
  81 |     |     function sendCredits(uint16 _dstChainId, uint256 _srcPoolId, uint256 _dstPoolId, address payable _refundAddress) external payable;
  82 |     | 
  83 |     |     function quoteLayerZeroFee(
  84 |     |         uint16 _dstChainId,
  85 |     |         uint8 _functionType,
  86 |     |         bytes calldata _toAddress,
  87 |     |         bytes calldata _transferAndCallPayload,
  88 |     |         lzTxObj memory _lzTxParams
  89 |     |     ) external view returns (uint256, uint256);
  90 |     | }
  91 |     | 
  92 |     | interface IStargateToken {
  93 |     |     function allowance(address owner, address spender) external view returns (uint256);
  94 |     | 
  95 |     |     function approve(address spender, uint256 amount) external returns (bool);
  96 |     | 
  97 |     |     function balanceOf(address account) external view returns (uint256);
  98 |     | 
  99 |     |     function chainId() external view returns (uint16);
 100 |     | 
 101 |     |     function decimals() external view returns (uint8);
 102 |     | 
 103 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
 104 |     | 
 105 |     |     function dstContractLookup(uint16) external view returns (bytes memory);
 106 |     | 
 107 |     |     function endpoint() external view returns (address);
 108 |     | 
 109 |     |     function estimateSendTokensFee(
 110 |     |         uint16 _dstChainId,
 111 |     |         bool _useZro,
 112 |     |         bytes memory txParameters
 113 |     |     ) external view returns (uint256 nativeFee, uint256 zroFee);
 114 |     | 
 115 |     |     function forceResumeReceive(uint16 _srcChainId, bytes memory _srcAddress) external;
 116 |     | 
 117 |     |     function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
 118 |     | 
 119 |     |     function isMain() external view returns (bool);
 120 |     | 
 121 |     |     function lzReceive(uint16 _srcChainId, bytes memory _fromAddress, uint64 nonce, bytes memory _payload) external;
 122 |     | 
 123 |     |     function name() external view returns (string memory);
 124 |     | 
 125 |     |     function owner() external view returns (address);
 126 |     | 
 127 |     |     function pauseSendTokens(bool _pause) external;
 128 |     | 
 129 |     |     function paused() external view returns (bool);
 130 |     | 
 131 |     |     function renounceOwnership() external;
 132 |     | 
 133 |     |     function sendTokens(
 134 |     |         uint16 _dstChainId,
 135 |     |         bytes memory _to,
 136 |     |         uint256 _qty,
 137 |     |         address zroPaymentAddress,
 138 |     |         bytes memory adapterParam
 139 |     |     ) external payable;
 140 |     | 
 141 |     |     function setConfig(uint16 _version, uint16 _chainId, uint256 _configType, bytes memory _config) external;
 142 |     | 
 143 |     |     function setDestination(uint16 _dstChainId, bytes memory _destinationContractAddress) external;
 144 |     | 
 145 |     |     function setReceiveVersion(uint16 version) external;
 146 |     | 
 147 |     |     function setSendVersion(uint16 version) external;
 148 |     | 
 149 |     |     function symbol() external view returns (string memory);
 150 |     | 
 151 |     |     function totalSupply() external view returns (uint256);
 152 |     | 
 153 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
 154 |     | 
 155 |     |     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
 156 |     | 
 157 |     |     function transferOwnership(address newOwner) external;
 158 |     | }
 159 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IStrategy.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | interface IStrategy {
  5 |     |     function skim(uint256 amount) external;
  6 |     | 
  7 |     |     function harvest(uint256 balance, address sender) external returns (int256 amountAdded);
  8 |     | 
  9 |     |     function withdraw(uint256 amount) external returns (uint256 actualAmount);
 10 |     | 
 11 |     |     function exit(uint256 balance) external returns (int256 amountAdded);
 12 |     | }
 13 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ISwapperV1.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | interface ISwapperV1 {
  5 |     |     function swap(
  6 |     |         address fromToken,
  7 |     |         address toToken,
  8 |     |         address recipient,
  9 |     |         uint256 shareToMin,
 10 |     |         uint256 shareFrom
 11 |     |     ) external returns (uint256 extraShare, uint256 shareReturned);
 12 |     | }

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/ISwapperV2.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | interface ISwapperV2 {
  5 |     |     function swap(
  6 |     |         address fromToken,
  7 |     |         address toToken,
  8 |     |         address recipient,
  9 |     |         uint256 shareToMin,
 10 |     |         uint256 shareFrom,
 11 |     |         bytes calldata data
 12 |     |     ) external returns (uint256 extraShare, uint256 shareReturned);
 13 |     | }
 14 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IUmbrellaFeeds.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | interface IUmbrellaFeeds {
  5 |     |     struct PriceData {
  6 |     |         uint8 data;
  7 |     |         uint24 heartbeat;
  8 |     |         uint32 timestamp;
  9 |     |         uint128 price;
 10 |     |     }
 11 |     | 
 12 |     |     function DECIMALS() external view returns (uint8);
 13 |     | 
 14 |     |     function getChainId() external view returns (uint256 id);
 15 |     | 
 16 |     |     function getManyPriceData(bytes32[] memory _keys) external view returns (PriceData[] memory data);
 17 |     | 
 18 |     |     function getManyPriceDataRaw(bytes32[] memory _keys) external view returns (PriceData[] memory data);
 19 |     | 
 20 |     |     function getName() external pure returns (bytes32);
 21 |     | 
 22 |     |     function getPrice(bytes32 _key) external view returns (uint128 price);
 23 |     | 
 24 |     |     function getPriceData(bytes32 _key) external view returns (PriceData memory data);
 25 |     | 
 26 |     |     function getPriceDataByName(string memory _name) external view returns (PriceData memory data);
 27 |     | }
 28 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IUniswapV2.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | interface IUniswapV2Pair {
   5 |     |     function name() external pure returns (string memory);
   6 |     | 
   7 |     |     function symbol() external pure returns (string memory);
   8 |     | 
   9 |     |     function decimals() external view returns (uint8);
  10 |     | 
  11 |     |     function totalSupply() external view returns (uint256);
  12 |     | 
  13 |     |     function balanceOf(address owner) external view returns (uint256);
  14 |     | 
  15 |     |     function allowance(address owner, address spender) external view returns (uint256);
  16 |     | 
  17 |     |     function approve(address spender, uint256 value) external returns (bool);
  18 |     | 
  19 |     |     function transfer(address to, uint256 value) external returns (bool);
  20 |     | 
  21 |     |     function mint(address to) external returns (uint256 liquidity);
  22 |     | 
  23 |     |     function burn(address to) external returns (uint256 amount0, uint256 amount1);
  24 |     | 
  25 |     |     function skim(address to) external;
  26 |     | 
  27 |     |     function sync() external;
  28 |     | 
  29 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool);
  30 |     | 
  31 |     |     function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;
  32 |     | 
  33 |     |     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
  34 |     | 
  35 |     |     function token0() external pure returns (address);
  36 |     | 
  37 |     |     function token1() external pure returns (address);
  38 |     | }
  39 |     | 
  40 |     | interface IUniswapV2Router01 {
  41 |     |     function factory() external pure returns (address);
  42 |     | 
  43 |     |     function WETH() external pure returns (address);
  44 |     | 
  45 |     |     function addLiquidity(
  46 |     |         address tokenA,
  47 |     |         address tokenB,
  48 |     |         uint amountADesired,
  49 |     |         uint amountBDesired,
  50 |     |         uint amountAMin,
  51 |     |         uint amountBMin,
  52 |     |         address to,
  53 |     |         uint deadline
  54 |     |     ) external returns (uint amountA, uint amountB, uint liquidity);
  55 |     | 
  56 |     |     function addLiquidityETH(
  57 |     |         address token,
  58 |     |         uint amountTokenDesired,
  59 |     |         uint amountTokenMin,
  60 |     |         uint amountETHMin,
  61 |     |         address to,
  62 |     |         uint deadline
  63 |     |     ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
  64 |     | 
  65 |     |     function removeLiquidity(
  66 |     |         address tokenA,
  67 |     |         address tokenB,
  68 |     |         uint liquidity,
  69 |     |         uint amountAMin,
  70 |     |         uint amountBMin,
  71 |     |         address to,
  72 |     |         uint deadline
  73 |     |     ) external returns (uint amountA, uint amountB);
  74 |     | 
  75 |     |     function removeLiquidityETH(
  76 |     |         address token,
  77 |     |         uint liquidity,
  78 |     |         uint amountTokenMin,
  79 |     |         uint amountETHMin,
  80 |     |         address to,
  81 |     |         uint deadline
  82 |     |     ) external returns (uint amountToken, uint amountETH);
  83 |     | 
  84 |     |     function removeLiquidityWithPermit(
  85 |     |         address tokenA,
  86 |     |         address tokenB,
  87 |     |         uint liquidity,
  88 |     |         uint amountAMin,
  89 |     |         uint amountBMin,
  90 |     |         address to,
  91 |     |         uint deadline,
  92 |     |         bool approveMax,
  93 |     |         uint8 v,
  94 |     |         bytes32 r,
  95 |     |         bytes32 s
  96 |     |     ) external returns (uint amountA, uint amountB);
  97 |     | 
  98 |     |     function removeLiquidityETHWithPermit(
  99 |     |         address token,
 100 |     |         uint liquidity,
 101 |     |         uint amountTokenMin,
 102 |     |         uint amountETHMin,
 103 |     |         address to,
 104 |     |         uint deadline,
 105 |     |         bool approveMax,
 106 |     |         uint8 v,
 107 |     |         bytes32 r,
 108 |     |         bytes32 s
 109 |     |     ) external returns (uint amountToken, uint amountETH);
 110 |     | 
 111 |     |     function swapExactTokensForTokens(
 112 |     |         uint amountIn,
 113 |     |         uint amountOutMin,
 114 |     |         address[] calldata path,
 115 |     |         address to,
 116 |     |         uint deadline
 117 |     |     ) external returns (uint[] memory amounts);
 118 |     | 
 119 |     |     function swapTokensForExactTokens(
 120 |     |         uint amountOut,
 121 |     |         uint amountInMax,
 122 |     |         address[] calldata path,
 123 |     |         address to,
 124 |     |         uint deadline
 125 |     |     ) external returns (uint[] memory amounts);
 126 |     | 
 127 |     |     function swapExactETHForTokens(
 128 |     |         uint amountOutMin,
 129 |     |         address[] calldata path,
 130 |     |         address to,
 131 |     |         uint deadline
 132 |     |     ) external payable returns (uint[] memory amounts);
 133 |     | 
 134 |     |     function swapTokensForExactETH(
 135 |     |         uint amountOut,
 136 |     |         uint amountInMax,
 137 |     |         address[] calldata path,
 138 |     |         address to,
 139 |     |         uint deadline
 140 |     |     ) external returns (uint[] memory amounts);
 141 |     | 
 142 |     |     function swapExactTokensForETH(
 143 |     |         uint amountIn,
 144 |     |         uint amountOutMin,
 145 |     |         address[] calldata path,
 146 |     |         address to,
 147 |     |         uint deadline
 148 |     |     ) external returns (uint[] memory amounts);
 149 |     | 
 150 |     |     function swapETHForExactTokens(
 151 |     |         uint amountOut,
 152 |     |         address[] calldata path,
 153 |     |         address to,
 154 |     |         uint deadline
 155 |     |     ) external payable returns (uint[] memory amounts);
 156 |     | 
 157 |     |     function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
 158 |     | 
 159 |     |     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
 160 |     | 
 161 |     |     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
 162 |     | 
 163 |     |     function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
 164 |     | 
 165 |     |     function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
 166 |     | }
 167 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IVaultHarvester.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity >=0.8.10;
 3 |     | 
 4 |     | interface IVaultHarvester {
 5 |     |     function harvest(address recipient) external;
 6 |     | }

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IWETH.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | 
  6 |     | interface IWETH is IERC20 {
  7 |     |     function deposit() external payable;
  8 |     | 
  9 |     |     function withdraw(uint256) external;
 10 |     | }
 11 |     | 
 12 |     | interface IWETHAlike is IWETH {}
 13 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IWhitelister.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.12;
  3 |     | 
  4 |     | interface IWhitelister {
  5 |     |     function isBorrowingAllowed(address user, uint256 newBorrowPart) external view returns (bool success);
  6 |     | 
  7 |     |     function setMaxBorrow(address user, uint256 maxBorrow, bytes32[] calldata merkleProof) external returns (bool success);
  8 |     | }
  9 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IWitnetPriceRouter.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity >=0.8.0;
 3 |     | 
 4 |     | interface IWitnetPriceRouter {
 5 |     |     function valueFor(bytes32 _erc2362id) external view returns (int256, uint256, uint256);
 6 |     | }
 7 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/interfaces/IYearnVault.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | 
  6 |     | interface IYearnVault is IERC20 {
  7 |     |     function withdraw() external returns (uint256);
  8 |     | 
  9 |     |     function deposit(uint256 amount, address recipient) external returns (uint256);
 10 |     | 
 11 |     |     function pricePerShare() external view returns (uint256);
 12 |     | 
 13 |     |     function token() external view returns (address);
 14 |     | 
 15 |     |     function decimals() external view returns (uint256);
 16 |     | }
 17 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/lenses/GmxLens.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   5 |     | import {MathLib} from "libraries/MathLib.sol";
   6 |     | import {IGmxVault, IGmxGlpManager, IVaultPriceFeed} from "interfaces/IGmxV1.sol";
   7 |     | 
   8 |     | contract GmxLens {
   9 |     |     uint256 private constant BASIS_POINTS_DIVISOR = 10000;
  10 |     |     uint256 private constant PRICE_PRECISION = 10 ** 30;
  11 |     |     uint256 private constant USDG_DECIMALS = 18;
  12 |     |     uint256 private constant PRECISION = 10 ** 18;
  13 |     | 
  14 |     |     struct TokenFee {
  15 |     |         address token;
  16 |     |         uint256 fee;
  17 |     |     }
  18 |     | 
  19 |     |     IGmxGlpManager public immutable manager;
  20 |     |     IGmxVault public immutable vault;
  21 |     | 
  22 |     |     IERC20 private immutable glp;
  23 |     |     IERC20 private immutable usdg;
  24 |     | 
  25 |     |     constructor(IGmxGlpManager _manager, IGmxVault _vault) {
  26 |     |         manager = _manager;
  27 |     |         vault = _vault;
  28 |     |         glp = IERC20(manager.glp());
  29 |     |         usdg = IERC20(manager.usdg());
  30 |     |     }
  31 |     | 
  32 |     |     function getGlpPrice() public view returns (uint256) {
  33 |     |         return (manager.getAumInUsdg(false) * PRICE_PRECISION) / glp.totalSupply();
  34 |     |     }
  35 |     | 
  36 |     |     function getTokenOutFromBurningGlp(address tokenOut, uint256 glpAmount) public view returns (uint256 amount, uint256 feeBasisPoints) {
  37 |     |         uint256 usdgAmount = (glpAmount * getGlpPrice()) / PRICE_PRECISION;
  38 |     | 
  39 |     |         feeBasisPoints = _getFeeBasisPoints(
  40 |     |             tokenOut,
  41 |     |             vault.usdgAmounts(tokenOut) - usdgAmount,
  42 |     |             usdgAmount,
  43 |     |             vault.mintBurnFeeBasisPoints(),
  44 |     |             vault.taxBasisPoints(),
  45 |     |             false
  46 |     |         );
  47 |     | 
  48 |     |         uint256 redemptionAmount = _getRedemptionAmount(tokenOut, usdgAmount);
  49 |     |         amount = _collectSwapFees(redemptionAmount, feeBasisPoints);
  50 |     |     }
  51 |     | 
  52 |     |     function getMaxAmountIn(IERC20 tokenIn) public view returns (uint256 amount) {
  53 |     |         amount = MathLib.subWithZeroFloor(vault.maxUsdgAmounts(address(tokenIn)), vault.usdgAmounts(address(tokenIn)));
  54 |     |     }
  55 |     | 
  56 |     |     function getMintedGlpFromTokenIn(address tokenIn, uint256 amount) public view returns (uint256 amountOut, uint256 feeBasisPoints) {
  57 |     |         uint256 aumInUsdg = manager.getAumInUsdg(true);
  58 |     |         uint256 usdgAmount;
  59 |     |         (usdgAmount, feeBasisPoints) = _simulateBuyUSDG(tokenIn, amount);
  60 |     | 
  61 |     |         amountOut = (aumInUsdg == 0 ? usdgAmount : ((usdgAmount * PRICE_PRECISION) / getGlpPrice()));
  62 |     |     }
  63 |     | 
  64 |     |     function getUsdgAmountFromTokenIn(address tokenIn, uint256 tokenAmount) public view returns (uint256 usdgAmount) {
  65 |     |         uint256 price = vault.getMinPrice(tokenIn);
  66 |     |         uint256 rawUsdgAmount = (tokenAmount * price) / PRICE_PRECISION;
  67 |     |         return vault.adjustForDecimals(rawUsdgAmount, tokenIn, address(usdg));
  68 |     |     }
  69 |     | 
  70 |     |     function _simulateBuyUSDG(address tokenIn, uint256 tokenAmount) private view returns (uint256 mintAmount, uint256 feeBasisPoints) {
  71 |     |         uint256 usdgAmount = getUsdgAmountFromTokenIn(tokenIn, tokenAmount);
  72 |     | 
  73 |     |         feeBasisPoints = _getFeeBasisPoints(
  74 |     |             tokenIn,
  75 |     |             vault.usdgAmounts(tokenIn),
  76 |     |             usdgAmount,
  77 |     |             vault.mintBurnFeeBasisPoints(),
  78 |     |             vault.taxBasisPoints(),
  79 |     |             true
  80 |     |         );
  81 |     | 
  82 |     |         uint256 amountAfterFees = _collectSwapFees(tokenAmount, feeBasisPoints);
  83 |     |         mintAmount = getUsdgAmountFromTokenIn(tokenIn, amountAfterFees);
  84 |     |     }
  85 |     | 
  86 |     |     function _collectSwapFees(uint256 _amount, uint256 _feeBasisPoints) private pure returns (uint256) {
  87 |     |         return (_amount * (BASIS_POINTS_DIVISOR - _feeBasisPoints)) / BASIS_POINTS_DIVISOR;
  88 |     |     }
  89 |     | 
  90 |     |     function _getFeeBasisPoints(
  91 |     |         address _token,
  92 |     |         uint256 tokenUsdgAmount,
  93 |     |         uint256 _usdgDelta,
  94 |     |         uint256 _feeBasisPoints,
  95 |     |         uint256 _taxBasisPoints,
  96 |     |         bool _increment
  97 |     |     ) private view returns (uint256) {
  98 |     |         if (!vault.hasDynamicFees()) {
  99 |     |             return _feeBasisPoints;
 100 |     |         }
 101 |     | 
 102 |     |         uint256 initialAmount = tokenUsdgAmount;
 103 |     |         uint256 nextAmount = initialAmount + _usdgDelta;
 104 |     |         if (!_increment) {
 105 |     |             nextAmount = _usdgDelta > initialAmount ? 0 : initialAmount - _usdgDelta;
 106 |     |         }
 107 |     | 
 108 |     |         uint256 targetAmount = _getTargetUsdgAmount(_token);
 109 |     |         if (targetAmount == 0) {
 110 |     |             return _feeBasisPoints;
 111 |     |         }
 112 |     | 
 113 |     |         uint256 initialDiff = initialAmount > targetAmount ? initialAmount - targetAmount : targetAmount - initialAmount;
 114 |     |         uint256 nextDiff = nextAmount > targetAmount ? nextAmount - targetAmount : targetAmount - nextAmount;
 115 |     | 
 116 |     |         if (nextDiff < initialDiff) {
 117 |     |             uint256 rebateBps = (_taxBasisPoints * initialDiff) / targetAmount;
 118 |     |             return rebateBps > _feeBasisPoints ? 0 : _feeBasisPoints - rebateBps;
 119 |     |         }
 120 |     | 
 121 |     |         uint256 averageDiff = (initialDiff + nextDiff) / 2;
 122 |     |         if (averageDiff > targetAmount) {
 123 |     |             averageDiff = targetAmount;
 124 |     |         }
 125 |     |         uint256 taxBps = (_taxBasisPoints * averageDiff) / targetAmount;
 126 |     |         return _feeBasisPoints + taxBps;
 127 |     |     }
 128 |     | 
 129 |     |     function _getTargetUsdgAmount(address _token) private view returns (uint256) {
 130 |     |         uint256 supply = IERC20(usdg).totalSupply();
 131 |     | 
 132 |     |         if (supply == 0) {
 133 |     |             return 0;
 134 |     |         }
 135 |     |         uint256 weight = vault.tokenWeights(_token);
 136 |     |         return (weight * supply) / vault.totalTokenWeights();
 137 |     |     }
 138 |     | 
 139 |     |     function _decreaseUsdgAmount(address _token, uint256 _amount) private view returns (uint256) {
 140 |     |         uint256 value = vault.usdgAmounts(_token);
 141 |     |         if (value <= _amount) {
 142 |     |             return 0;
 143 |     |         }
 144 |     |         return value - _amount;
 145 |     |     }
 146 |     | 
 147 |     |     function _getRedemptionAmount(address _token, uint256 _usdgAmount) private view returns (uint256) {
 148 |     |         uint256 price = _getMaxPrice(_token);
 149 |     |         uint256 redemptionAmount = (_usdgAmount * PRICE_PRECISION) / price;
 150 |     | 
 151 |     |         return _adjustForDecimals(redemptionAmount, address(usdg), _token);
 152 |     |     }
 153 |     | 
 154 |     |     function _adjustForDecimals(uint256 _amount, address _tokenDiv, address _tokenMul) private view returns (uint256) {
 155 |     |         uint256 decimalsDiv = _tokenDiv == address(usdg) ? USDG_DECIMALS : vault.tokenDecimals(_tokenDiv);
 156 |     |         uint256 decimalsMul = _tokenMul == address(usdg) ? USDG_DECIMALS : vault.tokenDecimals(_tokenMul);
 157 |     | 
 158 |     |         return (_amount * 10 ** decimalsMul) / 10 ** decimalsDiv;
 159 |     |     }
 160 |     | 
 161 |     |     function _getMaxPrice(address _token) private view returns (uint256) {
 162 |     |         return IVaultPriceFeed(vault.priceFeed()).getPrice(_token, true, false, true);
 163 |     |     }
 164 |     | }
 165 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/lenses/InterestStrategyLens.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | interface IInterestStrategy {
  5 |     |     function interestPerSecond() external view returns (uint64);
  6 |     | 
  7 |     |     function lastAccrued() external view returns (uint64);
  8 |     | 
  9 |     |     function pendingFeeEarned() external view returns (uint128);
 10 |     | 
 11 |     |     function principal() external view returns (uint256);
 12 |     | }
 13 |     | 
 14 |     | contract InterestStrategyLens {
 15 |     |     function previewAccrue(IInterestStrategy strategy) external view returns (uint128) {
 16 |     |         uint64 lastAccrued = strategy.lastAccrued();
 17 |     |         uint64 interestPerSecond = strategy.interestPerSecond();
 18 |     |         uint128 pendingFeeEarned = strategy.pendingFeeEarned();
 19 |     |         uint128 interest;
 20 |     |         uint256 principal = strategy.principal();
 21 |     | 
 22 |     |         if (lastAccrued == 0) {
 23 |     |             if (principal > 0) {
 24 |     |                 lastAccrued = uint64(block.timestamp);
 25 |     |             }
 26 |     |             return 0;
 27 |     |         }
 28 |     | 
 29 |     |         uint256 elapsedTime = block.timestamp - lastAccrued;
 30 |     |         if (elapsedTime == 0) {
 31 |     |             return 0;
 32 |     |         }
 33 |     | 
 34 |     |         lastAccrued = uint64(block.timestamp);
 35 |     | 
 36 |     |         if (principal == 0) {
 37 |     |             return 0;
 38 |     |         }
 39 |     | 
 40 |     |         interest = uint128((principal * interestPerSecond * elapsedTime) / 1e18);
 41 |     |         pendingFeeEarned += interest;
 42 |     | 
 43 |     |         return interest;
 44 |     |     }
 45 |     | }
 46 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/lenses/MarketLens.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity ^0.8.9;
   3 |     | 
   4 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
   5 |     | import {ICauldronV2} from "interfaces/ICauldronV2.sol";
   6 |     | import {ICauldronV3} from "interfaces/ICauldronV3.sol";
   7 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   8 |     | import {MathLib} from "libraries/MathLib.sol";
   9 |     | import {CauldronLib} from "libraries/CauldronLib.sol";
  10 |     | 
  11 |     | contract MarketLens {
  12 |     |     struct UserPosition {
  13 |     |         address cauldron;
  14 |     |         address account;
  15 |     |         uint256 ltvBps;
  16 |     |         uint256 healthFactor;
  17 |     |         uint256 borrowValue;
  18 |     |         AmountValue collateral;
  19 |     |         uint256 liquidationPrice;
  20 |     |     }
  21 |     | 
  22 |     |     struct MarketInfo {
  23 |     |         address cauldron;
  24 |     |         uint256 borrowFee;
  25 |     |         uint256 maximumCollateralRatio;
  26 |     |         uint256 liquidationFee;
  27 |     |         uint256 interestPerYear;
  28 |     |         uint256 marketMaxBorrow;
  29 |     |         uint256 userMaxBorrow;
  30 |     |         uint256 totalBorrowed;
  31 |     |         uint256 oracleExchangeRate;
  32 |     |         uint256 collateralPrice;
  33 |     |         AmountValue totalCollateral;
  34 |     |     }
  35 |     | 
  36 |     |     struct AmountValue {
  37 |     |         uint256 amount;
  38 |     |         uint256 value;
  39 |     |     }
  40 |     | 
  41 |     |     uint256 constant PRECISION = 1e18;
  42 |     |     uint256 constant TENK_PRECISION = 1e5;
  43 |     |     uint256 constant BPS_PRECISION = 1e4;
  44 |     | 
  45 |     |     function getBorrowFee(ICauldronV2 cauldron) public view returns (uint256) {
  46 |     |         return (cauldron.BORROW_OPENING_FEE() * BPS_PRECISION) / TENK_PRECISION;
  47 |     |     }
  48 |     | 
  49 |     |     function getMaximumCollateralRatio(ICauldronV2 cauldron) public view returns (uint256) {
  50 |     |         return (cauldron.COLLATERIZATION_RATE() * BPS_PRECISION) / TENK_PRECISION;
  51 |     |     }
  52 |     | 
  53 |     |     function getLiquidationFee(ICauldronV2 cauldron) public view returns (uint256) {
  54 |     |         uint256 liquidationFee = cauldron.LIQUIDATION_MULTIPLIER() - 100_000;
  55 |     |         return (liquidationFee * BPS_PRECISION) / TENK_PRECISION;
  56 |     |     }
  57 |     | 
  58 |     |     function getInterestPerYear(ICauldronV2 cauldron) public view returns (uint64) {
  59 |     |         (, , uint64 interestPerSecond) = cauldron.accrueInfo();
  60 |     |         return CauldronLib.getInterestPerYearFromInterestPerSecond(interestPerSecond);
  61 |     |     }
  62 |     | 
  63 |     |     function getMimInBentoBox(ICauldronV2 cauldron) private view returns (uint256 mimInBentoBox) {
  64 |     |         IBentoBoxV1 bentoBox = IBentoBoxV1(cauldron.bentoBox());
  65 |     |         IERC20 mim = IERC20(cauldron.magicInternetMoney());
  66 |     |         uint256 poolBalance = bentoBox.balanceOf(mim, address(cauldron));
  67 |     |         mimInBentoBox = bentoBox.toAmount(mim, poolBalance, false);
  68 |     |     }
  69 |     | 
  70 |     |     function getTokenInBentoBox(IBentoBoxV1 bentoBox, IERC20 token, address account) public view returns (uint256 share, uint256 amount) {
  71 |     |         return (bentoBox.balanceOf(token, account), bentoBox.toAmount(token, share, false));
  72 |     |     }
  73 |     | 
  74 |     |     function getMaxMarketBorrowForCauldronV2(ICauldronV2 cauldron) public view returns (uint256) {
  75 |     |         return getMimInBentoBox(cauldron);
  76 |     |     }
  77 |     | 
  78 |     |     function getMaxUserBorrowForCauldronV2(ICauldronV2 cauldron) public view returns (uint256) {
  79 |     |         return getMimInBentoBox(cauldron);
  80 |     |     }
  81 |     | 
  82 |     |     // Returns the maximum amount that can be borrowed across all users
  83 |     |     function getMaxMarketBorrowForCauldronV3(ICauldronV3 cauldron) public view returns (uint256) {
  84 |     |         (uint256 totalBorrowLimit, ) = cauldron.borrowLimit();
  85 |     | 
  86 |     |         uint256 mimInBentoBox = getMimInBentoBox(cauldron);
  87 |     |         uint256 remainingBorrowLimit = MathLib.subWithZeroFloor(totalBorrowLimit, getTotalBorrowed(cauldron));
  88 |     | 
  89 |     |         return MathLib.min(mimInBentoBox, remainingBorrowLimit);
  90 |     |     }
  91 |     | 
  92 |     |     // Returns the maximum amount that a single user can borrow
  93 |     |     function getMaxUserBorrowForCauldronV3(ICauldronV3 cauldron) public view returns (uint256) {
  94 |     |         (uint256 totalBorrowLimit, uint256 userBorrowLimit) = cauldron.borrowLimit();
  95 |     | 
  96 |     |         uint256[] memory values = new uint256[](3);
  97 |     |         values[0] = getMimInBentoBox(cauldron);
  98 |     |         values[1] = MathLib.subWithZeroFloor(totalBorrowLimit, getTotalBorrowed(cauldron));
  99 |     |         values[2] = userBorrowLimit;
 100 |     | 
 101 |     |         return MathLib.min(values);
 102 |     |     }
 103 |     | 
 104 |     |     function getTotalBorrowed(ICauldronV2 cauldron) public view returns (uint256) {
 105 |     |         return CauldronLib.getTotalBorrowWithAccruedInterests(cauldron).elastic;
 106 |     |     }
 107 |     | 
 108 |     |     function getOracleExchangeRate(ICauldronV2 cauldron) public view returns (uint256) {
 109 |     |         return CauldronLib.getOracleExchangeRate(cauldron);
 110 |     |     }
 111 |     | 
 112 |     |     function getCollateralPrice(ICauldronV2 cauldron) public view returns (uint256) {
 113 |     |         return CauldronLib.getCollateralPrice(cauldron);
 114 |     |     }
 115 |     | 
 116 |     |     function getTotalCollateral(ICauldronV2 cauldron) public view returns (AmountValue memory) {
 117 |     |         IBentoBoxV1 bentoBox = IBentoBoxV1(cauldron.bentoBox());
 118 |     |         uint256 amount = bentoBox.toAmount(cauldron.collateral(), cauldron.totalCollateralShare(), false);
 119 |     |         uint256 value = (amount * PRECISION) / getOracleExchangeRate(cauldron);
 120 |     |         return AmountValue(amount, value);
 121 |     |     }
 122 |     | 
 123 |     |     function getUserBorrow(ICauldronV2 cauldron, address account) public view returns (uint256) {
 124 |     |         return CauldronLib.getUserBorrowAmount(cauldron, account);
 125 |     |     }
 126 |     | 
 127 |     |     function getUserMaxBorrow(ICauldronV2 cauldron, address account) public view returns (uint256) {
 128 |     |         (, uint256 value) = CauldronLib.getUserCollateral(cauldron, account);
 129 |     |         return (value * getMaximumCollateralRatio(cauldron)) / TENK_PRECISION;
 130 |     |     }
 131 |     | 
 132 |     |     function getUserCollateral(ICauldronV2 cauldron, address account) public view returns (AmountValue memory) {
 133 |     |         (uint256 amount, uint256 value) = CauldronLib.getUserCollateral(cauldron, account);
 134 |     |         return AmountValue(amount, value);
 135 |     |     }
 136 |     | 
 137 |     |     function getUserLtv(ICauldronV2 cauldron, address account) public view returns (uint256 ltvBps) {
 138 |     |         (ltvBps, , , , , ) = CauldronLib.getUserPositionInfo(cauldron, account);
 139 |     |     }
 140 |     | 
 141 |     |     function getHealthFactor(ICauldronV2 cauldron, address account, bool isStable) public view returns (uint256) {
 142 |     |         (, uint256 healthFactor, , , , ) = CauldronLib.getUserPositionInfo(cauldron, account);
 143 |     |         return isStable ? healthFactor * 10 : healthFactor;
 144 |     |     }
 145 |     | 
 146 |     |     function getUserLiquidationPrice(ICauldronV2 cauldron, address account) public view returns (uint256 liquidationPrice) {
 147 |     |         (, , , , liquidationPrice, ) = CauldronLib.getUserPositionInfo(cauldron, account);
 148 |     |     }
 149 |     | 
 150 |     |     function getUserPosition(ICauldronV2 cauldron, address account) public view returns (UserPosition memory) {
 151 |     |         (
 152 |     |             uint256 ltvBps,
 153 |     |             uint256 healthFactor,
 154 |     |             uint256 borrowValue,
 155 |     |             uint256 collateralValue,
 156 |     |             uint256 liquidationPrice,
 157 |     |             uint256 collateralAmount
 158 |     |         ) = CauldronLib.getUserPositionInfo(cauldron, account);
 159 |     | 
 160 |     |         return
 161 |     |             UserPosition(
 162 |     |                 address(cauldron),
 163 |     |                 address(account),
 164 |     |                 ltvBps,
 165 |     |                 healthFactor,
 166 |     |                 borrowValue,
 167 |     |                 AmountValue({amount: collateralAmount, value: collateralValue}),
 168 |     |                 liquidationPrice
 169 |     |             );
 170 |     |     }
 171 |     | 
 172 |     |     // Get many user position information at once.
 173 |     |     // Beware of hitting RPC `eth_call` gas limit
 174 |     |     function getUserPositions(ICauldronV2 cauldron, address[] calldata accounts) public view returns (UserPosition[] memory positions) {
 175 |     |         positions = new UserPosition[](accounts.length);
 176 |     |         for (uint256 i = 0; i < accounts.length; i++) {
 177 |     |             positions[i] = getUserPosition(cauldron, accounts[i]);
 178 |     |         }
 179 |     |     }
 180 |     | 
 181 |     |     function getMarketInfoCauldronV2(ICauldronV2 cauldron) public view returns (MarketInfo memory) {
 182 |     |         return
 183 |     |             MarketInfo({
 184 |     |                 cauldron: address(cauldron),
 185 |     |                 borrowFee: getBorrowFee(cauldron),
 186 |     |                 maximumCollateralRatio: getMaximumCollateralRatio(cauldron),
 187 |     |                 liquidationFee: getLiquidationFee(cauldron),
 188 |     |                 interestPerYear: getInterestPerYear(cauldron),
 189 |     |                 marketMaxBorrow: getMaxMarketBorrowForCauldronV2(cauldron),
 190 |     |                 userMaxBorrow: getMaxUserBorrowForCauldronV2(cauldron),
 191 |     |                 totalBorrowed: getTotalBorrowed(cauldron),
 192 |     |                 oracleExchangeRate: getOracleExchangeRate(cauldron),
 193 |     |                 collateralPrice: getCollateralPrice(cauldron),
 194 |     |                 totalCollateral: getTotalCollateral(cauldron)
 195 |     |             });
 196 |     |     }
 197 |     | 
 198 |     |     function getMarketInfoCauldronV3(ICauldronV3 cauldron) public view returns (MarketInfo memory marketInfo) {
 199 |     |         marketInfo = getMarketInfoCauldronV2(cauldron);
 200 |     |         marketInfo.marketMaxBorrow = getMaxMarketBorrowForCauldronV3(cauldron);
 201 |     |         marketInfo.userMaxBorrow = getMaxUserBorrowForCauldronV3(cauldron);
 202 |     |     }
 203 |     | }
 204 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/libraries/BabylonianLib.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @notice Babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method).
  5 |     | library BabylonianLib {
  6 |     |     // computes square roots using the babylonian method
  7 |     |     // credit for this implementation goes to
  8 |     |     // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687
  9 |     |     function sqrt(uint256 x) internal pure returns (uint256) {
 10 |     |         if (x == 0) return 0;
 11 |     |         // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);
 12 |     |         // however that code costs significantly more gas
 13 |     |         uint256 xx = x;
 14 |     |         uint256 r = 1;
 15 |     |         if (xx >= 0x100000000000000000000000000000000) {
 16 |     |             xx >>= 128;
 17 |     |             r <<= 64;
 18 |     |         }
 19 |     |         if (xx >= 0x10000000000000000) {
 20 |     |             xx >>= 64;
 21 |     |             r <<= 32;
 22 |     |         }
 23 |     |         if (xx >= 0x100000000) {
 24 |     |             xx >>= 32;
 25 |     |             r <<= 16;
 26 |     |         }
 27 |     |         if (xx >= 0x10000) {
 28 |     |             xx >>= 16;
 29 |     |             r <<= 8;
 30 |     |         }
 31 |     |         if (xx >= 0x100) {
 32 |     |             xx >>= 8;
 33 |     |             r <<= 4;
 34 |     |         }
 35 |     |         if (xx >= 0x10) {
 36 |     |             xx >>= 4;
 37 |     |             r <<= 2;
 38 |     |         }
 39 |     |         if (xx >= 0x8) {
 40 |     |             r <<= 1;
 41 |     |         }
 42 |     |         r = (r + x / r) >> 1;
 43 |     |         r = (r + x / r) >> 1;
 44 |     |         r = (r + x / r) >> 1;
 45 |     |         r = (r + x / r) >> 1;
 46 |     |         r = (r + x / r) >> 1;
 47 |     |         r = (r + x / r) >> 1;
 48 |     |         r = (r + x / r) >> 1; // Seven iterations should be enough
 49 |     |         uint256 r1 = x / r;
 50 |     |         return (r < r1 ? r : r1);
 51 |     |     }
 52 |     | }

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/libraries/BytesLib.sol
   1 |     | // SPDX-License-Identifier: Unlicense
   2 |     | /*
   3 |     |  * @title Solidity Bytes Arrays Utils
   4 |     |  * @author Gonçalo Sá <goncalo.sa@consensys.net>
   5 |     |  *
   6 |     |  * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.
   7 |     |  *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.
   8 |     |  */
   9 |     | pragma solidity >=0.8.0 <0.9.0;
  10 |     | 
  11 |     | library BytesLib {
  12 |     |     function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {
  13 |     |         bytes memory tempBytes;
  14 |     | 
  15 |     |         assembly {
  16 |     |             // Get a location of some free memory and store it in tempBytes as
  17 |     |             // Solidity does for memory variables.
  18 |     |             tempBytes := mload(0x40)
  19 |     | 
  20 |     |             // Store the length of the first bytes array at the beginning of
  21 |     |             // the memory for tempBytes.
  22 |     |             let length := mload(_preBytes)
  23 |     |             mstore(tempBytes, length)
  24 |     | 
  25 |     |             // Maintain a memory counter for the current write location in the
  26 |     |             // temp bytes array by adding the 32 bytes for the array length to
  27 |     |             // the starting location.
  28 |     |             let mc := add(tempBytes, 0x20)
  29 |     |             // Stop copying when the memory counter reaches the length of the
  30 |     |             // first bytes array.
  31 |     |             let end := add(mc, length)
  32 |     | 
  33 |     |             for {
  34 |     |                 // Initialize a copy counter to the start of the _preBytes data,
  35 |     |                 // 32 bytes into its memory.
  36 |     |                 let cc := add(_preBytes, 0x20)
  37 |     |             } lt(mc, end) {
  38 |     |                 // Increase both counters by 32 bytes each iteration.
  39 |     |                 mc := add(mc, 0x20)
  40 |     |                 cc := add(cc, 0x20)
  41 |     |             } {
  42 |     |                 // Write the _preBytes data into the tempBytes memory 32 bytes
  43 |     |                 // at a time.
  44 |     |                 mstore(mc, mload(cc))
  45 |     |             }
  46 |     | 
  47 |     |             // Add the length of _postBytes to the current length of tempBytes
  48 |     |             // and store it as the new length in the first 32 bytes of the
  49 |     |             // tempBytes memory.
  50 |     |             length := mload(_postBytes)
  51 |     |             mstore(tempBytes, add(length, mload(tempBytes)))
  52 |     | 
  53 |     |             // Move the memory counter back from a multiple of 0x20 to the
  54 |     |             // actual end of the _preBytes data.
  55 |     |             mc := end
  56 |     |             // Stop copying when the memory counter reaches the new combined
  57 |     |             // length of the arrays.
  58 |     |             end := add(mc, length)
  59 |     | 
  60 |     |             for {
  61 |     |                 let cc := add(_postBytes, 0x20)
  62 |     |             } lt(mc, end) {
  63 |     |                 mc := add(mc, 0x20)
  64 |     |                 cc := add(cc, 0x20)
  65 |     |             } {
  66 |     |                 mstore(mc, mload(cc))
  67 |     |             }
  68 |     | 
  69 |     |             // Update the free-memory pointer by padding our last write location
  70 |     |             // to 32 bytes: add 31 bytes to the end of tempBytes to move to the
  71 |     |             // next 32 byte block, then round down to the nearest multiple of
  72 |     |             // 32. If the sum of the length of the two arrays is zero then add
  73 |     |             // one before rounding down to leave a blank 32 bytes (the length block with 0).
  74 |     |             mstore(
  75 |     |                 0x40,
  76 |     |                 and(
  77 |     |                     add(add(end, iszero(add(length, mload(_preBytes)))), 31),
  78 |     |                     not(31) // Round down to the nearest 32 bytes.
  79 |     |                 )
  80 |     |             )
  81 |     |         }
  82 |     | 
  83 |     |         return tempBytes;
  84 |     |     }
  85 |     | 
  86 |     |     function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {
  87 |     |         assembly {
  88 |     |             // Read the first 32 bytes of _preBytes storage, which is the length
  89 |     |             // of the array. (We don't need to use the offset into the slot
  90 |     |             // because arrays use the entire slot.)
  91 |     |             let fslot := sload(_preBytes.slot)
  92 |     |             // Arrays of 31 bytes or less have an even value in their slot,
  93 |     |             // while longer arrays have an odd value. The actual length is
  94 |     |             // the slot divided by two for odd values, and the lowest order
  95 |     |             // byte divided by two for even values.
  96 |     |             // If the slot is even, bitwise and the slot with 255 and divide by
  97 |     |             // two to get the length. If the slot is odd, bitwise and the slot
  98 |     |             // with -1 and divide by two.
  99 |     |             let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)
 100 |     |             let mlength := mload(_postBytes)
 101 |     |             let newlength := add(slength, mlength)
 102 |     |             // slength can contain both the length and contents of the array
 103 |     |             // if length < 32 bytes so let's prepare for that
 104 |     |             // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage
 105 |     |             switch add(lt(slength, 32), lt(newlength, 32))
 106 |     |             case 2 {
 107 |     |                 // Since the new array still fits in the slot, we just need to
 108 |     |                 // update the contents of the slot.
 109 |     |                 // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length
 110 |     |                 sstore(
 111 |     |                     _preBytes.slot,
 112 |     |                     // all the modifications to the slot are inside this
 113 |     |                     // next block
 114 |     |                     add(
 115 |     |                         // we can just add to the slot contents because the
 116 |     |                         // bytes we want to change are the LSBs
 117 |     |                         fslot,
 118 |     |                         add(
 119 |     |                             mul(
 120 |     |                                 div(
 121 |     |                                     // load the bytes from memory
 122 |     |                                     mload(add(_postBytes, 0x20)),
 123 |     |                                     // zero all bytes to the right
 124 |     |                                     exp(0x100, sub(32, mlength))
 125 |     |                                 ),
 126 |     |                                 // and now shift left the number of bytes to
 127 |     |                                 // leave space for the length in the slot
 128 |     |                                 exp(0x100, sub(32, newlength))
 129 |     |                             ),
 130 |     |                             // increase length by the double of the memory
 131 |     |                             // bytes length
 132 |     |                             mul(mlength, 2)
 133 |     |                         )
 134 |     |                     )
 135 |     |                 )
 136 |     |             }
 137 |     |             case 1 {
 138 |     |                 // The stored value fits in the slot, but the combined value
 139 |     |                 // will exceed it.
 140 |     |                 // get the keccak hash to get the contents of the array
 141 |     |                 mstore(0x0, _preBytes.slot)
 142 |     |                 let sc := add(keccak256(0x0, 0x20), div(slength, 32))
 143 |     | 
 144 |     |                 // save new length
 145 |     |                 sstore(_preBytes.slot, add(mul(newlength, 2), 1))
 146 |     | 
 147 |     |                 // The contents of the _postBytes array start 32 bytes into
 148 |     |                 // the structure. Our first read should obtain the `submod`
 149 |     |                 // bytes that can fit into the unused space in the last word
 150 |     |                 // of the stored array. To get this, we read 32 bytes starting
 151 |     |                 // from `submod`, so the data we read overlaps with the array
 152 |     |                 // contents by `submod` bytes. Masking the lowest-order
 153 |     |                 // `submod` bytes allows us to add that value directly to the
 154 |     |                 // stored value.
 155 |     | 
 156 |     |                 let submod := sub(32, slength)
 157 |     |                 let mc := add(_postBytes, submod)
 158 |     |                 let end := add(_postBytes, mlength)
 159 |     |                 let mask := sub(exp(0x100, submod), 1)
 160 |     | 
 161 |     |                 sstore(sc, add(and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00), and(mload(mc), mask)))
 162 |     | 
 163 |     |                 for {
 164 |     |                     mc := add(mc, 0x20)
 165 |     |                     sc := add(sc, 1)
 166 |     |                 } lt(mc, end) {
 167 |     |                     sc := add(sc, 1)
 168 |     |                     mc := add(mc, 0x20)
 169 |     |                 } {
 170 |     |                     sstore(sc, mload(mc))
 171 |     |                 }
 172 |     | 
 173 |     |                 mask := exp(0x100, sub(mc, end))
 174 |     | 
 175 |     |                 sstore(sc, mul(div(mload(mc), mask), mask))
 176 |     |             }
 177 |     |             default {
 178 |     |                 // get the keccak hash to get the contents of the array
 179 |     |                 mstore(0x0, _preBytes.slot)
 180 |     |                 // Start copying to the last used word of the stored array.
 181 |     |                 let sc := add(keccak256(0x0, 0x20), div(slength, 32))
 182 |     | 
 183 |     |                 // save new length
 184 |     |                 sstore(_preBytes.slot, add(mul(newlength, 2), 1))
 185 |     | 
 186 |     |                 // Copy over the first `submod` bytes of the new data as in
 187 |     |                 // case 1 above.
 188 |     |                 let slengthmod := mod(slength, 32)
 189 |     |                 let mlengthmod := mod(mlength, 32)
 190 |     |                 let submod := sub(32, slengthmod)
 191 |     |                 let mc := add(_postBytes, submod)
 192 |     |                 let end := add(_postBytes, mlength)
 193 |     |                 let mask := sub(exp(0x100, submod), 1)
 194 |     | 
 195 |     |                 sstore(sc, add(sload(sc), and(mload(mc), mask)))
 196 |     | 
 197 |     |                 for {
 198 |     |                     sc := add(sc, 1)
 199 |     |                     mc := add(mc, 0x20)
 200 |     |                 } lt(mc, end) {
 201 |     |                     sc := add(sc, 1)
 202 |     |                     mc := add(mc, 0x20)
 203 |     |                 } {
 204 |     |                     sstore(sc, mload(mc))
 205 |     |                 }
 206 |     | 
 207 |     |                 mask := exp(0x100, sub(mc, end))
 208 |     | 
 209 |     |                 sstore(sc, mul(div(mload(mc), mask), mask))
 210 |     |             }
 211 |     |         }
 212 |     |     }
 213 |     | 
 214 |     |     function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {
 215 |     |         require(_length + 31 >= _length, "slice_overflow");
 216 |     |         require(_bytes.length >= _start + _length, "slice_outOfBounds");
 217 |     | 
 218 |     |         bytes memory tempBytes;
 219 |     | 
 220 |     |         assembly {
 221 |     |             switch iszero(_length)
 222 |     |             case 0 {
 223 |     |                 // Get a location of some free memory and store it in tempBytes as
 224 |     |                 // Solidity does for memory variables.
 225 |     |                 tempBytes := mload(0x40)
 226 |     | 
 227 |     |                 // The first word of the slice result is potentially a partial
 228 |     |                 // word read from the original array. To read it, we calculate
 229 |     |                 // the length of that partial word and start copying that many
 230 |     |                 // bytes into the array. The first word we copy will start with
 231 |     |                 // data we don't care about, but the last `lengthmod` bytes will
 232 |     |                 // land at the beginning of the contents of the new array. When
 233 |     |                 // we're done copying, we overwrite the full first word with
 234 |     |                 // the actual length of the slice.
 235 |     |                 let lengthmod := and(_length, 31)
 236 |     | 
 237 |     |                 // The multiplication in the next line is necessary
 238 |     |                 // because when slicing multiples of 32 bytes (lengthmod == 0)
 239 |     |                 // the following copy loop was copying the origin's length
 240 |     |                 // and then ending prematurely not copying everything it should.
 241 |     |                 let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))
 242 |     |                 let end := add(mc, _length)
 243 |     | 
 244 |     |                 for {
 245 |     |                     // The multiplication in the next line has the same exact purpose
 246 |     |                     // as the one above.
 247 |     |                     let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)
 248 |     |                 } lt(mc, end) {
 249 |     |                     mc := add(mc, 0x20)
 250 |     |                     cc := add(cc, 0x20)
 251 |     |                 } {
 252 |     |                     mstore(mc, mload(cc))
 253 |     |                 }
 254 |     | 
 255 |     |                 mstore(tempBytes, _length)
 256 |     | 
 257 |     |                 //update free-memory pointer
 258 |     |                 //allocating the array padded to 32 bytes like the compiler does now
 259 |     |                 mstore(0x40, and(add(mc, 31), not(31)))
 260 |     |             }
 261 |     |             //if we want a zero-length slice let's just return a zero-length array
 262 |     |             default {
 263 |     |                 tempBytes := mload(0x40)
 264 |     |                 //zero out the 32 bytes slice we are about to return
 265 |     |                 //we need to do it because Solidity does not garbage collect
 266 |     |                 mstore(tempBytes, 0)
 267 |     | 
 268 |     |                 mstore(0x40, add(tempBytes, 0x20))
 269 |     |             }
 270 |     |         }
 271 |     | 
 272 |     |         return tempBytes;
 273 |     |     }
 274 |     | 
 275 |     |     function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {
 276 |     |         require(_bytes.length >= _start + 20, "toAddress_outOfBounds");
 277 |     |         address tempAddress;
 278 |     | 
 279 |     |         assembly {
 280 |     |             tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)
 281 |     |         }
 282 |     | 
 283 |     |         return tempAddress;
 284 |     |     }
 285 |     | 
 286 |     |     function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {
 287 |     |         require(_bytes.length >= _start + 1, "toUint8_outOfBounds");
 288 |     |         uint8 tempUint;
 289 |     | 
 290 |     |         assembly {
 291 |     |             tempUint := mload(add(add(_bytes, 0x1), _start))
 292 |     |         }
 293 |     | 
 294 |     |         return tempUint;
 295 |     |     }
 296 |     | 
 297 |     |     function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {
 298 |     |         require(_bytes.length >= _start + 2, "toUint16_outOfBounds");
 299 |     |         uint16 tempUint;
 300 |     | 
 301 |     |         assembly {
 302 |     |             tempUint := mload(add(add(_bytes, 0x2), _start))
 303 |     |         }
 304 |     | 
 305 |     |         return tempUint;
 306 |     |     }
 307 |     | 
 308 |     |     function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {
 309 |     |         require(_bytes.length >= _start + 4, "toUint32_outOfBounds");
 310 |     |         uint32 tempUint;
 311 |     | 
 312 |     |         assembly {
 313 |     |             tempUint := mload(add(add(_bytes, 0x4), _start))
 314 |     |         }
 315 |     | 
 316 |     |         return tempUint;
 317 |     |     }
 318 |     | 
 319 |     |     function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {
 320 |     |         require(_bytes.length >= _start + 8, "toUint64_outOfBounds");
 321 |     |         uint64 tempUint;
 322 |     | 
 323 |     |         assembly {
 324 |     |             tempUint := mload(add(add(_bytes, 0x8), _start))
 325 |     |         }
 326 |     | 
 327 |     |         return tempUint;
 328 |     |     }
 329 |     | 
 330 |     |     function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {
 331 |     |         require(_bytes.length >= _start + 12, "toUint96_outOfBounds");
 332 |     |         uint96 tempUint;
 333 |     | 
 334 |     |         assembly {
 335 |     |             tempUint := mload(add(add(_bytes, 0xc), _start))
 336 |     |         }
 337 |     | 
 338 |     |         return tempUint;
 339 |     |     }
 340 |     | 
 341 |     |     function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {
 342 |     |         require(_bytes.length >= _start + 16, "toUint128_outOfBounds");
 343 |     |         uint128 tempUint;
 344 |     | 
 345 |     |         assembly {
 346 |     |             tempUint := mload(add(add(_bytes, 0x10), _start))
 347 |     |         }
 348 |     | 
 349 |     |         return tempUint;
 350 |     |     }
 351 |     | 
 352 |     |     function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {
 353 |     |         require(_bytes.length >= _start + 32, "toUint256_outOfBounds");
 354 |     |         uint256 tempUint;
 355 |     | 
 356 |     |         assembly {
 357 |     |             tempUint := mload(add(add(_bytes, 0x20), _start))
 358 |     |         }
 359 |     | 
 360 |     |         return tempUint;
 361 |     |     }
 362 |     | 
 363 |     |     function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {
 364 |     |         require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");
 365 |     |         bytes32 tempBytes32;
 366 |     | 
 367 |     |         assembly {
 368 |     |             tempBytes32 := mload(add(add(_bytes, 0x20), _start))
 369 |     |         }
 370 |     | 
 371 |     |         return tempBytes32;
 372 |     |     }
 373 |     | 
 374 |     |     function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {
 375 |     |         bool success = true;
 376 |     | 
 377 |     |         assembly {
 378 |     |             let length := mload(_preBytes)
 379 |     | 
 380 |     |             // if lengths don't match the arrays are not equal
 381 |     |             switch eq(length, mload(_postBytes))
 382 |     |             case 1 {
 383 |     |                 // cb is a circuit breaker in the for loop since there's
 384 |     |                 //  no said feature for inline assembly loops
 385 |     |                 // cb = 1 - don't breaker
 386 |     |                 // cb = 0 - break
 387 |     |                 let cb := 1
 388 |     | 
 389 |     |                 let mc := add(_preBytes, 0x20)
 390 |     |                 let end := add(mc, length)
 391 |     | 
 392 |     |                 for {
 393 |     |                     let cc := add(_postBytes, 0x20)
 394 |     |                     // the next line is the loop condition:
 395 |     |                     // while(uint256(mc < end) + cb == 2)
 396 |     |                 } eq(add(lt(mc, end), cb), 2) {
 397 |     |                     mc := add(mc, 0x20)
 398 |     |                     cc := add(cc, 0x20)
 399 |     |                 } {
 400 |     |                     // if any of these checks fails then arrays are not equal
 401 |     |                     if iszero(eq(mload(mc), mload(cc))) {
 402 |     |                         // unsuccess:
 403 |     |                         success := 0
 404 |     |                         cb := 0
 405 |     |                     }
 406 |     |                 }
 407 |     |             }
 408 |     |             default {
 409 |     |                 // unsuccess:
 410 |     |                 success := 0
 411 |     |             }
 412 |     |         }
 413 |     | 
 414 |     |         return success;
 415 |     |     }
 416 |     | 
 417 |     |     function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {
 418 |     |         bool success = true;
 419 |     | 
 420 |     |         assembly {
 421 |     |             // we know _preBytes_offset is 0
 422 |     |             let fslot := sload(_preBytes.slot)
 423 |     |             // Decode the length of the stored array like in concatStorage().
 424 |     |             let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)
 425 |     |             let mlength := mload(_postBytes)
 426 |     | 
 427 |     |             // if lengths don't match the arrays are not equal
 428 |     |             switch eq(slength, mlength)
 429 |     |             case 1 {
 430 |     |                 // slength can contain both the length and contents of the array
 431 |     |                 // if length < 32 bytes so let's prepare for that
 432 |     |                 // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage
 433 |     |                 if iszero(iszero(slength)) {
 434 |     |                     switch lt(slength, 32)
 435 |     |                     case 1 {
 436 |     |                         // blank the last byte which is the length
 437 |     |                         fslot := mul(div(fslot, 0x100), 0x100)
 438 |     | 
 439 |     |                         if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {
 440 |     |                             // unsuccess:
 441 |     |                             success := 0
 442 |     |                         }
 443 |     |                     }
 444 |     |                     default {
 445 |     |                         // cb is a circuit breaker in the for loop since there's
 446 |     |                         //  no said feature for inline assembly loops
 447 |     |                         // cb = 1 - don't breaker
 448 |     |                         // cb = 0 - break
 449 |     |                         let cb := 1
 450 |     | 
 451 |     |                         // get the keccak hash to get the contents of the array
 452 |     |                         mstore(0x0, _preBytes.slot)
 453 |     |                         let sc := keccak256(0x0, 0x20)
 454 |     | 
 455 |     |                         let mc := add(_postBytes, 0x20)
 456 |     |                         let end := add(mc, mlength)
 457 |     | 
 458 |     |                         // the next line is the loop condition:
 459 |     |                         // while(uint256(mc < end) + cb == 2)
 460 |     |                         for {
 461 |     | 
 462 |     |                         } eq(add(lt(mc, end), cb), 2) {
 463 |     |                             sc := add(sc, 1)
 464 |     |                             mc := add(mc, 0x20)
 465 |     |                         } {
 466 |     |                             if iszero(eq(sload(sc), mload(mc))) {
 467 |     |                                 // unsuccess:
 468 |     |                                 success := 0
 469 |     |                                 cb := 0
 470 |     |                             }
 471 |     |                         }
 472 |     |                     }
 473 |     |                 }
 474 |     |             }
 475 |     |             default {
 476 |     |                 // unsuccess:
 477 |     |                 success := 0
 478 |     |             }
 479 |     |         }
 480 |     | 
 481 |     |         return success;
 482 |     |     }
 483 |     | }
 484 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/libraries/CauldronLib.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity ^0.8.13;
   3 |     | 
   4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   5 |     | import {RebaseLibrary, Rebase} from "BoringSolidity/libraries/BoringRebase.sol";
   6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
   7 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
   8 |     | import {ICauldronV2} from "interfaces/ICauldronV2.sol";
   9 |     | import {ICauldronV3} from "interfaces/ICauldronV3.sol";
  10 |     | import {ICauldronV4} from "interfaces/ICauldronV4.sol";
  11 |     | import {IOracle} from "interfaces/IOracle.sol";
  12 |     | import {MathLib} from "libraries/MathLib.sol";
  13 |     | 
  14 |     | library CauldronLib {
  15 |     |     using BoringERC20 for IERC20;
  16 |     |     using RebaseLibrary for Rebase;
  17 |     | 
  18 |     |     uint256 internal constant EXCHANGE_RATE_PRECISION = 1e18;
  19 |     |     uint256 internal constant BPS_PRECISION = 1e4;
  20 |     |     uint256 internal constant COLLATERIZATION_RATE_PRECISION = 1e5;
  21 |     |     uint256 internal constant LIQUIDATION_MULTIPLIER_PRECISION = 1e5;
  22 |     |     uint256 internal constant DISTRIBUTION_PART = 10;
  23 |     |     uint256 internal constant DISTRIBUTION_PRECISION = 100;
  24 |     | 
  25 |     |     /// @dev example: 200 is 2% interests
  26 |     |     function getInterestPerSecond(uint256 interestBips) internal pure returns (uint64 interestsPerSecond) {
  27 |     |         return uint64((interestBips * 316880878) / 100); // 316880878 is the precomputed integral part of 1e18 / (36525 * 3600 * 24)
  28 |     |     }
  29 |     | 
  30 |     |     function getInterestPerYearFromInterestPerSecond(uint64 interestPerSecond) internal pure returns (uint64 interestPerYearBips) {
  31 |     |         return (interestPerSecond * 100) / 316880878;
  32 |     |     }
  33 |     | 
  34 |     |     function getUserBorrowAmount(ICauldronV2 cauldron, address user) internal view returns (uint256 borrowAmount) {
  35 |     |         Rebase memory totalBorrow = getTotalBorrowWithAccruedInterests(cauldron);
  36 |     |         return (cauldron.userBorrowPart(user) * totalBorrow.elastic) / totalBorrow.base;
  37 |     |     }
  38 |     | 
  39 |     |     // total borrow with on-fly accrued interests
  40 |     |     function getTotalBorrowWithAccruedInterests(ICauldronV2 cauldron) internal view returns (Rebase memory totalBorrow) {
  41 |     |         totalBorrow = cauldron.totalBorrow();
  42 |     |         (uint64 lastAccrued, , uint64 INTEREST_PER_SECOND) = cauldron.accrueInfo();
  43 |     |         uint256 elapsedTime = block.timestamp - lastAccrued;
  44 |     | 
  45 |     |         if (elapsedTime != 0 && totalBorrow.base != 0) {
  46 |     |             totalBorrow.elastic = totalBorrow.elastic + uint128((uint256(totalBorrow.elastic) * INTEREST_PER_SECOND * elapsedTime) / 1e18);
  47 |     |         }
  48 |     |     }
  49 |     | 
  50 |     |     function getOracleExchangeRate(ICauldronV2 cauldron) internal view returns (uint256) {
  51 |     |         IOracle oracle = IOracle(cauldron.oracle());
  52 |     |         bytes memory oracleData = cauldron.oracleData();
  53 |     |         return oracle.peekSpot(oracleData);
  54 |     |     }
  55 |     | 
  56 |     |     function getUserCollateral(ICauldronV2 cauldron, address account) internal view returns (uint256 amount, uint256 value) {
  57 |     |         IBentoBoxV1 bentoBox = IBentoBoxV1(cauldron.bentoBox());
  58 |     |         uint256 share = cauldron.userCollateralShare(account);
  59 |     | 
  60 |     |         amount = bentoBox.toAmount(cauldron.collateral(), share, false);
  61 |     |         value = (amount * EXCHANGE_RATE_PRECISION) / getOracleExchangeRate(cauldron);
  62 |     |     }
  63 |     | 
  64 |     |     function getUserPositionInfo(
  65 |     |         ICauldronV2 cauldron,
  66 |     |         address account
  67 |     |     )
  68 |     |         internal
  69 |     |         view
  70 |     |         returns (
  71 |     |             uint256 ltvBps,
  72 |     |             uint256 healthFactor,
  73 |     |             uint256 borrowValue,
  74 |     |             uint256 collateralValue,
  75 |     |             uint256 liquidationPrice,
  76 |     |             uint256 collateralAmount
  77 |     |         )
  78 |     |     {
  79 |     |         (collateralAmount, collateralValue) = getUserCollateral(cauldron, account);
  80 |     | 
  81 |     |         borrowValue = getUserBorrowAmount(cauldron, account);
  82 |     | 
  83 |     |         if (collateralValue > 0) {
  84 |     |             ltvBps = (borrowValue * BPS_PRECISION) / collateralValue;
  85 |     |             uint256 COLLATERALIZATION_RATE = cauldron.COLLATERIZATION_RATE(); // 1e5 precision
  86 |     | 
  87 |     |             // example with WBTC (8 decimals)
  88 |     |             // 18 + 8 + 5 - 5 - 8 - 10 = 8 decimals
  89 |     |             IERC20 collateral = cauldron.collateral();
  90 |     |             uint256 collateralPrecision = 10 ** collateral.safeDecimals();
  91 |     | 
  92 |     |             liquidationPrice =
  93 |     |                 (borrowValue * collateralPrecision ** 2 * 1e5) /
  94 |     |                 COLLATERALIZATION_RATE /
  95 |     |                 collateralAmount /
  96 |     |                 EXCHANGE_RATE_PRECISION;
  97 |     | 
  98 |     |             healthFactor = MathLib.subWithZeroFloor(
  99 |     |                 EXCHANGE_RATE_PRECISION,
 100 |     |                 (EXCHANGE_RATE_PRECISION * liquidationPrice * getOracleExchangeRate(cauldron)) / collateralPrecision ** 2
 101 |     |             );
 102 |     |         }
 103 |     |     }
 104 |     | 
 105 |     |     /// @notice the liquidator will get "MIM borrowPart" worth of collateral + liquidation fee incentive but borrowPart needs to be adjusted to take in account
 106 |     |     /// the sSpell distribution taken off the liquidation fee. This function takes in account the bad debt repayment in case
 107 |     |     /// the borrowPart give less collateral than it should.
 108 |     |     /// @param cauldron Cauldron contract
 109 |     |     /// @param account Account to liquidate
 110 |     |     /// @param borrowPart Amount of MIM debt to liquidate
 111 |     |     /// @return collateralAmount Amount of collateral that the liquidator will receive
 112 |     |     /// @return adjustedBorrowPart Adjusted borrowPart to take in account position with bad debt where the
 113 |     |     ///                            borrowPart give out more collateral than what the user has.
 114 |     |     /// @return requiredMim MIM amount that the liquidator will need to pay back to get the collateralShare
 115 |     |     function getLiquidationCollateralAndBorrowAmount(
 116 |     |         ICauldronV2 cauldron,
 117 |     |         address account,
 118 |     |         uint256 borrowPart
 119 |     |     ) internal view returns (uint256 collateralAmount, uint256 adjustedBorrowPart, uint256 requiredMim) {
 120 |     |         uint256 exchangeRate = getOracleExchangeRate(cauldron);
 121 |     |         Rebase memory totalBorrow = getTotalBorrowWithAccruedInterests(cauldron);
 122 |     |         IBentoBoxV1 box = IBentoBoxV1(cauldron.bentoBox());
 123 |     |         uint256 collateralShare = cauldron.userCollateralShare(account);
 124 |     |         IERC20 collateral = cauldron.collateral();
 125 |     | 
 126 |     |         // cap to the maximum amount of debt that can be liquidated in case the cauldron has bad debt
 127 |     |         {
 128 |     |             Rebase memory bentoBoxTotals = box.totals(collateral);
 129 |     | 
 130 |     |             // how much debt can be liquidated
 131 |     |             uint256 maxBorrowPart = (bentoBoxTotals.toElastic(collateralShare, false) * 1e23) /
 132 |     |                 (cauldron.LIQUIDATION_MULTIPLIER() * exchangeRate);
 133 |     |             maxBorrowPart = totalBorrow.toBase(maxBorrowPart, false);
 134 |     | 
 135 |     |             if (borrowPart > maxBorrowPart) {
 136 |     |                 borrowPart = maxBorrowPart;
 137 |     |             }
 138 |     |         }
 139 |     | 
 140 |     |         // convert borrowPart to debt
 141 |     |         requiredMim = totalBorrow.toElastic(borrowPart, false);
 142 |     | 
 143 |     |         // convert borrowPart to collateralShare
 144 |     |         {
 145 |     |             Rebase memory bentoBoxTotals = box.totals(collateral);
 146 |     | 
 147 |     |             // how much collateral share the liquidator will get from the given borrow amount
 148 |     |             collateralShare = bentoBoxTotals.toBase(
 149 |     |                 (requiredMim * cauldron.LIQUIDATION_MULTIPLIER() * exchangeRate) /
 150 |     |                     (LIQUIDATION_MULTIPLIER_PRECISION * EXCHANGE_RATE_PRECISION),
 151 |     |                 false
 152 |     |             );
 153 |     |             collateralAmount = box.toAmount(collateral, collateralShare, false);
 154 |     |         }
 155 |     | 
 156 |     |         // add the sSpell distribution part
 157 |     |         {
 158 |     |             requiredMim +=
 159 |     |                 ((((requiredMim * cauldron.LIQUIDATION_MULTIPLIER()) / LIQUIDATION_MULTIPLIER_PRECISION) - requiredMim) *
 160 |     |                     DISTRIBUTION_PART) /
 161 |     |                 DISTRIBUTION_PRECISION;
 162 |     | 
 163 |     |             IERC20 mim = cauldron.magicInternetMoney();
 164 |     | 
 165 |     |             // convert back and forth to amount to compensate for rounded up toShare conversion inside `liquidate`
 166 |     |             requiredMim = box.toAmount(mim, box.toShare(mim, requiredMim, true), true);
 167 |     |         }
 168 |     | 
 169 |     |         adjustedBorrowPart = borrowPart;
 170 |     |     }
 171 |     | 
 172 |     |     function isSolvent(ICauldronV2 cauldron, address account) internal view returns (bool) {
 173 |     |         IBentoBoxV1 bentoBox = IBentoBoxV1(cauldron.bentoBox());
 174 |     |         Rebase memory totalBorrow = getTotalBorrowWithAccruedInterests(cauldron);
 175 |     |         uint256 exchangeRate = getOracleExchangeRate(cauldron);
 176 |     |         IERC20 collateral = cauldron.collateral();
 177 |     |         uint256 COLLATERIZATION_RATE = cauldron.COLLATERIZATION_RATE();
 178 |     |         uint256 collateralShare = cauldron.userCollateralShare(account);
 179 |     |         uint256 borrowPart = cauldron.userBorrowPart(account);
 180 |     | 
 181 |     |         if (borrowPart == 0) {
 182 |     |             return true;
 183 |     |         } else if (collateralShare == 0) {
 184 |     |             return false;
 185 |     |         } else {
 186 |     |             return
 187 |     |                 bentoBox.toAmount(
 188 |     |                     collateral,
 189 |     |                     (collateralShare * (EXCHANGE_RATE_PRECISION / COLLATERIZATION_RATE_PRECISION)) * COLLATERIZATION_RATE,
 190 |     |                     false
 191 |     |                 ) >= (borrowPart * totalBorrow.elastic * exchangeRate) / totalBorrow.base;
 192 |     |         }
 193 |     |     }
 194 |     | 
 195 |     |     function getCollateralPrice(ICauldronV2 cauldron) internal view returns (uint256) {
 196 |     |         IERC20 collateral = cauldron.collateral();
 197 |     |         uint256 collateralPrecision = 10 ** collateral.safeDecimals();
 198 |     |         return (collateralPrecision * collateralPrecision) / getOracleExchangeRate(cauldron);
 199 |     |     }
 200 |     | 
 201 |     |     function decodeInitData(
 202 |     |         bytes calldata data
 203 |     |     )
 204 |     |         internal
 205 |     |         pure
 206 |     |         returns (
 207 |     |             address collateral,
 208 |     |             address oracle,
 209 |     |             bytes memory oracleData,
 210 |     |             uint64 INTEREST_PER_SECOND,
 211 |     |             uint256 LIQUIDATION_MULTIPLIER,
 212 |     |             uint256 COLLATERIZATION_RATE,
 213 |     |             uint256 BORROW_OPENING_FEE
 214 |     |         )
 215 |     |     {
 216 |     |         (collateral, oracle, oracleData, INTEREST_PER_SECOND, LIQUIDATION_MULTIPLIER, COLLATERIZATION_RATE, BORROW_OPENING_FEE) = abi
 217 |     |             .decode(data, (address, address, bytes, uint64, uint256, uint256, uint256));
 218 |     |     }
 219 |     | }
 220 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/libraries/MathLib.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | library MathLib {
  5 |     |     function max(uint256[] memory values) internal pure returns (uint256) {
  6 |     |         uint256 maxValue = values[0];
  7 |     |         for (uint256 i = 1; i < values.length; i++) {
  8 |     |             if (values[i] > maxValue) {
  9 |     |                 maxValue = values[i];
 10 |     |             }
 11 |     |         }
 12 |     |         return maxValue;
 13 |     |     }
 14 |     | 
 15 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
 16 |     |         return a > b ? a : b;
 17 |     |     }
 18 |     | 
 19 |     |     function min(uint256[] memory values) internal pure returns (uint256) {
 20 |     |         uint256 minValue = values[0];
 21 |     |         for (uint256 i = 1; i < values.length; i++) {
 22 |     |             if (values[i] < minValue) {
 23 |     |                 minValue = values[i];
 24 |     |             }
 25 |     |         }
 26 |     |         return minValue;
 27 |     |     }
 28 |     | 
 29 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
 30 |     |         return a < b ? a : b;
 31 |     |     }
 32 |     | 
 33 |     |     function subWithZeroFloor(uint256 a, uint256 b) internal pure returns (uint256) {
 34 |     |         return a > b ? a - b : 0;
 35 |     |     }
 36 |     | }
 37 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/libraries/SafeApproveLib.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | 
  6 |     | library SafeApproveLib {
  7 |     |     error ErrApproveFailed();
  8 |     |     error ErrApproveFailedWithData(bytes data);
  9 |     | 
 10 |     |     function safeApprove(
 11 |     |         IERC20 token,
 12 |     |         address to,
 13 |     |         uint256 value
 14 |     |     ) internal {
 15 |     |         (bool success, bytes memory data) = address(token).call(abi.encodeCall(IERC20.approve, (to, value)));
 16 |     |         if (!success) {
 17 |     |             revert ErrApproveFailed();
 18 |     |         }
 19 |     |         if (data.length != 0 && !abi.decode(data, (bool))) {
 20 |     |             revert ErrApproveFailedWithData(data);
 21 |     |         }
 22 |     |     }
 23 |     | }

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/libraries/UniswapV2Lib.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {IUniswapV2Pair, IUniswapV2Router01} from "interfaces/IUniswapV2.sol";
   5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
   7 |     | import {BabylonianLib} from "./BabylonianLib.sol";
   8 |     | 
   9 |     | /* 
  10 |     | The following library is modified from @sushiswap/core/contracts/uniswapv2/libraries/UniswapV2Library.sol
  11 |     | 
  12 |     | changes: 
  13 |     |     - remove SafeMathUniswap library and replace all usage of it with basic operations
  14 |     |     - change casting from uint to bytes20 in pair address calculation and shift by 96 bits before casting
  15 |     |  */
  16 |     | library UniswapV2Library {
  17 |     |     // returns sorted token addresses, used to handle return values from pairs sorted in this order
  18 |     |     function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
  19 |     |         require(tokenA != tokenB, "UniswapV2Library: IDENTICAL_ADDRESSES");
  20 |     |         (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
  21 |     |         require(token0 != address(0), "UniswapV2Library: ZERO_ADDRESS");
  22 |     |     }
  23 |     | 
  24 |     |     // calculates the CREATE2 address for a pair without making any external calls
  25 |     |     function pairFor(address factory, address tokenA, address tokenB, bytes32 pairCodeHash) internal pure returns (address pair) {
  26 |     |         (address token0, address token1) = sortTokens(tokenA, tokenB);
  27 |     | 
  28 |     |         // Since Solidity 0.8.0 explicit conversions from literals larger than type(uint160).max to address are disallowed.
  29 |     |         // https://docs.soliditylang.org/en/develop/080-breaking-changes.html#new-restrictions
  30 |     |         pair = address(
  31 |     |             uint160(
  32 |     |                 uint256(
  33 |     |                     keccak256(
  34 |     |                         abi.encodePacked(
  35 |     |                             hex"ff",
  36 |     |                             factory,
  37 |     |                             keccak256(abi.encodePacked(token0, token1)),
  38 |     |                             pairCodeHash // init code hash
  39 |     |                         )
  40 |     |                     )
  41 |     |                 )
  42 |     |             )
  43 |     |         );
  44 |     |     }
  45 |     | 
  46 |     |     // fetches and sorts the reserves for a pair
  47 |     |     function getReserves(
  48 |     |         address factory,
  49 |     |         address tokenA,
  50 |     |         address tokenB,
  51 |     |         bytes32 pairCodeHash
  52 |     |     ) internal view returns (uint256 reserveA, uint256 reserveB) {
  53 |     |         (address token0, ) = sortTokens(tokenA, tokenB);
  54 |     |         (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB, pairCodeHash)).getReserves();
  55 |     |         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
  56 |     |     }
  57 |     | 
  58 |     |     // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset
  59 |     |     function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) internal pure returns (uint256 amountB) {
  60 |     |         require(amountA > 0, "UniswapV2Library: INSUFFICIENT_AMOUNT");
  61 |     |         require(reserveA > 0 && reserveB > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");
  62 |     |         amountB = (amountA * reserveB) / reserveA;
  63 |     |     }
  64 |     | 
  65 |     |     // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset
  66 |     |     function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) internal pure returns (uint256 amountOut) {
  67 |     |         require(amountIn > 0, "UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT");
  68 |     |         require(reserveIn > 0 && reserveOut > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");
  69 |     |         uint256 amountInWithFee = amountIn * 997;
  70 |     |         uint256 numerator = amountInWithFee * reserveOut;
  71 |     |         uint256 denominator = (reserveIn * 1000) + amountInWithFee;
  72 |     |         amountOut = numerator / denominator;
  73 |     |     }
  74 |     | 
  75 |     |     // given an output amount of an asset and pair reserves, returns a required input amount of the other asset
  76 |     |     function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) internal pure returns (uint256 amountIn) {
  77 |     |         require(amountOut > 0, "UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT");
  78 |     |         require(reserveIn > 0 && reserveOut > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");
  79 |     |         uint256 numerator = reserveIn * amountOut * 1000;
  80 |     |         uint256 denominator = (reserveOut - amountOut) * 997;
  81 |     |         amountIn = (numerator / denominator) + 1;
  82 |     |     }
  83 |     | 
  84 |     |     // performs chained getAmountOut calculations on any number of pairs
  85 |     |     function getAmountsOut(
  86 |     |         address factory,
  87 |     |         uint256 amountIn,
  88 |     |         address[] memory path,
  89 |     |         bytes32 pairCodeHash
  90 |     |     ) internal view returns (uint256[] memory amounts) {
  91 |     |         require(path.length >= 2, "UniswapV2Library: INVALID_PATH");
  92 |     |         amounts = new uint256[](path.length);
  93 |     |         amounts[0] = amountIn;
  94 |     |         for (uint256 i; i < path.length - 1; i++) {
  95 |     |             (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1], pairCodeHash);
  96 |     |             amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     // performs chained getAmountIn calculations on any number of pairs
 101 |     |     function getAmountsIn(
 102 |     |         address factory,
 103 |     |         uint256 amountOut,
 104 |     |         address[] memory path,
 105 |     |         bytes32 pairCodeHash
 106 |     |     ) internal view returns (uint256[] memory amounts) {
 107 |     |         require(path.length >= 2, "UniswapV2Library: INVALID_PATH");
 108 |     |         amounts = new uint256[](path.length);
 109 |     |         amounts[amounts.length - 1] = amountOut;
 110 |     |         for (uint256 i = path.length - 1; i > 0; i--) {
 111 |     |             (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i], pairCodeHash);
 112 |     |             amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
 113 |     |         }
 114 |     |     }
 115 |     | }
 116 |     | 
 117 |     | library UniswapV2OneSided {
 118 |     |     using BoringERC20 for IERC20;
 119 |     | 
 120 |     |     struct AddLiquidityAndOneSideRemainingParams {
 121 |     |         IUniswapV2Router01 router;
 122 |     |         IUniswapV2Pair pair;
 123 |     |         address token0;
 124 |     |         address token1;
 125 |     |         uint256 reserve0;
 126 |     |         uint256 reserve1;
 127 |     |         uint256 token0Amount;
 128 |     |         uint256 token1Amount;
 129 |     |         uint256 minOneSideableAmount0;
 130 |     |         uint256 minOneSideableAmount1;
 131 |     |         address recipient;
 132 |     |     }
 133 |     | 
 134 |     |     struct AddLiquidityFromSingleTokenParams {
 135 |     |         IUniswapV2Router01 router;
 136 |     |         IUniswapV2Pair pair;
 137 |     |         address token0;
 138 |     |         address token1;
 139 |     |         uint256 reserve0;
 140 |     |         uint256 reserve1;
 141 |     |         address tokenIn;
 142 |     |         uint256 tokenInAmount;
 143 |     |         address recipient;
 144 |     |     }
 145 |     | 
 146 |     |     function _calculateSwapInAmount(uint256 reserveIn, uint256 userIn) internal pure returns (uint256) {
 147 |     |         return (BabylonianLib.sqrt(reserveIn * ((userIn * 3988000) + (reserveIn * 3988009))) - (reserveIn * 1997)) / 1994;
 148 |     |     }
 149 |     | 
 150 |     |     function _calculateSwapInAmountUsingCustomFees(
 151 |     |         uint256 reserveIn,
 152 |     |         uint256 amountIn,
 153 |     |         uint256 swapFeeBps
 154 |     |     ) internal pure returns (uint256) {
 155 |     |         uint256 caclulatedFeeA = 20000 - swapFeeBps;
 156 |     |         uint256 caclulatedFeeB = 10000 - swapFeeBps;
 157 |     |         uint256 caclulatedFeeC = 4 * caclulatedFeeB * 10000;
 158 |     | 
 159 |     |         return
 160 |     |             (BabylonianLib.sqrt((caclulatedFeeA * caclulatedFeeA) * (reserveIn * reserveIn) + (caclulatedFeeC * amountIn * reserveIn)) -
 161 |     |                 caclulatedFeeA *
 162 |     |                 reserveIn) / (2 * caclulatedFeeB);
 163 |     |     }
 164 |     | 
 165 |     |     function _getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) internal pure returns (uint256 amountOut) {
 166 |     |         uint256 amountInWithFee = amountIn * 997;
 167 |     |         uint256 numerator = amountInWithFee * reserveOut;
 168 |     |         uint256 denominator = (reserveIn * 1000) + amountInWithFee;
 169 |     |         amountOut = numerator / denominator;
 170 |     |     }
 171 |     | 
 172 |     |     function addLiquidityAndOneSideRemaining(
 173 |     |         AddLiquidityAndOneSideRemainingParams memory params
 174 |     |     ) internal returns (uint256 idealAmount0, uint256 idealAmount1, uint256 liquidity) {
 175 |     |         (idealAmount0, idealAmount1, liquidity) = params.router.addLiquidity(
 176 |     |             params.token0,
 177 |     |             params.token1,
 178 |     |             params.token0Amount,
 179 |     |             params.token1Amount,
 180 |     |             0,
 181 |     |             0,
 182 |     |             params.recipient,
 183 |     |             type(uint256).max
 184 |     |         );
 185 |     | 
 186 |     |         params.token0Amount -= idealAmount0;
 187 |     |         params.token1Amount -= idealAmount1;
 188 |     | 
 189 |     |         address oneSideTokenIn;
 190 |     |         uint256 oneSideTokenAmount;
 191 |     | 
 192 |     |         if (params.token0Amount >= params.minOneSideableAmount0) {
 193 |     |             oneSideTokenIn = params.token0;
 194 |     |             oneSideTokenAmount = params.token0Amount;
 195 |     |         } else if (params.token1Amount > params.minOneSideableAmount1) {
 196 |     |             oneSideTokenIn = params.token1;
 197 |     |             oneSideTokenAmount = params.token1Amount;
 198 |     |         }
 199 |     | 
 200 |     |         if (oneSideTokenAmount > 0) {
 201 |     |             AddLiquidityFromSingleTokenParams memory _addLiquidityFromSingleTokenParams = AddLiquidityFromSingleTokenParams(
 202 |     |                 params.router,
 203 |     |                 params.pair,
 204 |     |                 params.token0,
 205 |     |                 params.token1,
 206 |     |                 params.reserve0,
 207 |     |                 params.reserve1,
 208 |     |                 oneSideTokenIn,
 209 |     |                 oneSideTokenAmount,
 210 |     |                 params.recipient
 211 |     |             );
 212 |     | 
 213 |     |             (uint256 _idealAmount0, uint256 _idealAmount1, uint256 _liquidity) = addLiquidityFromSingleToken(
 214 |     |                 _addLiquidityFromSingleTokenParams
 215 |     |             );
 216 |     | 
 217 |     |             idealAmount0 += _idealAmount0;
 218 |     |             idealAmount1 += _idealAmount1;
 219 |     |             liquidity += _liquidity;
 220 |     |         }
 221 |     |     }
 222 |     | 
 223 |     |     function addLiquidityFromSingleToken(
 224 |     |         AddLiquidityFromSingleTokenParams memory params
 225 |     |     ) internal returns (uint256 amountA, uint256 amountB, uint256 liquidity) {
 226 |     |         if (params.tokenIn == params.token0) {
 227 |     |             uint256 tokenInSwapAmount = _calculateSwapInAmount(params.reserve0, params.tokenInAmount);
 228 |     |             params.tokenInAmount -= tokenInSwapAmount;
 229 |     |             uint256 sideTokenAmount = _getAmountOut(tokenInSwapAmount, params.reserve0, params.reserve1);
 230 |     |             IERC20(params.tokenIn).safeTransfer(address(params.pair), tokenInSwapAmount);
 231 |     |             params.pair.swap(0, sideTokenAmount, address(this), "");
 232 |     |             return
 233 |     |                 params.router.addLiquidity(
 234 |     |                     params.token0,
 235 |     |                     params.token1,
 236 |     |                     params.tokenInAmount,
 237 |     |                     sideTokenAmount,
 238 |     |                     0,
 239 |     |                     0,
 240 |     |                     params.recipient,
 241 |     |                     type(uint256).max
 242 |     |                 );
 243 |     |         } else {
 244 |     |             uint256 tokenInSwapAmount = _calculateSwapInAmount(params.reserve1, params.tokenInAmount);
 245 |     |             params.tokenInAmount -= tokenInSwapAmount;
 246 |     |             uint256 sideTokenAmount = _getAmountOut(tokenInSwapAmount, params.reserve1, params.reserve0);
 247 |     |             IERC20(params.tokenIn).safeTransfer(address(params.pair), tokenInSwapAmount);
 248 |     |             params.pair.swap(sideTokenAmount, 0, address(this), "");
 249 |     | 
 250 |     |             return
 251 |     |                 params.router.addLiquidity(
 252 |     |                     params.token0,
 253 |     |                     params.token1,
 254 |     |                     sideTokenAmount,
 255 |     |                     params.tokenInAmount,
 256 |     |                     0,
 257 |     |                     0,
 258 |     |                     params.recipient,
 259 |     |                     type(uint256).max
 260 |     |                 );
 261 |     |         }
 262 |     |     }
 263 |     | }
 264 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/MagicLP.sol
   1 |     | /*
   2 |     | 
   3 |     |     Copyright 2020 DODO ZOO.
   4 |     |     SPDX-License-Identifier: Apache-2.0
   5 |     | 
   6 |     | */
   7 |     | 
   8 |     | pragma solidity >=0.8.0;
   9 |     | 
  10 |     | import {Owned} from "solmate/auth/Owned.sol";
  11 |     | import {IERC20Metadata} from "openzeppelin-contracts/interfaces/IERC20Metadata.sol";
  12 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
  13 |     | import {ReentrancyGuard} from "solady/utils/ReentrancyGuard.sol";
  14 |     | import {ERC20} from "solady/tokens/ERC20.sol";
  15 |     | import {SafeCastLib} from "solady/utils/SafeCastLib.sol";
  16 |     | import {DecimalMath} from "/mimswap/libraries/DecimalMath.sol";
  17 |     | import {Math} from "/mimswap/libraries/Math.sol";
  18 |     | import {PMMPricing} from "/mimswap/libraries/PMMPricing.sol";
  19 |     | import {ICallee} from "/mimswap/interfaces/ICallee.sol";
  20 |     | import {IFeeRateModel} from "/mimswap/interfaces/IFeeRateModel.sol";
  21 |     | import {IWETH} from "interfaces/IWETH.sol";
  22 |     | 
  23 |     | /// @title MIMSwap MagicLP
  24 |     | /// @author Adapted from DODOEX DSP https://github.com/DODOEX/contractV2/tree/main/contracts/DODOStablePool
  25 | *   | contract MagicLP is ERC20, ReentrancyGuard, Owned {
  26 |     |     using Math for uint256;
  27 |     |     using SafeCastLib for uint256;
  28 |     |     using SafeTransferLib for address;
  29 |     | 
  30 |     |     event BuyShares(address to, uint256 increaseShares, uint256 totalShares);
  31 |     |     event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);
  32 |     |     event Swap(address fromToken, address toToken, uint256 fromAmount, uint256 toAmount, address trader, address receiver);
  33 |     |     event FlashLoan(address borrower, address assetTo, uint256 baseAmount, uint256 quoteAmount);
  34 |     |     event RChange(PMMPricing.RState newRState);
  35 |     |     event TokenRescue(address indexed token, address to, uint256 amount);
  36 |     |     event ParametersChanged(uint256 newLpFeeRate, uint256 newI, uint256 newK, uint256 newBaseReserve, uint256 newQuoteReserve);
  37 |     |     event PausedChanged(bool paused);
  38 |     |     event OperatorChanged(address indexed operator, bool status);
  39 |     | 
  40 |     |     error ErrInitialized();
  41 |     |     error ErrBaseQuoteSame();
  42 |     |     error ErrInvalidI();
  43 |     |     error ErrInvalidK();
  44 |     |     error ErrExpired();
  45 |     |     error ErrInvalidSignature();
  46 |     |     error ErrFlashLoanFailed();
  47 |     |     error ErrNoBaseInput();
  48 |     |     error ErrZeroAddress();
  49 |     |     error ErrZeroQuoteAmount();
  50 |     |     error ErrZeroQuoteTarget();
  51 |     |     error ErrMintAmountNotEnough();
  52 |     |     error ErrNotEnough();
  53 |     |     error ErrWithdrawNotEnough();
  54 |     |     error ErrSellBackNotAllowed();
  55 |     |     error ErrInvalidLPFeeRate();
  56 |     |     error ErrNotImplementationOwner();
  57 |     |     error ErrNotImplementation();
  58 |     |     error ErrNotClone();
  59 |     |     error ErrNotAllowed();
  60 |     |     error ErrReserveAmountNotEnough();
  61 |     |     error ErrOverflow();
  62 |     |     error ErrNotPaused();
  63 |     |     error ErrNotAllowedImplementationOperator();
  64 |     |     error ErrInvalidTargets();
  65 |     |     
  66 |     |     MagicLP public immutable implementation;
  67 |     | 
  68 |     |     uint256 public constant MAX_I = 10 ** 36;
  69 |     |     uint256 public constant MAX_K = 10 ** 18;
  70 |     |     uint256 public constant MIN_LP_FEE_RATE = 1e14; // 0.01%
  71 |     |     uint256 public constant MAX_LP_FEE_RATE = 1e16; // 1%
  72 |     | 
  73 |     |     bool internal _INITIALIZED_;
  74 |     |     bool public _PAUSED_;
  75 |     |     bool public _PROTOCOL_OWNED_POOL_;
  76 |     | 
  77 |     |     address public _BASE_TOKEN_;
  78 |     |     address public _QUOTE_TOKEN_;
  79 |     |     uint112 public _BASE_RESERVE_;
  80 |     |     uint112 public _QUOTE_RESERVE_;
  81 |     |     uint32 public _BLOCK_TIMESTAMP_LAST_;
  82 |     |     uint256 public _BASE_PRICE_CUMULATIVE_LAST_;
  83 |     |     uint112 public _BASE_TARGET_;
  84 |     |     uint112 public _QUOTE_TARGET_;
  85 |     |     uint32 public _RState_;
  86 |     |     IFeeRateModel public _MT_FEE_RATE_MODEL_;
  87 |     |     uint256 public _LP_FEE_RATE_;
  88 |     |     uint256 public _K_;
  89 |     |     uint256 public _I_;
  90 |     | 
  91 |     |     mapping(address => bool) public operators;
  92 |     | 
  93 |     |     constructor(address owner_) Owned(owner_) {
  94 |     |         implementation = this;
  95 |     | 
  96 |     |         // prevents the implementation contract initialization
  97 |     |         _INITIALIZED_ = true;
  98 |     |     }
  99 |     | 
 100 |     |     function init(
 101 |     |         address baseTokenAddress,
 102 |     |         address quoteTokenAddress,
 103 |     |         uint256 lpFeeRate,
 104 |     |         address mtFeeRateModel,
 105 |     |         uint256 i,
 106 |     |         uint256 k,
 107 |     |         bool protocolOwnedPool
 108 |     |     ) external {
 109 |     |         if (_INITIALIZED_) {
 110 |     |             revert ErrInitialized();
 111 |     |         }
 112 |     |         if (mtFeeRateModel == address(0) || baseTokenAddress == address(0) || quoteTokenAddress == address(0)) {
 113 |     |             revert ErrZeroAddress();
 114 |     |         }
 115 |     |         if (baseTokenAddress == quoteTokenAddress) {
 116 |     |             revert ErrBaseQuoteSame();
 117 |     |         }
 118 |     |         if (i == 0 || i > MAX_I) {
 119 |     |             revert ErrInvalidI();
 120 |     |         }
 121 |     |         if (k > MAX_K) {
 122 |     |             revert ErrInvalidK();
 123 |     |         }
 124 |     |         if (lpFeeRate < MIN_LP_FEE_RATE || lpFeeRate > MAX_LP_FEE_RATE) {
 125 |     |             revert ErrInvalidLPFeeRate();
 126 |     |         }
 127 |     | 
 128 |     |         _INITIALIZED_ = true;
 129 |     |         _BASE_TOKEN_ = baseTokenAddress;
 130 |     |         _QUOTE_TOKEN_ = quoteTokenAddress;
 131 |     |         _I_ = i;
 132 |     |         _K_ = k;
 133 |     |         _LP_FEE_RATE_ = lpFeeRate;
 134 |     |         _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);
 135 |     |         _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2 ** 32);
 136 |     |         _PROTOCOL_OWNED_POOL_ = protocolOwnedPool;
 137 |     | 
 138 |     |         _afterInitialized();
 139 |     |     }
 140 |     | 
 141 |     |     //////////////////////////////////////////////////////////////////////////////////////
 142 |     |     /// PUBLIC - CLONES ONLY
 143 |     |     //////////////////////////////////////////////////////////////////////////////////////
 144 |     | 
 145 |     |     function sync() external nonReentrant onlyClones {
 146 |     |         _sync();
 147 |     |     }
 148 |     | 
 149 |     |     function correctRState() external onlyClones {
 150 |     |         if (_RState_ == uint32(PMMPricing.RState.BELOW_ONE) && _BASE_RESERVE_ < _BASE_TARGET_) {
 151 |     |             _RState_ = uint32(PMMPricing.RState.ONE);
 152 |     |             _BASE_TARGET_ = _BASE_RESERVE_;
 153 |     |             _QUOTE_TARGET_ = _QUOTE_RESERVE_;
 154 |     |         }
 155 |     |         if (_RState_ == uint32(PMMPricing.RState.ABOVE_ONE) && _QUOTE_RESERVE_ < _QUOTE_TARGET_) {
 156 |     |             _RState_ = uint32(PMMPricing.RState.ONE);
 157 |     |             _BASE_TARGET_ = _BASE_RESERVE_;
 158 |     |             _QUOTE_TARGET_ = _QUOTE_RESERVE_;
 159 |     |         }
 160 |     |     }
 161 |     | 
 162 |     |     //////////////////////////////////////////////////////////////////////////////////////
 163 |     |     /// VIEWS
 164 |     |     //////////////////////////////////////////////////////////////////////////////////////
 165 |     | 
 166 |     |     function name() public view override returns (string memory) {
 167 |     |         return string(abi.encodePacked("MagicLP ", IERC20Metadata(_BASE_TOKEN_).symbol(), "/", IERC20Metadata(_QUOTE_TOKEN_).symbol()));
 168 |     |     }
 169 |     | 
 170 |     |     function symbol() public pure override returns (string memory) {
 171 |     |         return "MagicLP";
 172 |     |     }
 173 |     | 
 174 |     |     function decimals() public view override returns (uint8) {
 175 |     |         return IERC20Metadata(_BASE_TOKEN_).decimals();
 176 |     |     }
 177 |     | 
 178 |     |     function isImplementationOperator(address _operator) public view returns (bool) {
 179 |     |         return implementation.operators(_operator) || _operator == implementation.owner();
 180 |     |     }
 181 |     | 
 182 |     |     function querySellBase(
 183 |     |         address trader,
 184 |     |         uint256 payBaseAmount
 185 |     |     ) public view returns (uint256 receiveQuoteAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newBaseTarget) {
 186 |     |         PMMPricing.PMMState memory state = getPMMState();
 187 |     |         (receiveQuoteAmount, newRState) = PMMPricing.sellBaseToken(state, payBaseAmount);
 188 |     | 
 189 |     |         (uint256 lpFeeRate, uint256 mtFeeRate) = _MT_FEE_RATE_MODEL_.getFeeRate(trader, _LP_FEE_RATE_);
 190 |     |         mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);
 191 |     |         receiveQuoteAmount = receiveQuoteAmount - DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate) - mtFee;
 192 |     |         newBaseTarget = state.B0;
 193 |     |     }
 194 |     | 
 195 |     |     function querySellQuote(
 196 |     |         address trader,
 197 |     |         uint256 payQuoteAmount
 198 |     |     ) public view returns (uint256 receiveBaseAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newQuoteTarget) {
 199 |     |         PMMPricing.PMMState memory state = getPMMState();
 200 |     |         (receiveBaseAmount, newRState) = PMMPricing.sellQuoteToken(state, payQuoteAmount);
 201 |     | 
 202 |     |         (uint256 lpFeeRate, uint256 mtFeeRate) = _MT_FEE_RATE_MODEL_.getFeeRate(trader, _LP_FEE_RATE_);
 203 |     |         mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);
 204 |     |         receiveBaseAmount = receiveBaseAmount - DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate) - mtFee;
 205 |     |         newQuoteTarget = state.Q0;
 206 |     |     }
 207 |     | 
 208 |     |     function getPMMState() public view returns (PMMPricing.PMMState memory state) {
 209 |     |         state.i = _I_;
 210 |     |         state.K = _K_;
 211 |     |         state.B = _BASE_RESERVE_;
 212 |     |         state.Q = _QUOTE_RESERVE_;
 213 |     |         state.B0 = _BASE_TARGET_; // will be calculated in adjustedTarget
 214 |     |         state.Q0 = _QUOTE_TARGET_;
 215 |     |         state.R = PMMPricing.RState(_RState_);
 216 |     |         PMMPricing.adjustedTarget(state);
 217 |     |     }
 218 |     | 
 219 |     |     function getPMMStateForCall() external view returns (uint256 i, uint256 K, uint256 B, uint256 Q, uint256 B0, uint256 Q0, uint256 R) {
 220 |     |         PMMPricing.PMMState memory state = getPMMState();
 221 |     |         i = state.i;
 222 |     |         K = state.K;
 223 |     |         B = state.B;
 224 |     |         Q = state.Q;
 225 |     |         B0 = state.B0;
 226 |     |         Q0 = state.Q0;
 227 |     |         R = uint256(state.R);
 228 |     |     }
 229 |     | 
 230 |     |     function getMidPrice() public view returns (uint256 midPrice) {
 231 |     |         return PMMPricing.getMidPrice(getPMMState());
 232 |     |     }
 233 |     | 
 234 |     |     function getReserves() external view returns (uint256 baseReserve, uint256 quoteReserve) {
 235 |     |         baseReserve = _BASE_RESERVE_;
 236 |     |         quoteReserve = _QUOTE_RESERVE_;
 237 |     |     }
 238 |     | 
 239 |     |     function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate) {
 240 |     |         return _MT_FEE_RATE_MODEL_.getFeeRate(user, _LP_FEE_RATE_);
 241 |     |     }
 242 |     | 
 243 |     |     function getBaseInput() public view nonReadReentrant returns (uint256 input) {
 244 |     |         return _BASE_TOKEN_.balanceOf(address(this)) - uint256(_BASE_RESERVE_);
 245 |     |     }
 246 |     | 
 247 |     |     function getQuoteInput() public view nonReadReentrant returns (uint256 input) {
 248 |     |         return _QUOTE_TOKEN_.balanceOf(address(this)) - uint256(_QUOTE_RESERVE_);
 249 |     |     }
 250 |     | 
 251 |     |     function version() external pure virtual returns (string memory) {
 252 |     |         return "MagicLP 1.0.0";
 253 |     |     }
 254 |     | 
 255 |     |     //////////////////////////////////////////////////////////////////////////////////////
 256 |     |     /// TRADE FUNCTIONS
 257 |     |     //////////////////////////////////////////////////////////////////////////////////////
 258 |     | 
 259 |     |     function sellBase(address to) external nonReentrant onlyClones whenNotPaused returns (uint256 receiveQuoteAmount) {
 260 |     |         uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));
 261 |     |         uint256 baseInput = baseBalance - uint256(_BASE_RESERVE_);
 262 |     |         uint256 mtFee;
 263 |     |         uint256 newBaseTarget;
 264 |     |         PMMPricing.RState newRState;
 265 |     |         (receiveQuoteAmount, mtFee, newRState, newBaseTarget) = querySellBase(tx.origin, baseInput);
 266 |     | 
 267 |     |         _transferQuoteOut(to, receiveQuoteAmount);
 268 |     |         _transferQuoteOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);
 269 |     | 
 270 |     |         // update TARGET
 271 |     |         if (_RState_ != uint32(newRState)) {
 272 |     |             _BASE_TARGET_ = newBaseTarget.toUint112();
 273 |     |             _RState_ = uint32(newRState);
 274 |     |             emit RChange(newRState);
 275 |     |         }
 276 |     | 
 277 |     |         _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)));
 278 |     | 
 279 |     |         emit Swap(address(_BASE_TOKEN_), address(_QUOTE_TOKEN_), baseInput, receiveQuoteAmount, msg.sender, to);
 280 |     |     }
 281 |     | 
 282 |     |     function sellQuote(address to) external nonReentrant onlyClones whenNotPaused returns (uint256 receiveBaseAmount) {
 283 |     |         uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));
 284 |     |         uint256 quoteInput = quoteBalance - uint256(_QUOTE_RESERVE_);
 285 |     |         uint256 mtFee;
 286 |     |         uint256 newQuoteTarget;
 287 |     |         PMMPricing.RState newRState;
 288 |     |         (receiveBaseAmount, mtFee, newRState, newQuoteTarget) = querySellQuote(tx.origin, quoteInput);
 289 |     | 
 290 |     |         _transferBaseOut(to, receiveBaseAmount);
 291 |     |         _transferBaseOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);
 292 |     | 
 293 |     |         // update TARGET
 294 |     |         if (_RState_ != uint32(newRState)) {
 295 |     |             _QUOTE_TARGET_ = newQuoteTarget.toUint112();
 296 |     |             _RState_ = uint32(newRState);
 297 |     |             emit RChange(newRState);
 298 |     |         }
 299 |     | 
 300 |     |         _setReserve(_BASE_TOKEN_.balanceOf(address(this)), quoteBalance);
 301 |     | 
 302 |     |         emit Swap(address(_QUOTE_TOKEN_), address(_BASE_TOKEN_), quoteInput, receiveBaseAmount, msg.sender, to);
 303 |     |     }
 304 |     | 
 305 |     |     function flashLoan(uint256 baseAmount, uint256 quoteAmount, address assetTo, bytes calldata data) external nonReentrant onlyClones whenNotPaused {
 306 |     |         _transferBaseOut(assetTo, baseAmount);
 307 |     |         _transferQuoteOut(assetTo, quoteAmount);
 308 |     | 
 309 |     |         if (data.length > 0) {
 310 |     |             ICallee(assetTo).FlashLoanCall(msg.sender, baseAmount, quoteAmount, data);
 311 |     |         }
 312 |     | 
 313 |     |         uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));
 314 |     |         uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));
 315 |     | 
 316 |     |         // no input -> pure loss
 317 |     |         if (baseBalance < _BASE_RESERVE_ && quoteBalance < _QUOTE_RESERVE_) {
 318 |     |             revert ErrFlashLoanFailed();
 319 |     |         }
 320 |     | 
 321 |     |         // sell quote case
 322 |     |         // quote input + base output
 323 |     |         if (baseBalance < _BASE_RESERVE_) {
 324 |     |             uint256 quoteInput = quoteBalance - uint256(_QUOTE_RESERVE_);
 325 |     |             (uint256 receiveBaseAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newQuoteTarget) = querySellQuote(
 326 |     |                 tx.origin,
 327 |     |                 quoteInput
 328 |     |             );
 329 |     | 
 330 |     |             if (uint256(_BASE_RESERVE_) - baseBalance > receiveBaseAmount) {
 331 |     |                 revert ErrFlashLoanFailed();
 332 |     |             }
 333 |     | 
 334 |     |             _transferBaseOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);
 335 |     |             if (_RState_ != uint32(newRState)) {
 336 |     |                 _QUOTE_TARGET_ = newQuoteTarget.toUint112();
 337 |     |                 _RState_ = uint32(newRState);
 338 |     |                 emit RChange(newRState);
 339 |     |             }
 340 |     |             emit Swap(address(_QUOTE_TOKEN_), address(_BASE_TOKEN_), quoteInput, receiveBaseAmount, msg.sender, assetTo);
 341 |     |         }
 342 |     | 
 343 |     |         // sell base case
 344 |     |         // base input + quote output
 345 |     |         if (quoteBalance < _QUOTE_RESERVE_) {
 346 |     |             uint256 baseInput = baseBalance - uint256(_BASE_RESERVE_);
 347 |     |             (uint256 receiveQuoteAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newBaseTarget) = querySellBase(
 348 |     |                 tx.origin,
 349 |     |                 baseInput
 350 |     |             );
 351 |     | 
 352 |     |             if (uint256(_QUOTE_RESERVE_) - quoteBalance > receiveQuoteAmount) {
 353 |     |                 revert ErrFlashLoanFailed();
 354 |     |             }
 355 |     | 
 356 |     |             _transferQuoteOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);
 357 |     |             if (_RState_ != uint32(newRState)) {
 358 |     |                 _BASE_TARGET_ = newBaseTarget.toUint112();
 359 |     |                 _RState_ = uint32(newRState);
 360 |     |                 emit RChange(newRState);
 361 |     |             }
 362 |     |             emit Swap(address(_BASE_TOKEN_), address(_QUOTE_TOKEN_), baseInput, receiveQuoteAmount, msg.sender, assetTo);
 363 |     |         }
 364 |     | 
 365 |     |         _sync();
 366 |     | 
 367 |     |         emit FlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);
 368 |     |     }
 369 |     | 
 370 |     |     //////////////////////////////////////////////////////////////////////////////////////
 371 |     |     /// BUY & SELL SHARES
 372 |     |     //////////////////////////////////////////////////////////////////////////////////////
 373 |     | 
 374 |     |     // buy shares [round down]
 375 |     |     function buyShares(address to) external nonReentrant onlyClones whenNotPaused returns (uint256 shares, uint256 baseInput, uint256 quoteInput) {
 376 |     |         uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));
 377 |     |         uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));
 378 |     |         uint256 baseReserve = _BASE_RESERVE_;
 379 |     |         uint256 quoteReserve = _QUOTE_RESERVE_;
 380 |     | 
 381 |     |         baseInput = baseBalance - baseReserve;
 382 |     |         quoteInput = quoteBalance - quoteReserve;
 383 |     | 
 384 |     |         if (baseInput == 0) {
 385 |     |             revert ErrNoBaseInput();
 386 |     |         }
 387 |     | 
 388 |     |         // Round down when withdrawing. Therefore, never be a situation occurring balance is 0 but totalsupply is not 0
 389 |     |         // But May Happen，reserve >0 But totalSupply = 0
 390 |     |         if (totalSupply() == 0) {
 391 |     |             // case 1. initial supply
 392 |     |             if (quoteBalance == 0) {
 393 |     |                 revert ErrZeroQuoteAmount();
 394 |     |             }
 395 |     | 
 396 |     |             shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_) ? DecimalMath.divFloor(quoteBalance, _I_) : baseBalance;
 397 |     |             _BASE_TARGET_ = shares.toUint112();
 398 |     |             _QUOTE_TARGET_ = DecimalMath.mulFloor(shares, _I_).toUint112();
 399 |     | 
 400 |     |             if (_QUOTE_TARGET_ == 0) {
 401 |     |                 revert ErrZeroQuoteTarget();
 402 |     |             }
 403 |     | 
 404 |     |             if (shares <= 2001) {
 405 |     |                 revert ErrMintAmountNotEnough();
 406 |     |             }
 407 |     | 
 408 |     |             _mint(address(0), 1001);
 409 |     |             shares -= 1001;
 410 |     |         } else if (baseReserve > 0 && quoteReserve > 0) {
 411 |     |             // case 2. normal case
 412 |     |             uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);
 413 |     |             uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);
 414 |     |             uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;
 415 |     |             shares = DecimalMath.mulFloor(totalSupply(), mintRatio);
 416 |     | 
 417 |     |             _BASE_TARGET_ = (uint256(_BASE_TARGET_) + DecimalMath.mulFloor(uint256(_BASE_TARGET_), mintRatio)).toUint112();
 418 |     |             _QUOTE_TARGET_ = (uint256(_QUOTE_TARGET_) + DecimalMath.mulFloor(uint256(_QUOTE_TARGET_), mintRatio)).toUint112();
 419 |     |         }
 420 |     | 
 421 |     |         _mint(to, shares);
 422 |     |         _setReserve(baseBalance, quoteBalance);
 423 |     | 
 424 |     |         emit BuyShares(to, shares, balanceOf(to));
 425 |     |     }
 426 |     | 
 427 |     |     // sell shares [round down]
 428 |     |     function sellShares(
 429 |     |         uint256 shareAmount,
 430 |     |         address to,
 431 |     |         uint256 baseMinAmount,
 432 |     |         uint256 quoteMinAmount,
 433 |     |         bytes calldata data,
 434 |     |         uint256 deadline
 435 |     |     ) external nonReentrant onlyClones whenNotPaused returns (uint256 baseAmount, uint256 quoteAmount) {
 436 |     |         if (deadline < block.timestamp) {
 437 |     |             revert ErrExpired();
 438 |     |         }
 439 |     |         if (shareAmount > balanceOf(msg.sender)) {
 440 |     |             revert ErrNotEnough();
 441 |     |         }
 442 |     |         if (to == address(this)) {
 443 |     |             revert ErrSellBackNotAllowed();
 444 |     |         }
 445 |     | 
 446 |     |         uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));
 447 |     |         uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));
 448 |     |         uint256 totalShares = totalSupply();
 449 |     | 
 450 |     |         baseAmount = (baseBalance * shareAmount) / totalShares;
 451 |     |         quoteAmount = (quoteBalance * shareAmount) / totalShares;
 452 |     | 
 453 |     |         _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_) - (uint256(_BASE_TARGET_) * shareAmount).divCeil(totalShares));
 454 |     |         _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_) - (uint256(_QUOTE_TARGET_) * shareAmount).divCeil(totalShares));
 455 |     | 
 456 |     |         if (baseAmount < baseMinAmount || quoteAmount < quoteMinAmount) {
 457 |     |             revert ErrWithdrawNotEnough();
 458 |     |         }
 459 |     | 
 460 |     |         _burn(msg.sender, shareAmount);
 461 |     |         _transferBaseOut(to, baseAmount);
 462 |     |         _transferQuoteOut(to, quoteAmount);
 463 |     |         _sync();
 464 |     | 
 465 |     |         if (data.length > 0) {
 466 |     |             ICallee(to).SellShareCall(msg.sender, shareAmount, baseAmount, quoteAmount, data);
 467 |     |         }
 468 |     | 
 469 |     |         emit SellShares(msg.sender, to, shareAmount, balanceOf(msg.sender));
 470 |     |     }
 471 |     | 
 472 |     |     //////////////////////////////////////////////////////////////////////////////////////
 473 |     |     /// ADMIN - IMPLEMENTATION ONLY
 474 |     |     //////////////////////////////////////////////////////////////////////////////////////
 475 |     | 
 476 |     |     function setOperator(address _operator, bool _status) external onlyImplementation onlyImplementationOwner {
 477 |     |         operators[_operator] = _status;
 478 |     |         emit OperatorChanged(_operator, _status);
 479 |     |     }
 480 |     | 
 481 |     |     //////////////////////////////////////////////////////////////////////////////////////
 482 |     |     /// OPERATORS / ADMIN - PROTOCOL OWNED POOL AND CLONES ONLY
 483 |     |     //////////////////////////////////////////////////////////////////////////////////////
 484 |     | 
 485 |     |     function setPaused(bool paused) external onlyClones onlyProtocolOwnedPool onlyImplementationOperators {
 486 |     |         _PAUSED_ = paused;
 487 |     |         emit PausedChanged(paused);
 488 |     |     }
 489 |     | 
 490 |     |     function rescue(address token, address to, uint256 amount) external onlyClones onlyProtocolOwnedPool onlyImplementationOperators {
 491 |     |         if (token == _BASE_TOKEN_ || token == _QUOTE_TOKEN_) {
 492 |     |             revert ErrNotAllowed();
 493 |     |         }
 494 |     | 
 495 |     |         token.safeTransfer(to, amount);
 496 |     |         emit TokenRescue(token, to, amount);
 497 |     |     }
 498 |     | 
 499 |     |     /// @notice Set new parameters for the pool
 500 |     |     /// The pool must be paused, preferably blocks earlier to avoid sandwiching
 501 |     |     function setParameters(
 502 |     |         address assetTo,
 503 |     |         uint256 newLpFeeRate,
 504 |     |         uint256 newI,
 505 |     |         uint256 newK,
 506 |     |         uint256 baseOutAmount,
 507 |     |         uint256 quoteOutAmount,
 508 |     |         uint256 minBaseReserve,
 509 |     |         uint256 minQuoteReserve
 510 |     |     ) public nonReentrant onlyClones whenPaused onlyProtocolOwnedPool onlyImplementationOperators {
 511 |     |         if (_BASE_RESERVE_ < minBaseReserve || _QUOTE_RESERVE_ < minQuoteReserve) {
 512 |     |             revert ErrReserveAmountNotEnough();
 513 |     |         }
 514 |     |         if (newI == 0 || newI > MAX_I) {
 515 |     |             revert ErrInvalidI();
 516 |     |         }
 517 |     |         if (newK > MAX_K) {
 518 |     |             revert ErrInvalidK();
 519 |     |         }
 520 |     |         if (newLpFeeRate < MIN_LP_FEE_RATE || newLpFeeRate > MAX_LP_FEE_RATE) {
 521 |     |             revert ErrInvalidLPFeeRate();
 522 |     |         }
 523 |     | 
 524 |     |         _LP_FEE_RATE_ = newLpFeeRate;
 525 |     |         _K_ = newK;
 526 |     |         _I_ = newI;
 527 |     | 
 528 |     |         _transferBaseOut(assetTo, baseOutAmount);
 529 |     |         _transferQuoteOut(assetTo, quoteOutAmount);
 530 |     |         (uint256 newBaseBalance, uint256 newQuoteBalance) = _resetTargetAndReserve();
 531 |     | 
 532 |     |         emit ParametersChanged(newLpFeeRate, newI, newK, newBaseBalance, newQuoteBalance);
 533 |     |     }
 534 |     | 
 535 |     |     function ratioSync() external nonReentrant onlyClones onlyProtocolOwnedPool onlyImplementationOperators {
 536 |     |         uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));
 537 |     |         uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));
 538 |     | 
 539 |     |         if (baseBalance > type(uint112).max || quoteBalance > type(uint112).max) {
 540 |     |             revert ErrOverflow();
 541 |     |         }
 542 |     | 
 543 |     |         if (baseBalance != _BASE_RESERVE_) {
 544 |     |             _BASE_TARGET_ = uint112((uint256(_BASE_TARGET_) * baseBalance) / uint256(_BASE_RESERVE_));
 545 |     |             _BASE_RESERVE_ = uint112(baseBalance);
 546 |     |         }
 547 |     |         if (quoteBalance != _QUOTE_RESERVE_) {
 548 |     |             _QUOTE_TARGET_ = uint112((uint256(_QUOTE_TARGET_) * quoteBalance) / uint256(_QUOTE_RESERVE_));
 549 |     |             _QUOTE_RESERVE_ = uint112(quoteBalance);
 550 |     |         }
 551 |     | 
 552 |     |         if(_BASE_TARGET_ == 0 || _QUOTE_TARGET_ == 0) {
 553 |     |             revert ErrInvalidTargets();
 554 |     |         }
 555 |     | 
 556 |     |         _twapUpdate();
 557 |     |     }
 558 |     | 
 559 |     |     //////////////////////////////////////////////////////////////////////////////////////
 560 |     |     /// INTERNALS
 561 |     |     //////////////////////////////////////////////////////////////////////////////////////
 562 |     | 
 563 |     |     function _resetTargetAndReserve() internal returns (uint256 baseBalance, uint256 quoteBalance) {
 564 |     |         baseBalance = _BASE_TOKEN_.balanceOf(address(this));
 565 |     |         quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));
 566 |     | 
 567 |     |         if (baseBalance > type(uint112).max || quoteBalance > type(uint112).max) {
 568 |     |             revert ErrOverflow();
 569 |     |         }
 570 |     | 
 571 |     |         _BASE_RESERVE_ = uint112(baseBalance);
 572 |     |         _QUOTE_RESERVE_ = uint112(quoteBalance);
 573 |     |         _BASE_TARGET_ = uint112(baseBalance);
 574 |     |         _QUOTE_TARGET_ = uint112(quoteBalance);
 575 |     |         _RState_ = uint32(PMMPricing.RState.ONE);
 576 |     | 
 577 |     |         _twapUpdate();
 578 |     |     }
 579 |     | 
 580 |     |     function _twapUpdate() internal {
 581 |     |         uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);
 582 |     |         uint32 timeElapsed = blockTimestamp - _BLOCK_TIMESTAMP_LAST_;
 583 |     | 
 584 |     |         if (timeElapsed > 0 && _BASE_RESERVE_ != 0 && _QUOTE_RESERVE_ != 0) {
 585 |     |             /// @dev It is desired and expected for this value to
 586 |     |             /// overflow once it has hit the max of `type.uint256`.
 587 |     |             unchecked {
 588 |     |                 _BASE_PRICE_CUMULATIVE_LAST_ += getMidPrice() * timeElapsed;
 589 |     |             }
 590 |     |         }
 591 |     | 
 592 |     |         _BLOCK_TIMESTAMP_LAST_ = blockTimestamp;
 593 |     |     }
 594 |     | 
 595 |     |     function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {
 596 |     |         _BASE_RESERVE_ = baseReserve.toUint112();
 597 |     |         _QUOTE_RESERVE_ = quoteReserve.toUint112();
 598 |     | 
 599 |     |         _twapUpdate();
 600 |     |     }
 601 |     | 
 602 |     |     function _sync() internal {
 603 |     |         uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));
 604 |     |         uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));
 605 |     | 
 606 |     |         if (baseBalance != _BASE_RESERVE_) {
 607 |     |             _BASE_RESERVE_ = baseBalance.toUint112();
 608 |     |         }
 609 |     |         if (quoteBalance != _QUOTE_RESERVE_) {
 610 |     |             _QUOTE_RESERVE_ = quoteBalance.toUint112();
 611 |     |         }
 612 |     | 
 613 |     |         _twapUpdate();
 614 |     |     }
 615 |     | 
 616 |     |     function _transferBaseOut(address to, uint256 amount) internal {
 617 |     |         if (amount > 0) {
 618 |     |             _BASE_TOKEN_.safeTransfer(to, amount);
 619 |     |         }
 620 |     |     }
 621 |     | 
 622 |     |     function _transferQuoteOut(address to, uint256 amount) internal {
 623 |     |         if (amount > 0) {
 624 |     |             _QUOTE_TOKEN_.safeTransfer(to, amount);
 625 |     |         }
 626 |     |     }
 627 |     | 
 628 |     |     function _mint(address to, uint256 amount) internal override {
 629 |     |         if (amount <= 1000) {
 630 |     |             revert ErrMintAmountNotEnough();
 631 |     |         }
 632 |     | 
 633 |     |         super._mint(to, amount);
 634 |     |     }
 635 |     | 
 636 |     |     function _afterInitialized() internal virtual {}
 637 |     | 
 638 |     |     //////////////////////////////////////////////////////////////////////////////////////
 639 |     |     /// MODIFIERS
 640 |     |     //////////////////////////////////////////////////////////////////////////////////////
 641 |     | 
 642 |     |     modifier onlyImplementationOwner() {
 643 |     |         if (msg.sender != implementation.owner()) {
 644 |     |             revert ErrNotImplementationOwner();
 645 |     |         }
 646 |     |         _;
 647 |     |     }
 648 |     | 
 649 |     |     /// @dev owner is always considered an operator
 650 |     |     modifier onlyImplementationOperators() {
 651 |     |         if (!isImplementationOperator(msg.sender)) {
 652 |     |             revert ErrNotAllowedImplementationOperator();
 653 |     |         }
 654 |     |         _;
 655 |     |     }
 656 |     | 
 657 |     |     /// @dev can only be called on a clone contract
 658 |     |     modifier onlyClones() {
 659 |     |         if (address(this) == address(implementation)) {
 660 |     |             revert ErrNotClone();
 661 |     |         }
 662 |     |         _;
 663 |     |     }
 664 |     | 
 665 |     |     /// @dev can only be called on the implementation contract
 666 |     |     modifier onlyImplementation() {
 667 |     |         if (address(this) != address(implementation)) {
 668 |     |             revert ErrNotImplementation();
 669 |     |         }
 670 |     |         _;
 671 |     |     }
 672 |     | 
 673 |     |     modifier onlyProtocolOwnedPool() {
 674 |     |         if (!_PROTOCOL_OWNED_POOL_) {
 675 |     |             revert ErrNotAllowed();
 676 |     |         }
 677 |     |         _;
 678 |     |     }
 679 |     | 
 680 |     |     modifier whenPaused() {
 681 |     |         if (!_PAUSED_) {
 682 |     |             revert ErrNotPaused();
 683 |     |         }
 684 |     |         _;
 685 |     |     }
 686 |     | 
 687 |     |     /// @dev When it's a paused protocol owned pool,
 688 |     |     /// only the implementation operators can call the function
 689 |     |     /// A normal pool can never be paused.
 690 |     |     modifier whenNotPaused() {
 691 |     |         if (_PROTOCOL_OWNED_POOL_ && _PAUSED_ && !isImplementationOperator(msg.sender)) {
 692 |     |             revert ErrNotAllowedImplementationOperator();
 693 |     |         }
 694 |     |         _;
 695 |     |     }
 696 |     | }
 697 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/auxiliary/FeeRateModel.sol
  1 |     | /*
  2 |     | 
  3 |     |     Copyright 2020 DODO ZOO.
  4 |     |     SPDX-License-Identifier: Apache-2.0
  5 |     | 
  6 |     | */
  7 |     | 
  8 |     | pragma solidity >=0.8.0;
  9 |     | 
 10 |     | import {Owned} from "solmate/auth/Owned.sol";
 11 |     | import {IFeeRateImpl} from "../interfaces/IFeeRateModel.sol";
 12 |     | 
 13 | *   | contract FeeRateModel is Owned {
 14 |     |     event LogImplementationChanged(address indexed implementation);
 15 |     |     event LogMaintainerChanged(address indexed maintainer);
 16 |     | 
 17 |     |     error ErrZeroAddress();
 18 |     | 
 19 | *   |     address public maintainer;
 20 | *   |     address public implementation;
 21 |     | 
 22 |     |     constructor(address maintainer_, address owner_) Owned(owner_) {
 23 |     |         if (maintainer_ == address(0)) {
 24 |     |             revert ErrZeroAddress();
 25 |     |         }
 26 |     | 
 27 |     |         maintainer = maintainer_;
 28 |     |     }
 29 |     | 
 30 |     |     //////////////////////////////////////////////////////////////////////////////////////
 31 |     |     /// VIEWS
 32 |     |     //////////////////////////////////////////////////////////////////////////////////////
 33 |     | 
 34 | *   |     function getFeeRate(address trader, uint256 lpFeeRate) external view returns (uint256 adjustedLpFeeRate, uint256 mtFeeRate) {
 35 | *   |         if (implementation == address(0)) {
 36 | *   |             return (lpFeeRate, 0);
 37 |     |         }
 38 |     | 
 39 |     |         return IFeeRateImpl(implementation).getFeeRate(msg.sender, trader, lpFeeRate);
 40 |     |     }
 41 |     | 
 42 |     |     //////////////////////////////////////////////////////////////////////////////////////
 43 |     |     /// ADMIN
 44 |     |     //////////////////////////////////////////////////////////////////////////////////////
 45 |     | 
 46 |     |     function setMaintainer(address maintainer_) external onlyOwner {
 47 |     |         if (maintainer_ == address(0)) {
 48 |     |             revert ErrZeroAddress();
 49 |     |         }
 50 |     | 
 51 |     |         maintainer = maintainer_;
 52 |     |         emit LogMaintainerChanged(maintainer_);
 53 |     |     }
 54 |     | 
 55 |     |     /// @notice Set the fee rate implementation and default fee rate
 56 |     |     /// @param implementation_ The address of the fee rate implementation, use address(0) to disable
 57 |     |     function setImplementation(address implementation_) public onlyOwner {
 58 |     |         implementation = implementation_;
 59 |     |         emit LogImplementationChanged(implementation_);
 60 |     |     }
 61 |     | }
 62 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/auxiliary/FeeRateModelImpl.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IFeeRateImpl} from "../interfaces/IFeeRateModel.sol";
  5 |     | import {Math} from "/mimswap/libraries/Math.sol";
  6 |     | 
  7 |     | contract FeeRateModelImpl {
  8 |     |     // 50% of the LP fee rate
  9 |     |     function getFeeRate(
 10 |     |         address /*pool*/,
 11 |     |         address /*trader*/,
 12 |     |         uint256 lpFeeRate
 13 |     |     ) external pure returns (uint256 adjustedLpFeeRate, uint256 mtFeeRate) {
 14 |     |         mtFeeRate = Math.divCeil(lpFeeRate, 2);
 15 |     |         return (lpFeeRate - mtFeeRate, mtFeeRate);
 16 |     |     }
 17 |     | }
 18 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/interfaces/ICallee.sol
  1 |     | /*
  2 |     | 
  3 |     |     Copyright 2020 DODO ZOO.
  4 |     |     SPDX-License-Identifier: Apache-2.0
  5 |     | 
  6 |     | */
  7 |     | 
  8 |     | pragma solidity >=0.8.0;
  9 |     | 
 10 |     | interface ICallee {
 11 |     |     function SellShareCall(
 12 |     |         address sender,
 13 |     |         uint256 burnShareAmount,
 14 |     |         uint256 baseAmount,
 15 |     |         uint256 quoteAmount,
 16 |     |         bytes calldata data
 17 |     |     ) external;
 18 |     | 
 19 |     |     function FlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external;
 20 |     | }
 21 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/interfaces/IFactory.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | interface IFactory {
  5 |     |     function predictDeterministicAddress(
  6 |     |         address creator,
  7 |     |         address baseToken_,
  8 |     |         address quoteToken_,
  9 |     |         uint256 lpFeeRate_,
 10 |     |         uint256 i_,
 11 |     |         uint256 k_
 12 |     |     ) external view returns (address);
 13 |     | 
 14 |     |     function maintainerFeeRateModel() external view returns (address);
 15 |     | 
 16 |     |     function create(
 17 |     |         address baseToken_,
 18 |     |         address quoteToken_,
 19 |     |         uint256 lpFeeRate_,
 20 |     |         uint256 i_,
 21 |     |         uint256 k_,
 22 |     |         bool protocolOwnedPool_
 23 |     |     ) external returns (address clone);
 24 |     | 
 25 |     |     function poolExists(address pool) external view returns (bool);
 26 |     | 
 27 |     |     function addPool(address creator, address baseToken, address quoteToken, address pool) external;
 28 |     | }
 29 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/interfaces/IFeeRateModel.sol
  1 |     | /*
  2 |     | 
  3 |     |     Copyright 2020 DODO ZOO.
  4 |     |     SPDX-License-Identifier: Apache-2.0
  5 |     | 
  6 |     | */
  7 |     | 
  8 |     | pragma solidity >=0.8.0;
  9 |     | 
 10 |     | interface IFeeRateImpl {
 11 |     |     function getFeeRate(
 12 |     |         address pool,
 13 |     |         address trader,
 14 |     |         uint256 lpFeeRate
 15 |     |     ) external view returns (uint256 adjustedLpFeeRate, uint256 mtFeeRate);
 16 |     | }
 17 |     | 
 18 |     | interface IFeeRateModel {
 19 |     |     function maintainer() external view returns (address);
 20 |     | 
 21 |     |     function getFeeRate(address trader, uint256 lpFeeRate) external view returns (uint256 adjustedLpFeeRate, uint256 mtFeeRate);
 22 |     | }
 23 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/interfaces/IMagicLP.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | interface IMagicLP {
  5 |     |     function _BASE_TOKEN_() external view returns (address);
  6 |     | 
  7 |     |     function _QUOTE_TOKEN_() external view returns (address);
  8 |     | 
  9 |     |     function _BASE_RESERVE_() external view returns (uint112);
 10 |     | 
 11 |     |     function _QUOTE_RESERVE_() external view returns (uint112);
 12 |     | 
 13 |     |     function _BASE_TARGET_() external view returns (uint112);
 14 |     | 
 15 |     |     function _QUOTE_TARGET_() external view returns (uint112);
 16 |     | 
 17 |     |     function _I_() external view returns (uint256);
 18 |     | 
 19 |     |     function getReserves() external view returns (uint256 baseReserve, uint256 quoteReserve);
 20 |     | 
 21 |     |     function totalSupply() external view returns (uint256 totalSupply);
 22 |     | 
 23 |     |     function init(
 24 |     |         address baseTokenAddress,
 25 |     |         address quoteTokenAddress,
 26 |     |         uint256 lpFeeRate,
 27 |     |         address mtFeeRateModel,
 28 |     |         uint256 i,
 29 |     |         uint256 k,
 30 |     |         bool protocolOwnedPool
 31 |     |     ) external;
 32 |     | 
 33 |     |     function sellBase(address to) external returns (uint256 receiveQuoteAmount);
 34 |     | 
 35 |     |     function sellQuote(address to) external returns (uint256 receiveBaseAmount);
 36 |     | 
 37 |     |     function flashLoan(uint256 baseAmount, uint256 quoteAmount, address assetTo, bytes calldata data) external;
 38 |     | 
 39 |     |     function buyShares(address to) external returns (uint256 shares, uint256 baseInput, uint256 quoteInput);
 40 |     | 
 41 |     |     function sellShares(
 42 |     |         uint256 shareAmount,
 43 |     |         address to,
 44 |     |         uint256 baseMinAmount,
 45 |     |         uint256 quoteMinAmount,
 46 |     |         bytes calldata data,
 47 |     |         uint256 deadline
 48 |     |     ) external returns (uint256 baseAmount, uint256 quoteAmount);
 49 |     | 
 50 |     |     function MIN_LP_FEE_RATE() external view returns (uint256);
 51 |     | 
 52 |     |     function MAX_LP_FEE_RATE() external view returns (uint256);
 53 |     | 
 54 |     |     function _PAUSED_() external view returns (bool);
 55 |     | 
 56 |     |     function setPaused(bool paused) external;
 57 |     | }
 58 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/libraries/DecimalMath.sol
  1 |     | /*
  2 |     | 
  3 |     |     Copyright 2020 DODO ZOO.
  4 |     |     SPDX-License-Identifier: Apache-2.0
  5 |     | 
  6 |     | */
  7 |     | pragma solidity >=0.8.0;
  8 |     | 
  9 |     | import {Math} from "/mimswap/libraries/Math.sol";
 10 |     | 
 11 |     | /**
 12 |     |  * @title DecimalMath
 13 |     |  * @author DODO Breeder
 14 |     |  *
 15 |     |  * @notice Functions for fixed point number with 18 decimals
 16 |     |  */
 17 |     | library DecimalMath {
 18 |     |     using Math for uint256;
 19 |     | 
 20 | *   |     uint256 internal constant ONE = 10 ** 18;
 21 |     |     uint256 internal constant ONE2 = 10 ** 36;
 22 |     | 
 23 | *   |     function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {
 24 | *   |         return (target * d) / ONE;
 25 |     |     }
 26 |     | 
 27 | *   |     function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {
 28 | *   |         return (target * d).divCeil(ONE);
 29 |     |     }
 30 |     | 
 31 | *   |     function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {
 32 | *   |         return (target * ONE) / d;
 33 |     |     }
 34 |     | 
 35 |     |     function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {
 36 |     |         return (target * ONE).divCeil(d);
 37 |     |     }
 38 |     | 
 39 |     |     function reciprocalFloor(uint256 target) internal pure returns (uint256) {
 40 |     |         return ONE2 / target;
 41 |     |     }
 42 |     | 
 43 |     |     function reciprocalCeil(uint256 target) internal pure returns (uint256) {
 44 |     |         return ONE2.divCeil(target);
 45 |     |     }
 46 |     | 
 47 |     |     function powFloor(uint256 target, uint256 e) internal pure returns (uint256) {
 48 |     |         if (e == 0) {
 49 |     |             return 10 ** 18;
 50 |     |         } else if (e == 1) {
 51 |     |             return target;
 52 |     |         } else {
 53 |     |             uint p = powFloor(target, e / 2);
 54 |     |             p = (p * p) / ONE;
 55 |     |             if (e % 2 == 1) {
 56 |     |                 p = (p * target) / ONE;
 57 |     |             }
 58 |     |             return p;
 59 |     |         }
 60 |     |     }
 61 |     | }
 62 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/libraries/Math.sol
   1 |     | /*
   2 |     | 
   3 |     |     Copyright 2020 DODO ZOO.
   4 |     |     SPDX-License-Identifier: Apache-2.0
   5 |     | 
   6 |     | */
   7 |     | 
   8 |     | pragma solidity >=0.8.0;
   9 |     | 
  10 |     | import {DecimalMath} from "/mimswap/libraries/DecimalMath.sol";
  11 |     | 
  12 |     | /**
  13 |     |  * @author Adapted from https://github.com/DODOEX/contractV2/blob/main/contracts/lib/Math.sol
  14 |     |  * @notice Functions for complex calculating. Including ONE Integration and TWO Quadratic solutions
  15 |     |  */
  16 |     | library Math {
  17 |     |     error ErrIsZero();
  18 |     | 
  19 | *   |     function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {
  20 | *   |         uint256 quotient = a / b;
  21 | *   |         uint256 remainder = a - quotient * b;
  22 | *   |         if (remainder > 0) {
  23 | *   |             return quotient + 1;
  24 |     |         } else {
  25 | *   |             return quotient;
  26 |     |         }
  27 |     |     }
  28 |     | 
  29 |     |     function sqrt(uint256 x) internal pure returns (uint256 y) {
  30 |     |         uint256 z = x / 2 + 1;
  31 |     |         y = x;
  32 |     |         while (z < y) {
  33 |     |             y = z;
  34 |     |             z = (x / z + z) / 2;
  35 |     |         }
  36 |     |     }
  37 |     | 
  38 |     |     /*
  39 |     |         Integrate dodo curve from V1 to V2
  40 |     |         require V0>=V1>=V2>0
  41 |     |         res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)
  42 |     |         let V1-V2=delta
  43 |     |         res = i*delta*(1-k+k(V0^2/V1/V2))
  44 |     | 
  45 |     |         i is the price of V-res trading pair
  46 |     | 
  47 |     |         support k=1 & k=0 case
  48 |     | 
  49 |     |         [round down]
  50 |     |     */
  51 |     |     function _GeneralIntegrate(uint256 V0, uint256 V1, uint256 V2, uint256 i, uint256 k) internal pure returns (uint256) {
  52 |     |         if (V0 == 0) {
  53 |     |             revert ErrIsZero();
  54 |     |         }
  55 |     | 
  56 |     |         uint256 fairAmount = i * (V1 - V2); // i*delta
  57 |     | 
  58 |     |         if (k == 0) {
  59 |     |             return fairAmount / DecimalMath.ONE;
  60 |     |         }
  61 |     | 
  62 |     |         uint256 V0V0V1V2 = DecimalMath.divFloor((V0 * V0) / V1, V2);
  63 |     |         uint256 penalty = DecimalMath.mulFloor(k, V0V0V1V2); // k(V0^2/V1/V2)
  64 |     |         return (((DecimalMath.ONE - k) + penalty) * fairAmount) / DecimalMath.ONE2;
  65 |     |     }
  66 |     | 
  67 |     |     /*
  68 |     |         Follow the integration function above
  69 |     |         i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)
  70 |     |         Assume Q2=Q0, Given Q1 and deltaB, solve Q0
  71 |     | 
  72 |     |         i is the price of delta-V trading pair
  73 |     |         give out target of V
  74 |     | 
  75 |     |         support k=1 & k=0 case
  76 |     | 
  77 |     |         [round down]
  78 |     |     */
  79 |     |     function _SolveQuadraticFunctionForTarget(uint256 V1, uint256 delta, uint256 i, uint256 k) internal pure returns (uint256) {
  80 |     |         if (k == 0) {
  81 |     |             return V1 + DecimalMath.mulFloor(i, delta);
  82 |     |         }
  83 |     | 
  84 |     |         // V0 = V1*(1+(sqrt-1)/2k)
  85 |     |         // sqrt = √(1+4kidelta/V1)
  86 |     |         // premium = 1+(sqrt-1)/2k
  87 |     |         // uint256 sqrt = (4 * k).mul(i).mul(delta).div(V1).add(DecimalMath.ONE2).sqrt();
  88 |     | 
  89 |     |         if (V1 == 0) {
  90 |     |             return 0;
  91 |     |         }
  92 |     |         uint256 _sqrt;
  93 |     |         uint256 ki = (4 * k) * i;
  94 |     |         if (ki == 0) {
  95 |     |             _sqrt = DecimalMath.ONE;
  96 |     |         } else if ((ki * delta) / ki == delta) {
  97 |     |             _sqrt = sqrt(((ki * delta) / V1) + DecimalMath.ONE2);
  98 |     |         } else {
  99 |     |             _sqrt = sqrt(((ki / V1) * delta) + DecimalMath.ONE2);
 100 |     |         }
 101 |     |         uint256 premium = DecimalMath.divFloor(_sqrt - DecimalMath.ONE, k * 2) + DecimalMath.ONE;
 102 |     |         // V0 is greater than or equal to V1 according to the solution
 103 |     |         return DecimalMath.mulFloor(V1, premium);
 104 |     |     }
 105 |     | 
 106 |     |     /*
 107 |     |         Follow the integration expression above, we have:
 108 |     |         i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)
 109 |     |         Given Q1 and deltaB, solve Q2
 110 |     |         This is a quadratic function and the standard version is
 111 |     |         aQ2^2 + bQ2 + c = 0, where
 112 |     |         a=1-k
 113 |     |         -b=(1-k)Q1-kQ0^2/Q1+i*deltaB
 114 |     |         c=-kQ0^2 
 115 |     |         and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)
 116 |     |         note: another root is negative, abondan
 117 |     | 
 118 |     |         if deltaBSig=true, then Q2>Q1, user sell Q and receive B
 119 |     |         if deltaBSig=false, then Q2<Q1, user sell B and receive Q
 120 |     |         return |Q1-Q2|
 121 |     | 
 122 |     |         as we only support sell amount as delta, the deltaB is always negative
 123 |     |         the input ideltaB is actually -ideltaB in the equation
 124 |     | 
 125 |     |         i is the price of delta-V trading pair
 126 |     | 
 127 |     |         support k=1 & k=0 case
 128 |     | 
 129 |     |         [round down]
 130 |     |     */
 131 |     |     function _SolveQuadraticFunctionForTrade(uint256 V0, uint256 V1, uint256 delta, uint256 i, uint256 k) internal pure returns (uint256) {
 132 |     |         if (V0 == 0) {
 133 |     |             revert ErrIsZero();
 134 |     |         }
 135 |     | 
 136 |     |         if (delta == 0) {
 137 |     |             return 0;
 138 |     |         }
 139 |     | 
 140 |     |         if (k == 0) {
 141 |     |             return DecimalMath.mulFloor(i, delta) > V1 ? V1 : DecimalMath.mulFloor(i, delta);
 142 |     |         }
 143 |     | 
 144 |     |         if (k == DecimalMath.ONE) {
 145 |     |             // if k==1
 146 |     |             // Q2=Q1/(1+ideltaBQ1/Q0/Q0)
 147 |     |             // temp = ideltaBQ1/Q0/Q0
 148 |     |             // Q2 = Q1/(1+temp)
 149 |     |             // Q1-Q2 = Q1*(1-1/(1+temp)) = Q1*(temp/(1+temp))
 150 |     |             // uint256 temp = i.mul(delta).mul(V1).div(V0.mul(V0));
 151 |     |             uint256 temp;
 152 |     |             uint256 idelta = i * delta;
 153 |     |             if (idelta == 0) {
 154 |     |                 temp = 0;
 155 |     |             } else if ((idelta * V1) / idelta == V1) {
 156 |     |                 temp = (idelta * V1) / (V0 * V0);
 157 |     |             } else {
 158 |     |                 temp = (((delta * V1) / V0) * i) / V0;
 159 |     |             }
 160 |     |             return (V1 * temp) / (temp + DecimalMath.ONE);
 161 |     |         }
 162 |     | 
 163 |     |         // calculate -b value and sig
 164 |     |         // b = kQ0^2/Q1-i*deltaB-(1-k)Q1
 165 |     |         // part1 = (1-k)Q1 >=0
 166 |     |         // part2 = kQ0^2/Q1-i*deltaB >=0
 167 |     |         // bAbs = abs(part1-part2)
 168 |     |         // if part1>part2 => b is negative => bSig is false
 169 |     |         // if part2>part1 => b is positive => bSig is true
 170 |     |         uint256 part2 = (((k * V0) / V1) * V0) + (i * delta); // kQ0^2/Q1-i*deltaB
 171 |     |         uint256 bAbs = (DecimalMath.ONE - k) * V1; // (1-k)Q1
 172 |     | 
 173 |     |         bool bSig;
 174 |     |         if (bAbs >= part2) {
 175 |     |             bAbs = bAbs - part2;
 176 |     |             bSig = false;
 177 |     |         } else {
 178 |     |             bAbs = part2 - bAbs;
 179 |     |             bSig = true;
 180 |     |         }
 181 |     |         bAbs = bAbs / DecimalMath.ONE;
 182 |     | 
 183 |     |         // calculate sqrt
 184 |     |         uint256 squareRoot = DecimalMath.mulFloor((DecimalMath.ONE - k) * 4, DecimalMath.mulFloor(k, V0) * V0); // 4(1-k)kQ0^2
 185 |     |         squareRoot = sqrt((bAbs * bAbs) + squareRoot); // sqrt(b*b+4(1-k)kQ0*Q0)
 186 |     | 
 187 |     |         // final res
 188 |     |         uint256 denominator = (DecimalMath.ONE - k) * 2; // 2(1-k)
 189 |     |         uint256 numerator;
 190 |     |         if (bSig) {
 191 |     |             numerator = squareRoot - bAbs;
 192 |     |             if (numerator == 0) {
 193 |     |                 revert ErrIsZero();
 194 |     |             }
 195 |     |         } else {
 196 |     |             numerator = bAbs + squareRoot;
 197 |     |         }
 198 |     | 
 199 |     |         uint256 V2 = DecimalMath.divCeil(numerator, denominator);
 200 |     |         if (V2 > V1) {
 201 |     |             return 0;
 202 |     |         } else {
 203 |     |             return V1 - V2;
 204 |     |         }
 205 |     |     }
 206 |     | }
 207 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/libraries/PMMPricing.sol
   1 |     | /*
   2 |     | 
   3 |     |     Copyright 2020 DODO ZOO.
   4 |     |     SPDX-License-Identifier: Apache-2.0
   5 |     | 
   6 |     | */
   7 |     | 
   8 |     | pragma solidity >=0.8.0;
   9 |     | 
  10 |     | import {DecimalMath} from "/mimswap/libraries/DecimalMath.sol";
  11 |     | import {Math} from "/mimswap/libraries/Math.sol";
  12 |     | 
  13 |     | /**
  14 |     |  * @title Pricing
  15 |     |  * @author DODO Breeder
  16 |     |  *
  17 |     |  * @notice DODO Pricing model
  18 |     |  */
  19 |     | 
  20 |     | library PMMPricing {
  21 |     |     enum RState {
  22 |     |         ONE,
  23 |     |         ABOVE_ONE,
  24 |     |         BELOW_ONE
  25 |     |     }
  26 |     | 
  27 |     |     struct PMMState {
  28 |     |         uint256 i;
  29 |     |         uint256 K;
  30 |     |         uint256 B;
  31 |     |         uint256 Q;
  32 |     |         uint256 B0;
  33 |     |         uint256 Q0;
  34 |     |         RState R;
  35 |     |     }
  36 |     | 
  37 |     |     // ============ buy & sell ============
  38 |     | 
  39 |     |     function sellBaseToken(PMMState memory state, uint256 payBaseAmount) internal pure returns (uint256 receiveQuoteAmount, RState newR) {
  40 |     |         if (state.R == RState.ONE) {
  41 |     |             // case 1: R=1
  42 |     |             // R falls below one
  43 |     |             receiveQuoteAmount = _ROneSellBaseToken(state, payBaseAmount);
  44 |     |             newR = RState.BELOW_ONE;
  45 |     |         } else if (state.R == RState.ABOVE_ONE) {
  46 |     |             uint256 backToOnePayBase = state.B0 - state.B;
  47 |     |             uint256 backToOneReceiveQuote = state.Q - state.Q0;
  48 |     |             // case 2: R>1
  49 |     |             // complex case, R status depends on trading amount
  50 |     |             if (payBaseAmount < backToOnePayBase) {
  51 |     |                 // case 2.1: R status do not change
  52 |     |                 receiveQuoteAmount = _RAboveSellBaseToken(state, payBaseAmount);
  53 |     |                 newR = RState.ABOVE_ONE;
  54 |     |                 if (receiveQuoteAmount > backToOneReceiveQuote) {
  55 |     |                     // [Important corner case!] may enter this branch when some precision problem happens. And consequently contribute to negative spare quote amount
  56 |     |                     // to make sure spare quote>=0, mannually set receiveQuote=backToOneReceiveQuote
  57 |     |                     receiveQuoteAmount = backToOneReceiveQuote;
  58 |     |                 }
  59 |     |             } else if (payBaseAmount == backToOnePayBase) {
  60 |     |                 // case 2.2: R status changes to ONE
  61 |     |                 receiveQuoteAmount = backToOneReceiveQuote;
  62 |     |                 newR = RState.ONE;
  63 |     |             } else {
  64 |     |                 // case 2.3: R status changes to BELOW_ONE
  65 |     |                 receiveQuoteAmount = backToOneReceiveQuote + _ROneSellBaseToken(state, payBaseAmount - backToOnePayBase);
  66 |     |                 newR = RState.BELOW_ONE;
  67 |     |             }
  68 |     |         } else {
  69 |     |             // state.R == RState.BELOW_ONE
  70 |     |             // case 3: R<1
  71 |     |             receiveQuoteAmount = _RBelowSellBaseToken(state, payBaseAmount);
  72 |     |             newR = RState.BELOW_ONE;
  73 |     |         }
  74 |     |     }
  75 |     | 
  76 |     |     function sellQuoteToken(PMMState memory state, uint256 payQuoteAmount) internal pure returns (uint256 receiveBaseAmount, RState newR) {
  77 |     |         if (state.R == RState.ONE) {
  78 |     |             receiveBaseAmount = _ROneSellQuoteToken(state, payQuoteAmount);
  79 |     |             newR = RState.ABOVE_ONE;
  80 |     |         } else if (state.R == RState.ABOVE_ONE) {
  81 |     |             receiveBaseAmount = _RAboveSellQuoteToken(state, payQuoteAmount);
  82 |     |             newR = RState.ABOVE_ONE;
  83 |     |         } else {
  84 |     |             uint256 backToOnePayQuote = state.Q0 - state.Q;
  85 |     |             uint256 backToOneReceiveBase = state.B - state.B0;
  86 |     |             if (payQuoteAmount < backToOnePayQuote) {
  87 |     |                 receiveBaseAmount = _RBelowSellQuoteToken(state, payQuoteAmount);
  88 |     |                 newR = RState.BELOW_ONE;
  89 |     |                 if (receiveBaseAmount > backToOneReceiveBase) {
  90 |     |                     receiveBaseAmount = backToOneReceiveBase;
  91 |     |                 }
  92 |     |             } else if (payQuoteAmount == backToOnePayQuote) {
  93 |     |                 receiveBaseAmount = backToOneReceiveBase;
  94 |     |                 newR = RState.ONE;
  95 |     |             } else {
  96 |     |                 receiveBaseAmount = backToOneReceiveBase + _ROneSellQuoteToken(state, payQuoteAmount - backToOnePayQuote);
  97 |     |                 newR = RState.ABOVE_ONE;
  98 |     |             }
  99 |     |         }
 100 |     |     }
 101 |     | 
 102 |     |     // ============ R = 1 cases ============
 103 |     | 
 104 |     |     function _ROneSellBaseToken(
 105 |     |         PMMState memory state,
 106 |     |         uint256 payBaseAmount
 107 |     |     )
 108 |     |         internal
 109 |     |         pure
 110 |     |         returns (
 111 |     |             uint256 // receiveQuoteToken
 112 |     |         )
 113 |     |     {
 114 |     |         // in theory Q2 <= targetQuoteTokenAmount
 115 |     |         // however when amount is close to 0, precision problems may cause Q2 > targetQuoteTokenAmount
 116 |     |         return Math._SolveQuadraticFunctionForTrade(state.Q0, state.Q0, payBaseAmount, state.i, state.K);
 117 |     |     }
 118 |     | 
 119 |     |     function _ROneSellQuoteToken(
 120 |     |         PMMState memory state,
 121 |     |         uint256 payQuoteAmount
 122 |     |     )
 123 |     |         internal
 124 |     |         pure
 125 |     |         returns (
 126 |     |             uint256 // receiveBaseToken
 127 |     |         )
 128 |     |     {
 129 |     |         return Math._SolveQuadraticFunctionForTrade(state.B0, state.B0, payQuoteAmount, DecimalMath.reciprocalFloor(state.i), state.K);
 130 |     |     }
 131 |     | 
 132 |     |     // ============ R < 1 cases ============
 133 |     | 
 134 |     |     function _RBelowSellQuoteToken(
 135 |     |         PMMState memory state,
 136 |     |         uint256 payQuoteAmount
 137 |     |     )
 138 |     |         internal
 139 |     |         pure
 140 |     |         returns (
 141 |     |             uint256 // receiveBaseToken
 142 |     |         )
 143 |     |     {
 144 |     |         return Math._GeneralIntegrate(state.Q0, state.Q + payQuoteAmount, state.Q, DecimalMath.reciprocalFloor(state.i), state.K);
 145 |     |     }
 146 |     | 
 147 |     |     function _RBelowSellBaseToken(
 148 |     |         PMMState memory state,
 149 |     |         uint256 payBaseAmount
 150 |     |     )
 151 |     |         internal
 152 |     |         pure
 153 |     |         returns (
 154 |     |             uint256 // receiveQuoteToken
 155 |     |         )
 156 |     |     {
 157 |     |         return Math._SolveQuadraticFunctionForTrade(state.Q0, state.Q, payBaseAmount, state.i, state.K);
 158 |     |     }
 159 |     | 
 160 |     |     // ============ R > 1 cases ============
 161 |     | 
 162 |     |     function _RAboveSellBaseToken(
 163 |     |         PMMState memory state,
 164 |     |         uint256 payBaseAmount
 165 |     |     )
 166 |     |         internal
 167 |     |         pure
 168 |     |         returns (
 169 |     |             uint256 // receiveQuoteToken
 170 |     |         )
 171 |     |     {
 172 |     |         return Math._GeneralIntegrate(state.B0, state.B + payBaseAmount, state.B, state.i, state.K);
 173 |     |     }
 174 |     | 
 175 |     |     function _RAboveSellQuoteToken(
 176 |     |         PMMState memory state,
 177 |     |         uint256 payQuoteAmount
 178 |     |     )
 179 |     |         internal
 180 |     |         pure
 181 |     |         returns (
 182 |     |             uint256 // receiveBaseToken
 183 |     |         )
 184 |     |     {
 185 |     |         return Math._SolveQuadraticFunctionForTrade(state.B0, state.B, payQuoteAmount, DecimalMath.reciprocalFloor(state.i), state.K);
 186 |     |     }
 187 |     | 
 188 |     |     // ============ Helper functions ============
 189 |     | 
 190 |     |     function adjustedTarget(PMMState memory state) internal pure {
 191 |     |         if (state.R == RState.BELOW_ONE) {
 192 |     |             state.Q0 = Math._SolveQuadraticFunctionForTarget(state.Q, state.B - state.B0, state.i, state.K);
 193 |     |         } else if (state.R == RState.ABOVE_ONE) {
 194 |     |             state.B0 = Math._SolveQuadraticFunctionForTarget(
 195 |     |                 state.B,
 196 |     |                 state.Q - state.Q0,
 197 |     |                 DecimalMath.reciprocalFloor(state.i),
 198 |     |                 state.K
 199 |     |             );
 200 |     |         }
 201 |     |     }
 202 |     | 
 203 |     |     function getMidPrice(PMMState memory state) internal pure returns (uint256) {
 204 |     |         if (state.R == RState.BELOW_ONE) {
 205 |     |             uint256 R = DecimalMath.divFloor((state.Q0 * state.Q0) / state.Q, state.Q);
 206 |     |             R = (DecimalMath.ONE - state.K) + DecimalMath.mulFloor(state.K, R);
 207 |     |             return DecimalMath.divFloor(state.i, R);
 208 |     |         } else {
 209 |     |             uint256 R = DecimalMath.divFloor((state.B0 * state.B0) / state.B, state.B);
 210 |     |             R = (DecimalMath.ONE - state.K) + DecimalMath.mulFloor(state.K, R);
 211 |     |             return DecimalMath.mulFloor(state.i, R);
 212 |     |         }
 213 |     |     }
 214 |     | }
 215 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/periphery/Factory.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {Owned} from "solmate/auth/Owned.sol";
   5 |     | import {LibClone} from "solady/utils/LibClone.sol";
   6 |     | import {IFeeRateModel} from "/mimswap/interfaces/IFeeRateModel.sol";
   7 |     | import {IMagicLP} from "/mimswap/interfaces/IMagicLP.sol";
   8 |     | import {MagicLP} from "/mimswap/MagicLP.sol";
   9 |     | 
  10 |     | /// @notice Create and register MagicLP pools
  11 | *   | contract Factory is Owned {
  12 |     |     event LogCreated(
  13 |     |         address clone_,
  14 |     |         address indexed baseToken_,
  15 |     |         address indexed quoteToken_,
  16 |     |         address indexed creator_,
  17 |     |         uint256 lpFeeRate_,
  18 |     |         IFeeRateModel maintainerFeeRateModel,
  19 |     |         uint256 i_,
  20 |     |         uint256 k_
  21 |     |     );
  22 |     | 
  23 |     |     event LogPoolAdded(address baseToken, address quoteToken, address creator, address pool);
  24 |     |     event LogPoolRemoved(address pool);
  25 |     |     event LogSetImplementation(address indexed implementation);
  26 |     |     event LogSetMaintainer(address indexed newMaintainer);
  27 |     |     event LogSetMaintainerFeeRateModel(IFeeRateModel newMaintainerFeeRateModel);
  28 |     | 
  29 |     |     error ErrInvalidUserPoolIndex();
  30 |     |     error ErrZeroAddress();
  31 |     | 
  32 |     |     address public implementation;
  33 | *   |     IFeeRateModel public maintainerFeeRateModel;
  34 |     | 
  35 | *   |     mapping(address pool => bool exists) public poolExists;
  36 |     |     mapping(address base => mapping(address quote => address[] pools)) public pools;
  37 |     |     mapping(address creator => address[] pools) public userPools;
  38 |     | 
  39 |     |     constructor(address implementation_, IFeeRateModel maintainerFeeRateModel_, address owner_) Owned(owner_) {
  40 |     |         if (implementation_ == address(0)) {
  41 |     |             revert ErrZeroAddress();
  42 |     |         }
  43 |     |         if (address(maintainerFeeRateModel_) == address(0)) {
  44 |     |             revert ErrZeroAddress();
  45 |     |         }
  46 |     |         implementation = implementation_;
  47 |     |         maintainerFeeRateModel = maintainerFeeRateModel_;
  48 |     |     }
  49 |     | 
  50 |     |     //////////////////////////////////////////////////////////////////////////////////////
  51 |     |     /// VIEWS
  52 |     |     //////////////////////////////////////////////////////////////////////////////////////
  53 |     | 
  54 |     |     function getPoolCount(address token0, address token1) external view returns (uint256) {
  55 |     |         return pools[token0][token1].length;
  56 |     |     }
  57 |     | 
  58 |     |     function getUserPoolCount(address creator) external view returns (uint256) {
  59 |     |         return userPools[creator].length;
  60 |     |     }
  61 |     | 
  62 |     |     //////////////////////////////////////////////////////////////////////////////////////
  63 |     |     /// PUBLIC
  64 |     |     //////////////////////////////////////////////////////////////////////////////////////
  65 |     | 
  66 |     |     function predictDeterministicAddress(
  67 |     |         address creator,
  68 |     |         address baseToken_,
  69 |     |         address quoteToken_,
  70 |     |         uint256 lpFeeRate_,
  71 |     |         uint256 i_,
  72 |     |         uint256 k_,
  73 |     |         bool protocolOwnedPool_
  74 |     |     ) public view returns (address) {
  75 |     |         return
  76 |     |             LibClone.predictDeterministicAddress(
  77 |     |                 implementation,
  78 |     |                 _computeSalt(creator, baseToken_, quoteToken_, lpFeeRate_, i_, k_, protocolOwnedPool_),
  79 |     |                 address(this)
  80 |     |             );
  81 |     |     }
  82 |     | 
  83 | *   |     function create(
  84 |     |         address baseToken_,
  85 |     |         address quoteToken_,
  86 |     |         uint256 lpFeeRate_,
  87 |     |         uint256 i_,
  88 |     |         uint256 k_,
  89 |     |         bool protocolOwnedPool_
  90 | *   |     ) external returns (address clone) {
  91 | *   |         address creator = tx.origin;
  92 |     | 
  93 | *   |         bytes32 salt = _computeSalt(creator, baseToken_, quoteToken_, lpFeeRate_, i_, k_, protocolOwnedPool_);
  94 | *   |         clone = LibClone.cloneDeterministic(address(implementation), salt);
  95 | *   |         IMagicLP(clone).init(
  96 |     |             address(baseToken_),
  97 |     |             address(quoteToken_),
  98 |     |             lpFeeRate_,
  99 | *   |             address(maintainerFeeRateModel),
 100 |     |             i_,
 101 |     |             k_,
 102 |     |             protocolOwnedPool_
 103 |     |         );
 104 |     | 
 105 | *   |         emit LogCreated(clone, baseToken_, quoteToken_, creator, lpFeeRate_, maintainerFeeRateModel, i_, k_);
 106 | *   |         _addPool(creator, baseToken_, quoteToken_, clone);
 107 |     |     }
 108 |     | 
 109 |     |     //////////////////////////////////////////////////////////////////////////////////////
 110 |     |     /// ADMIN
 111 |     |     //////////////////////////////////////////////////////////////////////////////////////
 112 |     | 
 113 |     |     function setLpImplementation(address implementation_) external onlyOwner {
 114 |     |         if (implementation_ == address(0)) {
 115 |     |             revert ErrZeroAddress();
 116 |     |         }
 117 |     | 
 118 |     |         implementation = implementation_;
 119 |     |         emit LogSetImplementation(implementation_);
 120 |     |     }
 121 |     | 
 122 |     |     function setMaintainerFeeRateModel(IFeeRateModel maintainerFeeRateModel_) external onlyOwner {
 123 |     |         if (address(maintainerFeeRateModel_) == address(0)) {
 124 |     |             revert ErrZeroAddress();
 125 |     |         }
 126 |     | 
 127 |     |         maintainerFeeRateModel = maintainerFeeRateModel_;
 128 |     |         emit LogSetMaintainerFeeRateModel(maintainerFeeRateModel_);
 129 |     |     }
 130 |     | 
 131 |     |     /// @notice Register a pool to the list
 132 |     |     /// Note this doesn't check if the pool is valid or if it's already registered.
 133 |     |     function addPool(address creator, address baseToken, address quoteToken, address pool) external onlyOwner {
 134 |     |         _addPool(creator, baseToken, quoteToken, pool);
 135 |     |     }
 136 |     | 
 137 |     |     function removePool(
 138 |     |         address creator,
 139 |     |         address baseToken,
 140 |     |         address quoteToken,
 141 |     |         uint256 poolIndex,
 142 |     |         uint256 userPoolIndex
 143 |     |     ) external onlyOwner {
 144 |     |         address[] storage _pools = pools[baseToken][quoteToken];
 145 |     |         address pool = _pools[poolIndex];
 146 |     |         address[] storage _userPools = userPools[creator];
 147 |     | 
 148 |     |         _pools[poolIndex] = _pools[_pools.length - 1];
 149 |     |         _pools.pop();
 150 |     | 
 151 |     |         if (_userPools[userPoolIndex] != pool) {
 152 |     |             revert ErrInvalidUserPoolIndex();
 153 |     |         }
 154 |     | 
 155 |     |         _userPools[userPoolIndex] = _userPools[_userPools.length - 1];
 156 |     |         _userPools.pop();
 157 |     |         poolExists[pool] = false;
 158 |     | 
 159 |     |         emit LogPoolRemoved(pool);
 160 |     |     }
 161 |     | 
 162 |     |     //////////////////////////////////////////////////////////////////////////////////////
 163 |     |     /// INTERNALS
 164 |     |     //////////////////////////////////////////////////////////////////////////////////////
 165 |     | 
 166 | *   |     function _addPool(address creator, address baseToken, address quoteToken, address pool) internal {
 167 | *   |         pools[baseToken][quoteToken].push(pool);
 168 | *   |         userPools[creator].push(pool);
 169 | *   |         poolExists[pool] = true;
 170 |     | 
 171 | *   |         emit LogPoolAdded(baseToken, quoteToken, creator, pool);
 172 |     |     }
 173 |     | 
 174 | *   |     function _computeSalt(
 175 |     |         address sender_,
 176 |     |         address baseToken_,
 177 |     |         address quoteToken_,
 178 |     |         uint256 lpFeeRate_,
 179 |     |         uint256 i_,
 180 |     |         uint256 k_,
 181 |     |         bool protocolOwnedPool_
 182 |     |     ) internal view returns (bytes32) {
 183 | *   |         return keccak256(abi.encodePacked(sender_, implementation, baseToken_, quoteToken_, lpFeeRate_, i_, k_, protocolOwnedPool_));
 184 |     |     }
 185 |     | }
 186 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/periphery/PrivateRouter.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {Router} from "/mimswap/periphery/Router.sol";
   5 |     | import {OperatableV2} from "mixins/OperatableV2.sol";
   6 |     | import {IFactory} from "/mimswap/interfaces/IFactory.sol";
   7 |     | import {IWETH} from "interfaces/IWETH.sol";
   8 |     | 
   9 |     | /// @notice Same as Router, but with an OperatableV2 modifier
  10 |     | /// so it can be whitelisted as an authorized protocol owned pool
  11 |     | /// MagicLP operator
  12 |     | contract PrivateRouter is Router, OperatableV2 {
  13 |     |     constructor(IWETH weth_, IFactory factory_, address owner_) Router(weth_, factory_) OperatableV2(owner_) {}
  14 |     | 
  15 |     |     function createPool(
  16 |     |         address baseToken,
  17 |     |         address quoteToken,
  18 |     |         uint256 lpFeeRate,
  19 |     |         uint256 i,
  20 |     |         uint256 k,
  21 |     |         address to,
  22 |     |         uint256 baseInAmount,
  23 |     |         uint256 quoteInAmount,
  24 |     |         bool protocolOwnedPool
  25 |     |     ) public override onlyOperators returns (address clone, uint256 shares) {
  26 |     |         return super.createPool(baseToken, quoteToken, lpFeeRate, i, k, to, baseInAmount, quoteInAmount, protocolOwnedPool);
  27 |     |     }
  28 |     | 
  29 |     |     function createPoolETH(
  30 |     |         address token,
  31 |     |         bool useTokenAsQuote,
  32 |     |         uint256 lpFeeRate,
  33 |     |         uint256 i,
  34 |     |         uint256 k,
  35 |     |         address to,
  36 |     |         uint256 tokenInAmount,
  37 |     |         bool protocolOwnedPool
  38 |     |     ) public payable override onlyOperators returns (address clone, uint256 shares) {
  39 |     |         return super.createPoolETH(token, useTokenAsQuote, lpFeeRate, i, k, to, tokenInAmount, protocolOwnedPool);
  40 |     |     }
  41 |     | 
  42 |     |     function addLiquidity(
  43 |     |         address lp,
  44 |     |         address to,
  45 |     |         uint256 baseInAmount,
  46 |     |         uint256 quoteInAmount,
  47 |     |         uint256 minimumShares,
  48 |     |         uint256 deadline
  49 |     |     ) public override onlyOperators returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {
  50 |     |         return super.addLiquidity(lp, to, baseInAmount, quoteInAmount, minimumShares, deadline);
  51 |     |     }
  52 |     | 
  53 |     |     function addLiquidityUnsafe(
  54 |     |         address lp,
  55 |     |         address to,
  56 |     |         uint256 baseInAmount,
  57 |     |         uint256 quoteInAmount,
  58 |     |         uint256 minimumShares,
  59 |     |         uint256 deadline
  60 |     |     ) public override onlyOperators returns (uint256 shares) {
  61 |     |         return super.addLiquidityUnsafe(lp, to, baseInAmount, quoteInAmount, minimumShares, deadline);
  62 |     |     }
  63 |     | 
  64 |     |     function addLiquidityETH(
  65 |     |         address lp,
  66 |     |         address to,
  67 |     |         address payable refundTo,
  68 |     |         uint256 tokenInAmount,
  69 |     |         uint256 minimumShares,
  70 |     |         uint256 deadline
  71 |     |     ) public payable override onlyOperators returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {
  72 |     |         return super.addLiquidityETH(lp, to, refundTo, tokenInAmount, minimumShares, deadline);
  73 |     |     }
  74 |     | 
  75 |     |     function addLiquidityETHUnsafe(
  76 |     |         address lp,
  77 |     |         address to,
  78 |     |         uint256 tokenInAmount,
  79 |     |         uint256 minimumShares,
  80 |     |         uint256 deadline
  81 |     |     ) public payable override onlyOperators returns (uint256 shares) {
  82 |     |         return super.addLiquidityETHUnsafe(lp, to, tokenInAmount, minimumShares, deadline);
  83 |     |     }
  84 |     | 
  85 |     |     function removeLiquidity(
  86 |     |         address lp,
  87 |     |         address to,
  88 |     |         uint256 sharesIn,
  89 |     |         uint256 minimumBaseAmount,
  90 |     |         uint256 minimumQuoteAmount,
  91 |     |         uint256 deadline
  92 |     |     ) public override onlyOperators returns (uint256 baseAmountOut, uint256 quoteAmountOut) {
  93 |     |         return super.removeLiquidity(lp, to, sharesIn, minimumBaseAmount, minimumQuoteAmount, deadline);
  94 |     |     }
  95 |     | 
  96 |     |     function removeLiquidityETH(
  97 |     |         address lp,
  98 |     |         address to,
  99 |     |         uint256 sharesIn,
 100 |     |         uint256 minimumETHAmount,
 101 |     |         uint256 minimumTokenAmount,
 102 |     |         uint256 deadline
 103 |     |     ) public override onlyOperators returns (uint256 ethAmountOut, uint256 tokenAmountOut) {
 104 |     |         return super.removeLiquidityETH(lp, to, sharesIn, minimumETHAmount, minimumTokenAmount, deadline);
 105 |     |     }
 106 |     | 
 107 |     |     function swapTokensForTokens(
 108 |     |         address to,
 109 |     |         uint256 amountIn,
 110 |     |         address[] calldata path,
 111 |     |         uint256 directions,
 112 |     |         uint256 minimumOut,
 113 |     |         uint256 deadline
 114 |     |     ) public override onlyOperators returns (uint256 amountOut) {
 115 |     |         return super.swapTokensForTokens(to, amountIn, path, directions, minimumOut, deadline);
 116 |     |     }
 117 |     | 
 118 |     |     function swapETHForTokens(
 119 |     |         address to,
 120 |     |         address[] calldata path,
 121 |     |         uint256 directions,
 122 |     |         uint256 minimumOut,
 123 |     |         uint256 deadline
 124 |     |     ) public payable override onlyOperators returns (uint256 amountOut) {
 125 |     |         return super.swapETHForTokens(to, path, directions, minimumOut, deadline);
 126 |     |     }
 127 |     | 
 128 |     |     function swapTokensForETH(
 129 |     |         address to,
 130 |     |         uint256 amountIn,
 131 |     |         address[] calldata path,
 132 |     |         uint256 directions,
 133 |     |         uint256 minimumOut,
 134 |     |         uint256 deadline
 135 |     |     ) public override onlyOperators returns (uint256 amountOut) {
 136 |     |         return super.swapTokensForETH(to, amountIn, path, directions, minimumOut, deadline);
 137 |     |     }
 138 |     | 
 139 |     |     function sellBaseTokensForTokens(
 140 |     |         address lp,
 141 |     |         address to,
 142 |     |         uint256 amountIn,
 143 |     |         uint256 minimumOut,
 144 |     |         uint256 deadline
 145 |     |     ) public override onlyOperators returns (uint256 amountOut) {
 146 |     |         return super.sellBaseTokensForTokens(lp, to, amountIn, minimumOut, deadline);
 147 |     |     }
 148 |     | 
 149 |     |     function sellBaseETHForTokens(
 150 |     |         address lp,
 151 |     |         address to,
 152 |     |         uint256 minimumOut,
 153 |     |         uint256 deadline
 154 |     |     ) public payable override onlyOperators returns (uint256 amountOut) {
 155 |     |         return super.sellBaseETHForTokens(lp, to, minimumOut, deadline);
 156 |     |     }
 157 |     | 
 158 |     |     function sellBaseTokensForETH(
 159 |     |         address lp,
 160 |     |         address to,
 161 |     |         uint256 amountIn,
 162 |     |         uint256 minimumOut,
 163 |     |         uint256 deadline
 164 |     |     ) public override onlyOperators returns (uint256 amountOut) {
 165 |     |         return super.sellBaseTokensForETH(lp, to, amountIn, minimumOut, deadline);
 166 |     |     }
 167 |     | 
 168 |     |     function sellQuoteTokensForTokens(
 169 |     |         address lp,
 170 |     |         address to,
 171 |     |         uint256 amountIn,
 172 |     |         uint256 minimumOut,
 173 |     |         uint256 deadline
 174 |     |     ) public override onlyOperators returns (uint256 amountOut) {
 175 |     |         return super.sellQuoteTokensForTokens(lp, to, amountIn, minimumOut, deadline);
 176 |     |     }
 177 |     | 
 178 |     |     function sellQuoteETHForTokens(
 179 |     |         address lp,
 180 |     |         address to,
 181 |     |         uint256 minimumOut,
 182 |     |         uint256 deadline
 183 |     |     ) public payable override onlyOperators returns (uint256 amountOut) {
 184 |     |         return super.sellQuoteETHForTokens(lp, to, minimumOut, deadline);
 185 |     |     }
 186 |     | 
 187 |     |     function sellQuoteTokensForETH(
 188 |     |         address lp,
 189 |     |         address to,
 190 |     |         uint256 amountIn,
 191 |     |         uint256 minimumOut,
 192 |     |         uint256 deadline
 193 |     |     ) public override onlyOperators returns (uint256 amountOut) {
 194 |     |         return super.sellQuoteTokensForETH(lp, to, amountIn, minimumOut, deadline);
 195 |     |     }
 196 |     | }
 197 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mimswap/periphery/Router.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
   5 |     | import {IERC20} from "openzeppelin-contracts/interfaces/IERC20.sol";
   6 |     | import {Math} from "/mimswap/libraries/Math.sol";
   7 |     | import {DecimalMath} from "/mimswap/libraries/DecimalMath.sol";
   8 |     | import {IWETH} from "interfaces/IWETH.sol";
   9 |     | import {IMagicLP} from "/mimswap/interfaces/IMagicLP.sol";
  10 |     | import {IFactory} from "/mimswap/interfaces/IFactory.sol";
  11 |     | import {IERC20Metadata} from "openzeppelin-contracts/interfaces/IERC20Metadata.sol";
  12 |     | import {ReentrancyGuard} from "solady/utils/ReentrancyGuard.sol";
  13 |     | 
  14 |     | /// @notice Router for creating and interacting with MagicLP
  15 |     | /// Can only be used for pool created by the Factory
  16 |     | ///
  17 |     | /// @dev A pool can be removed from the Factory. So, when integrating with this contract,
  18 |     | /// validate that the pool exists using the Factory `poolExists` function.
  19 | *   | contract Router is ReentrancyGuard {
  20 |     |     using SafeTransferLib for address;
  21 |     |     using SafeTransferLib for address payable;
  22 |     | 
  23 |     |     error ErrNotETHLP();
  24 |     |     error ErrExpired();
  25 |     |     error ErrZeroAddress();
  26 |     |     error ErrPathTooLong();
  27 |     |     error ErrEmptyPath();
  28 |     |     error ErrBadPath();
  29 |     |     error ErrTooHighSlippage(uint256 amountOut);
  30 |     |     error ErrInvalidBaseToken();
  31 |     |     error ErrInvalidQuoteToken();
  32 |     |     error ErrInTokenNotETH();
  33 |     |     error ErrOutTokenNotETH();
  34 |     |     error ErrInvalidQuoteTarget();
  35 |     |     error ErrZeroDecimals();
  36 |     |     error ErrDecimalsDifferenceTooLarge();
  37 |     |     error ErrUnknownPool();
  38 |     | 
  39 | *   |     uint256 public constant MAX_BASE_QUOTE_DECIMALS_DIFFERENCE = 12;
  40 |     | 
  41 |     |     IWETH public immutable weth;
  42 |     |     IFactory public immutable factory;
  43 |     | 
  44 |     |     receive() external payable {}
  45 |     | 
  46 |     |     constructor(IWETH weth_, IFactory factory_) {
  47 |     |         if (address(weth_) == address(0) || address(factory_) == address(0)) {
  48 |     |             revert ErrZeroAddress();
  49 |     |         }
  50 |     | 
  51 |     |         weth = weth_;
  52 |     |         factory = factory_;
  53 |     |     }
  54 |     | 
  55 |     |     modifier ensureDeadline(uint256 deadline) {
  56 | *   |         if (block.timestamp > deadline) {
  57 |     |             revert ErrExpired();
  58 |     |         }
  59 | *   |         _;
  60 |     |     }
  61 |     | 
  62 |     |     modifier onlyKnownPool(address pool) {
  63 | *   |         if (!factory.poolExists(pool)) {
  64 |     |             revert ErrUnknownPool();
  65 |     |         }
  66 | *   |         _;
  67 |     |     }
  68 |     | 
  69 | *   |     function createPool(
  70 |     |         address baseToken,
  71 |     |         address quoteToken,
  72 |     |         uint256 lpFeeRate,
  73 |     |         uint256 i,
  74 |     |         uint256 k,
  75 |     |         address to,
  76 |     |         uint256 baseInAmount,
  77 |     |         uint256 quoteInAmount,
  78 |     |         bool protocolOwnedPool
  79 | *   |     ) public virtual returns (address clone, uint256 shares) {
  80 | *   |         _validateDecimals(IERC20Metadata(baseToken).decimals(), IERC20Metadata(quoteToken).decimals());
  81 |     | 
  82 | *   |         clone = IFactory(factory).create(baseToken, quoteToken, lpFeeRate, i, k, protocolOwnedPool);
  83 |     | 
  84 | *   |         baseToken.safeTransferFrom(msg.sender, clone, baseInAmount);
  85 | *   |         quoteToken.safeTransferFrom(msg.sender, clone, quoteInAmount);
  86 | *   |         (shares, , ) = IMagicLP(clone).buyShares(to);
  87 |     |     }
  88 |     | 
  89 | *   |     function createPoolETH(
  90 |     |         address token,
  91 |     |         bool useTokenAsQuote,
  92 |     |         uint256 lpFeeRate,
  93 |     |         uint256 i,
  94 |     |         uint256 k,
  95 |     |         address to,
  96 |     |         uint256 tokenInAmount,
  97 |     |         bool protocolOwnedPool
  98 | *   |     ) public payable virtual returns (address clone, uint256 shares) {
  99 | *   |         if (useTokenAsQuote) {
 100 | *   |             _validateDecimals(18, IERC20Metadata(token).decimals());
 101 |     |         } else {
 102 | *   |             _validateDecimals(IERC20Metadata(token).decimals(), 18);
 103 |     |         }
 104 |     | 
 105 | *   |         clone = IFactory(factory).create(
 106 | *   |             useTokenAsQuote ? address(weth) : token,
 107 | *   |             useTokenAsQuote ? token : address(weth),
 108 |     |             lpFeeRate,
 109 |     |             i,
 110 |     |             k,
 111 |     |             protocolOwnedPool
 112 |     |         );
 113 |     | 
 114 | *   |         weth.deposit{value: msg.value}();
 115 | *   |         token.safeTransferFrom(msg.sender, clone, tokenInAmount);
 116 | *   |         address(weth).safeTransferFrom(address(this), clone, msg.value);
 117 | *   |         (shares, , ) = IMagicLP(clone).buyShares(to);
 118 |     |     }
 119 |     | 
 120 |     |     function previewCreatePool(
 121 |     |         uint256 i,
 122 |     |         uint256 baseInAmount,
 123 |     |         uint256 quoteInAmount
 124 |     |     ) external pure returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {
 125 |     |         shares = quoteInAmount < DecimalMath.mulFloor(baseInAmount, i) ? DecimalMath.divFloor(quoteInAmount, i) : baseInAmount;
 126 |     |         baseAdjustedInAmount = shares;
 127 |     |         quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);
 128 |     | 
 129 |     |         if (shares <= 2001) {
 130 |     |             return (0, 0, 0);
 131 |     |         }
 132 |     | 
 133 |     |         shares -= 1001;
 134 |     |     }
 135 |     | 
 136 | *   |     function previewAddLiquidity(
 137 |     |         address lp,
 138 |     |         uint256 baseInAmount,
 139 |     |         uint256 quoteInAmount
 140 |     |     )
 141 |     |         external
 142 |     |         view
 143 |     |         nonReadReentrant
 144 | *   |         onlyKnownPool(lp)
 145 | *   |         returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares)
 146 | *   |     {
 147 | *   |         (uint256 baseReserve, uint256 quoteReserve) = IMagicLP(lp).getReserves();
 148 |     | 
 149 | *   |         uint256 baseBalance = IMagicLP(lp)._BASE_TOKEN_().balanceOf(address(lp)) + baseInAmount;
 150 | *   |         uint256 quoteBalance = IMagicLP(lp)._QUOTE_TOKEN_().balanceOf(address(lp)) + quoteInAmount;
 151 |     | 
 152 | *   |         baseInAmount = baseBalance - baseReserve;
 153 | *   |         quoteInAmount = quoteBalance - quoteReserve;
 154 |     | 
 155 | *   |         if (baseInAmount == 0) {
 156 | *   |             return (0, 0, 0);
 157 |     |         }
 158 |     | 
 159 | *   |         uint256 totalSupply = IERC20(lp).totalSupply();
 160 |     | 
 161 | *   |         if (totalSupply == 0) {
 162 | *   |             if (quoteBalance == 0) {
 163 | *   |                 return (0, 0, 0);
 164 |     |             }
 165 |     | 
 166 | *   |             uint256 i = IMagicLP(lp)._I_();
 167 |     | 
 168 | *   |             shares = quoteBalance < DecimalMath.mulFloor(baseBalance, i) ? DecimalMath.divFloor(quoteBalance, i) : baseBalance;
 169 | *   |             baseAdjustedInAmount = shares;
 170 | *   |             quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);
 171 |     | 
 172 | *   |             if (shares <= 2001) {
 173 | *   |                 return (0, 0, 0);
 174 |     |             }
 175 |     | 
 176 | *   |             shares -= 1001;
 177 | *   |         } else if (baseReserve > 0 && quoteReserve > 0) {
 178 | *   |             uint256 baseInputRatio = DecimalMath.divFloor(baseInAmount, baseReserve);
 179 | *   |             uint256 quoteInputRatio = DecimalMath.divFloor(quoteInAmount, quoteReserve);
 180 | *   |             if (baseInputRatio <= quoteInputRatio) {
 181 | *   |                 baseAdjustedInAmount = baseInAmount;
 182 | *   |                 quoteAdjustedInAmount = DecimalMath.mulCeil(quoteReserve, baseInputRatio);
 183 | *   |                 shares = DecimalMath.mulFloor(totalSupply, baseInputRatio);
 184 |     |             } else {
 185 | *   |                 quoteAdjustedInAmount = quoteInAmount;
 186 | *   |                 baseAdjustedInAmount = DecimalMath.mulCeil(baseReserve, quoteInputRatio);
 187 | *   |                 shares = DecimalMath.mulFloor(totalSupply, quoteInputRatio);
 188 |     |             }
 189 |     |         }
 190 |     |     }
 191 |     | 
 192 | *   |     function addLiquidity(
 193 |     |         address lp,
 194 |     |         address to,
 195 |     |         uint256 baseInAmount,
 196 |     |         uint256 quoteInAmount,
 197 |     |         uint256 minimumShares,
 198 |     |         uint256 deadline
 199 |     |     )
 200 |     |         public
 201 |     |         virtual
 202 | *   |         ensureDeadline(deadline)
 203 | *   |         onlyKnownPool(lp)
 204 | *   |         returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares)
 205 |     |     {
 206 | *   |         (baseAdjustedInAmount, quoteAdjustedInAmount) = _adjustAddLiquidity(lp, baseInAmount, quoteInAmount);
 207 |     | 
 208 | *   |         IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, baseAdjustedInAmount);
 209 | *   |         IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, quoteAdjustedInAmount);
 210 |     | 
 211 | *   |         shares = _addLiquidity(lp, to, minimumShares);
 212 |     |     }
 213 |     | 
 214 | *   |     function addLiquidityUnsafe(
 215 |     |         address lp,
 216 |     |         address to,
 217 |     |         uint256 baseInAmount,
 218 |     |         uint256 quoteInAmount,
 219 |     |         uint256 minimumShares,
 220 |     |         uint256 deadline
 221 | *   |     ) public virtual ensureDeadline(deadline) onlyKnownPool(lp) returns (uint256 shares) {
 222 | *   |         IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, baseInAmount);
 223 | *   |         IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, quoteInAmount);
 224 |     | 
 225 | *   |         return _addLiquidity(lp, to, minimumShares);
 226 |     |     }
 227 |     | 
 228 |     |     function addLiquidityETH(
 229 |     |         address lp,
 230 |     |         address to,
 231 |     |         address payable refundTo,
 232 |     |         uint256 tokenInAmount,
 233 |     |         uint256 minimumShares,
 234 |     |         uint256 deadline
 235 |     |     )
 236 |     |         public
 237 |     |         payable
 238 |     |         virtual
 239 |     |         nonReentrant
 240 |     |         ensureDeadline(deadline)
 241 |     |         onlyKnownPool(lp)
 242 |     |         returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares)
 243 |     |     {
 244 |     |         uint256 wethAdjustedAmount;
 245 |     |         uint256 tokenAdjustedAmount;
 246 |     |         address token = IMagicLP(lp)._BASE_TOKEN_();
 247 |     |         if (token == address(weth)) {
 248 |     |             token = IMagicLP(lp)._QUOTE_TOKEN_();
 249 |     |             (baseAdjustedInAmount, quoteAdjustedInAmount) = _adjustAddLiquidity(lp, msg.value, tokenInAmount);
 250 |     |             wethAdjustedAmount = baseAdjustedInAmount;
 251 |     |             tokenAdjustedAmount = quoteAdjustedInAmount;
 252 |     |         } else if (IMagicLP(lp)._QUOTE_TOKEN_() == address(weth)) {
 253 |     |             (baseAdjustedInAmount, quoteAdjustedInAmount) = _adjustAddLiquidity(lp, tokenInAmount, msg.value);
 254 |     |             wethAdjustedAmount = quoteAdjustedInAmount;
 255 |     |             tokenAdjustedAmount = baseAdjustedInAmount;
 256 |     |         } else {
 257 |     |             revert ErrNotETHLP();
 258 |     |         }
 259 |     | 
 260 |     |         weth.deposit{value: wethAdjustedAmount}();
 261 |     |         address(weth).safeTransfer(lp, wethAdjustedAmount);
 262 |     | 
 263 |     |         // Refund unused ETH
 264 |     |         if (msg.value > wethAdjustedAmount) {
 265 |     |             refundTo.safeTransferETH(msg.value - wethAdjustedAmount);
 266 |     |         }
 267 |     | 
 268 |     |         token.safeTransferFrom(msg.sender, lp, tokenAdjustedAmount);
 269 |     | 
 270 |     |         shares = _addLiquidity(lp, to, minimumShares);
 271 |     |     }
 272 |     | 
 273 | *   |     function addLiquidityETHUnsafe(
 274 |     |         address lp,
 275 |     |         address to,
 276 |     |         uint256 tokenInAmount,
 277 |     |         uint256 minimumShares,
 278 |     |         uint256 deadline
 279 |     |     ) public payable virtual ensureDeadline(deadline) onlyKnownPool(lp) returns (uint256 shares) {
 280 |     |         address token = IMagicLP(lp)._BASE_TOKEN_();
 281 |     |         if (token == address(weth)) {
 282 |     |             token = IMagicLP(lp)._QUOTE_TOKEN_();
 283 |     |         } else if (IMagicLP(lp)._QUOTE_TOKEN_() != address(weth)) {
 284 |     |             revert ErrNotETHLP();
 285 |     |         }
 286 |     | 
 287 |     |         weth.deposit{value: msg.value}();
 288 |     |         address(weth).safeTransfer(lp, msg.value);
 289 |     | 
 290 |     |         token.safeTransferFrom(msg.sender, lp, tokenInAmount);
 291 |     | 
 292 | *   |         return _addLiquidity(lp, to, minimumShares);
 293 |     |     }
 294 |     | 
 295 | *   |     function previewRemoveLiquidity(
 296 |     |         address lp,
 297 |     |         uint256 sharesIn
 298 | *   |     ) external view nonReadReentrant onlyKnownPool(lp) returns (uint256 baseAmountOut, uint256 quoteAmountOut) {
 299 | *   |         uint256 baseBalance = IMagicLP(lp)._BASE_TOKEN_().balanceOf(address(lp));
 300 | *   |         uint256 quoteBalance = IMagicLP(lp)._QUOTE_TOKEN_().balanceOf(address(lp));
 301 |     | 
 302 | *   |         uint256 totalShares = IERC20(lp).totalSupply();
 303 |     | 
 304 | *   |         baseAmountOut = (baseBalance * sharesIn) / totalShares;
 305 | *   |         quoteAmountOut = (quoteBalance * sharesIn) / totalShares;
 306 |     |     }
 307 |     | 
 308 | *   |     function removeLiquidity(
 309 |     |         address lp,
 310 |     |         address to,
 311 |     |         uint256 sharesIn,
 312 |     |         uint256 minimumBaseAmount,
 313 |     |         uint256 minimumQuoteAmount,
 314 |     |         uint256 deadline
 315 |     |     ) public virtual onlyKnownPool(lp) returns (uint256 baseAmountOut, uint256 quoteAmountOut) {
 316 | *   |         lp.safeTransferFrom(msg.sender, address(this), sharesIn);
 317 |     | 
 318 | *   |         return IMagicLP(lp).sellShares(sharesIn, to, minimumBaseAmount, minimumQuoteAmount, "", deadline);
 319 |     |     }
 320 |     | 
 321 |     |     function removeLiquidityETH(
 322 |     |         address lp,
 323 |     |         address to,
 324 |     |         uint256 sharesIn,
 325 |     |         uint256 minimumETHAmount,
 326 |     |         uint256 minimumTokenAmount,
 327 |     |         uint256 deadline
 328 |     |     ) public virtual onlyKnownPool(lp) returns (uint256 ethAmountOut, uint256 tokenAmountOut) {
 329 |     |         lp.safeTransferFrom(msg.sender, address(this), sharesIn);
 330 |     | 
 331 |     |         address token = IMagicLP(lp)._BASE_TOKEN_();
 332 |     |         if (token == address(weth)) {
 333 |     |             token = IMagicLP(lp)._QUOTE_TOKEN_();
 334 |     |             (ethAmountOut, tokenAmountOut) = IMagicLP(lp).sellShares(
 335 |     |                 sharesIn,
 336 |     |                 address(this),
 337 |     |                 minimumETHAmount,
 338 |     |                 minimumTokenAmount,
 339 |     |                 "",
 340 |     |                 deadline
 341 |     |             );
 342 |     |         } else if (IMagicLP(lp)._QUOTE_TOKEN_() == address(weth)) {
 343 |     |             (tokenAmountOut, ethAmountOut) = IMagicLP(lp).sellShares(
 344 |     |                 sharesIn,
 345 |     |                 address(this),
 346 |     |                 minimumTokenAmount,
 347 |     |                 minimumETHAmount,
 348 |     |                 "",
 349 |     |                 deadline
 350 |     |             );
 351 |     |         } else {
 352 |     |             revert ErrNotETHLP();
 353 |     |         }
 354 |     | 
 355 |     |         weth.withdraw(ethAmountOut);
 356 |     |         to.safeTransferETH(ethAmountOut);
 357 |     | 
 358 |     |         token.safeTransfer(to, tokenAmountOut);
 359 |     |     }
 360 |     | 
 361 |     |     function swapTokensForTokens(
 362 |     |         address to,
 363 |     |         uint256 amountIn,
 364 |     |         address[] calldata path,
 365 |     |         uint256 directions,
 366 |     |         uint256 minimumOut,
 367 |     |         uint256 deadline
 368 |     |     ) public virtual ensureDeadline(deadline) returns (uint256 amountOut) {
 369 |     |         _validatePath(path);
 370 |     | 
 371 |     |         address firstLp = path[0];
 372 |     | 
 373 |     |         // Transfer to the first LP
 374 |     |         if (directions & 1 == 0) {
 375 |     |             IMagicLP(firstLp)._BASE_TOKEN_().safeTransferFrom(msg.sender, address(firstLp), amountIn);
 376 |     |         } else {
 377 |     |             IMagicLP(firstLp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, address(firstLp), amountIn);
 378 |     |         }
 379 |     | 
 380 |     |         return _swap(to, path, directions, minimumOut);
 381 |     |     }
 382 |     | 
 383 |     |     function swapETHForTokens(
 384 |     |         address to,
 385 |     |         address[] calldata path,
 386 |     |         uint256 directions,
 387 |     |         uint256 minimumOut,
 388 |     |         uint256 deadline
 389 |     |     ) public payable virtual ensureDeadline(deadline) returns (uint256 amountOut) {
 390 |     |         _validatePath(path);
 391 |     | 
 392 |     |         address firstLp = path[0];
 393 |     |         address inToken;
 394 |     | 
 395 |     |         if (directions & 1 == 0) {
 396 |     |             inToken = IMagicLP(firstLp)._BASE_TOKEN_();
 397 |     |         } else {
 398 |     |             inToken = IMagicLP(firstLp)._QUOTE_TOKEN_();
 399 |     |         }
 400 |     | 
 401 |     |         // Transfer to the first LP
 402 |     |         if (inToken != address(weth)) {
 403 |     |             revert ErrInTokenNotETH();
 404 |     |         }
 405 |     | 
 406 |     |         weth.deposit{value: msg.value}();
 407 |     |         inToken.safeTransfer(address(firstLp), msg.value);
 408 |     | 
 409 |     |         return _swap(to, path, directions, minimumOut);
 410 |     |     }
 411 |     | 
 412 |     |     function swapTokensForETH(
 413 |     |         address to,
 414 |     |         uint256 amountIn,
 415 |     |         address[] calldata path,
 416 |     |         uint256 directions,
 417 |     |         uint256 minimumOut,
 418 |     |         uint256 deadline
 419 |     |     ) public virtual ensureDeadline(deadline) returns (uint256 amountOut) {
 420 |     |         _validatePath(path);
 421 |     | 
 422 |     |         uint256 lastLpIndex = path.length - 1;
 423 |     |         address lastLp = path[lastLpIndex];
 424 |     |         address outToken;
 425 |     | 
 426 |     |         if ((directions >> lastLpIndex) & 1 == 0) {
 427 |     |             outToken = IMagicLP(lastLp)._QUOTE_TOKEN_();
 428 |     |         } else {
 429 |     |             outToken = IMagicLP(lastLp)._BASE_TOKEN_();
 430 |     |         }
 431 |     | 
 432 |     |         if (outToken != address(weth)) {
 433 |     |             revert ErrOutTokenNotETH();
 434 |     |         }
 435 |     | 
 436 |     |         address firstLp = path[0];
 437 |     | 
 438 |     |         // Transfer to the first LP
 439 |     |         if (directions & 1 == 0) {
 440 |     |             IMagicLP(firstLp)._BASE_TOKEN_().safeTransferFrom(msg.sender, firstLp, amountIn);
 441 |     |         } else {
 442 |     |             IMagicLP(firstLp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, firstLp, amountIn);
 443 |     |         }
 444 |     | 
 445 |     |         amountOut = _swap(address(this), path, directions, minimumOut);
 446 |     |         weth.withdraw(amountOut);
 447 |     | 
 448 |     |         to.safeTransferETH(amountOut);
 449 |     |     }
 450 |     | 
 451 | *   |     function sellBaseTokensForTokens(
 452 |     |         address lp,
 453 |     |         address to,
 454 |     |         uint256 amountIn,
 455 |     |         uint256 minimumOut,
 456 |     |         uint256 deadline
 457 | *   |     ) public virtual ensureDeadline(deadline) onlyKnownPool(lp) returns (uint256 amountOut) {
 458 | *   |         IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, amountIn);
 459 | *   |         return _sellBase(lp, to, minimumOut);
 460 |     |     }
 461 |     | 
 462 | *   |     function sellBaseETHForTokens(
 463 |     |         address lp,
 464 |     |         address to,
 465 |     |         uint256 minimumOut,
 466 |     |         uint256 deadline
 467 |     |     ) public payable virtual ensureDeadline(deadline) onlyKnownPool(lp) returns (uint256 amountOut) {
 468 |     |         address baseToken = IMagicLP(lp)._BASE_TOKEN_();
 469 |     | 
 470 |     |         if (baseToken != address(weth)) {
 471 |     |             revert ErrInvalidBaseToken();
 472 |     |         }
 473 |     | 
 474 |     |         weth.deposit{value: msg.value}();
 475 |     |         baseToken.safeTransfer(lp, msg.value);
 476 | *   |         return _sellBase(lp, to, minimumOut);
 477 |     |     }
 478 |     | 
 479 |     |     function sellBaseTokensForETH(
 480 |     |         address lp,
 481 |     |         address to,
 482 |     |         uint256 amountIn,
 483 |     |         uint256 minimumOut,
 484 |     |         uint256 deadline
 485 |     |     ) public virtual ensureDeadline(deadline) onlyKnownPool(lp) returns (uint256 amountOut) {
 486 |     |         if (IMagicLP(lp)._QUOTE_TOKEN_() != address(weth)) {
 487 |     |             revert ErrInvalidQuoteToken();
 488 |     |         }
 489 |     | 
 490 |     |         IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, amountIn);
 491 |     |         amountOut = _sellBase(lp, address(this), minimumOut);
 492 |     |         weth.withdraw(amountOut);
 493 |     |         to.safeTransferETH(amountOut);
 494 |     |     }
 495 |     | 
 496 | *   |     function sellQuoteTokensForTokens(
 497 |     |         address lp,
 498 |     |         address to,
 499 |     |         uint256 amountIn,
 500 |     |         uint256 minimumOut,
 501 |     |         uint256 deadline
 502 | *   |     ) public virtual ensureDeadline(deadline) onlyKnownPool(lp) returns (uint256 amountOut) {
 503 | *   |         IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, amountIn);
 504 |     | 
 505 | *   |         return _sellQuote(lp, to, minimumOut);
 506 |     |     }
 507 |     | 
 508 |     |     function sellQuoteETHForTokens(
 509 |     |         address lp,
 510 |     |         address to,
 511 |     |         uint256 minimumOut,
 512 |     |         uint256 deadline
 513 |     |     ) public payable virtual ensureDeadline(deadline) onlyKnownPool(lp) returns (uint256 amountOut) {
 514 |     |         address quoteToken = IMagicLP(lp)._QUOTE_TOKEN_();
 515 |     | 
 516 |     |         if (quoteToken != address(weth)) {
 517 |     |             revert ErrInvalidQuoteToken();
 518 |     |         }
 519 |     | 
 520 |     |         weth.deposit{value: msg.value}();
 521 |     |         quoteToken.safeTransfer(lp, msg.value);
 522 |     |         return _sellQuote(lp, to, minimumOut);
 523 |     |     }
 524 |     | 
 525 | *   |     function sellQuoteTokensForETH(
 526 |     |         address lp,
 527 |     |         address to,
 528 |     |         uint256 amountIn,
 529 |     |         uint256 minimumOut,
 530 |     |         uint256 deadline
 531 |     |     ) public virtual ensureDeadline(deadline) onlyKnownPool(lp) returns (uint256 amountOut) {
 532 |     |         if (IMagicLP(lp)._BASE_TOKEN_() != address(weth)) {
 533 |     |             revert ErrInvalidBaseToken();
 534 |     |         }
 535 |     | 
 536 | *   |         IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, amountIn);
 537 |     |         amountOut = _sellQuote(lp, address(this), minimumOut);
 538 |     |         weth.withdraw(amountOut);
 539 |     |         to.safeTransferETH(amountOut);
 540 |     |     }
 541 |     | 
 542 |     |     //////////////////////////////////////////////////////////////////////////////////////
 543 |     |     /// INTERNALS
 544 |     |     //////////////////////////////////////////////////////////////////////////////////////
 545 |     | 
 546 | *   |     function _addLiquidity(address lp, address to, uint256 minimumShares) internal returns (uint256 shares) {
 547 | *   |         (shares, , ) = IMagicLP(lp).buyShares(to);
 548 |     | 
 549 | *   |         if (shares < minimumShares) {
 550 | *   |             revert ErrTooHighSlippage(shares);
 551 |     |         }
 552 |     |     }
 553 |     | 
 554 |     |     /// Adapted from: https://github.com/DODOEX/contractV2/blob/main/contracts/SmartRoute/proxies/DODODspProxy.sol
 555 |     |     /// Copyright 2020 DODO ZOO. Licensed under Apache-2.0.
 556 | *   |     function _adjustAddLiquidity(
 557 |     |         address lp,
 558 |     |         uint256 baseInAmount,
 559 |     |         uint256 quoteInAmount
 560 | *   |     ) internal view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount) {
 561 | *   |         (uint256 baseReserve, uint256 quoteReserve) = IMagicLP(lp).getReserves();
 562 | *   |         uint256 baseBalance = IMagicLP(lp)._BASE_TOKEN_().balanceOf(address(lp)) + baseInAmount;
 563 | *   |         uint256 quoteBalance = IMagicLP(lp)._QUOTE_TOKEN_().balanceOf(address(lp)) + quoteInAmount;
 564 |     | 
 565 | *   |         baseInAmount = baseBalance - baseReserve;
 566 | *   |         quoteInAmount = quoteBalance - quoteReserve;
 567 |     | 
 568 | *   |         if (IERC20(lp).totalSupply() == 0) {
 569 | *   |             uint256 i = IMagicLP(lp)._I_();
 570 | *   |             uint256 shares = quoteInAmount < DecimalMath.mulFloor(baseInAmount, i) ? DecimalMath.divFloor(quoteInAmount, i) : baseInAmount;
 571 | *   |             baseAdjustedInAmount = shares;
 572 | *   |             quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);
 573 |     |         } else {
 574 | *   |             if (quoteReserve > 0 && baseReserve > 0) {
 575 | *   |                 uint256 baseIncreaseRatio = DecimalMath.divFloor(baseInAmount, baseReserve);
 576 | *   |                 uint256 quoteIncreaseRatio = DecimalMath.divFloor(quoteInAmount, quoteReserve);
 577 | *   |                 if (baseIncreaseRatio <= quoteIncreaseRatio) {
 578 | *   |                     baseAdjustedInAmount = baseInAmount;
 579 | *   |                     quoteAdjustedInAmount = DecimalMath.mulFloor(quoteReserve, baseIncreaseRatio);
 580 |     |                 } else {
 581 | *   |                     quoteAdjustedInAmount = quoteInAmount;
 582 | *   |                     baseAdjustedInAmount = DecimalMath.mulFloor(baseReserve, quoteIncreaseRatio);
 583 |     |                 }
 584 |     |             }
 585 |     |         }
 586 |     |     }
 587 |     | 
 588 |     |     function _swap(address to, address[] calldata path, uint256 directions, uint256 minimumOut) internal returns (uint256 amountOut) {
 589 |     |         uint256 iterations = path.length - 1; // Subtract by one as last swap is done separately
 590 |     | 
 591 |     |         for (uint256 i = 0; i < iterations; ) {
 592 |     |             address lp = path[i];
 593 |     |             if (!factory.poolExists(lp)) {
 594 |     |                 revert ErrUnknownPool();
 595 |     |             }
 596 |     | 
 597 |     |             if (directions & 1 == 0) {
 598 |     |                 // Sell base
 599 |     |                 IMagicLP(lp).sellBase(address(path[i + 1]));
 600 |     |             } else {
 601 |     |                 // Sell quote
 602 |     |                 IMagicLP(lp).sellQuote(address(path[i + 1]));
 603 |     |             }
 604 |     | 
 605 |     |             directions >>= 1;
 606 |     | 
 607 |     |             unchecked {
 608 |     |                 ++i;
 609 |     |             }
 610 |     |         }
 611 |     | 
 612 |     |         if ((directions & 1 == 0)) {
 613 |     |             amountOut = IMagicLP(path[iterations]).sellBase(to);
 614 |     |         } else {
 615 |     |             amountOut = IMagicLP(path[iterations]).sellQuote(to);
 616 |     |         }
 617 |     | 
 618 |     |         if (amountOut < minimumOut) {
 619 |     |             revert ErrTooHighSlippage(amountOut);
 620 |     |         }
 621 |     |     }
 622 |     | 
 623 | *   |     function _sellBase(address lp, address to, uint256 minimumOut) internal returns (uint256 amountOut) {
 624 | *   |         amountOut = IMagicLP(lp).sellBase(to);
 625 |     |         if (amountOut < minimumOut) {
 626 |     |             revert ErrTooHighSlippage(amountOut);
 627 |     |         }
 628 |     |     }
 629 |     | 
 630 | *   |     function _sellQuote(address lp, address to, uint256 minimumOut) internal returns (uint256 amountOut) {
 631 | *   |         amountOut = IMagicLP(lp).sellQuote(to);
 632 |     | 
 633 | *   |         if (amountOut < minimumOut) {
 634 | *   |             revert ErrTooHighSlippage(amountOut);
 635 |     |         }
 636 |     |     }
 637 |     | 
 638 |     |     function _validatePath(address[] calldata path) internal pure {
 639 |     |         uint256 pathLength = path.length;
 640 |     | 
 641 |     |         // Max 256 because of bits in directions
 642 |     |         if (pathLength > 256) {
 643 |     |             revert ErrPathTooLong();
 644 |     |         }
 645 |     |         if (pathLength <= 0) {
 646 |     |             revert ErrEmptyPath();
 647 |     |         }
 648 |     |     }
 649 |     | 
 650 | *   |     function _validateDecimals(uint8 baseDecimals, uint8 quoteDecimals) internal pure {
 651 | *   |         if (baseDecimals == 0 || quoteDecimals == 0) {
 652 |     |             revert ErrZeroDecimals();
 653 |     |         }
 654 |     | 
 655 | *   |         uint256 deltaDecimals = baseDecimals > quoteDecimals ? baseDecimals - quoteDecimals : quoteDecimals - baseDecimals;
 656 |     | 
 657 | *   |         if (deltaDecimals > MAX_BASE_QUOTE_DECIMALS_DIFFERENCE) {
 658 | *   |             revert ErrDecimalsDifferenceTooLarge();
 659 |     |         }
 660 |     |     }
 661 |     | }
 662 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/Create3Factory.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {CREATE3} from "solmate/utils/CREATE3.sol";
  5 |     | 
  6 |     | contract Create3Factory {
  7 |     |     event LogDeployed(address deployed, address sender, bytes32 salt);
  8 |     | 
  9 |     |     function deploy(bytes32 salt, bytes memory bytecode, uint256 value) public returns (address deployed) {
 10 |     |         deployed = CREATE3.deploy(_getSalt(msg.sender, salt), bytecode, value);
 11 |     |         emit LogDeployed(deployed, msg.sender, salt);
 12 |     |     }
 13 |     | 
 14 |     |     function getDeployed(address account, bytes32 salt) public view returns (address) {
 15 |     |         return CREATE3.getDeployed(_getSalt(account, salt));
 16 |     |     }
 17 |     | 
 18 |     |     function _getSalt(address account, bytes32 salt) internal pure returns (bytes32) {
 19 |     |         return keccak256(abi.encode(account, salt));
 20 |     |     }
 21 |     | }
 22 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/FeeCollectable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | 
  6 |     | abstract contract FeeCollectable {
  7 |     |     error ErrInvalidFeeBips();
  8 |     |     error ErrInvalidFeeOperator(address);
  9 |     |     event LogFeeParametersChanged(
 10 |     |         address indexed previousFeeCollector,
 11 |     |         uint16 previousFeeAmount,
 12 |     |         address indexed feeCollector,
 13 |     |         uint16 feeAmount
 14 |     |     );
 15 |     | 
 16 |     |     uint256 internal constant BIPS = 10_000;
 17 |     | 
 18 |     |     uint16 public feeBips;
 19 |     |     address public feeCollector;
 20 |     | 
 21 |     |     modifier onlyAllowedFeeOperator() {
 22 |     |         if (!isFeeOperator(msg.sender)) {
 23 |     |             revert ErrInvalidFeeOperator(msg.sender);
 24 |     |         }
 25 |     |         _;
 26 |     |     }
 27 |     | 
 28 |     |     function setFeeParameters(address _feeCollector, uint16 _feeBips) external onlyAllowedFeeOperator {
 29 |     |         if (feeBips > BIPS) {
 30 |     |             revert ErrInvalidFeeBips();
 31 |     |         }
 32 |     | 
 33 |     |         emit LogFeeParametersChanged(feeCollector, feeBips, _feeCollector, _feeBips);
 34 |     | 
 35 |     |         feeCollector = _feeCollector;
 36 |     |         feeBips = _feeBips;
 37 |     |     }
 38 |     | 
 39 |     |     function calculateFees(uint256 amountIn) internal view returns (uint userAmount, uint feeAmount) {
 40 |     |         feeAmount = (amountIn * feeBips) / BIPS;
 41 |     |         userAmount = amountIn - feeAmount;
 42 |     |     }
 43 |     | 
 44 |     |     function isFeeOperator(address account) public virtual returns (bool);
 45 |     | }
 46 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/LzApp.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {Owned} from "solmate/auth/Owned.sol";
   5 |     | import {ILzReceiver, ILzUserApplicationConfig, ILzEndpoint} from "interfaces/ILayerZero.sol";
   6 |     | import {BytesLib} from "libraries/BytesLib.sol";
   7 |     | 
   8 |     | /*
   9 |     |  * a generic LzReceiver implementation
  10 |     |  */
  11 |     | abstract contract LzApp is Owned, ILzReceiver, ILzUserApplicationConfig {
  12 |     |     using BytesLib for bytes;
  13 |     | 
  14 |     |     // ua can not send payload larger than this by default, but it can be changed by the ua owner
  15 |     |     uint public constant DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;
  16 |     | 
  17 |     |     ILzEndpoint public immutable lzEndpoint;
  18 |     |     mapping(uint16 => bytes) public trustedRemoteLookup;
  19 |     |     mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;
  20 |     |     mapping(uint16 => uint) public payloadSizeLimitLookup;
  21 |     |     address public precrime;
  22 |     | 
  23 |     |     event SetPrecrime(address precrime);
  24 |     |     event SetTrustedRemote(uint16 _remoteChainId, bytes _path);
  25 |     |     event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);
  26 |     |     event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);
  27 |     | 
  28 |     |     constructor(address _endpoint, address _owner) Owned(_owner) {
  29 |     |         lzEndpoint = ILzEndpoint(_endpoint);
  30 |     |     }
  31 |     | 
  32 |     |     function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {
  33 |     |         // lzReceive must be called by the endpoint for security
  34 |     |         require(msg.sender == address(lzEndpoint), "LzApp: invalid endpoint caller");
  35 |     | 
  36 |     |         bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];
  37 |     |         // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.
  38 |     |         require(
  39 |     |             _srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote),
  40 |     |             "LzApp: invalid source sending contract"
  41 |     |         );
  42 |     | 
  43 |     |         _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);
  44 |     |     }
  45 |     | 
  46 |     |     // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging
  47 |     |     function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;
  48 |     | 
  49 |     |     function _lzSend(
  50 |     |         uint16 _dstChainId,
  51 |     |         bytes memory _payload,
  52 |     |         address payable _refundAddress,
  53 |     |         address _zroPaymentAddress,
  54 |     |         bytes memory _adapterParams,
  55 |     |         uint _nativeFee
  56 |     |     ) internal virtual {
  57 |     |         bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];
  58 |     |         require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");
  59 |     |         _checkPayloadSize(_dstChainId, _payload.length);
  60 |     |         lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);
  61 |     |     }
  62 |     | 
  63 |     |     function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {
  64 |     |         uint providedGasLimit = _getGasLimit(_adapterParams);
  65 |     |         uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;
  66 |     |         require(minGasLimit > 0, "LzApp: minGasLimit not set");
  67 |     |         require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");
  68 |     |     }
  69 |     | 
  70 |     |     function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {
  71 |     |         require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");
  72 |     |         assembly {
  73 |     |             gasLimit := mload(add(_adapterParams, 34))
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {
  78 |     |         uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];
  79 |     |         if (payloadSizeLimit == 0) {
  80 |     |             // use default if not set
  81 |     |             payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;
  82 |     |         }
  83 |     |         require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");
  84 |     |     }
  85 |     | 
  86 |     |     //---------------------------UserApplication config----------------------------------------
  87 |     |     function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {
  88 |     |         return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);
  89 |     |     }
  90 |     | 
  91 |     |     // generic config for LayerZero user Application
  92 |     |     function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {
  93 |     |         lzEndpoint.setConfig(_version, _chainId, _configType, _config);
  94 |     |     }
  95 |     | 
  96 |     |     function setSendVersion(uint16 _version) external override onlyOwner {
  97 |     |         lzEndpoint.setSendVersion(_version);
  98 |     |     }
  99 |     | 
 100 |     |     function setReceiveVersion(uint16 _version) external override onlyOwner {
 101 |     |         lzEndpoint.setReceiveVersion(_version);
 102 |     |     }
 103 |     | 
 104 |     |     function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {
 105 |     |         lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);
 106 |     |     }
 107 |     | 
 108 |     |     // _path = abi.encodePacked(remoteAddress, localAddress)
 109 |     |     // this function set the trusted path for the cross-chain communication
 110 |     |     function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {
 111 |     |         trustedRemoteLookup[_remoteChainId] = _path;
 112 |     |         emit SetTrustedRemote(_remoteChainId, _path);
 113 |     |     }
 114 |     | 
 115 |     |     function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {
 116 |     |         trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));
 117 |     |         emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);
 118 |     |     }
 119 |     | 
 120 |     |     function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {
 121 |     |         bytes memory path = trustedRemoteLookup[_remoteChainId];
 122 |     |         require(path.length != 0, "LzApp: no trusted path record");
 123 |     |         return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)
 124 |     |     }
 125 |     | 
 126 |     |     function setPrecrime(address _precrime) external onlyOwner {
 127 |     |         precrime = _precrime;
 128 |     |         emit SetPrecrime(_precrime);
 129 |     |     }
 130 |     | 
 131 |     |     function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {
 132 |     |         require(_minGas > 0, "LzApp: invalid minGas");
 133 |     |         minDstGasLookup[_dstChainId][_packetType] = _minGas;
 134 |     |         emit SetMinDstGas(_dstChainId, _packetType, _minGas);
 135 |     |     }
 136 |     | 
 137 |     |     // if the size is 0, it means default size limit
 138 |     |     function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {
 139 |     |         payloadSizeLimitLookup[_dstChainId] = _size;
 140 |     |     }
 141 |     | 
 142 |     |     //--------------------------- VIEW FUNCTION ----------------------------------------
 143 |     |     function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {
 144 |     |         bytes memory trustedSource = trustedRemoteLookup[_srcChainId];
 145 |     |         return keccak256(trustedSource) == keccak256(_srcAddress);
 146 |     |     }
 147 |     | }
 148 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/LzNonblockingApp.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {LzApp} from "mixins/LzApp.sol";
  5 |     | import {ExcessivelySafeCall} from "ExcessivelySafeCall/ExcessivelySafeCall.sol";
  6 |     | 
  7 |     | /*
  8 |     |  * the default LayerZero messaging behaviour is blocking, i.e. any failed message will block the channel
  9 |     |  * this abstract class try-catch all fail messages and store locally for future retry. hence, non-blocking
 10 |     |  * NOTE: if the srcAddress is not configured properly, it will still block the message pathway from (srcChainId, srcAddress)
 11 |     |  */
 12 |     | abstract contract LzNonblockingApp is LzApp {
 13 |     |     using ExcessivelySafeCall for address;
 14 |     | 
 15 |     |     constructor(address _endpoint, address _owner) LzApp(_endpoint, _owner) {}
 16 |     | 
 17 |     |     mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;
 18 |     | 
 19 |     |     event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);
 20 |     |     event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);
 21 |     | 
 22 |     |     // overriding the virtual function in LzReceiver
 23 |     |     function _blockingLzReceive(
 24 |     |         uint16 _srcChainId,
 25 |     |         bytes memory _srcAddress,
 26 |     |         uint64 _nonce,
 27 |     |         bytes memory _payload
 28 |     |     ) internal virtual override {
 29 |     |         (bool success, bytes memory reason) = address(this).excessivelySafeCall(
 30 |     |             gasleft(),
 31 |     |             150,
 32 |     |             abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload)
 33 |     |         );
 34 |     |         // try-catch all errors/exceptions
 35 |     |         if (!success) {
 36 |     |             _storeFailedMessage(_srcChainId, _srcAddress, _nonce, _payload, reason);
 37 |     |         }
 38 |     |     }
 39 |     | 
 40 |     |     function _storeFailedMessage(
 41 |     |         uint16 _srcChainId,
 42 |     |         bytes memory _srcAddress,
 43 |     |         uint64 _nonce,
 44 |     |         bytes memory _payload,
 45 |     |         bytes memory _reason
 46 |     |     ) internal virtual {
 47 |     |         failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);
 48 |     |         emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);
 49 |     |     }
 50 |     | 
 51 |     |     function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual {
 52 |     |         // only internal transaction
 53 |     |         require(msg.sender == address(this), "NonblockingLzApp: caller must be LzApp");
 54 |     |         _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload, false);
 55 |     |     }
 56 |     | 
 57 |     |     //@notice override this function
 58 |     |     function _nonblockingLzReceive(
 59 |     |         uint16 _srcChainId,
 60 |     |         bytes memory _srcAddress,
 61 |     |         uint64 _nonce,
 62 |     |         bytes memory _payload,
 63 |     |         bool retry
 64 |     |     ) internal virtual;
 65 |     | 
 66 |     |     function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public payable virtual {
 67 |     |         // assert there is message to retry
 68 |     |         bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];
 69 |     |         require(payloadHash != bytes32(0), "NonblockingLzApp: no stored message");
 70 |     |         require(keccak256(_payload) == payloadHash, "NonblockingLzApp: invalid payload");
 71 |     |         // clear the stored message
 72 |     |         failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);
 73 |     |         // execute the message. revert if it fails again
 74 |     |         _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload, true);
 75 |     |         emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);
 76 |     |     }
 77 |     | }
 78 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/MasterContractManager.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | // Copyright (c) 2021 BoringCrypto - All rights reserved
   3 |     | // Twitter: @Boring_Crypto
   4 |     | // Special thanks to Keno for all his hard work and support
   5 |     | pragma solidity >=0.8.0;
   6 |     | 
   7 |     | // solhint-disable avoid-low-level-calls
   8 |     | // solhint-disable not-rely-on-time
   9 |     | // solhint-disable no-inline-assembly
  10 |     | import {BoringOwnable} from "BoringSolidity/BoringOwnable.sol";
  11 |     | import {BoringFactory} from "BoringSolidity/BoringFactory.sol";
  12 |     | 
  13 |     | contract MasterContractManager is BoringOwnable, BoringFactory {
  14 |     |     event LogWhiteListMasterContract(address indexed masterContract, bool approved);
  15 |     |     event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);
  16 |     |     event LogRegisterProtocol(address indexed protocol);
  17 |     | 
  18 |     |     /// @notice masterContract to user to approval state
  19 |     |     mapping(address => mapping(address => bool)) public masterContractApproved;
  20 |     |     /// @notice masterContract to whitelisted state for approval without signed message
  21 |     |     mapping(address => bool) public whitelistedMasterContracts;
  22 |     |     /// @notice user nonces for masterContract approvals
  23 |     |     mapping(address => uint256) public nonces;
  24 |     | 
  25 |     |     bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH =
  26 |     |         keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");
  27 |     |     // See https://eips.ethereum.org/EIPS/eip-191
  28 |     |     string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = "\x19\x01";
  29 |     |     bytes32 private constant APPROVAL_SIGNATURE_HASH =
  30 |     |         keccak256("SetMasterContractApproval(string warning,address user,address masterContract,bool approved,uint256 nonce)");
  31 |     | 
  32 |     |     // solhint-disable-next-line var-name-mixedcase
  33 |     |     bytes32 private immutable _DOMAIN_SEPARATOR;
  34 |     |     // solhint-disable-next-line var-name-mixedcase
  35 |     |     uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;
  36 |     | 
  37 |     |     constructor() {
  38 |     |         uint256 chainId;
  39 |     |         assembly {
  40 |     |             chainId := chainid()
  41 |     |         }
  42 |     |         _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);
  43 |     |     }
  44 |     | 
  45 |     |     function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {
  46 |     |         return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, keccak256("BentoBox V1"), chainId, address(this)));
  47 |     |     }
  48 |     | 
  49 |     |     // solhint-disable-next-line func-name-mixedcase
  50 |     |     function DOMAIN_SEPARATOR() public view returns (bytes32) {
  51 |     |         uint256 chainId;
  52 |     |         assembly {
  53 |     |             chainId := chainid()
  54 |     |         }
  55 |     |         return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);
  56 |     |     }
  57 |     | 
  58 |     |     /// @notice Other contracts need to register with this master contract so that users can approve them for the BentoBox.
  59 |     |     function registerProtocol() public {
  60 |     |         masterContractOf[msg.sender] = msg.sender;
  61 |     |         emit LogRegisterProtocol(msg.sender);
  62 |     |     }
  63 |     | 
  64 |     |     /// @notice Enables or disables a contract for approval without signed message.
  65 |     |     function whitelistMasterContract(address masterContract, bool approved) public onlyOwner {
  66 |     |         // Checks
  67 |     |         require(masterContract != address(0), "MasterCMgr: Cannot approve 0");
  68 |     | 
  69 |     |         // Effects
  70 |     |         whitelistedMasterContracts[masterContract] = approved;
  71 |     |         emit LogWhiteListMasterContract(masterContract, approved);
  72 |     |     }
  73 |     | 
  74 |     |     /// @notice Approves or revokes a `masterContract` access to `user` funds.
  75 |     |     /// @param user The address of the user that approves or revokes access.
  76 |     |     /// @param masterContract The address who gains or loses access.
  77 |     |     /// @param approved If True approves access. If False revokes access.
  78 |     |     /// @param v Part of the signature. (See EIP-191)
  79 |     |     /// @param r Part of the signature. (See EIP-191)
  80 |     |     /// @param s Part of the signature. (See EIP-191)
  81 |     |     // F4 - Check behaviour for all function arguments when wrong or extreme
  82 |     |     // F4: Don't allow masterContract 0 to be approved. Unknown contracts will have a masterContract of 0.
  83 |     |     // F4: User can't be 0 for signed approvals because the recoveredAddress will be 0 if ecrecover fails
  84 |     |     function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) public {
  85 |     |         // Checks
  86 |     |         require(masterContract != address(0), "MasterCMgr: masterC not set"); // Important for security
  87 |     | 
  88 |     |         // If no signature is provided, the fallback is executed
  89 |     |         if (r == 0 && s == 0 && v == 0) {
  90 |     |             require(user == msg.sender, "MasterCMgr: user not sender");
  91 |     |             require(masterContractOf[user] == address(0), "MasterCMgr: user is clone");
  92 |     |             require(whitelistedMasterContracts[masterContract], "MasterCMgr: not whitelisted");
  93 |     |         } else {
  94 |     |             // Important for security - any address without masterContract has address(0) as masterContract
  95 |     |             // So approving address(0) would approve every address, leading to full loss of funds
  96 |     |             // Also, ecrecover returns address(0) on failure. So we check this:
  97 |     |             require(user != address(0), "MasterCMgr: User cannot be 0");
  98 |     | 
  99 |     |             // C10 - Protect signatures against replay, use nonce and chainId (SWC-121)
 100 |     |             // C10: nonce + chainId are used to prevent replays
 101 |     |             // C11 - All signatures strictly EIP-712 (SWC-117 SWC-122)
 102 |     |             // C11: signature is EIP-712 compliant
 103 |     |             // C12 - abi.encodePacked can't contain variable length user input (SWC-133)
 104 |     |             // C12: abi.encodePacked has fixed length parameters
 105 |     |             bytes32 digest = keccak256(
 106 |     |                 abi.encodePacked(
 107 |     |                     EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,
 108 |     |                     DOMAIN_SEPARATOR(),
 109 |     |                     keccak256(
 110 |     |                         abi.encode(
 111 |     |                             APPROVAL_SIGNATURE_HASH,
 112 |     |                             approved
 113 |     |                                 ? keccak256("Give FULL access to funds in (and approved to) BentoBox?")
 114 |     |                                 : keccak256("Revoke access to BentoBox?"),
 115 |     |                             user,
 116 |     |                             masterContract,
 117 |     |                             approved,
 118 |     |                             nonces[user]++
 119 |     |                         )
 120 |     |                     )
 121 |     |                 )
 122 |     |             );
 123 |     |             address recoveredAddress = ecrecover(digest, v, r, s);
 124 |     |             require(recoveredAddress == user, "MasterCMgr: Invalid Signature");
 125 |     |         }
 126 |     | 
 127 |     |         // Effects
 128 |     |         masterContractApproved[masterContract][user] = approved;
 129 |     |         emit LogSetMasterContractApproval(masterContract, user, approved);
 130 |     |     }
 131 |     | }
 132 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/OFTWrapper.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {ReentrancyGuard} from "openzeppelin-contracts/security/ReentrancyGuard.sol";
   5 |     | import {OperatableV2} from "mixins/OperatableV2.sol";
   6 |     | import {IERC20, SafeERC20} from "openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol";
   7 |     | import {ILzOFTV2, IOFTWrapper, ILzApp, ILzCommonOFT, ILzEndpoint} from "interfaces/ILayerZero.sol";
   8 |     | import {IAggregator} from "interfaces/IAggregator.sol";
   9 |     | 
  10 |     | contract OFTWrapper is IOFTWrapper, OperatableV2, ReentrancyGuard {
  11 |     |     using SafeERC20 for IERC20;
  12 |     | 
  13 |     |     address public feeTo;
  14 |     |     IAggregator public aggregator;
  15 |     |     ILzOFTV2 public immutable oft;
  16 |     |     IERC20 public immutable token;
  17 |     | 
  18 |     |     uint256 public defaultExchangeRate;
  19 |     |     QUOTE_TYPE public defaultQuoteType = QUOTE_TYPE.FIXED_EXCHANGE_RATE;
  20 |     | 
  21 |     |     error InvalidQuoteType(QUOTE_TYPE);
  22 |     |     error ErrWithdrawFailed();
  23 |     |     error MessageValueIsLow(uint256);
  24 |     |     error InvalidAddress();
  25 |     | 
  26 |     |     constructor(uint256 _defaultExchangeRate, address _oft, address _aggregator, address _multisig) OperatableV2(_multisig) {
  27 |     |         defaultExchangeRate = _defaultExchangeRate;
  28 |     |         require(_oft != address(0), "OFTWrapper: invalid oft");
  29 |     |         oft = ILzOFTV2(_oft);
  30 |     |         token = IERC20(oft.token());
  31 |     |         require(_aggregator != address(0), "OFTWrapper: invalid aggregator");
  32 |     |         aggregator = IAggregator(_aggregator);
  33 |     |         token.safeApprove(address(oft), type(uint256).max);
  34 |     |         feeTo = _multisig;
  35 |     |     }
  36 |     | 
  37 |     |     function setDefaultExchangeRate(uint256 _defaultExchangeRate) external onlyOperators {
  38 |     |         emit LogDefaultExchangeRateChanged(defaultExchangeRate, _defaultExchangeRate);
  39 |     |         defaultExchangeRate = _defaultExchangeRate;
  40 |     |     }
  41 |     | 
  42 |     |     function setAggregator(IAggregator _aggregator) external onlyOperators {
  43 |     |         if (address(_aggregator) == address(0)) revert InvalidAddress();
  44 |     |         emit LogOracleImplementationChange(aggregator, _aggregator);
  45 |     |         aggregator = _aggregator;
  46 |     |     }
  47 |     | 
  48 |     |     function setDefaultQuoteType(QUOTE_TYPE _quoteType) external onlyOperators {
  49 |     |         if (_quoteType > QUOTE_TYPE.FIXED_EXCHANGE_RATE) revert InvalidQuoteType(_quoteType);
  50 |     |         emit LogDefaultQuoteTypeChanged(defaultQuoteType, _quoteType);
  51 |     |         defaultQuoteType = _quoteType;
  52 |     |     }
  53 |     | 
  54 |     |     function setFeeTo(address _feeTo) external onlyOwner {
  55 |     |         if (_feeTo == address(0)) revert InvalidAddress();
  56 |     |         emit LogFeeToChange(feeTo, _feeTo);
  57 |     |         feeTo = _feeTo;
  58 |     |     }
  59 |     | 
  60 |     |     function withdrawFees() external {
  61 |     |         uint balance = address(this).balance;
  62 |     |         (bool success, ) = feeTo.call{value: balance}("");
  63 |     |         if (!success) revert ErrWithdrawFailed();
  64 |     |         emit LogWrapperFeeWithdrawn(feeTo, balance);
  65 |     |     }
  66 |     | 
  67 |     |     function sendOFTV2(
  68 |     |         uint16 _dstChainId,
  69 |     |         bytes32 _toAddress,
  70 |     |         uint256 _amount,
  71 |     |         ILzCommonOFT.LzCallParams calldata _callParams
  72 |     |     ) external payable override nonReentrant {
  73 |     |         uint fee = _estimateFee();
  74 |     |         if (msg.value < fee) revert MessageValueIsLow(msg.value);
  75 |     |         uint256 val = msg.value - fee;
  76 |     |         oft.sendFrom{value: val}(msg.sender, _dstChainId, _toAddress, _amount, _callParams);
  77 |     |     }
  78 |     | 
  79 |     |     function sendProxyOFTV2(
  80 |     |         uint16 _dstChainId,
  81 |     |         bytes32 _toAddress,
  82 |     |         uint256 _amount,
  83 |     |         ILzCommonOFT.LzCallParams calldata _callParams
  84 |     |     ) external payable override nonReentrant {
  85 |     |         uint fee = _estimateFee();
  86 |     |         if (msg.value < fee) revert MessageValueIsLow(msg.value);
  87 |     |         uint256 val = msg.value - fee;
  88 |     |         token.safeTransferFrom(msg.sender, address(this), _amount);
  89 |     |         oft.sendFrom{value: val}(address(this), _dstChainId, _toAddress, _amount, _callParams);
  90 |     |     }
  91 |     | 
  92 |     |     function estimateSendFeeV2(
  93 |     |         uint16 _dstChainId,
  94 |     |         bytes32 _toAddress,
  95 |     |         uint256 _amount,
  96 |     |         bytes calldata _adapterParams
  97 |     |     ) external view override returns (uint nativeFee, uint zroFee) {
  98 |     |         (nativeFee, zroFee) = oft.estimateSendFee(_dstChainId, _toAddress, _amount, false, _adapterParams);
  99 |     |         nativeFee += _estimateFee();
 100 |     |     }
 101 |     | 
 102 |     |     function _estimateFee() internal view returns (uint256 fee) {
 103 |     |         if (defaultQuoteType == QUOTE_TYPE.ORACLE) {
 104 |     |             fee = ((10 ** aggregator.decimals()) * 1e18) / uint256(aggregator.latestAnswer());
 105 |     |         } else {
 106 |     |             fee = defaultExchangeRate;
 107 |     |         }
 108 |     |     }
 109 |     | 
 110 |     |     function lzEndpoint() external view returns (ILzEndpoint) {
 111 |     |         return ILzApp(address(oft)).lzEndpoint();
 112 |     |     }
 113 |     | 
 114 |     |     function minDstGasLookup(uint16 _srcChainId, uint16 _dstChainId) external view returns (uint) {
 115 |     |         return ILzApp(address(oft)).minDstGasLookup(_srcChainId, _dstChainId);
 116 |     |     }
 117 |     | }
 118 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/Operatable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {BoringOwnable} from "BoringSolidity/BoringOwnable.sol";
  5 |     | 
  6 |     | contract Operatable is BoringOwnable {
  7 |     |     event OperatorChanged(address indexed, bool);
  8 |     |     error NotAllowedOperator();
  9 |     | 
 10 |     |     mapping(address => bool) public operators;
 11 |     | 
 12 |     |     constructor() {}
 13 |     | 
 14 |     |     modifier onlyOperators() {
 15 |     |         if (!operators[msg.sender] && msg.sender != owner) {
 16 |     |             revert NotAllowedOperator();
 17 |     |         }
 18 |     |         _;
 19 |     |     }
 20 |     | 
 21 |     |     function setOperator(address operator, bool status) external onlyOwner {
 22 |     |         operators[operator] = status;
 23 |     |         emit OperatorChanged(operator, status);
 24 |     |     }
 25 |     | }
 26 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/OperatableV2.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {Owned} from "solmate/auth/Owned.sol";
  5 |     | 
  6 |     | /// @title OperatableV2
  7 |     | /// @notice OperatableV2 is a contract that allows operator management.
  8 |     | /// The difference with OperatableV1 apart from using solmate `Owned` vs `BoringOwnable` is that
  9 |     | /// the constructor is taking in the owner except of using msg.sender.
 10 |     | /// This allows ensuring that the owner is right one.
 11 |     | /// For example, when deploying from a CREATE2 factory, the msg.sender would the factory address
 12 |     | /// which is usually not what we want.
 13 |     | contract OperatableV2 is Owned {
 14 |     |     event OperatorChanged(address indexed, bool);
 15 |     |     error NotAllowedOperator();
 16 |     | 
 17 |     |     mapping(address => bool) public operators;
 18 |     | 
 19 |     |     constructor(address _owner) Owned(_owner) {}
 20 |     | 
 21 |     |     modifier onlyOperators() {
 22 |     |         if (!operators[msg.sender] && msg.sender != owner) {
 23 |     |             revert NotAllowedOperator();
 24 |     |         }
 25 |     |         _;
 26 |     |     }
 27 |     | 
 28 |     |     function setOperator(address operator, bool status) external onlyOwner {
 29 |     |         operators[operator] = status;
 30 |     |         emit OperatorChanged(operator, status);
 31 |     |     }
 32 |     | }
 33 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/OperatableV3.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title OperatableV3
  5 |     | /// @notice Same as OperatableV2 but without taking care of the Ownable part.
  6 |     | /// This is useful when the contract inheriting this is already inheriting from Owned.
  7 |     | abstract contract OperatableV3 {
  8 |     |     event LogOperatorChanged(address indexed, bool);
  9 |     | 
 10 |     |     error ErrNotAllowedOperator();
 11 |     |     error ErrNotOwner();
 12 |     | 
 13 |     |     mapping(address => bool) public operators;
 14 |     | 
 15 |     |     constructor() {}
 16 |     | 
 17 |     |     modifier onlyOperators() {
 18 |     |         if (!operators[msg.sender] && !isOwner(msg.sender)) {
 19 |     |             revert ErrNotAllowedOperator();
 20 |     |         }
 21 |     |         _;
 22 |     |     }
 23 |     | 
 24 |     |     function setOperator(address operator, bool status) external {
 25 |     |         if (!isOwner(msg.sender)) {
 26 |     |             revert ErrNotOwner();
 27 |     |         }
 28 |     | 
 29 |     |         operators[operator] = status;
 30 |     |         emit LogOperatorChanged(operator, status);
 31 |     |     }
 32 |     | 
 33 |     |     function isOwner(address _account) internal view virtual returns (bool);
 34 |     | }
 35 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/mixins/Whitelister.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0-only
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {MerkleProof} from "openzeppelin-contracts/utils/cryptography/MerkleProof.sol";
  5 |     | import {BoringOwnable} from "BoringSolidity/BoringOwnable.sol";
  6 |     | import {IWhitelister} from "interfaces/IWhitelister.sol";
  7 |     | 
  8 |     | contract Whitelister is IWhitelister, BoringOwnable {
  9 |     |     event LogSetMaxBorrow(address user, uint256 maxBorrowAmount);
 10 |     |     event LogSetMerkleRoot(bytes32 newRoot, string ipfsMerkleProofs);
 11 |     |     mapping(address => uint256) public amountAllowed;
 12 |     | 
 13 |     |     bytes32 public merkleRoot;
 14 |     |     string public ipfsMerkleProofs;
 15 |     | 
 16 |     |     constructor(bytes32 _merkleRoot, string memory _ipfsMerkleProofs) {
 17 |     |         merkleRoot = _merkleRoot;
 18 |     |         ipfsMerkleProofs = _ipfsMerkleProofs;
 19 |     |         emit LogSetMerkleRoot(_merkleRoot, _ipfsMerkleProofs);
 20 |     |     }
 21 |     | 
 22 |     |     function setMaxBorrowOwner(address user, uint256 maxBorrow) external onlyOwner {
 23 |     |         amountAllowed[user] = maxBorrow;
 24 |     | 
 25 |     |         emit LogSetMaxBorrow(user, maxBorrow);
 26 |     |     }
 27 |     | 
 28 |     |     /// @inheritdoc IWhitelister
 29 |     |     function isBorrowingAllowed(address user, uint256 newBorrowAmount) external view override returns (bool success) {
 30 |     |         return amountAllowed[user] >= newBorrowAmount;
 31 |     |     }
 32 |     | 
 33 |     |     /// @inheritdoc IWhitelister
 34 |     |     function setMaxBorrow(address user, uint256 maxBorrow, bytes32[] calldata merkleProof) external returns (bool success) {
 35 |     |         // Verify the merkle proof.
 36 |     |         bytes32 node = keccak256(abi.encodePacked(user, maxBorrow));
 37 |     |         require(MerkleProof.verify(merkleProof, merkleRoot, node), "Whitelister: Invalid proof.");
 38 |     | 
 39 |     |         amountAllowed[user] = maxBorrow;
 40 |     | 
 41 |     |         emit LogSetMaxBorrow(user, maxBorrow);
 42 |     | 
 43 |     |         return true;
 44 |     |     }
 45 |     | 
 46 |     |     function changeMerkleRoot(bytes32 newRoot, string calldata ipfsMerkleProofs_) external onlyOwner {
 47 |     |         ipfsMerkleProofs = ipfsMerkleProofs_;
 48 |     |         merkleRoot = newRoot;
 49 |     |         emit LogSetMerkleRoot(newRoot, ipfsMerkleProofs_);
 50 |     |     }
 51 |     | }
 52 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/ChainlinkOracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IOracle} from "interfaces/IOracle.sol";
  5 |     | import {IAggregator} from "interfaces/IAggregator.sol";
  6 |     | 
  7 |     | contract ChainlinkOracle is IOracle {
  8 |     |     IAggregator public immutable aggregator;
  9 |     |     uint256 public immutable decimalScale;
 10 |     |     uint8 public immutable decimals;
 11 |     |     string private desc;
 12 |     | 
 13 |     |     /// @notice Uses chainlink aggregator with optional upscaling decimals
 14 |     |     /// @param _desc A description of the oracle
 15 |     |     /// @param _aggregator The aggregator to use
 16 |     |     /// @param _upscaledTargetDecimals The number of decimals to return, 0 to use the aggregator's decimals
 17 |     |     constructor(string memory _desc, IAggregator _aggregator, uint8 _upscaledTargetDecimals) {
 18 |     |         aggregator = _aggregator;
 19 |     |         desc = _desc;
 20 |     | 
 21 |     |         uint8 aggregatorDecimals = _aggregator.decimals();
 22 |     | 
 23 |     |         decimals = _upscaledTargetDecimals > aggregatorDecimals ? _upscaledTargetDecimals : aggregatorDecimals;
 24 |     |         decimalScale = _upscaledTargetDecimals > aggregatorDecimals ? 10 ** (_upscaledTargetDecimals - aggregatorDecimals) : 1;
 25 |     |     }
 26 |     | 
 27 |     |     function _get() internal view returns (uint256) {
 28 |     |         return uint256(aggregator.latestAnswer()) * decimalScale;
 29 |     |     }
 30 |     | 
 31 |     |     // Get the latest exchange rate
 32 |     |     /// @inheritdoc IOracle
 33 |     |     function get(bytes calldata) public view override returns (bool, uint256) {
 34 |     |         return (true, _get());
 35 |     |     }
 36 |     | 
 37 |     |     // Check the last exchange rate without any state changes
 38 |     |     /// @inheritdoc IOracle
 39 |     |     function peek(bytes calldata) public view override returns (bool, uint256) {
 40 |     |         return (true, _get());
 41 |     |     }
 42 |     | 
 43 |     |     // Check the current spot exchange rate without any state changes
 44 |     |     /// @inheritdoc IOracle
 45 |     |     function peekSpot(bytes calldata data) external view override returns (uint256 rate) {
 46 |     |         (, rate) = peek(data);
 47 |     |     }
 48 |     | 
 49 |     |     /// @inheritdoc IOracle
 50 |     |     function name(bytes calldata) public view override returns (string memory) {
 51 |     |         return desc;
 52 |     |     }
 53 |     | 
 54 |     |     /// @inheritdoc IOracle
 55 |     |     function symbol(bytes calldata) public view override returns (string memory) {
 56 |     |         return desc;
 57 |     |     }
 58 |     | }
 59 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/FixedPriceOracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {Owned} from "solmate/auth/Owned.sol";
  5 |     | import {IOracle} from "interfaces/IOracle.sol";
  6 |     | 
  7 |     | contract FixedPriceOracle is IOracle, Owned {
  8 |     |     event LogPriceChanged(uint256 price);
  9 |     | 
 10 |     |     uint8 public immutable decimals;
 11 |     |     uint256 public price;
 12 |     |     string public desc;
 13 |     | 
 14 |     |     constructor(string memory _desc, uint256 _price, uint8 _decimals) Owned(msg.sender) {
 15 |     |         desc = _desc;
 16 |     |         price = _price;
 17 |     |         decimals = _decimals;
 18 |     |     }
 19 |     | 
 20 |     |     function setPrice(uint256 _price) public onlyOwner {
 21 |     |         price = _price;
 22 |     |         emit LogPriceChanged(_price);
 23 |     |     }
 24 |     | 
 25 |     |     function _get() internal view returns (uint256) {
 26 |     |         return price;
 27 |     |     }
 28 |     | 
 29 |     |     /// @inheritdoc IOracle
 30 |     |     function get(bytes calldata) public view override returns (bool, uint256) {
 31 |     |         return (true, _get());
 32 |     |     }
 33 |     | 
 34 |     |     /// @inheritdoc IOracle
 35 |     |     function peek(bytes calldata) public view override returns (bool, uint256) {
 36 |     |         return (true, _get());
 37 |     |     }
 38 |     | 
 39 |     |     /// @inheritdoc IOracle
 40 |     |     function peekSpot(bytes calldata data) external view override returns (uint256 rate) {
 41 |     |         (, rate) = peek(data);
 42 |     |     }
 43 |     | 
 44 |     |     /// @inheritdoc IOracle
 45 |     |     function name(bytes calldata) public view override returns (string memory) {
 46 |     |         return desc;
 47 |     |     }
 48 |     | 
 49 |     |     /// @inheritdoc IOracle
 50 |     |     function symbol(bytes calldata) public view override returns (string memory) {
 51 |     |         return desc;
 52 |     |     }
 53 |     | }

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/FloorPriceOracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {Owned} from "solmate/auth/Owned.sol";
  5 |     | import {MathLib} from "libraries/MathLib.sol";
  6 |     | import {IOracle} from "interfaces/IOracle.sol";
  7 |     | import {IAggregator} from "interfaces/IAggregator.sol";
  8 |     | 
  9 |     | contract FloorPriceOracle is IOracle, Owned {
 10 |     |     IOracle public immutable oracle;
 11 |     |     uint256 public floor;
 12 |     |     bytes public oracleData;
 13 |     |     string public desc;
 14 |     | 
 15 |     |     constructor(string memory _desc, IOracle _oracle, bytes memory _oracleData, uint256 _floor) Owned(msg.sender) {
 16 |     |         desc = _desc;
 17 |     |         oracle = _oracle;
 18 |     |         oracleData = _oracleData;
 19 |     |         floor = _floor;
 20 |     |     }
 21 |     | 
 22 |     |     function decimals() external view returns (uint8) {
 23 |     |         return oracle.decimals();
 24 |     |     }
 25 |     | 
 26 |     |     function setFloor(uint256 _floor) public onlyOwner {
 27 |     |         floor = _floor;
 28 |     |     }
 29 |     | 
 30 |     |     function _get() internal view returns (uint256) {
 31 |     |         (, uint256 price) = oracle.peek(oracleData);
 32 |     |         return MathLib.min(floor, price);
 33 |     |     }
 34 |     | 
 35 |     |     /// @inheritdoc IOracle
 36 |     |     function get(bytes calldata) public view override returns (bool, uint256) {
 37 |     |         return (true, _get());
 38 |     |     }
 39 |     | 
 40 |     |     /// @inheritdoc IOracle
 41 |     |     function peek(bytes calldata) public view override returns (bool, uint256) {
 42 |     |         return (true, _get());
 43 |     |     }
 44 |     | 
 45 |     |     /// @inheritdoc IOracle
 46 |     |     function peekSpot(bytes calldata data) external view override returns (uint256 rate) {
 47 |     |         (, rate) = peek(data);
 48 |     |     }
 49 |     | 
 50 |     |     /// @inheritdoc IOracle
 51 |     |     function name(bytes calldata) public view override returns (string memory) {
 52 |     |         return desc;
 53 |     |     }
 54 |     | 
 55 |     |     /// @inheritdoc IOracle
 56 |     |     function symbol(bytes calldata) public view override returns (string memory) {
 57 |     |         return desc;
 58 |     |     }
 59 |     | }
 60 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/GmOracleWithAggregator.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IOracle} from "interfaces/IOracle.sol";
  5 |     | import {IAggregator} from "interfaces/IAggregator.sol";
  6 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  7 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  8 |     | import {IGmxV2Market, IGmxV2Price, IGmxReader} from "interfaces/IGmxV2.sol";
  9 |     | 
 10 |     | contract GmOracleWithAggregator is IOracle {
 11 |     |     using BoringERC20 for IERC20;
 12 |     |     bytes32 private constant PNL_TYPE = keccak256(abi.encode("MAX_PNL_FACTOR_FOR_TRADERS"));
 13 |     |     IGmxReader public immutable reader;
 14 |     |     IAggregator public immutable indexAggregator;
 15 |     |     uint256 public immutable expansionFactorIndex;
 16 |     |     uint256 public immutable expansionFactorShort;
 17 |     |     IAggregator public immutable shortAggregator;
 18 |     |     address public immutable dataStore;
 19 |     |     address immutable marketToken;
 20 |     |     address immutable indexToken;
 21 |     |     address immutable longToken;
 22 |     |     address immutable shortToken;
 23 |     | 
 24 |     |     string private desc;
 25 |     | 
 26 |     |     constructor(
 27 |     |         IGmxReader _reader,
 28 |     |         IAggregator _indexTokenAggregator,
 29 |     |         IAggregator _shortTokenAggregator,
 30 |     |         address _market,
 31 |     |         address _indexToken,
 32 |     |         address _dataStore,
 33 |     |         string memory _desc
 34 |     |     ) {
 35 |     |         reader = _reader;
 36 |     |         indexAggregator = _indexTokenAggregator;
 37 |     |         shortAggregator = _shortTokenAggregator;
 38 |     |         indexToken = _indexToken;
 39 |     |         dataStore = _dataStore;
 40 |     |         IGmxV2Market.Props memory props = _reader.getMarket(_dataStore, _market);
 41 |     |         (marketToken, , longToken, shortToken) = (props.marketToken, props.indexToken, props.longToken, props.shortToken);
 42 |     | 
 43 |     |         // GMX uses an internal precision of 1e30
 44 |     |         expansionFactorIndex = 10 ** (30 - indexAggregator.decimals() - IERC20(indexToken).safeDecimals());
 45 |     |         expansionFactorShort = 10 ** (30 - shortAggregator.decimals() - IERC20(shortToken).safeDecimals());
 46 |     |         desc = _desc;
 47 |     |     }
 48 |     | 
 49 |     |     function decimals() external pure returns (uint8) {
 50 |     |         return uint8(18);
 51 |     |     }
 52 |     | 
 53 |     |     function _get() internal view returns (uint256 lpPrice) {
 54 |     |         uint256 indexTokenPrice = uint256(indexAggregator.latestAnswer()) * expansionFactorIndex;
 55 |     |         uint256 shortTokenPrice = uint256(shortAggregator.latestAnswer()) * expansionFactorShort;
 56 |     | 
 57 |     |         (int256 price, ) = reader.getMarketTokenPrice(
 58 |     |             dataStore,
 59 |     |             IGmxV2Market.Props(marketToken, indexToken, longToken, shortToken),
 60 |     |             IGmxV2Price.Props(indexTokenPrice, indexTokenPrice),
 61 |     |             IGmxV2Price.Props(indexTokenPrice, indexTokenPrice),
 62 |     |             IGmxV2Price.Props(shortTokenPrice, shortTokenPrice),
 63 |     |             PNL_TYPE,
 64 |     |             false
 65 |     |         );
 66 |     | 
 67 |     |         // GMX uses an internal precision of 1e30
 68 |     |         lpPrice = (1e18 * 1e30) / uint256(price);
 69 |     |     }
 70 |     | 
 71 |     |     /// @inheritdoc IOracle
 72 |     |     function get(bytes calldata) public view override returns (bool, uint256) {
 73 |     |         return (true, _get());
 74 |     |     }
 75 |     | 
 76 |     |     /// @inheritdoc IOracle
 77 |     |     function peek(bytes calldata) public view override returns (bool, uint256) {
 78 |     |         return (true, _get());
 79 |     |     }
 80 |     | 
 81 |     |     /// @inheritdoc IOracle
 82 |     |     function peekSpot(bytes calldata data) external view override returns (uint256 rate) {
 83 |     |         (, rate) = peek(data);
 84 |     |     }
 85 |     | 
 86 |     |     /// @inheritdoc IOracle
 87 |     |     function name(bytes calldata) public view override returns (string memory) {
 88 |     |         return desc;
 89 |     |     }
 90 |     | 
 91 |     |     /// @inheritdoc IOracle
 92 |     |     function symbol(bytes calldata) public view override returns (string memory) {
 93 |     |         return desc;
 94 |     |     }
 95 |     | }
 96 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/InverseOracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IOracle} from "interfaces/IOracle.sol";
  5 |     | import {IAggregator} from "interfaces/IAggregator.sol";
  6 |     | 
  7 |     | /// @title InverseOracle
  8 |     | /// @notice An oracle that inverts the price of an aggregator
  9 |     | contract InverseOracle is IOracle {
 10 |     |     IAggregator public immutable aggregator;
 11 |     |     uint256 public immutable decimalScale;
 12 |     |     uint8 public immutable decimals;
 13 |     |     string private desc;
 14 |     | 
 15 |     |     /// @notice Construct an oracle that inverts the price of an aggregator
 16 |     |     /// @param _desc A description of the oracle
 17 |     |     /// @param _aggregator The aggregator to invert
 18 |     |     /// @param _upscaledTargetDecimals The number of decimals to return, 0 to use the aggregator's decimals
 19 |     |     constructor(string memory _desc, IAggregator _aggregator, uint8 _upscaledTargetDecimals) {
 20 |     |         aggregator = _aggregator;
 21 |     |         desc = _desc;
 22 |     | 
 23 |     |         uint8 aggregatorDecimals = _aggregator.decimals();
 24 |     | 
 25 |     |         decimalScale = _upscaledTargetDecimals > aggregatorDecimals
 26 |     |             ? 10 ** ((_upscaledTargetDecimals * 2) - (_upscaledTargetDecimals - aggregatorDecimals))
 27 |     |             : 10 ** (aggregatorDecimals * 2);
 28 |     | 
 29 |     |         decimals = _upscaledTargetDecimals > aggregatorDecimals ? _upscaledTargetDecimals : aggregatorDecimals;
 30 |     |     }
 31 |     | 
 32 |     |     function _get() internal view returns (uint256) {
 33 |     |         return decimalScale / uint256(aggregator.latestAnswer());
 34 |     |     }
 35 |     | 
 36 |     |     // Get the latest exchange rate
 37 |     |     /// @inheritdoc IOracle
 38 |     |     function get(bytes calldata) public view override returns (bool, uint256) {
 39 |     |         return (true, _get());
 40 |     |     }
 41 |     | 
 42 |     |     // Check the last exchange rate without any state changes
 43 |     |     /// @inheritdoc IOracle
 44 |     |     function peek(bytes calldata) public view override returns (bool, uint256) {
 45 |     |         return (true, _get());
 46 |     |     }
 47 |     | 
 48 |     |     // Check the current spot exchange rate without any state changes
 49 |     |     /// @inheritdoc IOracle
 50 |     |     function peekSpot(bytes calldata data) external view override returns (uint256 rate) {
 51 |     |         (, rate) = peek(data);
 52 |     |     }
 53 |     | 
 54 |     |     /// @inheritdoc IOracle
 55 |     |     function name(bytes calldata) public view override returns (string memory) {
 56 |     |         return desc;
 57 |     |     }
 58 |     | 
 59 |     |     /// @inheritdoc IOracle
 60 |     |     function symbol(bytes calldata) public view override returns (string memory) {
 61 |     |         return desc;
 62 |     |     }
 63 |     | }
 64 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/MagicGlpOracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | import {IERC4626} from "interfaces/IERC4626.sol";
  6 |     | import {IOracle} from "interfaces/IOracle.sol";
  7 |     | import {IGmxGlpManager} from "interfaces/IGmxV1.sol";
  8 |     | 
  9 |     | contract MagicGlpOracle is IOracle {
 10 |     |     IGmxGlpManager private immutable glpManager;
 11 |     |     IERC20 private immutable glp;
 12 |     |     IERC4626 public immutable magicGlp;
 13 |     | 
 14 |     |     constructor(IGmxGlpManager glpManager_, IERC20 glp_, IERC4626 magicGlp_) {
 15 |     |         glpManager = glpManager_;
 16 |     |         glp = glp_;
 17 |     |         magicGlp = magicGlp_;
 18 |     |     }
 19 |     | 
 20 |     |     function decimals() external pure returns (uint8) {
 21 |     |         return 18;
 22 |     |     }
 23 |     | 
 24 |     |     function _get() internal view returns (uint256) {
 25 |     |         uint256 glpPrice = (uint256(glpManager.getAum(false)) / glp.totalSupply());
 26 |     |         return 1e30 / magicGlp.convertToAssets(glpPrice);
 27 |     |     }
 28 |     | 
 29 |     |     // Get the latest exchange rate
 30 |     |     /// @inheritdoc IOracle
 31 |     |     function get(bytes calldata) public view override returns (bool, uint256) {
 32 |     |         return (true, _get());
 33 |     |     }
 34 |     | 
 35 |     |     // Check the last exchange rate without any state changes
 36 |     |     /// @inheritdoc IOracle
 37 |     |     function peek(bytes calldata) public view override returns (bool, uint256) {
 38 |     |         return (true, _get());
 39 |     |     }
 40 |     | 
 41 |     |     // Check the current spot exchange rate without any state changes
 42 |     |     /// @inheritdoc IOracle
 43 |     |     function peekSpot(bytes calldata data) external view override returns (uint256 rate) {
 44 |     |         (, rate) = peek(data);
 45 |     |     }
 46 |     | 
 47 |     |     /// @inheritdoc IOracle
 48 |     |     function name(bytes calldata) public pure override returns (string memory) {
 49 |     |         return "MagicGlp USD Oracle";
 50 |     |     }
 51 |     | 
 52 |     |     /// @inheritdoc IOracle
 53 |     |     function symbol(bytes calldata) public pure override returns (string memory) {
 54 |     |         return "MagicGlp/USD";
 55 |     |     }
 56 |     | }
 57 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/MagicVaultOracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | import {IERC4626} from "interfaces/IERC4626.sol";
  6 |     | import {IAggregator} from "interfaces/IAggregator.sol";
  7 |     | import {IOracle} from "interfaces/IOracle.sol";
  8 |     | import {IGmxGlpManager} from "interfaces/IGmxV1.sol";
  9 |     | 
 10 |     | contract MagicVaultOracle is IOracle {
 11 |     |     IERC4626 public immutable vault;
 12 |     |     IAggregator public immutable aggregator;
 13 |     |     uint256 public immutable decimalScale;
 14 |     |     string private desc;
 15 |     | 
 16 |     |     /// @notice Magic vault oracle
 17 |     |     /// @param _desc The description of the oracle
 18 |     |     /// @param _vault The vault to use
 19 |     |     /// @param _aggregator The aggregator to use for the asset.
 20 |     |     constructor(string memory _desc, IERC4626 _vault, IAggregator _aggregator) {
 21 |     |         assert(_vault.decimals() == _aggregator.decimals());
 22 |     |         desc = _desc;
 23 |     |         vault = _vault;
 24 |     |         aggregator = _aggregator;
 25 |     |         decimalScale = 10 ** (_vault.decimals() * 2);
 26 |     |     }
 27 |     | 
 28 |     |     function decimals() external view returns (uint8) {
 29 |     |         return vault.decimals();
 30 |     |     }
 31 |     | 
 32 |     |     function _get() internal view returns (uint256) {
 33 |     |         return decimalScale / vault.convertToAssets(uint256(aggregator.latestAnswer()));
 34 |     |     }
 35 |     | 
 36 |     |     // Get the latest exchange rate
 37 |     |     /// @inheritdoc IOracle
 38 |     |     function get(bytes calldata) public view override returns (bool, uint256) {
 39 |     |         return (true, _get());
 40 |     |     }
 41 |     | 
 42 |     |     // Check the last exchange rate without any state changes
 43 |     |     /// @inheritdoc IOracle
 44 |     |     function peek(bytes calldata) public view override returns (bool, uint256) {
 45 |     |         return (true, _get());
 46 |     |     }
 47 |     | 
 48 |     |     // Check the current spot exchange rate without any state changes
 49 |     |     /// @inheritdoc IOracle
 50 |     |     function peekSpot(bytes calldata data) external view override returns (uint256 rate) {
 51 |     |         (, rate) = peek(data);
 52 |     |     }
 53 |     | 
 54 |     |     /// @inheritdoc IOracle
 55 |     |     function name(bytes calldata) public view override returns (string memory) {
 56 |     |         return desc;
 57 |     |     }
 58 |     | 
 59 |     |     /// @inheritdoc IOracle
 60 |     |     function symbol(bytes calldata) public view override returns (string memory) {
 61 |     |         return desc;
 62 |     |     }
 63 |     | }
 64 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/ProxyOracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {Owned} from "solmate/auth/Owned.sol";
  5 |     | import {IOracle} from "interfaces/IOracle.sol";
  6 |     | 
  7 |     | /// @title ProxyOracle
  8 |     | /// @author 0xMerlin
  9 |     | /// @notice Oracle used for getting the price of an oracle implementation
 10 |     | contract ProxyOracle is IOracle, Owned {
 11 |     |     IOracle public oracleImplementation;
 12 |     | 
 13 |     |     event LogOracleImplementationChange(IOracle indexed oldOracle, IOracle indexed newOracle);
 14 |     | 
 15 |     |     constructor() Owned(msg.sender) {}
 16 |     | 
 17 |     |     function changeOracleImplementation(IOracle newOracle) external onlyOwner {
 18 |     |         IOracle oldOracle = oracleImplementation;
 19 |     |         oracleImplementation = newOracle;
 20 |     |         emit LogOracleImplementationChange(oldOracle, newOracle);
 21 |     |     }
 22 |     | 
 23 |     |     function decimals() external view returns (uint8) {
 24 |     |         return oracleImplementation.decimals();
 25 |     |     }
 26 |     | 
 27 |     |     // Get the latest exchange rate
 28 |     |     /// @inheritdoc IOracle
 29 |     |     function get(bytes calldata data) public override returns (bool, uint256) {
 30 |     |         return oracleImplementation.get(data);
 31 |     |     }
 32 |     | 
 33 |     |     // Check the last exchange rate without any state changes
 34 |     |     /// @inheritdoc IOracle
 35 |     |     function peek(bytes calldata data) public view override returns (bool, uint256) {
 36 |     |         return oracleImplementation.peek(data);
 37 |     |     }
 38 |     | 
 39 |     |     // Check the current spot exchange rate without any state changes
 40 |     |     /// @inheritdoc IOracle
 41 |     |     function peekSpot(bytes calldata data) external view override returns (uint256 rate) {
 42 |     |         return oracleImplementation.peekSpot(data);
 43 |     |     }
 44 |     | 
 45 |     |     /// @inheritdoc IOracle
 46 |     |     function name(bytes calldata) public pure override returns (string memory) {
 47 |     |         return "Proxy Oracle";
 48 |     |     }
 49 |     | 
 50 |     |     /// @inheritdoc IOracle
 51 |     |     function symbol(bytes calldata) public pure override returns (string memory) {
 52 |     |         return "Proxy";
 53 |     |     }
 54 |     | }
 55 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/StargateLPOracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IOracle} from "interfaces/IOracle.sol";
  5 |     | import {IStargatePool} from "interfaces/IStargate.sol";
  6 |     | import {IAggregator} from "interfaces/IAggregator.sol";
  7 |     | 
  8 |     | contract StargateLPOracle is IOracle {
  9 |     |     IStargatePool public immutable pool;
 10 |     |     IAggregator public immutable tokenAggregator;
 11 |     | 
 12 |     |     uint256 public immutable decimalScale;
 13 |     |     string private desc;
 14 |     | 
 15 |     |     constructor(IStargatePool _pool, IAggregator _tokenAggregator, string memory _desc) {
 16 |     |         pool = _pool;
 17 |     |         tokenAggregator = _tokenAggregator;
 18 |     |         desc = _desc;
 19 |     |         decimalScale = 10 ** (_pool.decimals() + _tokenAggregator.decimals());
 20 |     |     }
 21 |     | 
 22 |     |     function decimals() external view returns (uint8) {
 23 |     |         return uint8(pool.decimals());
 24 |     |     }
 25 |     | 
 26 |     |     function _get() internal view returns (uint256) {
 27 |     |         uint256 lpPrice = (pool.totalLiquidity() * uint256(tokenAggregator.latestAnswer())) / pool.totalSupply();
 28 |     |         return decimalScale / lpPrice;
 29 |     |     }
 30 |     | 
 31 |     |     /// @inheritdoc IOracle
 32 |     |     function get(bytes calldata) public view override returns (bool, uint256) {
 33 |     |         return (true, _get());
 34 |     |     }
 35 |     | 
 36 |     |     /// @inheritdoc IOracle
 37 |     |     function peek(bytes calldata) public view override returns (bool, uint256) {
 38 |     |         return (true, _get());
 39 |     |     }
 40 |     | 
 41 |     |     /// @inheritdoc IOracle
 42 |     |     function peekSpot(bytes calldata data) external view override returns (uint256 rate) {
 43 |     |         (, rate) = peek(data);
 44 |     |     }
 45 |     | 
 46 |     |     /// @inheritdoc IOracle
 47 |     |     function name(bytes calldata) public view override returns (string memory) {
 48 |     |         return desc;
 49 |     |     }
 50 |     | 
 51 |     |     /// @inheritdoc IOracle
 52 |     |     function symbol(bytes calldata) public view override returns (string memory) {
 53 |     |         return desc;
 54 |     |     }
 55 |     | }
 56 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/YearnCurvePoolOracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IOracle} from "interfaces/IOracle.sol";
  5 |     | import {ICurveStablePoolAggregator} from "interfaces/ICurveStablePoolAggregator.sol";
  6 |     | import {IYearnVault} from "interfaces/IYearnVault.sol";
  7 |     | import {ICurvePool} from "interfaces/ICurvePool.sol";
  8 |     | 
  9 |     | /// @notice Yearn oracle version using CurveStablePoolAggregator
 10 |     | contract YearnCurvePoolOracle is IOracle {
 11 |     |     ICurveStablePoolAggregator public immutable aggregator;
 12 |     |     IYearnVault public immutable vault;
 13 |     |     uint256 public immutable decimalScale;
 14 |     |     string private desc;
 15 |     | 
 16 |     |     constructor(IYearnVault _vault, ICurveStablePoolAggregator _aggregator, string memory _desc) {
 17 |     |         assert(_vault.token() == _aggregator.curvePool());
 18 |     |         assert(_vault.decimals() == _aggregator.decimals());
 19 |     | 
 20 |     |         vault = _vault;
 21 |     |         aggregator = _aggregator;
 22 |     |         desc = _desc;
 23 |     | 
 24 |     |         decimalScale = 10 ** (_aggregator.decimals() + (vault.decimals() * 2));
 25 |     |     }
 26 |     | 
 27 |     |     function decimals() external view returns (uint8) {
 28 |     |         return uint8(vault.decimals());
 29 |     |     }
 30 |     | 
 31 |     |     function _get() internal view returns (uint256) {
 32 |     |         return decimalScale / (uint256(aggregator.latestAnswer()) * vault.pricePerShare());
 33 |     |     }
 34 |     | 
 35 |     |     /// @inheritdoc IOracle
 36 |     |     function get(bytes calldata) public view override returns (bool, uint256) {
 37 |     |         return (true, _get());
 38 |     |     }
 39 |     | 
 40 |     |     /// @inheritdoc IOracle
 41 |     |     function peek(bytes calldata) public view override returns (bool, uint256) {
 42 |     |         return (true, _get());
 43 |     |     }
 44 |     | 
 45 |     |     /// @inheritdoc IOracle
 46 |     |     function peekSpot(bytes calldata data) external view override returns (uint256 rate) {
 47 |     |         (, rate) = peek(data);
 48 |     |     }
 49 |     | 
 50 |     |     /// @inheritdoc IOracle
 51 |     |     function name(bytes calldata) public view override returns (string memory) {
 52 |     |         return desc;
 53 |     |     }
 54 |     | 
 55 |     |     /// @inheritdoc IOracle
 56 |     |     function symbol(bytes calldata) public view override returns (string memory) {
 57 |     |         return desc;
 58 |     |     }
 59 |     | }
 60 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/YearnTriCryptoOracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IOracle} from "interfaces/IOracle.sol";
  5 |     | import {IYearnVault} from "interfaces/IYearnVault.sol";
  6 |     | 
  7 |     | interface ITriCryptoOracle {
  8 |     |     function lp_price() external view returns (uint256 price);
  9 |     | }
 10 |     | 
 11 |     | contract YearnTriCryptoOracle is IOracle {
 12 |     |     ITriCryptoOracle public immutable LP_ORACLE;
 13 |     |     IYearnVault public immutable vault;
 14 |     | 
 15 |     |     constructor(address vault_, address _lpOracle) {
 16 |     |         vault = IYearnVault(vault_);
 17 |     |         LP_ORACLE = ITriCryptoOracle(_lpOracle);
 18 |     |     }
 19 |     | 
 20 |     |     function decimals() external pure returns (uint8) {
 21 |     |         return 18;
 22 |     |     }
 23 |     | 
 24 |     |     // Calculates the lastest exchange rate
 25 |     |     // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD
 26 |     |     function _get() internal view returns (uint256) {
 27 |     |         return 1e54 / (LP_ORACLE.lp_price() * vault.pricePerShare());
 28 |     |     }
 29 |     | 
 30 |     |     // Get the latest exchange rate
 31 |     |     /// @inheritdoc IOracle
 32 |     |     function get(bytes calldata) public view override returns (bool, uint256) {
 33 |     |         return (true, _get());
 34 |     |     }
 35 |     | 
 36 |     |     // Check the last exchange rate without any state changes
 37 |     |     /// @inheritdoc IOracle
 38 |     |     function peek(bytes calldata) public view override returns (bool, uint256) {
 39 |     |         return (true, _get());
 40 |     |     }
 41 |     | 
 42 |     |     // Check the current spot exchange rate without any state changes
 43 |     |     /// @inheritdoc IOracle
 44 |     |     function peekSpot(bytes calldata data) external view override returns (uint256 rate) {
 45 |     |         (, rate) = peek(data);
 46 |     |     }
 47 |     | 
 48 |     |     /// @inheritdoc IOracle
 49 |     |     function name(bytes calldata) public pure override returns (string memory) {
 50 |     |         return "y3Crypto";
 51 |     |     }
 52 |     | 
 53 |     |     /// @inheritdoc IOracle
 54 |     |     function symbol(bytes calldata) public pure override returns (string memory) {
 55 |     |         return "y3Crypto";
 56 |     |     }
 57 |     | }
 58 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/aggregators/CurveStablePoolAggregator.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IAggregator} from "interfaces/IAggregator.sol";
  5 |     | import {ICurvePool} from "interfaces/ICurvePool.sol";
  6 |     | import {MathLib} from "libraries/MathLib.sol";
  7 |     | 
  8 |     | /// @title CurveStablePoolAggregator
  9 |     | /// @notice An aggregator that expect a CurvePool with stablecoins and uses
 10 |     | /// the one with the lowest price as the price of the pool along with the virtual price
 11 |     | contract CurveStablePoolAggregator is IAggregator {
 12 |     |     ICurvePool public immutable curvePool;
 13 |     |     uint256 public immutable decimalScale;
 14 |     |     IAggregator[] public aggregators;
 15 |     | 
 16 |     |     constructor(ICurvePool _curvePool, IAggregator[] memory _aggregators) {
 17 |     |         curvePool = _curvePool;
 18 |     |         aggregators = _aggregators;
 19 |     | 
 20 |     |         // assert that all aggregators are the same decimals
 21 |     |         uint8 aggregatorDecimals = _aggregators[0].decimals();
 22 |     |         for (uint256 i = 1; i < _aggregators.length; ) {
 23 |     |             assert(_aggregators[i].decimals() == aggregatorDecimals);
 24 |     |             unchecked {
 25 |     |                 ++i;
 26 |     |             }
 27 |     |         }
 28 |     | 
 29 |     |         decimalScale = 10 ** aggregatorDecimals;
 30 |     |         assert(decimalScale != 0);
 31 |     |     }
 32 |     | 
 33 |     |     function decimals() external view returns (uint8) {
 34 |     |         return uint8(curvePool.decimals());
 35 |     |     }
 36 |     | 
 37 |     |     function latestAnswer() public view override returns (int256) {
 38 |     |         uint256 minStable = uint256(aggregators[0].latestAnswer());
 39 |     | 
 40 |     |         for (uint256 i = 1; i < aggregators.length - 1; ) {
 41 |     |             uint256 price = uint256(aggregators[i].latestAnswer());
 42 |     |             if (price < minStable) {
 43 |     |                 minStable = price;
 44 |     |             }
 45 |     |             unchecked {
 46 |     |                 ++i;
 47 |     |             }
 48 |     |         }
 49 |     | 
 50 |     |         return int256((curvePool.get_virtual_price() * minStable) / decimalScale);
 51 |     |     }
 52 |     | 
 53 |     |     function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {
 54 |     |         return (0, latestAnswer(), 0, 0, 0);
 55 |     |     }
 56 |     | }
 57 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/aggregators/MagicLpAggregator.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";
  5 |     | import {IERC20Metadata} from "openzeppelin-contracts/interfaces/IERC20Metadata.sol";
  6 |     | import {IAggregator} from "interfaces/IAggregator.sol";
  7 |     | import {IMagicLP} from "/mimswap/interfaces/IMagicLP.sol";
  8 |     | 
  9 |     | contract MagicLpAggregator is IAggregator {
 10 |     |     IMagicLP public immutable pair;
 11 |     |     IAggregator public immutable baseOracle;
 12 |     |     IAggregator public immutable quoteOracle;
 13 |     |     uint8 public immutable baseDecimals;
 14 |     |     uint8 public immutable quoteDecimals;
 15 |     | 
 16 |     |     uint256 public constant WAD = 18;
 17 |     | 
 18 |     |     /// @param pair_ The MagicLP pair address
 19 |     |     /// @param baseOracle_ The base oracle
 20 |     |     /// @param quoteOracle_ The quote oracle
 21 |     |     constructor(IMagicLP pair_, IAggregator baseOracle_, IAggregator quoteOracle_) {
 22 |     |         pair = pair_;
 23 |     |         baseOracle = baseOracle_;
 24 |     |         quoteOracle = quoteOracle_;
 25 |     |         baseDecimals = IERC20Metadata(pair_._BASE_TOKEN_()).decimals();
 26 |     |         quoteDecimals = IERC20Metadata(pair_._QUOTE_TOKEN_()).decimals();
 27 |     |     }
 28 |     | 
 29 |     |     function decimals() external pure override returns (uint8) {
 30 |     |         return 18;
 31 |     |     }
 32 |     | 
 33 |     |     function _getReserves() internal view virtual returns (uint256, uint256) {
 34 |     |         return pair.getReserves();
 35 |     |     }
 36 |     | 
 37 |     |     function latestAnswer() public view override returns (int256) {
 38 |     |         uint256 baseAnswerNomalized = uint256(baseOracle.latestAnswer()) * (10 ** (WAD - baseOracle.decimals()));
 39 |     |         uint256 quoteAnswerNormalized = uint256(quoteOracle.latestAnswer()) * (10 ** (WAD - quoteOracle.decimals()));
 40 |     |         uint256 minAnswer = baseAnswerNomalized < quoteAnswerNormalized ? baseAnswerNomalized : quoteAnswerNormalized;
 41 |     | 
 42 |     |         (uint256 baseReserve, uint256 quoteReserve) = _getReserves();
 43 |     |         baseReserve = baseReserve * (10 ** (WAD - baseDecimals));
 44 |     |         quoteReserve = quoteReserve * (10 ** (WAD - quoteDecimals));
 45 |     |         return int256(minAnswer * (baseReserve + quoteReserve) / pair.totalSupply());
 46 |     |     }
 47 |     | 
 48 |     |     function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {
 49 |     |         return (0, latestAnswer(), 0, 0, 0);
 50 |     |     }
 51 |     | }

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/aggregators/RedstoneAggregator.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IAggregator} from "interfaces/IAggregator.sol";
  5 |     | 
  6 |     | interface IRedstoneAdapter {
  7 |     |     function getValueForDataFeed(bytes32 dataFeedId) external view returns (uint256);
  8 |     | }
  9 |     | 
 10 |     | contract RedstoneAggregator is IAggregator {
 11 |     |     error ErrUnsafeUintToIntConversion();
 12 |     | 
 13 |     |     uint8 public constant decimals = 8;
 14 |     |     IRedstoneAdapter public immutable priceFeedAdapter;
 15 |     |     bytes32 public immutable dataFeedId;
 16 |     |     string public description;
 17 |     | 
 18 |     |     constructor(string memory _description, IRedstoneAdapter _priceFeedAdapter, bytes32 _dataFeedId) {
 19 |     |         description = _description;
 20 |     |         priceFeedAdapter = _priceFeedAdapter;
 21 |     |         dataFeedId = _dataFeedId;
 22 |     |     }
 23 |     | 
 24 |     |     function latestRoundData() public view override returns (uint80, int256, uint256, uint256, uint80) {
 25 |     |         return (0, latestAnswer(), 0, 0, 0);
 26 |     |     }
 27 |     | 
 28 |     |     function latestAnswer() public view override returns (int256) {
 29 |     |         uint256 uintAnswer = priceFeedAdapter.getValueForDataFeed(dataFeedId);
 30 |     | 
 31 |     |         if (uintAnswer > uint256(type(int256).max)) {
 32 |     |             revert ErrUnsafeUintToIntConversion();
 33 |     |         }
 34 |     | 
 35 |     |         return int256(uintAnswer);
 36 |     |     }
 37 |     | }
 38 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/aggregators/TokenAggregator.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IAggregator} from "interfaces/IAggregator.sol";
  5 |     | 
  6 |     | /// @title TokenAggregator
  7 |     | /// @notice Aggregator used for getting the price of 1 token in given denominator using Chainlink
  8 |     | contract TokenAggregator is IAggregator {
  9 |     |     error NegativePriceFeed();
 10 |     | 
 11 |     |     IAggregator public immutable tokenUSD;
 12 |     |     IAggregator public immutable denominatorUSD;
 13 |     | 
 14 |     |     uint8 public immutable oracle0Decimals;
 15 |     |     uint8 public immutable oracle1Decimals;
 16 |     | 
 17 |     |     uint8 public immutable _decimals;
 18 |     | 
 19 |     |     constructor(IAggregator _tokenUSD, IAggregator _denominatorUSD, uint8 __decimals) {
 20 |     |         tokenUSD = _tokenUSD;
 21 |     |         denominatorUSD = _denominatorUSD;
 22 |     | 
 23 |     |         oracle0Decimals = _tokenUSD.decimals();
 24 |     |         oracle1Decimals = _denominatorUSD.decimals();
 25 |     | 
 26 |     |         _decimals = __decimals;
 27 |     |     }
 28 |     | 
 29 |     |     function decimals() external view override returns (uint8) {
 30 |     |         return _decimals;
 31 |     |     }
 32 |     | 
 33 |     |     function latestAnswer() public view override returns (int256 answer) {
 34 |     |         int256 tokenUSDFeed = tokenUSD.latestAnswer();
 35 |     |         int256 denominatorUSDFeed = denominatorUSD.latestAnswer();
 36 |     | 
 37 |     |         if (tokenUSDFeed < 0 || denominatorUSDFeed < 0) {
 38 |     |             revert NegativePriceFeed();
 39 |     |         }
 40 |     | 
 41 |     |         uint256 normalizedTokenUSDFeed = uint256(tokenUSDFeed) * (10 ** (_decimals - oracle0Decimals));
 42 |     |         uint256 normalizedDenominatorUSDFeed = uint256(denominatorUSDFeed) * (10 ** (_decimals - oracle1Decimals));
 43 |     | 
 44 |     |         return int256((normalizedTokenUSDFeed * (10**_decimals)) / normalizedDenominatorUSDFeed);
 45 |     |     }
 46 |     | 
 47 |     |     function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {
 48 |     |         return (0, latestAnswer(), 0, 0, 0);
 49 |     |     }
 50 |     | }
 51 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/aggregators/UmbrellaAggregator.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IAggregator} from "interfaces/IAggregator.sol";
  5 |     | import {IUmbrellaFeeds} from "interfaces/IUmbrellaFeeds.sol";
  6 |     | 
  7 |     | interface IUmbrellaRegistry {
  8 |     |     function getAddress(bytes32 _bytes) external view returns (address);
  9 |     | }
 10 |     | 
 11 |     | /// @title UmbrellaAggregator
 12 |     | /// @notice Wraps umbrella price feed in an aggregator interface
 13 |     | contract UmbrellaAggregator is IAggregator {
 14 |     |     bytes32 public constant FEEDS_KEY_NAME = bytes32("UmbrellaFeeds");
 15 |     | 
 16 |     |     IUmbrellaRegistry public immutable registry;
 17 |     |     bytes32 public immutable key;
 18 |     | 
 19 |     |     constructor(bytes32 _key, IUmbrellaRegistry _registry) {
 20 |     |         key = _key;
 21 |     |         registry = _registry;
 22 |     |     }
 23 |     | 
 24 |     |     function decimals() external view override returns (uint8) {
 25 |     |         return _getFeeds().DECIMALS();
 26 |     |     }
 27 |     | 
 28 |     |     function latestAnswer() external view returns (int256 answer) {
 29 |     |         (, answer, , , ) = latestRoundData();
 30 |     |     }
 31 |     | 
 32 |     |     function latestRoundData() public view returns (uint80, int256 answer, uint256, uint256 updatedAt, uint80) {
 33 |     |         IUmbrellaFeeds.PriceData memory data = _getFeeds().getPriceData(key);
 34 |     |         return (0, int256(uint256(data.price)), 0, data.timestamp, 0);
 35 |     |     }
 36 |     | 
 37 |     |     function _getFeeds() private view returns (IUmbrellaFeeds) {
 38 |     |         return IUmbrellaFeeds(registry.getAddress(FEEDS_KEY_NAME));
 39 |     |     }
 40 |     | }
 41 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/aggregators/UniswapLikeLPAggregator.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | import {IUniswapV2Pair} from "interfaces/IUniswapV2.sol";
  6 |     | import {IAggregator} from "interfaces/IAggregator.sol";
  7 |     | import {BabylonianLib} from "libraries/BabylonianLib.sol";
  8 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  9 |     | 
 10 |     | /// @title UniswapLikeLPAggregator
 11 |     | /// @author BoringCrypto, 0xCalibur
 12 |     | /// @notice Aggregator used for getting the price of an LP token denominated in tokenOracle.
 13 |     | /// @dev Optimized version based on https://blog.alphafinance.io/fair-lp-token-pricing/
 14 |     | contract UniswapLikeLPAggregator is IAggregator {
 15 |     |     using BoringERC20 for IERC20;
 16 |     | 
 17 |     |     IUniswapV2Pair public immutable pair;
 18 |     |     IAggregator public immutable tokenOracle;
 19 |     |     uint8 public immutable token0Decimals;
 20 |     |     uint8 public immutable token1Decimals;
 21 |     |     uint8 public immutable oracleDecimals;
 22 |     | 
 23 |     |     uint256 public constant WAD = 18;
 24 |     | 
 25 |     |     /// @param pair_ The UniswapV2 compatible pair address
 26 |     |     /// @param tokenOracle_ The token price 1 lp should be denominated with.
 27 |     |     constructor(IUniswapV2Pair pair_, IAggregator tokenOracle_) {
 28 |     |         pair = pair_;
 29 |     |         tokenOracle = tokenOracle_;
 30 |     | 
 31 |     |         token0Decimals = IERC20(pair_.token0()).safeDecimals();
 32 |     |         token1Decimals = IERC20(pair_.token1()).safeDecimals();
 33 |     | 
 34 |     |         oracleDecimals = tokenOracle_.decimals();
 35 |     |     }
 36 |     | 
 37 |     |     function decimals() external pure override returns (uint8) {
 38 |     |         return 18;
 39 |     |     }
 40 |     | 
 41 |     |     /// Calculates the lastest exchange rate
 42 |     |     /// @return the price of 1 lp in token price
 43 |     |     /// Example:
 44 |     |     /// - For 1 AVAX = $82
 45 |     |     /// - Total LP Value is: $160,000,000
 46 |     |     /// - LP supply is 8.25
 47 |     |     /// - latestAnswer() returns 234420638348190662349201 / 1e18 = 234420.63 AVAX
 48 |     |     /// - 1 LP = 234420.63 AVAX => 234420.63 * 8.25 * 82 = ≈$160,000,000
 49 |     |     function latestAnswer() public view override returns (int256) {
 50 |     |         (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pair).getReserves();
 51 |     |         uint256 totalSupply = pair.totalSupply();
 52 |     | 
 53 |     |         uint256 normalizedReserve0 = reserve0 * (10 ** (WAD - token0Decimals));
 54 |     |         uint256 normalizedReserve1 = reserve1 * (10 ** (WAD - token1Decimals));
 55 |     | 
 56 |     |         uint256 k = normalizedReserve0 * normalizedReserve1;
 57 |     |         (, int256 priceFeed, , , ) = tokenOracle.latestRoundData();
 58 |     | 
 59 |     |         uint256 normalizedPriceFeed = uint256(priceFeed) * (10 ** (WAD - oracleDecimals));
 60 |     | 
 61 |     |         uint256 totalValue = uint256(BabylonianLib.sqrt((k / 1e18) * normalizedPriceFeed)) * 2;
 62 |     |         return int256((totalValue * 1e18) / totalSupply);
 63 |     |     }
 64 |     | 
 65 |     |     function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {
 66 |     |         return (0, latestAnswer(), 0, 0, 0);
 67 |     |     }
 68 |     | }
 69 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/oracles/aggregators/WitnetAggregator.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IAggregator} from "interfaces/IAggregator.sol";
  5 |     | import {IWitnetPriceRouter} from "interfaces/IWitnetPriceRouter.sol";
  6 |     | 
  7 |     | /// @title WitnetAggregator
  8 |     | /// @notice Wraps witnet price router in an aggregator interface
  9 |     | contract WitnetAggregator is IAggregator {
 10 |     |     IWitnetPriceRouter public immutable router;
 11 |     |     bytes4 public immutable id;
 12 |     |     uint8 public immutable _decimals;
 13 |     | 
 14 |     |     constructor(bytes4 _id, address _router, uint8 __decimals) {
 15 |     |         id = _id;
 16 |     |         router = IWitnetPriceRouter(_router);
 17 |     |         _decimals = __decimals;
 18 |     |     }
 19 |     | 
 20 |     |     function decimals() external view override returns (uint8) {
 21 |     |         return _decimals;
 22 |     |     }
 23 |     | 
 24 |     |     function latestAnswer() external view returns (int256 _price) {
 25 |     |         (_price, , ) = router.valueFor(id);
 26 |     |     }
 27 |     | 
 28 |     |     function latestRoundData() public view returns (uint80, int256 answer, uint256, uint256 updatedAt, uint80) {
 29 |     |         (answer, updatedAt, ) = router.valueFor(id);
 30 |     |         return (0, answer, 0, updatedAt, 0);
 31 |     |     }
 32 |     | }
 33 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/CauldronFeeWithdrawer.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   5 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
   6 |     | import {ILzOFTV2, ILzApp, ILzCommonOFT} from "interfaces/ILayerZero.sol";
   7 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
   8 |     | import {ICauldronV1} from "interfaces/ICauldronV1.sol";
   9 |     | import {ICauldronV2} from "interfaces/ICauldronV2.sol";
  10 |     | import {SafeApproveLib} from "libraries/SafeApproveLib.sol";
  11 |     | import {OperatableV2} from "mixins/OperatableV2.sol";
  12 |     | 
  13 |     | library CauldronFeeWithdrawWithdrawerEvents {
  14 |     |     event LogMimWithdrawn(IBentoBoxV1 indexed bentoBox, uint256 amount);
  15 |     |     event LogMimTotalWithdrawn(uint256 amount);
  16 |     |     event LogBentoBoxChanged(IBentoBoxV1 indexed bentoBox, bool previous, bool current);
  17 |     |     event LogCauldronChanged(address indexed cauldron, bool previous, bool current);
  18 |     |     event LogParametersChanged(address mimProvider, bytes32 bridgeRecipient, address mimWithdrawRecipient);
  19 |     |     event LogFeeToOverrideChanged(address indexed cauldron, address previous, address current);
  20 |     | }
  21 |     | 
  22 |     | /// @notice Responsible of withdrawing MIM fees from Cauldron and in case of altchains, bridge
  23 |     | /// MIM inside this contract to mainnet CauldronFeeWithdrawer
  24 |     | contract CauldronFeeWithdrawer is OperatableV2 {
  25 |     |     using BoringERC20 for IERC20;
  26 |     |     using SafeApproveLib for IERC20;
  27 |     | 
  28 |     |     error ErrInvalidFeeTo(address masterContract);
  29 |     |     error ErrNotEnoughNativeTokenToCoverFee();
  30 |     | 
  31 |     |     struct CauldronInfo {
  32 |     |         address cauldron;
  33 |     |         address masterContract;
  34 |     |         IBentoBoxV1 bentoBox;
  35 |     |         uint8 version;
  36 |     |     }
  37 |     | 
  38 |     |     uint16 public constant LZ_MAINNET_CHAINID = 101;
  39 |     |     IERC20 public immutable mim;
  40 |     |     ILzOFTV2 public immutable lzOftv2;
  41 |     | 
  42 |     |     mapping(address => address) public feeToOverrides;
  43 |     | 
  44 |     |     /// @dev By default withdraw MIM from bentoBox to this contract because they will need
  45 |     |     /// to get bridge from altchains to mainnet SpellStakingRewardDistributor.
  46 |     |     /// On mainnet, this should be withdrawn to SpellStakingRewardDistributor directly.
  47 |     |     address public mimWithdrawRecipient;
  48 |     |     bytes32 public bridgeRecipient;
  49 |     |     address public mimProvider;
  50 |     | 
  51 |     |     CauldronInfo[] public cauldronInfos;
  52 |     |     IBentoBoxV1[] public bentoBoxes;
  53 |     | 
  54 |     |     constructor(address _owner, IERC20 _mim, ILzOFTV2 _lzOftv2) OperatableV2(_owner) {
  55 |     |         mim = _mim;
  56 |     |         lzOftv2 = _lzOftv2;
  57 |     |     }
  58 |     | 
  59 |     |     receive() external payable {}
  60 |     | 
  61 |     |     function bentoBoxesCount() external view returns (uint256) {
  62 |     |         return bentoBoxes.length;
  63 |     |     }
  64 |     | 
  65 |     |     function cauldronInfosCount() external view returns (uint256) {
  66 |     |         return cauldronInfos.length;
  67 |     |     }
  68 |     | 
  69 |     |     function withdraw() external returns (uint256 amount) {
  70 |     |         for (uint256 i = 0; i < cauldronInfos.length; i++) {
  71 |     |             CauldronInfo memory info = cauldronInfos[i];
  72 |     | 
  73 |     |             if (ICauldronV1(info.masterContract).feeTo() != address(this)) {
  74 |     |                 revert ErrInvalidFeeTo(info.masterContract);
  75 |     |             }
  76 |     | 
  77 |     |             ICauldronV1(info.cauldron).accrue();
  78 |     |             uint256 feesEarned;
  79 |     |             IBentoBoxV1 bentoBox = info.bentoBox;
  80 |     | 
  81 |     |             if (info.version == 1) {
  82 |     |                 (, feesEarned) = ICauldronV1(info.cauldron).accrueInfo();
  83 |     |             } else if (info.version >= 2) {
  84 |     |                 (, feesEarned, ) = ICauldronV2(info.cauldron).accrueInfo();
  85 |     |             }
  86 |     | 
  87 |     |             uint256 cauldronMimAmount = bentoBox.toAmount(mim, bentoBox.balanceOf(mim, info.cauldron), false);
  88 |     |             if (feesEarned > cauldronMimAmount) {
  89 |     |                 // only transfer the required mim amount
  90 |     |                 uint256 diff = feesEarned - cauldronMimAmount;
  91 |     |                 mim.safeTransferFrom(mimProvider, address(bentoBox), diff);
  92 |     |                 bentoBox.deposit(mim, address(bentoBox), info.cauldron, diff, 0);
  93 |     |             }
  94 |     | 
  95 |     |             ICauldronV1(info.cauldron).withdrawFees();
  96 |     | 
  97 |     |             // redirect fees to override address if set
  98 |     |             address feeToOverride = feeToOverrides[info.cauldron];
  99 |     |             if (feeToOverride != address(0)) {
 100 |     |                 info.bentoBox.transfer(mim, address(this), feeToOverride, bentoBox.toShare(mim, feesEarned, false));
 101 |     |             }
 102 |     |         }
 103 |     | 
 104 |     |         amount = _withdrawAllMimFromBentoBoxes();
 105 |     |         emit CauldronFeeWithdrawWithdrawerEvents.LogMimTotalWithdrawn(amount);
 106 |     |     }
 107 |     | 
 108 |     |     function estimateBridgingFee(uint256 amount) external view returns (uint256 fee, uint256 gas) {
 109 |     |         gas = ILzApp(address(lzOftv2)).minDstGasLookup(LZ_MAINNET_CHAINID, 0 /* packet type for sendFrom */);
 110 |     |         (fee, ) = lzOftv2.estimateSendFee(LZ_MAINNET_CHAINID, bridgeRecipient, amount, false, abi.encodePacked(uint16(1), uint256(gas)));
 111 |     |     }
 112 |     | 
 113 |     |     function bridge(uint256 amount, uint256 fee, uint256 gas) external onlyOperators {
 114 |     |         // optionnal check for convenience
 115 |     |         // check if there is enough native token to cover the bridging fees
 116 |     |         if (fee > address(this).balance) {
 117 |     |             revert ErrNotEnoughNativeTokenToCoverFee();
 118 |     |         }
 119 |     | 
 120 |     |         ILzCommonOFT.LzCallParams memory lzCallParams = ILzCommonOFT.LzCallParams({
 121 |     |             refundAddress: payable(address(this)),
 122 |     |             zroPaymentAddress: address(0),
 123 |     |             adapterParams: abi.encodePacked(uint16(1), uint256(gas))
 124 |     |         });
 125 |     | 
 126 |     |         lzOftv2.sendFrom{value: fee}(
 127 |     |             address(this), // 'from' address to send tokens
 128 |     |             LZ_MAINNET_CHAINID, // mainnet remote LayerZero chainId
 129 |     |             bridgeRecipient, // 'to' address to send tokens
 130 |     |             amount, // amount of tokens to send (in wei)
 131 |     |             lzCallParams
 132 |     |         );
 133 |     |     }
 134 |     | 
 135 |     |     function setFeeToOverride(address cauldron, address feeTo) external onlyOwner {
 136 |     |         emit CauldronFeeWithdrawWithdrawerEvents.LogFeeToOverrideChanged(cauldron, feeToOverrides[cauldron], feeTo);
 137 |     |         feeToOverrides[cauldron] = feeTo;
 138 |     |     }
 139 |     | 
 140 |     |     function setCauldron(address cauldron, uint8 version, bool enabled) external onlyOwner {
 141 |     |         _setCauldron(cauldron, version, enabled);
 142 |     |     }
 143 |     | 
 144 |     |     function setCauldrons(address[] memory cauldrons, uint8[] memory versions, bool[] memory enabled) external onlyOwner {
 145 |     |         for (uint256 i = 0; i < cauldrons.length; i++) {
 146 |     |             _setCauldron(cauldrons[i], versions[i], enabled[i]);
 147 |     |         }
 148 |     |     }
 149 |     | 
 150 |     |     function _setCauldron(address cauldron, uint8 version, bool enabled) private {
 151 |     |         bool previousEnabled;
 152 |     | 
 153 |     |         for (uint256 i = 0; i < cauldronInfos.length; i++) {
 154 |     |             if (cauldronInfos[i].cauldron == cauldron) {
 155 |     |                 cauldronInfos[i] = cauldronInfos[cauldronInfos.length - 1];
 156 |     |                 cauldronInfos.pop();
 157 |     |                 break;
 158 |     |             }
 159 |     |         }
 160 |     | 
 161 |     |         if (enabled) {
 162 |     |             cauldronInfos.push(
 163 |     |                 CauldronInfo({
 164 |     |                     cauldron: cauldron,
 165 |     |                     masterContract: address(ICauldronV1(cauldron).masterContract()),
 166 |     |                     bentoBox: IBentoBoxV1(ICauldronV1(cauldron).bentoBox()),
 167 |     |                     version: version
 168 |     |                 })
 169 |     |             );
 170 |     |         }
 171 |     | 
 172 |     |         emit CauldronFeeWithdrawWithdrawerEvents.LogCauldronChanged(cauldron, previousEnabled, enabled);
 173 |     |     }
 174 |     | 
 175 |     |     function _withdrawAllMimFromBentoBoxes() private returns (uint256 totalAmount) {
 176 |     |         for (uint256 i = 0; i < bentoBoxes.length; i++) {
 177 |     |             uint256 share = bentoBoxes[i].balanceOf(mim, address(this));
 178 |     |             (uint256 amount, ) = bentoBoxes[i].withdraw(mim, address(this), mimWithdrawRecipient, 0, share);
 179 |     |             totalAmount += amount;
 180 |     | 
 181 |     |             emit CauldronFeeWithdrawWithdrawerEvents.LogMimWithdrawn(bentoBoxes[i], amount);
 182 |     |         }
 183 |     |     }
 184 |     | 
 185 |     |     function setParameters(address _mimProvider, address _bridgeRecipient, address _mimWithdrawRecipient) external onlyOwner {
 186 |     |         mimProvider = _mimProvider;
 187 |     |         bridgeRecipient = bytes32(uint256(uint160(_bridgeRecipient)));
 188 |     |         mimWithdrawRecipient = _mimWithdrawRecipient;
 189 |     | 
 190 |     |         emit CauldronFeeWithdrawWithdrawerEvents.LogParametersChanged(_mimProvider, bridgeRecipient, _mimWithdrawRecipient);
 191 |     |     }
 192 |     | 
 193 |     |     function setBentoBox(IBentoBoxV1 bentoBox, bool enabled) external onlyOwner {
 194 |     |         bool previousEnabled;
 195 |     | 
 196 |     |         for (uint256 i = 0; i < bentoBoxes.length; i++) {
 197 |     |             if (bentoBoxes[i] == bentoBox) {
 198 |     |                 bentoBoxes[i] = bentoBoxes[bentoBoxes.length - 1];
 199 |     |                 bentoBoxes.pop();
 200 |     |                 previousEnabled = true;
 201 |     |                 break;
 202 |     |             }
 203 |     |         }
 204 |     | 
 205 |     |         if (enabled) {
 206 |     |             bentoBoxes.push(bentoBox);
 207 |     |         }
 208 |     | 
 209 |     |         emit CauldronFeeWithdrawWithdrawerEvents.LogBentoBoxChanged(bentoBox, previousEnabled, enabled);
 210 |     |     }
 211 |     | 
 212 |     |     ////////////////////////////////////////////////////////
 213 |     |     // Emergency Functions
 214 |     |     ////////////////////////////////////////////////////////
 215 |     | 
 216 |     |     function rescueTokens(IERC20 token, address to, uint256 amount) external onlyOwner {
 217 |     |         token.safeTransfer(to, amount);
 218 |     |     }
 219 |     | 
 220 |     |     function execute(address to, uint256 value, bytes calldata data) external onlyOwner returns (bool success, bytes memory result) {
 221 |     |         // solhint-disable-next-line avoid-low-level-calls
 222 |     |         (success, result) = to.call{value: value}(data);
 223 |     |     }
 224 |     | }
 225 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/CauldronOwner.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {ERC20} from "BoringSolidity/ERC20.sol";
   5 |     | import {BoringOwnable} from "BoringSolidity/BoringOwnable.sol";
   6 |     | import {ICauldronV2} from "interfaces/ICauldronV2.sol";
   7 |     | import {ICauldronV3} from "interfaces/ICauldronV3.sol";
   8 |     | import {ICauldronV4} from "interfaces/ICauldronV4.sol";
   9 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  10 |     | 
  11 |     | contract CauldronOwner is BoringOwnable {
  12 |     |     error ErrNotOperator(address operator);
  13 |     |     error ErrNotDeprecated(address cauldron);
  14 |     |     error ErrNotMasterContract(address cauldron);
  15 |     | 
  16 |     |     event LogOperatorChanged(address indexed operator, bool previous, bool current);
  17 |     |     event LogTreasuryChanged(address indexed previous, address indexed current);
  18 |     |     event LogDeprecated(address indexed cauldron, bool previous, bool current);
  19 |     | 
  20 |     |     ERC20 public immutable mim;
  21 |     | 
  22 |     |     mapping(address => bool) public operators;
  23 |     |     mapping(address => bool) public deprecated;
  24 |     | 
  25 |     |     address public treasury;
  26 |     | 
  27 |     |     modifier onlyOperators() {
  28 |     |         if (msg.sender != owner && !operators[msg.sender]) {
  29 |     |             revert ErrNotOperator(msg.sender);
  30 |     |         }
  31 |     |         _;
  32 |     |     }
  33 |     | 
  34 |     |     constructor(address _treasury, ERC20 _mim) {
  35 |     |         treasury = _treasury;
  36 |     |         mim = _mim;
  37 |     | 
  38 |     |         emit LogTreasuryChanged(address(0), _treasury);
  39 |     |     }
  40 |     | 
  41 |     |     function reduceSupply(ICauldronV2 cauldron, uint256 amount) external onlyOperators {
  42 |     |         cauldron.reduceSupply(amount);
  43 |     |     }
  44 |     | 
  45 |     |     function changeInterestRate(ICauldronV3 cauldron, uint64 newInterestRate) external onlyOperators {
  46 |     |         cauldron.changeInterestRate(newInterestRate);
  47 |     |     }
  48 |     | 
  49 |     |     function reduceCompletely(ICauldronV2 cauldron) external {
  50 |     |         if (!deprecated[address(cauldron)]) {
  51 |     |             revert ErrNotDeprecated(address(cauldron));
  52 |     |         }
  53 |     | 
  54 |     |         IBentoBoxV1 bentoBox = IBentoBoxV1(cauldron.bentoBox());
  55 |     |         uint256 amount = bentoBox.toAmount(mim, bentoBox.balanceOf(mim, address(cauldron)), false);
  56 |     |         cauldron.reduceSupply(amount);
  57 |     |     }
  58 |     | 
  59 |     |     function changeBorrowLimit(ICauldronV3 cauldron, uint128 newBorrowLimit, uint128 perAddressPart) external onlyOperators {
  60 |     |         cauldron.changeBorrowLimit(newBorrowLimit, perAddressPart);
  61 |     |     }
  62 |     | 
  63 |     |     function withdrawMIMToTreasury(IBentoBoxV1 bentoBox, uint256 share) external onlyOperators {
  64 |     |         uint256 maxShare = bentoBox.balanceOf(mim, address(this));
  65 |     |         if (share > maxShare) {
  66 |     |             share = maxShare;
  67 |     |         }
  68 |     | 
  69 |     |         bentoBox.withdraw(mim, address(this), treasury, 0, share);
  70 |     |     }
  71 |     | 
  72 |     |     function setFeeTo(ICauldronV2 cauldron, address newFeeTo) external onlyOperators {
  73 |     |         if (cauldron.masterContract() != cauldron) {
  74 |     |             revert ErrNotMasterContract(address(cauldron));
  75 |     |         }
  76 |     | 
  77 |     |         cauldron.setFeeTo(newFeeTo);
  78 |     |     }
  79 |     | 
  80 |     |     function setDeprecated(address cauldron, bool _deprecated) external onlyOperators {
  81 |     |         emit LogDeprecated(cauldron, deprecated[cauldron], _deprecated);
  82 |     | 
  83 |     |         deprecated[cauldron] = _deprecated;
  84 |     |     }
  85 |     | 
  86 |     |     function setBlacklistedCallee(ICauldronV4 cauldron, address callee, bool blacklisted) external onlyOperators {
  87 |     |         cauldron.setBlacklistedCallee(callee, blacklisted);
  88 |     |     }
  89 |     | 
  90 |     |     function setOperator(address operator, bool enabled) external onlyOwner {
  91 |     |         emit LogOperatorChanged(operator, operators[operator], enabled);
  92 |     |         operators[operator] = enabled;
  93 |     |     }
  94 |     | 
  95 |     |     function setTreasury(address _treasury) external onlyOwner {
  96 |     |         emit LogTreasuryChanged(treasury, _treasury);
  97 |     |         treasury = _treasury;
  98 |     |     }
  99 |     | 
 100 |     |     function transferMasterContractOwnership(BoringOwnable masterContract, address newOwner) external onlyOwner {
 101 |     |         masterContract.transferOwnership(newOwner, true, false);
 102 |     |     }
 103 |     | 
 104 |     |     function rescueMIM() external {
 105 |     |         mim.transfer(treasury, mim.balanceOf(address(this)));
 106 |     |     }
 107 |     | 
 108 |     |     /// low level execution for any other future added functions
 109 |     |     function execute(address to, uint256 value, bytes calldata data) external onlyOwner returns (bool success, bytes memory result) {
 110 |     |         // solhint-disable-next-line avoid-low-level-calls
 111 |     |         (success, result) = to.call{value: value}(data);
 112 |     |     }
 113 |     | }
 114 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/CauldronRegistry.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8;
  3 |     | 
  4 |     | import {Owned} from "solmate/auth/Owned.sol";
  5 |     | import {ICauldronV1} from "interfaces/ICauldronV1.sol";
  6 |     | 
  7 |     | contract CauldronRegistry is Owned {
  8 |     |     error ErrAlreadyRegistered(ICauldronV1 cauldron_);
  9 |     |     error ErrNotRegistered(ICauldronV1 cauldron_);
 10 |     |     error ErrEmptyRegistry();
 11 |     |     error ErrTooManyCauldrons();
 12 |     |     error ErrInvalidCauldron(ICauldronV1 cauldron_);
 13 |     | 
 14 |     |     ICauldronV1[] public cauldrons;
 15 |     |     mapping(ICauldronV1 => uint256) internal cauldronIndicies;
 16 |     | 
 17 |     |     constructor(address owner_) Owned(owner_) {}
 18 |     | 
 19 |     |     function addCauldrons(ICauldronV1[] calldata cauldrons_) external onlyOwner {
 20 |     |         for (uint256 i = 0; i < cauldrons_.length; ++i) {
 21 |     |             ICauldronV1 cauldron = cauldrons_[i];
 22 |     | 
 23 |     |             if (address(cauldron) == address(0)) {
 24 |     |                 revert ErrInvalidCauldron(cauldron);
 25 |     |             }
 26 |     | 
 27 |     |             if (cauldronIndicies[cauldron] != 0 || (cauldrons.length != 0 && cauldrons[0] == cauldron)) {
 28 |     |                 revert ErrAlreadyRegistered(cauldron);
 29 |     |             }
 30 |     | 
 31 |     |             uint256 cauldronIndex = cauldrons.length;
 32 |     |             cauldrons.push(cauldron);
 33 |     |             cauldronIndicies[cauldron] = cauldronIndex;
 34 |     |         }
 35 |     |     }
 36 |     | 
 37 |     |     function removeCauldrons(ICauldronV1[] calldata cauldrons_) external onlyOwner {
 38 |     |         if (cauldrons.length == 0) {
 39 |     |             revert ErrEmptyRegistry();
 40 |     |         }
 41 |     | 
 42 |     |         if (cauldrons.length < cauldrons_.length) {
 43 |     |             revert ErrTooManyCauldrons();
 44 |     |         }
 45 |     | 
 46 |     |         for (uint256 i = 0; i < cauldrons_.length; ++i) {
 47 |     |             ICauldronV1 cauldron = cauldrons_[i];
 48 |     | 
 49 |     |             if (address(cauldron) == address(0)) {
 50 |     |                 revert ErrInvalidCauldron(cauldron);
 51 |     |             }
 52 |     | 
 53 |     |             uint256 cauldronIndex = cauldronIndicies[cauldron];
 54 |     |             if (cauldronIndex == 0 && cauldrons[0] != cauldron) {
 55 |     |                 revert ErrNotRegistered(cauldron);
 56 |     |             }
 57 |     | 
 58 |     |             uint256 lastIndex = cauldrons.length - 1;
 59 |     |             if (cauldronIndex == lastIndex) {
 60 |     |                 cauldrons.pop();
 61 |     |                 delete cauldronIndicies[cauldron];
 62 |     |             } else {
 63 |     |                 cauldronIndicies[cauldrons[lastIndex]] = cauldronIndex;
 64 |     |                 cauldrons[cauldronIndex] = cauldrons[lastIndex];
 65 |     |                 cauldrons.pop();
 66 |     |                 delete cauldronIndicies[cauldron];
 67 |     |             }
 68 |     |         }
 69 |     |     }
 70 |     | 
 71 |     |     function cauldronsLength() public view returns (uint256) {
 72 |     |         return cauldrons.length;
 73 |     |     }
 74 |     | }
 75 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/DegenBoxConvexWrapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | import {SafeApproveLib} from "libraries/SafeApproveLib.sol";
  6 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  7 |     | import {IConvexWrapper} from "interfaces/IConvexWrapper.sol";
  8 |     | 
  9 |     | /// @notice Wrap token to ConvexWrapper and deposit into DegenBox for recipient
 10 |     | /// Need to be used atomically, do not transfer fund in it and then wrap / unwrap on another block as
 11 |     | /// it could be retrieved by anyone else, by calling deposit or withdraw.
 12 |     | contract DegenBoxConvexWrapper {
 13 |     |     using SafeApproveLib for IERC20;
 14 |     | 
 15 |     |     IBentoBoxV1 immutable degenBox;
 16 |     |     IConvexWrapper immutable wrapper;
 17 |     |     IERC20 immutable underlying;
 18 |     | 
 19 |     |     constructor(IBentoBoxV1 _degenBox, IConvexWrapper _wrapper) {
 20 |     |         degenBox = _degenBox;
 21 |     |         wrapper = _wrapper;
 22 |     | 
 23 |     |         IERC20 _underlying = IERC20(wrapper.curveToken());
 24 |     |         _underlying.approve(address(wrapper), type(uint256).max);
 25 |     |         _underlying.approve(address(degenBox), type(uint256).max);
 26 |     |         underlying = _underlying;
 27 |     |     }
 28 |     | 
 29 |     |     function wrap(address recipient, uint256 amount) external returns (uint256 amountOut, uint256 shareOut) {
 30 |     |         wrapper.deposit(amount, address(degenBox));
 31 |     |         return degenBox.deposit(IERC20(address(wrapper)), address(degenBox), recipient, amount, 0);
 32 |     |     }
 33 |     | 
 34 |     |     function unwrap(address recipient, uint256 amount) external returns (uint256 amountOut, uint256 shareOut) {
 35 |     |         wrapper.withdrawAndUnwrap(amount);
 36 |     |         return degenBox.deposit(underlying, address(this), recipient, amount, 0);
 37 |     |     }
 38 |     | }
 39 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/DegenBoxERC4626Wrapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | import {SafeApproveLib} from "libraries/SafeApproveLib.sol";
  6 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  7 |     | import {IERC4626} from "interfaces/IERC4626.sol";
  8 |     | 
  9 |     | /// @notice Wrap token to ERC4626 Tokenized Vault and deposit into DegenBox for recipient
 10 |     | /// Need to be used atomically, do not transfer fund in it and then wrap / unwrap on another block as
 11 |     | /// it could be retrieved by anyone else, by calling deposit or withdraw.
 12 |     | contract DegenBoxERC4626Wrapper {
 13 |     |     using SafeApproveLib for IERC20;
 14 |     | 
 15 |     |     IBentoBoxV1 immutable degenBox;
 16 |     |     IERC4626 immutable wrapper;
 17 |     |     IERC20 immutable underlying;
 18 |     | 
 19 |     |     constructor(IBentoBoxV1 _degenBox, IERC4626 _wrapper) {
 20 |     |         degenBox = _degenBox;
 21 |     |         wrapper = _wrapper;
 22 |     | 
 23 |     |         IERC20 _underlying = wrapper.asset();
 24 |     |         _underlying.approve(address(wrapper), type(uint256).max);
 25 |     | 
 26 |     |         underlying = _underlying;
 27 |     |     }
 28 |     | 
 29 |     |     function wrap(address recipient, uint256 amount) external returns (uint256 amountOut, uint256 shareOut) {
 30 |     |         uint256 shares = wrapper.deposit(amount, address(degenBox));
 31 |     |         return degenBox.deposit(IERC20(address(wrapper)), address(degenBox), recipient, shares, 0);
 32 |     |     }
 33 |     | 
 34 |     |     function unwrap(address recipient, uint256 shares) external returns (uint256 amountOut, uint256 shareOut) {
 35 |     |         uint256 amount = wrapper.redeem(shares, address(degenBox), address(this));
 36 |     |         return degenBox.deposit(underlying, address(degenBox), recipient, amount, 0);
 37 |     |     }
 38 |     | }
 39 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/ElevatedMinterBurner.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {Operatable} from "mixins/Operatable.sol";
  5 |     | import {IMintableBurnable} from "interfaces/IMintableBurnable.sol";
  6 |     | 
  7 |     | /// @title ElevatedMinterBurner
  8 |     | /// @notice ElevatedMinterBurner is a periphery contract for minting and burning tokens and executing arbitrary calls.
  9 |     | contract ElevatedMinterBurner is IMintableBurnable, Operatable {
 10 |     |     IMintableBurnable public immutable token;
 11 |     | 
 12 |     |     constructor(IMintableBurnable token_) {
 13 |     |         token = token_;
 14 |     |     }
 15 |     | 
 16 |     |     function burn(address from, uint256 amount) external override onlyOperators returns (bool) {
 17 |     |         return token.burn(from, amount);
 18 |     |     }
 19 |     | 
 20 |     |     function mint(address to, uint256 amount) external override onlyOperators returns (bool) {
 21 |     |         return token.mint(to, amount);
 22 |     |     }
 23 |     | 
 24 |     |     function exec(address target, bytes calldata data) external onlyOwner {
 25 |     |         (bool success, bytes memory result) = target.call(data);
 26 |     |         if (!success) {
 27 |     |             if (result.length == 0) revert();
 28 |     |             assembly {
 29 |     |                 revert(add(32, result), mload(result))
 30 |     |             }
 31 |     |         }
 32 |     |     }
 33 |     | }
 34 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/EpochBasedRewardDistributor.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {OperatableV2} from "mixins/OperatableV2.sol";
   5 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
   6 |     | 
   7 |     | interface IEpochBasedStaking {
   8 |     |     function epoch() external view returns (uint256);
   9 |     | 
  10 |     |     function nextEpoch() external view returns (uint256);
  11 |     | 
  12 |     |     function rewardData(
  13 |     |         address token
  14 |     |     ) external view returns (uint256 periodFinish, uint256 rewardRate, uint256 rewardPerTokenStored, bool exists, uint248 lastUpdateTime);
  15 |     | 
  16 |     |     function notifyRewardAmount(address rewardToken, uint256 amount, uint minRemainingTime) external;
  17 |     | 
  18 |     |     function rewardTokensLength() external view returns (uint);
  19 |     | 
  20 |     |     function rewardTokens(uint index) external view returns (address);
  21 |     | }
  22 |     | 
  23 |     | /// @notice Distribute rewards to staking contracts based on epochs
  24 |     | /// Amounts deposited to this contract are distributed to staking contracts
  25 |     | /// only on the next epoch
  26 |     | contract EpochBasedRewardDistributor is OperatableV2 {
  27 |     |     using SafeTransferLib for address;
  28 |     | 
  29 |     |     event LogRewardAdded(address indexed reward, uint256 amount);
  30 |     |     event LogWithdraw(address indexed token, address indexed to, uint256 amount);
  31 |     |     event LogDistributed(uint256 epoch);
  32 |     |     event LogMinRemainingTimeSet(uint256 previous, uint256 current);
  33 |     | 
  34 |     |     error ErrInvalidRewardToken();
  35 |     |     error ErrNotReady();
  36 |     | 
  37 |     |     address public immutable staking;
  38 |     | 
  39 |     |     uint256 public epoch;
  40 |     |     uint256 public minRemainingTime;
  41 |     | 
  42 |     |     mapping(address => uint256) public balanceOf;
  43 |     | 
  44 |     |     constructor(address _staking, uint256 _minRemainingTime, address _owner) OperatableV2(_owner) {
  45 |     |         staking = _staking;
  46 |     |         minRemainingTime = _minRemainingTime;
  47 |     |         epoch = IEpochBasedStaking(_staking).nextEpoch();
  48 |     |     }
  49 |     | 
  50 |     |     ////////////////////////////////////////////////////////////////////////////////////////////////
  51 |     |     /// VIEWS
  52 |     |     ////////////////////////////////////////////////////////////////////////////////////////////////
  53 |     | 
  54 |     |     function ready() public view returns (bool) {
  55 |     |         return epoch <= IEpochBasedStaking(staking).epoch();
  56 |     |     }
  57 |     | 
  58 |     |     ////////////////////////////////////////////////////////////////////////////////////////////////
  59 |     |     /// OPERATORS
  60 |     |     ////////////////////////////////////////////////////////////////////////////////////////////////
  61 |     | 
  62 |     |     function deposit(address _token, uint256 _amount) external onlyOperators {
  63 |     |         (, , , bool exists, ) = IEpochBasedStaking(staking).rewardData(_token);
  64 |     |         if (!exists) {
  65 |     |             revert ErrInvalidRewardToken();
  66 |     |         }
  67 |     | 
  68 |     |         _token.safeTransferFrom(msg.sender, address(this), _amount);
  69 |     |         balanceOf[_token] += _amount;
  70 |     | 
  71 |     |         _token.safeApprove(staking, balanceOf[_token]);
  72 |     | 
  73 |     |         emit LogRewardAdded(_token, _amount);
  74 |     |     }
  75 |     | 
  76 |     |     function distribute() external onlyOperators {
  77 |     |         if (!ready()) {
  78 |     |             revert ErrNotReady();
  79 |     |         }
  80 |     | 
  81 |     |         uint256 rewardLength = IEpochBasedStaking(staking).rewardTokensLength();
  82 |     | 
  83 |     |         for (uint256 i = 0; i < rewardLength; i++) {
  84 |     |             address reward = IEpochBasedStaking(staking).rewardTokens(i);
  85 |     |             uint256 rewardAmount = balanceOf[reward];
  86 |     | 
  87 |     |             delete balanceOf[reward];
  88 |     | 
  89 |     |             if (rewardAmount > 0) {
  90 |     |                 IEpochBasedStaking(staking).notifyRewardAmount(reward, rewardAmount, minRemainingTime);
  91 |     |             }
  92 |     |         }
  93 |     | 
  94 |     |         epoch = IEpochBasedStaking(staking).nextEpoch();
  95 |     |         emit LogDistributed(epoch);
  96 |     |     }
  97 |     | 
  98 |     |     ////////////////////////////////////////////////////////////////////////////////////////////////
  99 |     |     /// ADMIN
 100 |     |     ////////////////////////////////////////////////////////////////////////////////////////////////
 101 |     | 
 102 |     |     function withdraw(address _token, address _to, uint256 _amount) external onlyOwner {
 103 |     |         _token.safeTransfer(_to, _amount);
 104 |     |         balanceOf[_token] = _token.balanceOf(address(this));
 105 |     |         emit LogWithdraw(_token, _to, _amount);
 106 |     |     }
 107 |     | 
 108 |     |     function setMinRemainingTime(uint256 _minRemainingTime) external onlyOwner {
 109 |     |         emit LogMinRemainingTimeSet(minRemainingTime, _minRemainingTime);
 110 |     |         minRemainingTime = _minRemainingTime;
 111 |     |     }
 112 |     | }
 113 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/GmxV2CauldronOrderAgent.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
   5 |     | import {ICauldronV4GmxV2} from "interfaces/ICauldronV4GmxV2.sol";
   6 |     | import {ICauldronV4} from "interfaces/ICauldronV4.sol";
   7 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   8 |     | import {OperatableV2} from "mixins/OperatableV2.sol";
   9 |     | import {LibClone} from "solady/utils/LibClone.sol";
  10 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
  11 |     | import {IOracle} from "interfaces/IOracle.sol";
  12 |     | import {IGmxV2Deposit, IGmxV2WithdrawalCallbackReceiver, IGmxV2Withdrawal, IGmxV2EventUtils, IGmxV2Market, IGmxDataStore, IGmxV2DepositCallbackReceiver, IGmxReader, IGmxV2DepositHandler, IGmxV2WithdrawalHandler, IGmxV2ExchangeRouter} from "interfaces/IGmxV2.sol";
  13 |     | import {IWETH} from "interfaces/IWETH.sol";
  14 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  15 |     | 
  16 |     | struct GmRouterOrderParams {
  17 |     |     address inputToken;
  18 |     |     bool deposit;
  19 |     |     uint128 inputAmount;
  20 |     |     uint128 executionFee;
  21 |     |     uint128 minOutput;
  22 |     |     uint128 minOutLong; // 0 for deposit
  23 |     | }
  24 |     | 
  25 |     | interface IGmCauldronOrderAgent {
  26 |     |     function createOrder(address user, GmRouterOrderParams memory params) external payable returns (address order);
  27 |     | 
  28 |     |     function setOracle(address market, IOracle oracle) external;
  29 |     | 
  30 |     |     function oracles(address market) external view returns (IOracle);
  31 |     | 
  32 |     |     function callbackGasLimit() external view returns (uint256);
  33 |     | 
  34 |     |     function setCallbackGasLimit(uint256 _callbackGasLimit) external;
  35 |     | }
  36 |     | 
  37 |     | interface IGmRouterOrder {
  38 |     |     function init(address _cauldron, address user, GmRouterOrderParams memory _params) external payable;
  39 |     | 
  40 |     |     /// @notice cancelling an order
  41 |     |     function cancelOrder() external;
  42 |     | 
  43 |     |     function getExchangeRates() external view returns (uint256 shortExchangeRate, uint256 marketExchangeRate);
  44 |     | 
  45 |     |     /// @notice withdraw from an order that does not end in addition of collateral.
  46 |     |     function withdrawFromOrder(address token, address to, uint256 amount, bool closeOrder) external;
  47 |     | 
  48 |     |     /// @notice the value of the order in collateral terms
  49 |     |     function orderValueInCollateral() external view returns (uint256);
  50 |     | 
  51 |     |     /// @notice sends a specific value to recipient
  52 |     |     function sendValueInCollateral(address recipient, uint256 share) external;
  53 |     | 
  54 |     |     function isActive() external view returns (bool);
  55 |     | 
  56 |     |     function orderKey() external view returns (bytes32);
  57 |     | 
  58 |     |     function orderAgent() external view returns (IGmCauldronOrderAgent);
  59 |     | }
  60 |     | 
  61 |     | contract GmxV2CauldronRouterOrder is IGmRouterOrder, IGmxV2DepositCallbackReceiver, IGmxV2WithdrawalCallbackReceiver {
  62 |     |     using SafeTransferLib for address;
  63 |     |     using BoringERC20 for IERC20;
  64 |     | 
  65 |     |     error ErrFinalized();
  66 |     |     error ErrNotOwner();
  67 |     |     error ErrAlreadyInitialized();
  68 |     |     error ErrMinOutTooLarge();
  69 |     |     error ErrUnauthorized();
  70 |     |     error ErrWrongUser();
  71 |     |     error ErrIncorrectInitialization();
  72 |     |     error ErrExecuteDepositsDisabled();
  73 |     |     error ErrExecuteWithdrawalsDisabled();
  74 |     | 
  75 |     |     event LogRefundWETH(address indexed user, uint256 amount);
  76 |     | 
  77 |     |     bytes32 public constant DEPOSIT_LIST = keccak256(abi.encode("DEPOSIT_LIST"));
  78 |     |     bytes32 public constant WITHDRAWAL_LIST = keccak256(abi.encode("WITHDRAWAL_LIST"));
  79 |     |     bytes32 public constant ORDER_KEEPER = keccak256(abi.encode("ORDER_KEEPER"));
  80 |     |     bytes32 public constant EXECUTE_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode("EXECUTE_DEPOSIT_FEATURE_DISABLED"));
  81 |     |     bytes32 public constant EXECUTE_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode("EXECUTE_WITHDRAWAL_FEATURE_DISABLED"));
  82 |     | 
  83 |     |     IGmxV2ExchangeRouter public immutable GMX_ROUTER;
  84 |     |     IGmxReader public immutable GMX_READER;
  85 |     |     IGmxDataStore public immutable DATASTORE;
  86 |     |     address public immutable DEPOSIT_VAULT;
  87 |     |     address public immutable WITHDRAWAL_VAULT;
  88 |     |     address public immutable SYNTHETICS_ROUTER;
  89 |     |     IWETH public immutable WETH;
  90 |     |     address public immutable REFUND_TO;
  91 |     |     IBentoBoxV1 public immutable degenBox;
  92 |     | 
  93 |     |     address public cauldron;
  94 |     |     address public user;
  95 |     |     bytes32 public orderKey;
  96 |     |     address public market;
  97 |     |     address public shortToken;
  98 |     |     IOracle public oracle;
  99 |     |     uint128 public inputAmount;
 100 |     |     uint128 public minOut;
 101 |     |     uint128 public minOutLong;
 102 |     |     uint128 public oracleDecimalScale;
 103 |     | 
 104 |     |     bool public depositType;
 105 |     |     bool public isHomogenousMarket;
 106 |     |     IGmCauldronOrderAgent public orderAgent;
 107 |     | 
 108 |     |     modifier onlyCauldron() virtual {
 109 |     |         if (msg.sender != cauldron) {
 110 |     |             revert ErrNotOwner();
 111 |     |         }
 112 |     |         _;
 113 |     |     }
 114 |     | 
 115 |     |     modifier onlyDepositHandler() {
 116 |     |         if (msg.sender != address(GMX_ROUTER.depositHandler())) {
 117 |     |             revert ErrUnauthorized();
 118 |     |         }
 119 |     |         _;
 120 |     |     }
 121 |     | 
 122 |     |     modifier onlyWithdrawalHandler() {
 123 |     |         if (msg.sender != address(GMX_ROUTER.withdrawalHandler())) {
 124 |     |             revert ErrUnauthorized();
 125 |     |         }
 126 |     |         _;
 127 |     |     }
 128 |     | 
 129 |     |     receive() external payable virtual {
 130 |     |         (bool success, ) = REFUND_TO.call{value: msg.value}("");
 131 |     | 
 132 |     |         // ignore failures
 133 |     |         if (!success) {
 134 |     |             return;
 135 |     |         }
 136 |     |     }
 137 |     | 
 138 |     |     constructor(
 139 |     |         IBentoBoxV1 _degenBox,
 140 |     |         IGmxV2ExchangeRouter _gmxRouter,
 141 |     |         address _syntheticsRouter,
 142 |     |         IGmxReader _gmxReader,
 143 |     |         IWETH _weth,
 144 |     |         address _refundTo
 145 |     |     ) {
 146 |     |         degenBox = _degenBox;
 147 |     |         GMX_ROUTER = _gmxRouter;
 148 |     |         GMX_READER = _gmxReader;
 149 |     |         SYNTHETICS_ROUTER = _syntheticsRouter;
 150 |     |         DATASTORE = IGmxDataStore(_gmxRouter.dataStore());
 151 |     |         DEPOSIT_VAULT = IGmxV2DepositHandler(_gmxRouter.depositHandler()).depositVault();
 152 |     |         WITHDRAWAL_VAULT = IGmxV2WithdrawalHandler(_gmxRouter.withdrawalHandler()).withdrawalVault();
 153 |     |         WETH = _weth;
 154 |     |         REFUND_TO = _refundTo;
 155 |     |     }
 156 |     | 
 157 |     |     function init(address _cauldron, address _user, GmRouterOrderParams memory params) external payable {
 158 |     |         if (cauldron != address(0)) {
 159 |     |             revert ErrAlreadyInitialized();
 160 |     |         }
 161 |     | 
 162 |     |         if (_cauldron == address(0)) {
 163 |     |             revert ErrIncorrectInitialization();
 164 |     |         }
 165 |     | 
 166 |     |         orderAgent = GmxV2CauldronOrderAgent(msg.sender);
 167 |     |         cauldron = _cauldron;
 168 |     |         user = _user;
 169 |     | 
 170 |     |         market = address(ICauldronV4(_cauldron).collateral());
 171 |     |         IGmxV2Market.Props memory props = GMX_READER.getMarket(address(DATASTORE), market);
 172 |     | 
 173 |     |         inputAmount = params.inputAmount;
 174 |     |         minOut = params.minOutput;
 175 |     |         minOutLong = params.minOutLong;
 176 |     | 
 177 |     |         if (uint256(params.minOutput) + uint256(params.minOutLong) > type(uint128).max) {
 178 |     |             revert ErrMinOutTooLarge();
 179 |     |         }
 180 |     | 
 181 |     |         isHomogenousMarket = props.longToken == props.shortToken;
 182 |     |         shortToken = props.shortToken;
 183 |     |         depositType = params.deposit;
 184 |     | 
 185 |     |         oracleDecimalScale = uint128(10 ** (orderAgent.oracles(shortToken).decimals() + IERC20(shortToken).safeDecimals()));
 186 |     | 
 187 |     |         if (depositType) {
 188 |     |             if (isDepositExecutionDisabled()) {
 189 |     |                 revert ErrExecuteDepositsDisabled();
 190 |     |             }
 191 |     | 
 192 |     |             shortToken.safeApprove(address(SYNTHETICS_ROUTER), params.inputAmount);
 193 |     |             orderKey = _createDepositOrder(
 194 |     |                 market,
 195 |     |                 props.shortToken,
 196 |     |                 props.longToken,
 197 |     |                 params.inputAmount,
 198 |     |                 params.minOutput,
 199 |     |                 params.executionFee
 200 |     |             );
 201 |     |         } else {
 202 |     |             if (isWithdrawalExecutionDisabled()) {
 203 |     |                 revert ErrExecuteWithdrawalsDisabled();
 204 |     |             }
 205 |     |             
 206 |     |             market.safeApprove(address(SYNTHETICS_ROUTER), params.inputAmount);
 207 |     |             orderKey = _createWithdrawalOrder(params.inputAmount, params.minOutput, params.minOutLong, params.executionFee);
 208 |     |         }
 209 |     |     }
 210 |     | 
 211 |     |     function isDepositExecutionDisabled() public view returns (bool) {
 212 |     |         bytes32 depositExecutionDisabledKey = keccak256(abi.encode(EXECUTE_DEPOSIT_FEATURE_DISABLED, GMX_ROUTER.depositHandler()));
 213 |     |         return DATASTORE.getBool(depositExecutionDisabledKey);
 214 |     |     }
 215 |     | 
 216 |     |     function isWithdrawalExecutionDisabled() public view returns (bool) {
 217 |     |         bytes32 withdrawalExecutionDisabledKey = keccak256(abi.encode(EXECUTE_WITHDRAWAL_FEATURE_DISABLED, GMX_ROUTER.withdrawalHandler()));
 218 |     |         return DATASTORE.getBool(withdrawalExecutionDisabledKey);
 219 |     |     }
 220 |     | 
 221 |     |     function cancelOrder() external onlyCauldron {
 222 |     |         if (depositType) {
 223 |     |             GMX_ROUTER.cancelDeposit(orderKey);
 224 |     |         } else {
 225 |     |             GMX_ROUTER.cancelWithdrawal(orderKey);
 226 |     |         }
 227 |     |     }
 228 |     | 
 229 |     |     function withdrawFromOrder(address token, address to, uint256 amount, bool) external onlyCauldron {
 230 |     |         token.safeTransfer(address(degenBox), amount);
 231 |     |         degenBox.deposit(IERC20(token), address(degenBox), to, amount, 0);
 232 |     | 
 233 |     |         uint256 balance = shortToken.balanceOf(address(this));
 234 |     |         if (balance > 0) {
 235 |     |             shortToken.safeTransfer(address(degenBox), balance);
 236 |     |             degenBox.deposit(IERC20(shortToken), address(degenBox), user, balance, 0);
 237 |     |         }
 238 |     |         ICauldronV4GmxV2(cauldron).closeOrder(user);
 239 |     |     }
 240 |     | 
 241 |     |     function sendValueInCollateral(address recipient, uint256 shareMarketToken) public onlyCauldron {
 242 |     |         (uint256 shortExchangeRate, uint256 marketExchangeRate) = getExchangeRates();
 243 |     | 
 244 |     |         /// @dev For oracleDecimalScale = 1e14:
 245 |     |         /// (18 decimals + 14 decimals) - (8 decimals + 18 decimals) = 6 decimals
 246 |     |         ///
 247 |     |         /// Ex:
 248 |     |         /// - 100,000 GM token where 1 GM = 0.5 USD each
 249 |     |         /// - 1 USDC = 0.997 USD
 250 |     |         /// - 99700000 is the chainlink oracle USDC price in USD with 8 decimals
 251 |     |         /// - 2e18 is how many GM tokens 1 USD can buy
 252 |     |         /// - 1e14 is 8 decimals for the chainlink oracle + 6 decimals for USDC
 253 |     |         /// (100_000e18 * 1e14) / (99700000 *  2e18) = ≈50150.45e6 USDC
 254 |     |         uint256 amountShortToken = (degenBox.toAmount(IERC20(market), shareMarketToken, true) * oracleDecimalScale) /
 255 |     |             (shortExchangeRate * marketExchangeRate);
 256 |     | 
 257 |     |         shortToken.safeTransfer(address(degenBox), amountShortToken);
 258 |     |         degenBox.deposit(IERC20(shortToken), address(degenBox), recipient, amountShortToken, 0);
 259 |     |     }
 260 |     | 
 261 |     |     /// @notice the value of the order in collateral terms
 262 |     |     function orderValueInCollateral() public view returns (uint256 result) {
 263 |     |         (uint256 shortExchangeRate, uint256 marketExchangeRate) = getExchangeRates();
 264 |     | 
 265 |     |         /// @dev short exchangeRate is in USD in native decimals
 266 |     |         /// marketExchangeRate is in inverse similar to other cauldron oracles 1e36 / (price in 18 decimals)
 267 |     |         /// Ex:
 268 |     |         /// - input is 100,000 USDC
 269 |     |         /// - 1 USDC = 0.997 USD
 270 |     |         /// - 99700000 is the chainlink oracle USDC price in USD with 8 decimals
 271 |     |         /// - 2e18 is how many GM tokens 1 USD can buy
 272 |     |         ///  (100_000e6 * 99700000 * 2e18) / 1e14 = ≈199400e18 GM tokens
 273 |     |         if (depositType) {
 274 |     |             uint256 marketTokenFromValue = (inputAmount * shortExchangeRate * marketExchangeRate) / oracleDecimalScale;
 275 |     |             result = minOut < marketTokenFromValue ? minOut : marketTokenFromValue;
 276 |     |         } else {
 277 |     |             uint256 marketTokenFromValue = ((minOut + minOutLong) * shortExchangeRate * marketExchangeRate) / oracleDecimalScale;
 278 |     |             result = inputAmount < marketTokenFromValue ? inputAmount : marketTokenFromValue;
 279 |     |         }
 280 |     |     }
 281 |     | 
 282 |     |     function getExchangeRates() public view returns (uint256 shortExchangeRate, uint256 marketExchangeRate) {
 283 |     |         (, shortExchangeRate) = orderAgent.oracles(shortToken).peek(bytes(""));
 284 |     |         (, marketExchangeRate) = orderAgent.oracles(market).peek(bytes(""));
 285 |     |     }
 286 |     | 
 287 |     |     function isActive() public view returns (bool) {
 288 |     |         return DATASTORE.containsBytes32(DEPOSIT_LIST, orderKey) || DATASTORE.containsBytes32(WITHDRAWAL_LIST, orderKey);
 289 |     |     }
 290 |     | 
 291 |     |     function _createDepositOrder(
 292 |     |         address _gmToken,
 293 |     |         address _inputToken,
 294 |     |         address _underlyingToken,
 295 |     |         uint128 _usdcAmount,
 296 |     |         uint128 _minGmTokenOutput,
 297 |     |         uint128 _executionFee
 298 |     |     ) private returns (bytes32) {
 299 |     |         GMX_ROUTER.sendWnt{value: _executionFee}(address(DEPOSIT_VAULT), _executionFee);
 300 |     |         GMX_ROUTER.sendTokens(_inputToken, address(DEPOSIT_VAULT), _usdcAmount);
 301 |     | 
 302 |     |         address[] memory emptyPath = new address[](0);
 303 |     | 
 304 |     |         IGmxV2Deposit.CreateDepositParams memory params = IGmxV2Deposit.CreateDepositParams({
 305 |     |             receiver: address(this),
 306 |     |             callbackContract: address(this),
 307 |     |             uiFeeReceiver: address(0),
 308 |     |             market: _gmToken,
 309 |     |             initialLongToken: _underlyingToken,
 310 |     |             initialShortToken: _inputToken,
 311 |     |             longTokenSwapPath: emptyPath,
 312 |     |             shortTokenSwapPath: emptyPath,
 313 |     |             minMarketTokens: _minGmTokenOutput,
 314 |     |             shouldUnwrapNativeToken: false,
 315 |     |             executionFee: _executionFee,
 316 |     |             callbackGasLimit: orderAgent.callbackGasLimit()
 317 |     |         });
 318 |     | 
 319 |     |         return GMX_ROUTER.createDeposit(params);
 320 |     |     }
 321 |     | 
 322 |     |     function _createWithdrawalOrder(
 323 |     |         uint128 _inputAmount,
 324 |     |         uint128 _minUsdcOutput,
 325 |     |         uint128 _minOutLong,
 326 |     |         uint128 _executionFee
 327 |     |     ) private returns (bytes32) {
 328 |     |         GMX_ROUTER.sendWnt{value: _executionFee}(address(WITHDRAWAL_VAULT), _executionFee);
 329 |     |         GMX_ROUTER.sendTokens(market, address(WITHDRAWAL_VAULT), _inputAmount);
 330 |     | 
 331 |     |         address[] memory path = new address[](1);
 332 |     |         path[0] = market;
 333 |     | 
 334 |     |         address[] memory emptyPath = new address[](0);
 335 |     | 
 336 |     |         IGmxV2Withdrawal.CreateWithdrawalParams memory params = IGmxV2Withdrawal.CreateWithdrawalParams({
 337 |     |             receiver: address(this),
 338 |     |             callbackContract: address(this),
 339 |     |             uiFeeReceiver: address(0),
 340 |     |             market: market,
 341 |     |             longTokenSwapPath: isHomogenousMarket ? emptyPath : path,
 342 |     |             shortTokenSwapPath: emptyPath,
 343 |     |             minLongTokenAmount: _minOutLong,
 344 |     |             minShortTokenAmount: _minUsdcOutput,
 345 |     |             shouldUnwrapNativeToken: false,
 346 |     |             executionFee: _executionFee,
 347 |     |             callbackGasLimit: orderAgent.callbackGasLimit()
 348 |     |         });
 349 |     | 
 350 |     |         return GMX_ROUTER.createWithdrawal(params);
 351 |     |     }
 352 |     | 
 353 |     |     function _depositMarketTokensAsCollateral() internal {
 354 |     |         uint256 received = IERC20(market).balanceOf(address(this));
 355 |     |         market.safeTransfer(address(degenBox), received);
 356 |     |         (, uint256 share) = degenBox.deposit(IERC20(market), address(degenBox), cauldron, received, 0);
 357 |     |         ICauldronV4(cauldron).addCollateral(user, true, share);
 358 |     |         ICauldronV4GmxV2(cauldron).closeOrder(user);
 359 |     |     }
 360 |     | 
 361 |     |     function afterDepositExecution(
 362 |     |         bytes32 /*key*/,
 363 |     |         IGmxV2Deposit.Props memory deposit,
 364 |     |         IGmxV2EventUtils.EventLogData memory /*eventData*/
 365 |     |     ) external override onlyDepositHandler {
 366 |     |         // verify that the deposit was from this address
 367 |     |         if (deposit.addresses.account != address(this)) {
 368 |     |             revert ErrWrongUser();
 369 |     |         }
 370 |     |         _depositMarketTokensAsCollateral();
 371 |     |     }
 372 |     | 
 373 |     |     function afterWithdrawalCancellation(
 374 |     |         bytes32 /*key*/,
 375 |     |         IGmxV2Withdrawal.Props memory withdrawal,
 376 |     |         IGmxV2EventUtils.EventLogData memory /*eventData*/
 377 |     |     ) external override onlyWithdrawalHandler {
 378 |     |         // verify that the withdrawal was from this address
 379 |     |         if (withdrawal.addresses.account != address(this)) {
 380 |     |             revert ErrWrongUser();
 381 |     |         }
 382 |     |         _depositMarketTokensAsCollateral();
 383 |     |     }
 384 |     | 
 385 |     |     function afterDepositCancellation(
 386 |     |         bytes32 key,
 387 |     |         IGmxV2Deposit.Props memory deposit,
 388 |     |         IGmxV2EventUtils.EventLogData memory eventData
 389 |     |     ) external override {}
 390 |     | 
 391 |     |     function afterWithdrawalExecution(
 392 |     |         bytes32 key,
 393 |     |         IGmxV2Withdrawal.Props memory withdrawal,
 394 |     |         IGmxV2EventUtils.EventLogData memory eventData
 395 |     |     ) external override {}
 396 |     | }
 397 |     | 
 398 |     | contract GmxV2CauldronOrderAgent is IGmCauldronOrderAgent, OperatableV2 {
 399 |     |     using SafeTransferLib for address;
 400 |     | 
 401 |     |     event LogSetOracle(address indexed market, IOracle indexed oracle);
 402 |     |     event LogOrderCreated(address indexed order, address indexed user, GmRouterOrderParams params);
 403 |     |     event LogCallbackGasLimit(uint256 previous, uint256 current);
 404 |     | 
 405 |     |     error ErrInvalidParams();
 406 |     | 
 407 |     |     address public immutable orderImplementation;
 408 |     |     IBentoBoxV1 public immutable degenBox;
 409 |     |     mapping(address => IOracle) public oracles;
 410 |     | 
 411 |     |     uint256 public callbackGasLimit = 1_000_000;
 412 |     | 
 413 |     |     constructor(IBentoBoxV1 _degenBox, address _orderImplementation, address _owner) OperatableV2(_owner) {
 414 |     |         degenBox = _degenBox;
 415 |     |         orderImplementation = _orderImplementation;
 416 |     |     }
 417 |     | 
 418 |     |     function setCallbackGasLimit(uint256 _callbackGasLimit) external onlyOwner {
 419 |     |         emit LogCallbackGasLimit(callbackGasLimit, _callbackGasLimit);
 420 |     |         callbackGasLimit = _callbackGasLimit;
 421 |     |     }
 422 |     | 
 423 |     |     function setOracle(address market, IOracle oracle) external onlyOwner {
 424 |     |         oracles[market] = oracle;
 425 |     |         emit LogSetOracle(market, oracle);
 426 |     |     }
 427 |     | 
 428 |     |     function createOrder(address user, GmRouterOrderParams memory params) external payable override onlyOperators returns (address order) {
 429 |     |         order = LibClone.clone(orderImplementation);
 430 |     |         degenBox.withdraw(IERC20(params.inputToken), address(this), address(order), params.inputAmount, 0);
 431 |     |         IGmRouterOrder(order).init{value: msg.value}(msg.sender, user, params);
 432 |     | 
 433 |     |         emit LogOrderCreated(order, user, params);
 434 |     |     }
 435 |     | }
 436 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/LiquidationHelper.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {IERC20, ERC20} from "BoringSolidity/ERC20.sol";
   5 |     | import {CauldronLib} from "libraries/CauldronLib.sol";
   6 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
   7 |     | import {ICauldronV2} from "interfaces/ICauldronV2.sol";
   8 |     | import {ICauldronV3} from "interfaces/ICauldronV3.sol";
   9 |     | import {ICauldronV4} from "interfaces/ICauldronV4.sol";
  10 |     | 
  11 |     | /// @title LiquidationHelper
  12 |     | /// @notice Helper contract to liquidate accounts using max borrow amount or a part of it.
  13 |     | /// The required MiM is transferred from the liquidator to the BentoBox in case there's not enough balance
  14 |     | /// inside the user degenbox to cover the liquidation.
  15 |     | contract LiquidationHelper {
  16 |     |     error ErrInvalidCauldronVersion(uint8 cauldronVersion);
  17 |     | 
  18 |     |     ERC20 public mim;
  19 |     | 
  20 |     |     constructor(ERC20 _mim) payable {
  21 |     |         mim = _mim;
  22 |     |     }
  23 |     | 
  24 |     |     function isLiquidatable(ICauldronV2 cauldron, address account) public view returns (bool) {
  25 |     |         return !CauldronLib.isSolvent(cauldron, account);
  26 |     |     }
  27 |     | 
  28 |     |     function previewMaxLiquidation(
  29 |     |         ICauldronV2 cauldron,
  30 |     |         address account
  31 |     |     ) external view returns (bool liquidatable, uint256 requiredMIMAmount, uint256 adjustedBorrowPart, uint256 returnedCollateralAmount) {
  32 |     |         adjustedBorrowPart = cauldron.userBorrowPart(account);
  33 |     |         (liquidatable, requiredMIMAmount, adjustedBorrowPart, returnedCollateralAmount) = previewLiquidation(
  34 |     |             cauldron,
  35 |     |             account,
  36 |     |             adjustedBorrowPart
  37 |     |         );
  38 |     |     }
  39 |     | 
  40 |     |     function previewLiquidation(
  41 |     |         ICauldronV2 cauldron,
  42 |     |         address account,
  43 |     |         uint256 borrowPart
  44 |     |     ) public view returns (bool liquidatable, uint256 requiredMIMAmount, uint256 adjustedBorrowPart, uint256 returnedCollateralAmount) {
  45 |     |         liquidatable = isLiquidatable(cauldron, account);
  46 |     |         (returnedCollateralAmount, adjustedBorrowPart, requiredMIMAmount) = CauldronLib.getLiquidationCollateralAndBorrowAmount(
  47 |     |             ICauldronV2(cauldron),
  48 |     |             account,
  49 |     |             borrowPart
  50 |     |         );
  51 |     |     }
  52 |     | 
  53 |     |     /// @notice Liquidate an account using max borrow amount
  54 |     |     function liquidateMax(
  55 |     |         address cauldron,
  56 |     |         address account,
  57 |     |         uint8 cauldronVersion
  58 |     |     ) external returns (uint256 collateralAmount, uint256 adjustedBorrowPart, uint256 requiredMimAmount) {
  59 |     |         return liquidateMaxTo(cauldron, account, msg.sender, cauldronVersion);
  60 |     |     }
  61 |     | 
  62 |     |     /// @notice Liquidate an account using max borrow amount and send the collateral to a different address
  63 |     |     function liquidateMaxTo(
  64 |     |         address cauldron,
  65 |     |         address account,
  66 |     |         address recipient,
  67 |     |         uint8 cauldronVersion
  68 |     |     ) public returns (uint256 collateralAmount, uint256 adjustedBorrowPart, uint256 requiredMimAmount) {
  69 |     |         uint256 borrowPart = ICauldronV2(cauldron).userBorrowPart(account);
  70 |     |         return liquidateTo(cauldron, account, recipient, borrowPart, cauldronVersion);
  71 |     |     }
  72 |     | 
  73 |     |     /// @notice Liquidate an account using a part of the borrow amount
  74 |     |     function liquidate(
  75 |     |         address cauldron,
  76 |     |         address account,
  77 |     |         uint256 borrowPart,
  78 |     |         uint8 cauldronVersion
  79 |     |     ) external returns (uint256 collateralAmount, uint256 adjustedBorrowPart, uint256 requiredMimAmount) {
  80 |     |         return liquidateTo(cauldron, account, msg.sender, borrowPart, cauldronVersion);
  81 |     |     }
  82 |     | 
  83 |     |     /// @notice Liquidate an account using a part of the borrow amount and send the collateral to a different address
  84 |     |     function liquidateTo(
  85 |     |         address cauldron,
  86 |     |         address account,
  87 |     |         address recipient,
  88 |     |         uint256 borrowPart,
  89 |     |         uint8 cauldronVersion
  90 |     |     ) public returns (uint256 collateralAmount, uint256 adjustedBorrowPart, uint256 requiredMimAmount) {
  91 |     |         (collateralAmount, adjustedBorrowPart, requiredMimAmount) = CauldronLib.getLiquidationCollateralAndBorrowAmount(
  92 |     |             ICauldronV2(cauldron),
  93 |     |             account,
  94 |     |             borrowPart
  95 |     |         );
  96 |     | 
  97 |     |         IBentoBoxV1 box = IBentoBoxV1(ICauldronV2(cauldron).bentoBox());
  98 |     |         uint256 shareMIMBefore = _transferRequiredMIMToCauldronDegenBox(box, requiredMimAmount);
  99 |     | 
 100 |     |         address masterContract = address(ICauldronV2(cauldron).masterContract());
 101 |     |         box.setMasterContractApproval(address(this), masterContract, true, 0, 0, 0);
 102 |     | 
 103 |     |         _liquidate(cauldron, account, adjustedBorrowPart, cauldronVersion);
 104 |     |         box.setMasterContractApproval(address(this), masterContract, false, 0, 0, 0);
 105 |     | 
 106 |     |         // withdraw/refund any MiM left and withdraw collateral to wallet
 107 |     |         box.withdraw(mim, address(this), msg.sender, 0, box.balanceOf(mim, address(this)) - shareMIMBefore);
 108 |     | 
 109 |     |         {
 110 |     |             IERC20 collateral = ICauldronV2(cauldron).collateral();
 111 |     |             box.withdraw(collateral, address(this), recipient, 0, box.balanceOf(collateral, address(this)));
 112 |     |         }
 113 |     |     }
 114 |     | 
 115 |     |     function _liquidate(address cauldron, address account, uint256 borrowPart, uint8 cauldronVersion) internal {
 116 |     |         address[] memory users = new address[](1);
 117 |     |         users[0] = account;
 118 |     |         uint256[] memory maxBorrowParts = new uint256[](1);
 119 |     |         maxBorrowParts[0] = borrowPart;
 120 |     | 
 121 |     |         if (cauldronVersion <= 2) {
 122 |     |             ICauldronV2(cauldron).liquidate(users, maxBorrowParts, address(this), address(0));
 123 |     |         } else if (cauldronVersion >= 3) {
 124 |     |             ICauldronV3(cauldron).liquidate(users, maxBorrowParts, address(this), address(0), new bytes(0));
 125 |     |         } else {
 126 |     |             revert ErrInvalidCauldronVersion(cauldronVersion);
 127 |     |         }
 128 |     |     }
 129 |     | 
 130 |     |     /// @notice Transfer MiM from the liquidator to the BentoBox
 131 |     |     function _transferRequiredMIMToCauldronDegenBox(IBentoBoxV1 box, uint256 amount) internal returns (uint256 shareMIMBefore) {
 132 |     |         shareMIMBefore = box.balanceOf(mim, address(this));
 133 |     |         mim.transferFrom(msg.sender, address(box), amount);
 134 |     |         box.deposit(mim, address(box), address(this), amount, 0);
 135 |     |     }
 136 |     | }
 137 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/LzMulticallSenderReceiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {LzNonblockingApp} from "mixins/LzNonblockingApp.sol";
  5 |     | import {OperatableV3} from "mixins/OperatableV3.sol";
  6 |     | import {Address} from "openzeppelin-contracts/utils/Address.sol";
  7 |     | 
  8 |     | /// @notice A contract that sends and receive calls to and from other chains.
  9 |     | contract LzMulticallSenderReceiver is LzNonblockingApp, OperatableV3 {
 10 |     |     struct Call {
 11 |     |         address to;
 12 |     |         uint256 value;
 13 |     |         bytes data;
 14 |     |     }
 15 |     | 
 16 |     |     event LogSent(uint16 indexed _chainId, Call[] calls);
 17 |     |     event LogReceived(uint16 indexed _srcChainId, Call[] calls);
 18 |     |     event LogNonceExpired(uint16 indexed _chainId, uint64 indexed _nonce);
 19 |     | 
 20 |     |     error ErrArrayLengthMismatch();
 21 |     | 
 22 |     |     mapping(uint16 chainid => uint64 nonce) public noncePerChain;
 23 |     | 
 24 |     |     constructor(address _lzEndpoint, address _owner) LzNonblockingApp(_lzEndpoint, _owner) {}
 25 |     | 
 26 |     |     function send(uint16 _chainId, Call[] memory _calls) external payable onlyOperators {
 27 |     |         _lzSend(_chainId, abi.encode(_calls), payable(msg.sender), address(0), bytes(""), msg.value);
 28 |     |         emit LogSent(_chainId, _calls);
 29 |     |     }
 30 |     | 
 31 |     |     function multisend(uint16[] calldata _chainIds, Call[][] memory _calls, uint256[] memory _nativeFees) external payable onlyOperators {
 32 |     |         if (_chainIds.length != _calls.length) {
 33 |     |             revert ErrArrayLengthMismatch();
 34 |     |         }
 35 |     | 
 36 |     |         for (uint256 i = 0; i < _calls.length; ) {
 37 |     |             _lzSend(_chainIds[i], abi.encode(_calls[i]), payable(msg.sender), address(0), bytes(""), _nativeFees[i]);
 38 |     |             emit LogSent(_chainIds[i], _calls[i]);
 39 |     |             unchecked {
 40 |     |                 ++i;
 41 |     |             }
 42 |     |         }
 43 |     |     }
 44 |     | 
 45 |     |     function _nonblockingLzReceive(uint16 _srcChainId, bytes memory, uint64 nonce, bytes memory _payload, bool) internal override {
 46 |     |         if (nonce < noncePerChain[_srcChainId]) {
 47 |     |             emit LogNonceExpired(_srcChainId, nonce);
 48 |     |             return;
 49 |     |         }
 50 |     | 
 51 |     |         Call[] memory _calls = abi.decode(_payload, (Call[]));
 52 |     |         for (uint256 i = 0; i < _calls.length; ) {
 53 |     |             Address.functionCallWithValue(_calls[i].to, _calls[i].data, _calls[i].value);
 54 |     |             unchecked {
 55 |     |                 ++i;
 56 |     |             }
 57 |     |         }
 58 |     | 
 59 |     |         emit LogReceived(_srcChainId, _calls);
 60 |     |     }
 61 |     | 
 62 |     |     function isOwner(address _account) internal view override returns (bool) {
 63 |     |         return _account == owner;
 64 |     |     }
 65 |     | }
 66 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/LzOFTV2FeeHandler.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {OperatableV2} from "mixins/OperatableV2.sol";
   5 |     | import {ILzFeeHandler, ILzOFTV2} from "interfaces/ILayerZero.sol";
   6 |     | import {IAggregator} from "interfaces/IAggregator.sol";
   7 |     | 
   8 |     | contract LzOFTV2FeeHandler is OperatableV2, ILzFeeHandler {
   9 |     |     event LogFeeWithdrawn(address to, uint256 amount);
  10 |     |     event LogFixedNativeFeeChanged(uint256 previous, uint256 current);
  11 |     |     event LogOracleImplementationChange(IAggregator indexed previous, IAggregator indexed current);
  12 |     |     event LogQuoteTypeChanged(QuoteType previous, QuoteType current);
  13 |     |     event LogFeeToChanged(address indexed previous, address indexed current);
  14 |     |     event LogUsdFeeChanged(uint256 previous, uint256 current);
  15 |     |     event LogFeeCollected(uint256 amount);
  16 |     | 
  17 |     |     error ErrInvalidQuoteType(QuoteType);
  18 |     |     error ErrWithdrawFailed();
  19 |     |     error ErrValueTooLowToCoverFees(uint256);
  20 |     |     error ErrUnauthorizedSender();
  21 |     | 
  22 |     |     modifier onlyFromOFT() {
  23 |     |         if (msg.sender != address(oft)) {
  24 |     |             revert ErrUnauthorizedSender();
  25 |     |         }
  26 |     |         _;
  27 |     |     }
  28 |     | 
  29 |     |     uint256 public constant DEFAULT_USD_FEE = 1e18;
  30 |     | 
  31 |     |     ILzOFTV2 public immutable oft;
  32 |     | 
  33 |     |     address public feeTo;
  34 |     |     IAggregator public aggregator;
  35 |     |     uint256 public fixedNativeFee;
  36 |     |     uint256 public usdFee;
  37 |     |     QuoteType public quoteType = QuoteType.Oracle;
  38 |     | 
  39 |     |     constructor(
  40 |     |         address _owner,
  41 |     |         uint256 _fixedNativeFee,
  42 |     |         address _oft,
  43 |     |         address _aggregator,
  44 |     |         address _feeTo,
  45 |     |         uint8 _quoteType
  46 |     |     ) OperatableV2(_owner) {
  47 |     |         fixedNativeFee = _fixedNativeFee;
  48 |     |         oft = ILzOFTV2(_oft);
  49 |     |         aggregator = IAggregator(_aggregator);
  50 |     |         feeTo = _feeTo;
  51 |     |         quoteType = QuoteType(_quoteType);
  52 |     |         usdFee = DEFAULT_USD_FEE;
  53 |     |     }
  54 |     | 
  55 |     |     receive() external payable {
  56 |     |         emit LogFeeCollected(msg.value);
  57 |     |     }
  58 |     | 
  59 |     |     /************************************************************************
  60 |     |      * Public
  61 |     |      ************************************************************************/
  62 |     |     function withdrawFees() external {
  63 |     |         uint256 balance = address(this).balance;
  64 |     |         (bool success, ) = feeTo.call{value: balance}("");
  65 |     |         if (!success) revert ErrWithdrawFailed();
  66 |     |         emit LogFeeWithdrawn(feeTo, balance);
  67 |     |     }
  68 |     | 
  69 |     |     /************************************************************************
  70 |     |      * Operations
  71 |     |      ************************************************************************/
  72 |     |     function setFixedNativeFee(uint256 _fixedNativeFee) external onlyOperators {
  73 |     |         emit LogFixedNativeFeeChanged(fixedNativeFee, _fixedNativeFee);
  74 |     |         fixedNativeFee = _fixedNativeFee;
  75 |     |     }
  76 |     | 
  77 |     |     function setAggregator(IAggregator _aggregator) external onlyOperators {
  78 |     |         emit LogOracleImplementationChange(aggregator, _aggregator);
  79 |     |         aggregator = _aggregator;
  80 |     |     }
  81 |     | 
  82 |     |     function setUsdFee(uint256 _usdFee) external onlyOperators {
  83 |     |         emit LogUsdFeeChanged(usdFee, _usdFee);
  84 |     |         usdFee = _usdFee;
  85 |     |     }
  86 |     | 
  87 |     |     function setQuoteType(QuoteType _quoteType) external onlyOperators {
  88 |     |         if (_quoteType > QuoteType.Fixed) {
  89 |     |             revert ErrInvalidQuoteType(_quoteType);
  90 |     |         }
  91 |     | 
  92 |     |         emit LogQuoteTypeChanged(quoteType, _quoteType);
  93 |     |         quoteType = _quoteType;
  94 |     |     }
  95 |     | 
  96 |     |     /************************************************************************
  97 |     |      * Owners
  98 |     |      ************************************************************************/
  99 |     |     function setFeeTo(address _feeTo) external onlyOwner {
 100 |     |         emit LogFeeToChanged(feeTo, _feeTo);
 101 |     |         feeTo = _feeTo;
 102 |     |     }
 103 |     | 
 104 |     |     /************************************************************************
 105 |     |      * Views
 106 |     |      ************************************************************************/
 107 |     |     function getFee() public view override returns (uint256 nativeFee) {
 108 |     |         if (quoteType == QuoteType.Oracle) {
 109 |     |             nativeFee = ((10 ** aggregator.decimals()) * usdFee) / uint256(aggregator.latestAnswer());
 110 |     |         } else if (quoteType == QuoteType.Fixed) {
 111 |     |             nativeFee = fixedNativeFee;
 112 |     |         }
 113 |     |     }
 114 |     | }
 115 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/MSpellStaking.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // Inspired by Stable Joe Staking which in turn is derived from the SushiSwap MasterChef contract
   3 |     | 
   4 |     | pragma solidity >=0.8.0;
   5 |     | import {BoringOwnable} from "BoringSolidity/BoringOwnable.sol";
   6 |     | import {SafeTransferLib} from "solmate/utils/SafeTransferLib.sol";
   7 |     | import {ERC20} from "solmate/tokens/ERC20.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @title Magic Spell Staking
  11 |     |  * @author 0xMerlin
  12 |     |  */
  13 |     | contract MSpellStaking is BoringOwnable {
  14 |     |     using SafeTransferLib for ERC20;
  15 |     | 
  16 |     |     /// @notice Info of each user
  17 |     |     struct UserInfo {
  18 |     |         uint128 amount;
  19 |     |         uint128 rewardDebt;
  20 |     |         uint128 lastAdded;
  21 |     |         /**
  22 |     |          * @notice We do some fancy math here. Basically, any point in time, the amount of JOEs
  23 |     |          * entitled to a user but is pending to be distributed is:
  24 |     |          *
  25 |     |          *   pending reward = (user.amount * accRewardPerShare) - user.rewardDebt[token]
  26 |     |          *
  27 |     |          * Whenever a user deposits or withdraws SPELL. Here's what happens:
  28 |     |          *   1. accRewardPerShare (and `lastRewardBalance`) gets updated
  29 |     |          *   2. User receives the pending reward sent to his/her address
  30 |     |          *   3. User's `amount` gets updated
  31 |     |          *   4. User's `rewardDebt[token]` gets updated
  32 |     |          */
  33 |     |     }
  34 |     | 
  35 |     |     ERC20 public immutable spell;
  36 |     |     /// @notice Array of tokens that users can claim
  37 |     |     ERC20 public immutable mim;
  38 |     |     /// @notice Last reward balance of `token`
  39 |     |     uint256 public lastRewardBalance;
  40 |     | 
  41 |     |     /// @notice amount of time that the position is locked for.
  42 |     |     uint256 private constant LOCK_TIME = 24 hours;
  43 |     |     bool public toggleLockup;
  44 |     | 
  45 |     |     /// @notice Accumulated `token` rewards per share, scaled to `ACC_REWARD_PER_SHARE_PRECISION`
  46 |     |     uint256 public accRewardPerShare;
  47 |     |     /// @notice The precision of `accRewardPerShare`
  48 |     |     uint256 public constant ACC_REWARD_PER_SHARE_PRECISION = 1e24;
  49 |     | 
  50 |     |     /// @dev Info of each user that stakes SPELL
  51 |     |     mapping(address => UserInfo) public userInfo;
  52 |     | 
  53 |     |     /// @notice Emitted when a user deposits SPELL
  54 |     |     event Deposit(address indexed user, uint256 amount);
  55 |     | 
  56 |     |     /// @notice Emitted when a user withdraws SPELL
  57 |     |     event Withdraw(address indexed user, uint256 amount);
  58 |     | 
  59 |     |     /// @notice Emitted when a user claims reward
  60 |     |     event ClaimReward(address indexed user, uint256 amount);
  61 |     | 
  62 |     |     /// @notice Emitted when a user emergency withdraws its SPELL
  63 |     |     event EmergencyWithdraw(address indexed user, uint256 amount);
  64 |     | 
  65 |     |     /**
  66 |     |      * @notice Initialize a new mSpellStaking contract
  67 |     |      * @dev This contract needs to receive an ERC20 `_rewardToken` in order to distribute them
  68 |     |      * (with MoneyMaker in our case)
  69 |     |      * @param _mim The address of the MIM token
  70 |     |      * @param _spell The address of the SPELL token
  71 |     |      */
  72 |     |     constructor(ERC20 _mim, ERC20 _spell) {
  73 |     |         require(address(_mim) != address(0), "mSpellStaking: reward token can't be address(0)");
  74 |     |         require(address(_spell) != address(0), "mSpellStaking: spell can't be address(0)");
  75 |     | 
  76 |     |         spell = _spell;
  77 |     |         toggleLockup = true;
  78 |     | 
  79 |     |         mim = _mim;
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @notice Deposit SPELL for reward token allocation
  84 |     |      * @param _amount The amount of SPELL to deposit
  85 |     |      */
  86 |     |     function deposit(uint256 _amount) external {
  87 |     |         UserInfo storage user = userInfo[msg.sender];
  88 |     | 
  89 |     |         uint256 _previousAmount = user.amount;
  90 |     |         uint256 _newAmount = user.amount + _amount;
  91 |     |         user.amount = uint128(_newAmount);
  92 |     |         user.lastAdded = uint128(block.timestamp);
  93 |     | 
  94 |     |         updateReward();
  95 |     | 
  96 |     |         uint256 _previousRewardDebt = user.rewardDebt;
  97 |     |         user.rewardDebt = uint128((_newAmount * accRewardPerShare) / ACC_REWARD_PER_SHARE_PRECISION);
  98 |     | 
  99 |     |         if (_previousAmount != 0) {
 100 |     |             uint256 _pending = (_previousAmount * accRewardPerShare) / ACC_REWARD_PER_SHARE_PRECISION - _previousRewardDebt;
 101 |     |             if (_pending != 0) {
 102 |     |                 safeTokenTransfer(mim, msg.sender, _pending);
 103 |     |                 emit ClaimReward(msg.sender, _pending);
 104 |     |             }
 105 |     |         }
 106 |     | 
 107 |     |         spell.safeTransferFrom(msg.sender, address(this), _amount);
 108 |     |         emit Deposit(msg.sender, _amount);
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @notice View function to see pending reward token on frontend
 113 |     |      * @param _user The address of the user
 114 |     |      * @return `_user`'s pending reward token
 115 |     |      */
 116 |     |     function pendingReward(address _user) external view returns (uint256) {
 117 |     |         UserInfo storage user = userInfo[_user];
 118 |     |         uint256 _totalSpell = spell.balanceOf(address(this));
 119 |     |         uint256 _accRewardTokenPerShare = accRewardPerShare;
 120 |     | 
 121 |     |         uint256 _rewardBalance = mim.balanceOf(address(this));
 122 |     | 
 123 |     |         if (_rewardBalance != lastRewardBalance && _totalSpell != 0) {
 124 |     |             uint256 _accruedReward = _rewardBalance - lastRewardBalance;
 125 |     |             _accRewardTokenPerShare = _accRewardTokenPerShare + (_accruedReward * ACC_REWARD_PER_SHARE_PRECISION) / _totalSpell;
 126 |     |         }
 127 |     |         return (user.amount * _accRewardTokenPerShare) / ACC_REWARD_PER_SHARE_PRECISION - user.rewardDebt;
 128 |     |     }
 129 |     | 
 130 |     |     /**
 131 |     |      * @notice Withdraw SPELL and harvest the rewards
 132 |     |      * @param _amount The amount of SPELL to withdraw
 133 |     |      */
 134 |     |     function withdraw(uint256 _amount) external {
 135 |     |         UserInfo storage user = userInfo[msg.sender];
 136 |     | 
 137 |     |         require(!toggleLockup || user.lastAdded + LOCK_TIME < block.timestamp, "mSpell: Wait for LockUp");
 138 |     | 
 139 |     |         uint256 _previousAmount = user.amount;
 140 |     |         uint256 _newAmount = user.amount - _amount;
 141 |     |         user.amount = uint128(_newAmount);
 142 |     | 
 143 |     |         updateReward();
 144 |     | 
 145 |     |         uint256 _pending = (_previousAmount * accRewardPerShare) / ACC_REWARD_PER_SHARE_PRECISION - user.rewardDebt;
 146 |     |         user.rewardDebt = uint128((_newAmount * accRewardPerShare) / ACC_REWARD_PER_SHARE_PRECISION);
 147 |     | 
 148 |     |         if (_pending != 0) {
 149 |     |             safeTokenTransfer(mim, msg.sender, _pending);
 150 |     |             emit ClaimReward(msg.sender, _pending);
 151 |     |         }
 152 |     | 
 153 |     |         spell.safeTransfer(msg.sender, _amount);
 154 |     |         emit Withdraw(msg.sender, _amount);
 155 |     |     }
 156 |     | 
 157 |     |     /**
 158 |     |      * @notice Withdraw without caring about rewards. EMERGENCY ONLY
 159 |     |      */
 160 |     |     function emergencyWithdraw() external {
 161 |     |         UserInfo storage user = userInfo[msg.sender];
 162 |     | 
 163 |     |         require(!toggleLockup || user.lastAdded + LOCK_TIME < block.timestamp, "mSpell: Wait for LockUp");
 164 |     | 
 165 |     |         uint256 _amount = user.amount;
 166 |     | 
 167 |     |         user.amount = 0;
 168 |     |         user.rewardDebt = 0;
 169 |     | 
 170 |     |         spell.safeTransfer(msg.sender, _amount);
 171 |     |         emit EmergencyWithdraw(msg.sender, _amount);
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @notice Update reward variables
 176 |     |      * @dev Needs to be called before any deposit or withdrawal
 177 |     |      */
 178 |     |     function updateReward() public {
 179 |     |         uint256 _rewardBalance = mim.balanceOf(address(this));
 180 |     |         uint256 _totalSpell = spell.balanceOf(address(this));
 181 |     | 
 182 |     |         // Did mSpellStaking receive any token
 183 |     |         if (_rewardBalance == lastRewardBalance || _totalSpell == 0) {
 184 |     |             return;
 185 |     |         }
 186 |     | 
 187 |     |         uint256 _accruedReward = _rewardBalance - lastRewardBalance;
 188 |     | 
 189 |     |         accRewardPerShare = accRewardPerShare + (_accruedReward * ACC_REWARD_PER_SHARE_PRECISION) / _totalSpell;
 190 |     |         lastRewardBalance = _rewardBalance;
 191 |     |     }
 192 |     | 
 193 |     |     /**
 194 |     |      * @notice Safe token transfer function, just in case if rounding error
 195 |     |      * causes pool to not have enough reward tokens
 196 |     |      * @param _token The address of then token to transfer
 197 |     |      * @param _to The address that will receive `_amount` `rewardToken`
 198 |     |      * @param _amount The amount to send to `_to`
 199 |     |      */
 200 |     |     function safeTokenTransfer(ERC20 _token, address _to, uint256 _amount) internal {
 201 |     |         uint256 _rewardBalance = _token.balanceOf(address(this));
 202 |     | 
 203 |     |         if (_amount > _rewardBalance) {
 204 |     |             lastRewardBalance = lastRewardBalance - _rewardBalance;
 205 |     |             _token.safeTransfer(_to, _rewardBalance);
 206 |     |         } else {
 207 |     |             lastRewardBalance = lastRewardBalance - _amount;
 208 |     |             _token.safeTransfer(_to, _amount);
 209 |     |         }
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @notice Allows to enable and disable the lockup
 214 |     |      * @param status The new lockup status
 215 |     |      */
 216 |     | 
 217 |     |     function toggleLockUp(bool status) external onlyOwner {
 218 |     |         toggleLockup = status;
 219 |     |     }
 220 |     | }
 221 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/MagicCurveLpHarvestor.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   5 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
   6 |     | import {Rebase} from "BoringSolidity/libraries/BoringRebase.sol";
   7 |     | import {SafeApproveLib} from "libraries/SafeApproveLib.sol";
   8 |     | import {MathLib} from "libraries/MathLib.sol";
   9 |     | import {Operatable} from "mixins/Operatable.sol";
  10 |     | import {FeeCollectable} from "mixins/FeeCollectable.sol";
  11 |     | import {IMagicCurveLpRewardHandler} from "interfaces/IMagicCurveLpRewardHandler.sol";
  12 |     | import {IERC4626} from "interfaces/IERC4626.sol";
  13 |     | import {ICurveRewardGauge} from "interfaces/ICurveRewardGauge.sol";
  14 |     | import {ICurvePool} from "interfaces/ICurvePool.sol";
  15 |     | 
  16 |     | /// @notice Contract to harvest rewards from the staking contract and distribute them to the vault
  17 |     | contract MagicCurveLpHarvestor is Operatable, FeeCollectable {
  18 |     |     using BoringERC20 for IERC20;
  19 |     |     using SafeApproveLib for IERC20;
  20 |     | 
  21 |     |     error ErrSwapFailed();
  22 |     |     event LogFeeParametersChanged(address indexed feeCollector, uint16 feeAmount);
  23 |     |     event LogExchangeRouterChanged(address indexed previous, address indexed current);
  24 |     |     event LogHarvest(uint256 total, uint256 amount, uint256 fee);
  25 |     | 
  26 |     |     /// @notice Vault to harvest rewards from and compound
  27 |     |     IERC4626 public immutable vault;
  28 |     | 
  29 |     |     /// @notice Reward token to harvest
  30 |     |     IERC20 public immutable rewardToken;
  31 |     | 
  32 |     |     /// @notice Number of coins in the pool
  33 |     |     uint8 public immutable poolNumCoins;
  34 |     | 
  35 |     |     /// @notice Index of the token to one side liquidity to the pool
  36 |     |     uint8 public immutable poolTokenInIndex;
  37 |     | 
  38 |     |     /// @notice Exchange router to swap rewards
  39 |     |     address public exchangeRouter;
  40 |     | 
  41 |     |     /// @notice Last time the harvest happened
  42 |     |     uint64 public lastExecution;
  43 |     | 
  44 |     |     /// @param _rewardToken Reward token to harvest
  45 |     |     constructor(IERC20 _rewardToken, uint8 _poolNumCoins, uint8 _poolTokenInIndex, IERC4626 _vault) {
  46 |     |         rewardToken = _rewardToken;
  47 |     |         poolNumCoins = _poolNumCoins;
  48 |     |         poolTokenInIndex = _poolTokenInIndex;
  49 |     |         vault = _vault;
  50 |     |     }
  51 |     | 
  52 |     |     /// @notice Returns true when the caller is the fee operator
  53 |     |     function isFeeOperator(address account) public view override returns (bool) {
  54 |     |         return account == owner;
  55 |     |     }
  56 |     | 
  57 |     |     /// @notice Returns the number of rewards amount from the staking contract
  58 |     |     function claimable() public view returns (uint256) {
  59 |     |         ICurveRewardGauge staking = IMagicCurveLpRewardHandler(address(vault)).staking();
  60 |     |         return staking.claimable_reward(address(vault), address(rewardToken));
  61 |     |     }
  62 |     | 
  63 |     |     /// @notice Returns the total amount of rewards in the contract (including the staking contract)
  64 |     |     function totalRewardsBalanceAfterClaiming() external view returns (uint256) {
  65 |     |         return claimable() + rewardToken.balanceOf(address(this));
  66 |     |     }
  67 |     | 
  68 |     |     /// @notice Harvests rewards from the staking contract and distributes them to the vault
  69 |     |     /// @param minLp Minimum amount of LP tokens to mint otherwise revert
  70 |     |     /// @param tokenIn Token to swap rewards to and used to mint LP tokens
  71 |     |     /// @param maxAmountIn Maximum amount of tokenIn to swap
  72 |     |     /// @param swapData exchange router data for the swap
  73 |     |     function run(uint256 minLp, IERC20 tokenIn, uint256 maxAmountIn, bytes memory swapData) external onlyOperators {
  74 |     |         IMagicCurveLpRewardHandler(address(vault)).harvest(address(this));
  75 |     | 
  76 |     |         // wKAVA -> USDT
  77 |     |         (bool success, ) = exchangeRouter.call(swapData);
  78 |     |         if (!success) {
  79 |     |             revert ErrSwapFailed();
  80 |     |         }
  81 |     |         uint256 amountIn = MathLib.min(tokenIn.balanceOf(address(this)), maxAmountIn);
  82 |     | 
  83 |     |         if (amountIn > 0) {
  84 |     |             _compoundFromToken(tokenIn, amountIn, minLp);
  85 |     |         }
  86 |     |     }
  87 |     | 
  88 |     |     /// @notice Harvests rewards from the staking contract and distributes them to the vault
  89 |     |     function compoundFromToken(IERC20 tokenIn, uint256 amount, uint256 minLp) external onlyOperators {
  90 |     |         _compoundFromToken(tokenIn, amount, minLp);
  91 |     |     }
  92 |     | 
  93 |     |     /// @notice Changes the allowance of the reward token to the staking contract
  94 |     |     function setLiquidityPoolAllowance(address pool, IERC20 token, uint256 amount) external onlyOwner {
  95 |     |         token.approve(pool, amount);
  96 |     |     }
  97 |     | 
  98 |     |     /// @notice Changes the allowance of the LLP tokens to the vault for `distributeRewards`
  99 |     |     function setVaultAssetAllowance(uint256 amount) external onlyOwner {
 100 |     |         IERC20 asset = vault.asset();
 101 |     |         asset.approve(address(vault), amount);
 102 |     |     }
 103 |     | 
 104 |     |     /// @notice Changes the exchange router to swap the rewards to
 105 |     |     function setExchangeRouter(address _exchangeRouter) external onlyOwner {
 106 |     |         if (exchangeRouter != address(0)) {
 107 |     |             rewardToken.approve(exchangeRouter, 0);
 108 |     |         }
 109 |     | 
 110 |     |         emit LogExchangeRouterChanged(exchangeRouter, _exchangeRouter);
 111 |     |         exchangeRouter = _exchangeRouter;
 112 |     |         rewardToken.approve(_exchangeRouter, type(uint256).max);
 113 |     |     }
 114 |     | 
 115 |     |     function _compoundFromToken(
 116 |     |         IERC20 tokenIn,
 117 |     |         uint256 amountIn,
 118 |     |         uint256 minLp
 119 |     |     ) private returns (uint256 totalAmount, uint256 assetAmount, uint256 feeAmount) {
 120 |     |         IERC20 asset = vault.asset();
 121 |     |         uint balanceLpBefore = asset.balanceOf(address(this));
 122 |     |         tokenIn.safeApprove(address(asset), amountIn);
 123 |     |         ICurvePool pool = ICurvePool(address(asset));
 124 |     | 
 125 |     |         if (poolNumCoins == 2) {
 126 |     |             uint256[2] memory amounts = [uint256(0), uint256(0)];
 127 |     |             amounts[poolTokenInIndex] = amountIn;
 128 |     |             pool.add_liquidity(amounts, minLp);
 129 |     |         } else if (poolNumCoins == 3) {
 130 |     |             uint256[3] memory amounts = [uint256(0), uint256(0), uint256(0)];
 131 |     |             amounts[poolTokenInIndex] = amountIn;
 132 |     |             pool.add_liquidity(amounts, minLp);
 133 |     |         } else if (poolNumCoins == 4) {
 134 |     |             uint256[4] memory amounts = [uint256(0), uint256(0), uint256(0), uint256(0)];
 135 |     |             amounts[poolTokenInIndex] = amountIn;
 136 |     |             pool.add_liquidity(amounts, minLp);
 137 |     |         }
 138 |     | 
 139 |     |         totalAmount = asset.balanceOf(address(this)) - balanceLpBefore;
 140 |     |         (assetAmount, feeAmount) = calculateFees(totalAmount);
 141 |     | 
 142 |     |         if (feeAmount > 0) {
 143 |     |             asset.safeTransfer(feeCollector, feeAmount);
 144 |     |         }
 145 |     | 
 146 |     |         IMagicCurveLpRewardHandler(address(vault)).distributeRewards(assetAmount);
 147 |     |         lastExecution = uint64(block.timestamp);
 148 |     | 
 149 |     |         emit LogHarvest(totalAmount, assetAmount, feeAmount);
 150 |     |     }
 151 |     | }
 152 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/MagicCurveLpRewardHandler.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20, BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  5 |     | import {MagicCurveLpData} from "tokens/MagicCurveLp.sol";
  6 |     | import {ICurveRewardGauge} from "interfaces/ICurveRewardGauge.sol";
  7 |     | import {IMagicCurveLpRewardHandler} from "interfaces/IMagicCurveLpRewardHandler.sol";
  8 |     | 
  9 |     | /// @dev in case of V2, if adding new variable create MagicCurveLpRewardHandlerDataV2 that inherits
 10 |     | /// from MagicCurveLpRewardHandlerDataV1
 11 |     | contract MagicCurveLpRewardHandlerDataV1 is MagicCurveLpData {
 12 |     |     ICurveRewardGauge _staking;
 13 |     | }
 14 |     | 
 15 |     | /// @dev When making a new version, never change existing variables, always add after
 16 |     | /// the existing one. Ex: Inherit from MagicCurveLpRewardHandlerDataV2 in case of a V2 version.
 17 |     | contract MagicCurveLpRewardHandler is MagicCurveLpRewardHandlerDataV1, IMagicCurveLpRewardHandler {
 18 |     |     using BoringERC20 for IERC20;
 19 |     | 
 20 |     |     event LogStakingChanged(ICurveRewardGauge indexed previousStaking, ICurveRewardGauge indexed currentStaking);
 21 |     | 
 22 |     |     ////////////////////////////////////////////////////////////////////////////////
 23 |     |     /// @dev Avoid adding storage variable in this contract.
 24 |     |     /// Use MagicCurveLpRewardHandlerData instead.
 25 |     |     ////////////////////////////////////////////////////////////////////////////////
 26 |     | 
 27 |     |     /// @notice harvests rewards from the staking contract and distributes them to the vault
 28 |     |     /// @param to Address to send the rewards to
 29 |     |     function harvest(address to) external override onlyOperators {
 30 |     |         _staking.claim_rewards(address(this), to);
 31 |     |     }
 32 |     | 
 33 |     |     /// @notice distributes rewards to the staking contract
 34 |     |     /// @param amount Amount of rewards to distribute
 35 |     |     function distributeRewards(uint256 amount) external override onlyOperators {
 36 |     |         _asset.transferFrom(msg.sender, address(this), amount);
 37 |     |         _staking.deposit(amount, address(this), false);
 38 |     |         _totalAssets += amount;
 39 |     |     }
 40 |     | 
 41 |     |     /// @notice Skims excess assets from the staking contract and current contract balance
 42 |     |     function skimAssets() external override onlyOwner returns (uint256 excessStakedAmount, uint256 excessLpAmount) {
 43 |     |         uint256 stakedAmount = _staking.balanceOf(address(this));
 44 |     | 
 45 |     |         excessStakedAmount = stakedAmount - _totalAssets;
 46 |     |         excessLpAmount = _asset.balanceOf(address(this));
 47 |     | 
 48 |     |         _staking.withdraw(excessStakedAmount);
 49 |     | 
 50 |     |         uint total = _asset.balanceOf(address(this));
 51 |     | 
 52 |     |         if (total > 0) {
 53 |     |             _asset.transfer(msg.sender, total);
 54 |     |         }
 55 |     |     }
 56 |     | 
 57 |     |     /// @notice Sets the staking contract and pid and approves the staking contract to spend the asset
 58 |     |     /// @param __staking Staking contract
 59 |     |     function setStaking(ICurveRewardGauge __staking) external override onlyOwner {
 60 |     |         emit LogStakingChanged(_staking, __staking);
 61 |     |         _staking = __staking;
 62 |     |         _asset.approve(address(__staking), type(uint256).max);
 63 |     |     }
 64 |     | 
 65 |     |     /// @notice Returns the staking contract and pid
 66 |     |     function staking() external view override returns (ICurveRewardGauge) {
 67 |     |         return _staking;
 68 |     |     }
 69 |     | 
 70 |     |     ////////////////////////////////////////////////////////////////////////////////
 71 |     |     // Private Delegate Functions
 72 |     |     // Only allowed to be called by the MagicCurveLp contract
 73 |     |     ////////////////////////////////////////////////////////////////////////////////
 74 |     | 
 75 |     |     /// @notice Stakes the asset in the staking contract
 76 |     |     function stakeAsset(uint256 amount) external override {
 77 |     |         _staking.deposit(amount, address(this), false);
 78 |     |     }
 79 |     | 
 80 |     |     /// @notice Unstakes the asset in the staking contract
 81 |     |     function unstakeAsset(uint256 amount) external override {
 82 |     |         _staking.withdraw(amount);
 83 |     |     }
 84 |     | 
 85 |     |     /// @notice Private functions are not meant to be called by the fallback function directly
 86 |     |     /// as they would compromise the state of the contract.
 87 |     |     function isPrivateDelegateFunction(bytes4 sig) external pure returns (bool) {
 88 |     |         return sig == this.stakeAsset.selector || sig == this.unstakeAsset.selector;
 89 |     |     }
 90 |     | }
 91 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/MagicGlpHarvestor.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   5 |     | import {BoringOwnable} from "BoringSolidity/BoringOwnable.sol";
   6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
   7 |     | import {Operatable} from "mixins/Operatable.sol";
   8 |     | import {IMagicGlpRewardHandler} from "interfaces/IMagicGlpRewardHandler.sol";
   9 |     | import {IGmxGlpRewardRouter, IGmxRewardRouterV2, IGmxRewardTracker} from "interfaces/IGmxV1.sol";
  10 |     | import {IWETHAlike} from "interfaces/IWETH.sol";
  11 |     | import {IERC4626} from "interfaces/IERC4626.sol";
  12 |     | 
  13 |     | /// @dev Glp harvester version that swap the reward to USDC to mint glp
  14 |     | /// and transfer them back in GmxGlpVault token for auto compounding
  15 |     | contract MagicGlpHarvestor is Operatable {
  16 |     |     using BoringERC20 for IERC20;
  17 |     |     using BoringERC20 for IWETHAlike;
  18 |     | 
  19 |     |     error ErrInvalidFeePercent();
  20 |     |     error ErrNotRewardToken();
  21 |     | 
  22 |     |     event LogFeeParametersChanged(address indexed feeCollector, uint16 feeAmount);
  23 |     |     event LogRewardRouterV2Changed(IGmxRewardRouterV2 indexed, IGmxRewardRouterV2 indexed);
  24 |     |     event LogHarvest(uint256 total, uint256 amount, uint256 fee);
  25 |     | 
  26 |     |     uint256 public constant BIPS = 10_000;
  27 |     | 
  28 |     |     IMagicGlpRewardHandler public immutable vault;
  29 |     |     IERC20 public immutable asset;
  30 |     |     IWETHAlike public immutable rewardToken;
  31 |     | 
  32 |     |     IGmxRewardRouterV2 public rewardRouterV2;
  33 |     |     IGmxGlpRewardRouter public glpRewardRouter;
  34 |     |     uint64 public lastExecution;
  35 |     | 
  36 |     |     address public feeCollector;
  37 |     |     uint16 public feePercentBips;
  38 |     | 
  39 |     |     bool public useDistributeRewardsFeature;
  40 |     | 
  41 |     |     constructor(
  42 |     |         IWETHAlike _rewardToken,
  43 |     |         IGmxRewardRouterV2 _rewardRouterV2,
  44 |     |         IGmxGlpRewardRouter _glpRewardRouter,
  45 |     |         IMagicGlpRewardHandler _vault,
  46 |     |         bool _useDistributeRewardsFeature
  47 |     |     ) {
  48 |     |         rewardToken = _rewardToken;
  49 |     |         rewardRouterV2 = _rewardRouterV2;
  50 |     |         glpRewardRouter = _glpRewardRouter;
  51 |     |         vault = _vault;
  52 |     |         useDistributeRewardsFeature = _useDistributeRewardsFeature;
  53 |     | 
  54 |     |         asset = IERC4626(address(vault)).asset();
  55 |     |         asset.approve(address(_vault), type(uint256).max);
  56 |     |     }
  57 |     | 
  58 |     |     // Only accept native reward token from rewardToken.withdraw calls
  59 |     |     receive() external payable virtual {
  60 |     |         if (msg.sender != address(rewardToken)) {
  61 |     |             revert ErrNotRewardToken();
  62 |     |         }
  63 |     |     }
  64 |     | 
  65 |     |     function claimable() external view returns (uint256) {
  66 |     |         return
  67 |     |             IGmxRewardTracker(rewardRouterV2.feeGmxTracker()).claimable(address(vault)) +
  68 |     |             IGmxRewardTracker(rewardRouterV2.feeGlpTracker()).claimable(address(vault));
  69 |     |     }
  70 |     | 
  71 |     |     /// @dev if deploying a new version of this contract, add `+ address(this).balance` as well.
  72 |     |     /// keeping it as is to match what is currently onchain.
  73 |     |     function totalRewardsBalanceAfterClaiming() external view returns (uint256) {
  74 |     |         return
  75 |     |             rewardToken.balanceOf(address(vault)) +
  76 |     |             rewardToken.balanceOf(address(this)) +
  77 |     |             IGmxRewardTracker(rewardRouterV2.feeGmxTracker()).claimable(address(vault)) +
  78 |     |             IGmxRewardTracker(rewardRouterV2.feeGlpTracker()).claimable(address(vault));
  79 |     |     }
  80 |     | 
  81 |     |     function run(uint256 minGlp, uint256 rewardAmount) external onlyOperators {
  82 |     |         vault.harvest();
  83 |     | 
  84 |     |         rewardToken.safeTransferFrom(address(vault), address(this), rewardToken.balanceOf(address(vault)));
  85 |     |         rewardToken.withdraw(rewardToken.balanceOf(address(this)));
  86 |     | 
  87 |     |         if (rewardAmount > address(this).balance) {
  88 |     |             rewardAmount = address(this).balance;
  89 |     |         }
  90 |     | 
  91 |     |         uint256 total = glpRewardRouter.mintAndStakeGlpETH{value: rewardAmount}(0, minGlp);
  92 |     |         uint256 assetAmount = total;
  93 |     |         uint256 feeAmount = (total * feePercentBips) / BIPS;
  94 |     | 
  95 |     |         if (feeAmount > 0) {
  96 |     |             assetAmount -= feeAmount;
  97 |     |             asset.safeTransfer(feeCollector, feeAmount);
  98 |     |         }
  99 |     | 
 100 |     |         if (useDistributeRewardsFeature) {
 101 |     |             vault.distributeRewards(assetAmount);
 102 |     |         } else {
 103 |     |             asset.safeTransfer(address(vault), assetAmount);
 104 |     |         }
 105 |     | 
 106 |     |         lastExecution = uint64(block.timestamp);
 107 |     | 
 108 |     |         emit LogHarvest(total, assetAmount, feeAmount);
 109 |     |     }
 110 |     | 
 111 |     |     function setRewardRouterV2(IGmxRewardRouterV2 _rewardRouterV2) external onlyOwner {
 112 |     |         emit LogRewardRouterV2Changed(rewardRouterV2, _rewardRouterV2);
 113 |     |         rewardRouterV2 = _rewardRouterV2;
 114 |     |     }
 115 |     | 
 116 |     |     function setFeeParameters(address _feeCollector, uint16 _feePercentBips) external onlyOwner {
 117 |     |         if (feePercentBips > BIPS) {
 118 |     |             revert ErrInvalidFeePercent();
 119 |     |         }
 120 |     | 
 121 |     |         feeCollector = _feeCollector;
 122 |     |         feePercentBips = _feePercentBips;
 123 |     | 
 124 |     |         emit LogFeeParametersChanged(_feeCollector, _feePercentBips);
 125 |     |     }
 126 |     | }
 127 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/MagicGlpRewardHandler.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {IERC20, BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
   5 |     | import {BoringOwnable} from "BoringSolidity/BoringOwnable.sol";
   6 |     | import {MagicGlpData} from "tokens/MagicGlp.sol";
   7 |     | import {IGmxGlpManager, IGmxRewardRouterV2, IGmxStakedGlp, IGmxVester} from "interfaces/IGmxV1.sol";
   8 |     | import {IMagicGlpRewardHandler} from "interfaces/IMagicGlpRewardHandler.sol";
   9 |     | 
  10 |     | /// @dev in case of V2, if adding new variable create MagicGlpRewardHandlerDataV2 that inherits
  11 |     | /// from MagicGlpRewardHandlerDataV1
  12 |     | contract MagicGlpRewardHandlerDataV1 is MagicGlpData {
  13 |     |     /// @dev V1 variables, do not change.
  14 |     |     IGmxRewardRouterV2 public rewardRouter;
  15 |     | }
  16 |     | 
  17 |     | /// @dev When making a new version, never change existing variables, always add after
  18 |     | /// the existing one. Ex: Inherit from GmxGlpVaultRewardHandlerDataV2 in case of a V2 version.
  19 |     | contract MagicGlpRewardHandler is MagicGlpRewardHandlerDataV1, IMagicGlpRewardHandler {
  20 |     |     using BoringERC20 for IERC20;
  21 |     | 
  22 |     |     event LogRewardRouterChanged(IGmxRewardRouterV2 indexed previous, IGmxRewardRouterV2 indexed current);
  23 |     | 
  24 |     |     ////////////////////////////////////////////////////////////////////////////////
  25 |     |     /// @dev Avoid adding storage variable here
  26 |     |     /// Should use GmxGlpVaultData instead.
  27 |     |     ////////////////////////////////////////////////////////////////////////////////
  28 |     | 
  29 |     |     function harvest() external onlyStrategyExecutor {
  30 |     |         rewardRouter.handleRewards({
  31 |     |             shouldClaimGmx: true,
  32 |     |             shouldStakeGmx: true,
  33 |     |             shouldClaimEsGmx: true,
  34 |     |             shouldStakeEsGmx: true,
  35 |     |             shouldStakeMultiplierPoints: true,
  36 |     |             shouldClaimWeth: true,
  37 |     |             shouldConvertWethToEth: false
  38 |     |         });
  39 |     |     }
  40 |     | 
  41 |     |     function distributeRewards(uint256 amount) external onlyStrategyExecutor {
  42 |     |         _asset.transferFrom(msg.sender, address(this), amount);
  43 |     |         _totalAssets += amount;
  44 |     |     }
  45 |     | 
  46 |     |     function skimAssets() external onlyOwner returns (uint256 amount) {
  47 |     |         amount = _asset.balanceOf(address(this)) - _totalAssets;
  48 |     | 
  49 |     |         if (amount > 0) {
  50 |     |             _asset.transfer(msg.sender, amount);
  51 |     |         }
  52 |     |     }
  53 |     | 
  54 |     |     function setRewardRouter(IGmxRewardRouterV2 _rewardRouter) external onlyOwner {
  55 |     |         emit LogRewardRouterChanged(rewardRouter, _rewardRouter);
  56 |     |         rewardRouter = _rewardRouter;
  57 |     |     }
  58 |     | 
  59 |     |     function setTokenAllowance(IERC20 token, address spender, uint256 amount) external onlyOwner {
  60 |     |         token.approve(spender, amount);
  61 |     |     }
  62 |     | 
  63 |     |     ///////////////////////////////////////////////////////////////////////
  64 |     |     // esGMX Vesting Handling
  65 |     |     // Adapted from RageTrade contract code
  66 |     | 
  67 |     |     /// @notice unstakes and vest protocol esGmx to convert it to Gmx
  68 |     |     function unstakeGmx(uint256 amount, uint256 amountToTransferToSender, address recipient) external onlyOwner {
  69 |     |         IERC20 gmx = IERC20(rewardRouter.gmx());
  70 |     | 
  71 |     |         if (amount > 0) {
  72 |     |             rewardRouter.unstakeGmx(amount);
  73 |     |         }
  74 |     |         if (amountToTransferToSender > 0) {
  75 |     |             uint256 gmxAmount = gmx.balanceOf(address(this));
  76 |     | 
  77 |     |             if (amountToTransferToSender < gmxAmount) {
  78 |     |                 gmxAmount = amountToTransferToSender;
  79 |     |             }
  80 |     | 
  81 |     |             gmx.safeTransfer(recipient, gmxAmount);
  82 |     |         }
  83 |     |     }
  84 |     | 
  85 |     |     /// @notice unstakes and vest protocol esGmx to convert it to Gmx
  86 |     |     function unstakeEsGmxAndVest(uint256 amount, uint256 glpVesterDepositAmount, uint256 gmxVesterDepositAmount) external onlyOwner {
  87 |     |         if (amount > 0) {
  88 |     |             rewardRouter.unstakeEsGmx(amount);
  89 |     |         }
  90 |     |         if (glpVesterDepositAmount > 0) {
  91 |     |             IGmxVester(rewardRouter.glpVester()).deposit(glpVesterDepositAmount);
  92 |     |         }
  93 |     |         if (gmxVesterDepositAmount > 0) {
  94 |     |             IGmxVester(rewardRouter.gmxVester()).deposit(gmxVesterDepositAmount);
  95 |     |         }
  96 |     |     }
  97 |     | 
  98 |     |     /// @notice claims vested gmx tokens (i.e. stops vesting esGmx so that the relevant glp amount is unlocked)
  99 |     |     /// This will withdraw and unreserve all tokens as well as pause vesting. esGMX tokens that have been converted
 100 |     |     /// to GMX will remain as GMX tokens.
 101 |     |     function withdrawFromVesting(bool withdrawFromGlpVester, bool withdrawFromGmxVester, bool stake) external onlyOwner {
 102 |     |         if (withdrawFromGlpVester) {
 103 |     |             IGmxVester(rewardRouter.glpVester()).withdraw();
 104 |     |         }
 105 |     |         if (withdrawFromGmxVester) {
 106 |     |             IGmxVester(rewardRouter.gmxVester()).withdraw();
 107 |     |         }
 108 |     | 
 109 |     |         if (stake) {
 110 |     |             uint256 esGmxWithdrawn = IERC20(rewardRouter.esGmx()).balanceOf(address(this));
 111 |     |             rewardRouter.stakeEsGmx(esGmxWithdrawn);
 112 |     |         }
 113 |     |     }
 114 |     | 
 115 |     |     /// @notice claims vested gmx tokens and optionnaly stake or transfer to feeRecipient
 116 |     |     /// @dev vested esGmx gets converted to GMX every second, so whatever amount is vested gets claimed
 117 |     |     function claimVestedGmx(bool withdrawFromGlpVester, bool withdrawFromGmxVester, bool stake, bool transferToOwner) external onlyOwner {
 118 |     |         IERC20 gmx = IERC20(rewardRouter.gmx());
 119 |     | 
 120 |     |         if (withdrawFromGlpVester) {
 121 |     |             IGmxVester(rewardRouter.glpVester()).claim();
 122 |     |         }
 123 |     |         if (withdrawFromGmxVester) {
 124 |     |             IGmxVester(rewardRouter.gmxVester()).claim();
 125 |     |         }
 126 |     | 
 127 |     |         uint256 gmxAmount = gmx.balanceOf(address(this));
 128 |     | 
 129 |     |         if (stake) {
 130 |     |             gmx.approve(address(rewardRouter.stakedGmxTracker()), gmxAmount);
 131 |     |             rewardRouter.stakeGmx(gmxAmount);
 132 |     |         } else if (transferToOwner) {
 133 |     |             gmx.safeTransfer(owner, gmxAmount);
 134 |     |         }
 135 |     |     }
 136 |     | }
 137 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/MasterContractConfigurationRegistry.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8;
  3 |     | 
  4 |     | import {Owned} from "solmate/auth/Owned.sol";
  5 |     | import {ICauldronV1} from "interfaces/ICauldronV1.sol";
  6 |     | 
  7 |     | struct MasterContractConfiguration {
  8 |     |     uint24 collaterizationRate;
  9 |     |     uint24 liquidationMultiplier;
 10 |     | }
 11 |     | 
 12 |     | contract MasterContractConfigurationRegistry is Owned {
 13 |     |     error ErrInvalidConfigration();
 14 |     |     error ErrInvalidMasterContract(ICauldronV1 masterContract);
 15 |     |     error ErrLengthMismatch();
 16 |     | 
 17 |     |     mapping(ICauldronV1 => MasterContractConfiguration) public configurations;
 18 |     | 
 19 |     |     constructor(address owner_) Owned(owner_) {}
 20 |     | 
 21 |     |     function setConfigurations(
 22 |     |         ICauldronV1[] calldata masterContracts_,
 23 |     |         MasterContractConfiguration[] calldata configurations_
 24 |     |     ) external onlyOwner {
 25 |     |         if (masterContracts_.length != configurations_.length) {
 26 |     |             revert ErrLengthMismatch();
 27 |     |         }
 28 |     | 
 29 |     |         for (uint256 i = 0; i < masterContracts_.length; ++i) {
 30 |     |             ICauldronV1 masterContract = masterContracts_[i];
 31 |     |             MasterContractConfiguration calldata configuration = configurations_[i];
 32 |     | 
 33 |     |             if (address(masterContract) == address(0)) {
 34 |     |                 revert ErrInvalidMasterContract(masterContract);
 35 |     |             }
 36 |     | 
 37 |     |             if (configuration.collaterizationRate == 0 || configuration.liquidationMultiplier == 0) {
 38 |     |                 revert ErrInvalidConfigration();
 39 |     |             }
 40 |     | 
 41 |     |             configurations[masterContract] = configuration;
 42 |     |         }
 43 |     |     }
 44 |     | 
 45 |     |     function removeConfigurations(ICauldronV1[] calldata masterContracts_) external onlyOwner {
 46 |     |         for (uint256 i = 0; i < masterContracts_.length; ++i) {
 47 |     |             ICauldronV1 masterContract = masterContracts_[i];
 48 |     | 
 49 |     |             if (address(masterContract) == address(0)) {
 50 |     |                 revert ErrInvalidMasterContract(masterContract);
 51 |     |             }
 52 |     | 
 53 |     |             delete configurations[masterContract];
 54 |     |         }
 55 |     |     }
 56 |     | }
 57 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/OracleUpdater.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8;
  3 |     | 
  4 |     | import {ICauldronV1} from "interfaces/ICauldronV1.sol";
  5 |     | import {ICauldronV2} from "interfaces/ICauldronV2.sol";
  6 |     | import {CauldronRegistry} from "periphery/CauldronRegistry.sol";
  7 |     | import {MasterContractConfigurationRegistry} from "periphery/MasterContractConfigurationRegistry.sol";
  8 |     | import {Owned} from "solmate/auth/Owned.sol";
  9 |     | 
 10 |     | interface IOracleUpdater {
 11 |     |     function updateCauldrons(ICauldronV1[] memory cauldrons_) external;
 12 |     | }
 13 |     | 
 14 |     | interface IGelatoChecker {
 15 |     |     function checker() external view returns (bool canExec, bytes memory execPayload);
 16 |     | }
 17 |     | 
 18 |     | contract OracleUpdater is IOracleUpdater, IGelatoChecker {
 19 |     |     uint256 private constant EXCHANGERATE_PRECISION = 1e18;
 20 |     |     uint256 private constant COLLATERIZATION_RATE_PRECISION = 1e5;
 21 |     |     uint256 private constant LIQUIDATION_MULTIPLIER_PRECISION = 1e5;
 22 |     | 
 23 |     |     CauldronRegistry cauldronRegistry;
 24 |     |     MasterContractConfigurationRegistry masterContractConfigurationRegistry;
 25 |     | 
 26 |     |     constructor(CauldronRegistry cauldronRegistry_, MasterContractConfigurationRegistry masterContractConfigurationRegistry_) {
 27 |     |         cauldronRegistry = cauldronRegistry_;
 28 |     |         masterContractConfigurationRegistry = masterContractConfigurationRegistry_;
 29 |     |     }
 30 |     | 
 31 |     |     function updateCauldrons(ICauldronV1[] calldata cauldrons_) external override {
 32 |     |         for (uint256 i = 0; i < cauldrons_.length; ++i) {
 33 |     |             cauldrons_[i].updateExchangeRate();
 34 |     |         }
 35 |     |     }
 36 |     | 
 37 |     |     function checker() external view override returns (bool canExec, bytes memory execPayload) {
 38 |     |         canExec = false;
 39 |     |         uint256 len;
 40 |     |         uint256 cauldronsLength = cauldronRegistry.cauldronsLength();
 41 |     |         bool[] memory isToBeUpdated = new bool[](cauldronsLength);
 42 |     | 
 43 |     |         for (uint256 i = 0; i < cauldronsLength; ++i) {
 44 |     |             ICauldronV1 cauldron = cauldronRegistry.cauldrons(i);
 45 |     | 
 46 |     |             (uint256 collaterizationRate, uint256 liquidationMultiplier) = masterContractConfigurationRegistry.configurations(
 47 |     |                 cauldron.masterContract()
 48 |     |             );
 49 |     |             if (collaterizationRate == 0) {
 50 |     |                 // Not registered --- assume V2 plus
 51 |     |                 collaterizationRate = ICauldronV2(address(cauldron)).COLLATERIZATION_RATE();
 52 |     |                 liquidationMultiplier = ICauldronV2(address(cauldron)).LIQUIDATION_MULTIPLIER();
 53 |     |             }
 54 |     |             uint256 collateralizationDelta = COLLATERIZATION_RATE_PRECISION - collaterizationRate;
 55 |     |             uint256 liquidationDelta = liquidationMultiplier - LIQUIDATION_MULTIPLIER_PRECISION;
 56 |     | 
 57 |     |             (, uint256 currentRate) = cauldron.oracle().peek(cauldron.oracleData());
 58 |     | 
 59 |     |             uint256 staleRate = cauldron.exchangeRate();
 60 |     | 
 61 |     |             // Effectively staleRate * (1 - LTV)
 62 |     |             uint256 collaterizationBuffer = (staleRate * collateralizationDelta) / COLLATERIZATION_RATE_PRECISION;
 63 |     |             // Effectively staleRate * (liquidationMultiplier - 1)
 64 |     |             uint256 liquidationBuffer = (staleRate * liquidationDelta) / LIQUIDATION_MULTIPLIER_PRECISION;
 65 |     |             if (staleRate + collaterizationBuffer - liquidationBuffer < currentRate) {
 66 |     |                 canExec = true;
 67 |     |                 isToBeUpdated[i] = true;
 68 |     |                 unchecked {
 69 |     |                     len++;
 70 |     |                 }
 71 |     |             }
 72 |     |         }
 73 |     | 
 74 |     |         ICauldronV1[] memory toBeUpdated = new ICauldronV1[](len);
 75 |     | 
 76 |     |         for (uint256 i = 0; i < cauldronsLength; ++i) {
 77 |     |             if (isToBeUpdated[i]) {
 78 |     |                 toBeUpdated[toBeUpdated.length - len] = cauldronRegistry.cauldrons(i);
 79 |     |                 unchecked {
 80 |     |                     --len;
 81 |     |                 }
 82 |     |             }
 83 |     |         }
 84 |     | 
 85 |     |         execPayload = abi.encodeCall(IOracleUpdater.updateCauldrons, (toBeUpdated));
 86 |     |     }
 87 |     | }
 88 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/RepayHelper.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {ERC20} from "BoringSolidity/ERC20.sol";
   5 |     | import {RebaseLibrary, Rebase} from "BoringSolidity/libraries/BoringRebase.sol";
   6 |     | import {BoringERC20, IERC20} from "BoringSolidity/libraries/BoringERC20.sol";
   7 |     | import {Operatable} from "mixins/Operatable.sol";
   8 |     | import {ICauldronV4} from "interfaces/ICauldronV4.sol";
   9 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  10 |     | 
  11 |     | contract RepayHelper {
  12 |     |     using RebaseLibrary for Rebase;
  13 |     |     using BoringERC20 for IERC20;
  14 |     | 
  15 |     |     IERC20 public immutable magicInternetMoney;
  16 |     |     address public constant multisig = 0x5f0DeE98360d8200b20812e174d139A1a633EDd2;
  17 |     |     address public constant safe = 0xDF2C270f610Dc35d8fFDA5B453E74db5471E126B;
  18 |     | 
  19 |     |     error ErrNotAllowed();
  20 |     | 
  21 |     |     event LogTotalRepaid(ICauldronV4 indexed cauldron, uint256 amount);
  22 |     | 
  23 |     |     modifier onlySafe() {
  24 |     |         if (msg.sender != safe) {
  25 |     |             revert ErrNotAllowed();
  26 |     |         }
  27 |     |         _;
  28 |     |     }
  29 |     | 
  30 |     |     modifier onlyMultisig() {
  31 |     |         if (msg.sender != multisig) {
  32 |     |             revert ErrNotAllowed();
  33 |     |         }
  34 |     |         _;
  35 |     |     }
  36 |     | 
  37 |     |     constructor(IERC20 magicInternetMoney_) {
  38 |     |         magicInternetMoney = magicInternetMoney_;
  39 |     |     }
  40 |     | 
  41 |     |     /// @notice Repays a loan.
  42 |     |     /// @param to Address of the user this payment should go.
  43 |     |     /// @param cauldron cauldron on which it is repaid
  44 |     |     /// @param amount The amount to repay.
  45 |     |     /// @return part The total part repayed.
  46 |     |     function repayAmount(address to, ICauldronV4 cauldron, uint256 amount) public onlySafe returns (uint256 part) {
  47 |     |         cauldron.accrue();
  48 |     |         Rebase memory totalBorrow = cauldron.totalBorrow();
  49 |     |         part = totalBorrow.toBase(amount - 1, true);
  50 |     | 
  51 |     |         cauldron.repay(to, true, part);
  52 |     |     }
  53 |     | 
  54 |     |     /// @notice Repays multiple loans completely
  55 |     |     /// @param to Address of the users this payment should go.
  56 |     |     /// @param cauldron cauldron on which it is repaid
  57 |     |     function repayTotal(address[] calldata to, ICauldronV4 cauldron) external onlySafe returns (uint256 amount) {
  58 |     |         cauldron.accrue();
  59 |     |         Rebase memory totalBorrow = cauldron.totalBorrow();
  60 |     | 
  61 |     |         uint totalPart;
  62 |     |         for (uint i; i < to.length; i++) {
  63 |     |             totalPart += cauldron.userBorrowPart(to[i]);
  64 |     |         }
  65 |     | 
  66 |     |         amount = totalBorrow.toElastic(totalPart + 1e6, true);
  67 |     |         IBentoBoxV1 bentoBox = IBentoBoxV1(address(cauldron.bentoBox()));
  68 |     | 
  69 |     |         magicInternetMoney.safeTransferFrom(safe, address(bentoBox), amount);
  70 |     |         bentoBox.deposit(magicInternetMoney, address(bentoBox), address(bentoBox), amount, 0);
  71 |     | 
  72 |     |         for (uint i; i < to.length; i++) {
  73 |     |             cauldron.repay(to[i], true, cauldron.userBorrowPart(to[i]));
  74 |     |         }
  75 |     | 
  76 |     |         emit LogTotalRepaid(cauldron, amount);
  77 |     |     }
  78 |     | 
  79 |     |     /// @notice Repays multiple loans completely
  80 |     |     /// @param to Address of the users this payment should go.
  81 |     |     /// @param cauldron cauldron on which it is repaid
  82 |     |     function repayTotalMultisig(address[] calldata to, ICauldronV4 cauldron) external onlyMultisig returns (uint256 amount) {
  83 |     |         cauldron.accrue();
  84 |     |         Rebase memory totalBorrow = cauldron.totalBorrow();
  85 |     | 
  86 |     |         uint totalPart;
  87 |     |         for (uint i; i < to.length; i++) {
  88 |     |             totalPart += cauldron.userBorrowPart(to[i]);
  89 |     |         }
  90 |     | 
  91 |     |         amount = totalBorrow.toElastic(totalPart + 1e6, true);
  92 |     |         IBentoBoxV1 bentoBox = IBentoBoxV1(address(cauldron.bentoBox()));
  93 |     | 
  94 |     |         magicInternetMoney.safeTransferFrom(multisig, address(bentoBox), amount);
  95 |     |         bentoBox.deposit(magicInternetMoney, address(bentoBox), address(bentoBox), amount, 0);
  96 |     | 
  97 |     |         for (uint i; i < to.length; i++) {
  98 |     |             cauldron.repay(to[i], true, cauldron.userBorrowPart(to[i]));
  99 |     |         }
 100 |     | 
 101 |     |         emit LogTotalRepaid(cauldron, amount);
 102 |     |     }
 103 |     | }
 104 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/SpellStakingRewardDistributor.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | /// solhint-disable not-rely-on-time
   3 |     | pragma solidity >=0.8.0;
   4 |     | 
   5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   6 |     | import {ERC20} from "BoringSolidity/ERC20.sol";
   7 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
   8 |     | import {OperatableV2} from "mixins/OperatableV2.sol";
   9 |     | import {ILzReceiver, ILzApp, ILzOFTV2, ILzCommonOFT} from "interfaces/ILayerZero.sol";
  10 |     | 
  11 |     | /// @notice Responsible of distributing MIM rewards.
  12 |     | /// Mainnet Only
  13 |     | contract SpellStakingRewardDistributor is OperatableV2 {
  14 |     |     using BoringERC20 for IERC20;
  15 |     | 
  16 |     |     event LogSetOperator(address indexed operator, bool status);
  17 |     |     event LogDistribute(Distribution indexed distribution);
  18 |     |     error ErrNotEnoughNativeTokenToCoverFee();
  19 |     | 
  20 |     |     struct Distribution {
  21 |     |         // slot 0
  22 |     |         address recipient;
  23 |     |         uint80 gas; // lz  gas limit
  24 |     |         uint16 lzChainId; // lz chain id
  25 |     |         // slot 1
  26 |     |         uint128 fee; // lz fee
  27 |     |         uint128 amount;
  28 |     |     }
  29 |     | 
  30 |     |     ERC20 public constant MIM = ERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);
  31 |     |     ILzOFTV2 public constant OFT = ILzOFTV2(0x439a5f0f5E8d149DDA9a0Ca367D4a8e4D6f83C10);
  32 |     | 
  33 |     |     constructor(address _owner) OperatableV2(_owner) {
  34 |     |         MIM.approve(address(OFT), type(uint256).max);
  35 |     |     }
  36 |     | 
  37 |     |     receive() external payable {}
  38 |     | 
  39 |     |     function estimateBridgingFee(uint256 amount, uint16 lzChainId, address recipient) external view returns (uint256 fee, uint256 gas) {
  40 |     |         gas = ILzApp(address(OFT)).minDstGasLookup(lzChainId, 0 /* packet type for sendFrom */);
  41 |     | 
  42 |     |         (fee, ) = OFT.estimateSendFee(
  43 |     |             lzChainId,
  44 |     |             bytes32(uint256(uint160(recipient))),
  45 |     |             amount,
  46 |     |             false,
  47 |     |             abi.encodePacked(uint16(1), uint256(gas))
  48 |     |         );
  49 |     |     }
  50 |     | 
  51 |     |     function distribute(Distribution[] calldata distributions) external onlyOperators {
  52 |     |         uint256 length = distributions.length;
  53 |     |         for (uint256 i = 0; length > i; ) {
  54 |     |             Distribution memory distribution = distributions[i];
  55 |     | 
  56 |     |             if (distribution.fee > 0) {
  57 |     |                 // optionnal check for convenience
  58 |     |                 // check if there is enough native token to cover the bridging fees
  59 |     |                 if (distribution.fee > address(this).balance) {
  60 |     |                     revert ErrNotEnoughNativeTokenToCoverFee();
  61 |     |                 }
  62 |     | 
  63 |     |                 ILzCommonOFT.LzCallParams memory lzCallParams = ILzCommonOFT.LzCallParams({
  64 |     |                     refundAddress: payable(address(this)),
  65 |     |                     zroPaymentAddress: address(0),
  66 |     |                     adapterParams: abi.encodePacked(uint16(1), uint256(distribution.gas))
  67 |     |                 });
  68 |     | 
  69 |     |                 OFT.sendFrom{value: distribution.fee}(
  70 |     |                     address(this),
  71 |     |                     uint16(distribution.lzChainId),
  72 |     |                     bytes32(uint256(uint160(distribution.recipient))),
  73 |     |                     distribution.amount,
  74 |     |                     lzCallParams
  75 |     |                 );
  76 |     |             } else {
  77 |     |                 MIM.transfer(distribution.recipient, distribution.amount);
  78 |     |             }
  79 |     | 
  80 |     |             emit LogDistribute(distribution);
  81 |     | 
  82 |     |             unchecked {
  83 |     |                 ++i;
  84 |     |             }
  85 |     |         }
  86 |     |     }
  87 |     | 
  88 |     |     ////////////////////////////////////////////////////////
  89 |     |     // Emergency Functions
  90 |     |     ////////////////////////////////////////////////////////
  91 |     | 
  92 |     |     function rescueTokens(IERC20 token, address to, uint256 amount) external onlyOwner {
  93 |     |         token.safeTransfer(to, amount);
  94 |     |     }
  95 |     | 
  96 |     |     function execute(address to, uint256 value, bytes calldata data) external onlyOwner returns (bool success, bytes memory result) {
  97 |     |         // solhint-disable-next-line avoid-low-level-calls
  98 |     |         (success, result) = to.call{value: value}(data);
  99 |     |     }
 100 |     | }
 101 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/StargateLPMIMPool.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   5 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
   6 |     | import {BoringOwnable} from "BoringSolidity/BoringOwnable.sol";
   7 |     | import {Address} from "openzeppelin-contracts/utils/Address.sol";
   8 |     | import {SafeApproveLib} from "libraries/SafeApproveLib.sol";
   9 |     | import {IStargatePool, IStargateRouter} from "interfaces/IStargate.sol";
  10 |     | import {IOracle} from "interfaces/IOracle.sol";
  11 |     | import {IAggregator} from "interfaces/IAggregator.sol";
  12 |     | 
  13 |     | contract StargateLPMIMPool is BoringOwnable {
  14 |     |     using BoringERC20 for IERC20;
  15 |     |     using SafeApproveLib for IERC20;
  16 |     | 
  17 |     |     error ErrSwapFailed();
  18 |     |     error ErrUnauthorizedRedeemer(address);
  19 |     |     error ErrUnauthorizedExecutor(address);
  20 |     |     error ErrInvalidToken(address);
  21 |     |     error ErrInvalidFee(uint256);
  22 |     | 
  23 |     |     event AllowedRedeemerChanged(address redeemer, bool allowed);
  24 |     |     event AllowedExecutorChanged(address redeemer, bool allowed);
  25 |     |     event Swap(address from, IStargatePool tokenIn, uint256 amountIn, uint256 amountOut, address recipient);
  26 |     |     event PoolChanged(IStargatePool lp, uint16 poolId, IOracle oracle);
  27 |     |     event FeeChanged(uint256 previousFeeBps, uint256 feeBps);
  28 |     | 
  29 |     |     struct PoolInfo {
  30 |     |         uint16 poolId; // 16 bits
  31 |     |         IOracle oracle; // 160 bits
  32 |     |         uint80 oracleDecimalsMultipler; // 80 bits
  33 |     |     }
  34 |     | 
  35 |     |     IERC20 public immutable mim;
  36 |     |     IAggregator public immutable mimOracle;
  37 |     |     IStargateRouter public immutable stargateRouter;
  38 |     | 
  39 |     |     uint256 public feeBps;
  40 |     | 
  41 |     |     mapping(IStargatePool => PoolInfo) public pools;
  42 |     |     mapping(address => bool) public allowedRedeemers;
  43 |     |     mapping(address => bool) public allowedExecutors;
  44 |     | 
  45 |     |     modifier onlyAllowedRedeemers() {
  46 |     |         if (!allowedRedeemers[msg.sender]) {
  47 |     |             revert ErrUnauthorizedRedeemer(msg.sender);
  48 |     |         }
  49 |     |         _;
  50 |     |     }
  51 |     | 
  52 |     |     modifier onlyAllowedExecutors() {
  53 |     |         if (!allowedExecutors[msg.sender]) {
  54 |     |             revert ErrUnauthorizedExecutor(msg.sender);
  55 |     |         }
  56 |     |         _;
  57 |     |     }
  58 |     | 
  59 |     |     constructor(IERC20 _mim, IAggregator _mimOracle, IStargateRouter _stargateRouter) {
  60 |     |         feeBps = 20;
  61 |     |         mim = _mim;
  62 |     |         mimOracle = _mimOracle;
  63 |     |         stargateRouter = _stargateRouter;
  64 |     |     }
  65 |     | 
  66 |     |     function swapForMim(IStargatePool tokenIn, uint256 amountIn, address recipient) external onlyAllowedRedeemers returns (uint256) {
  67 |     |         if (address(pools[tokenIn].oracle) == address(0)) {
  68 |     |             revert ErrInvalidToken(address(tokenIn));
  69 |     |         }
  70 |     | 
  71 |     |         uint256 amount = getMimAmountOut(tokenIn, amountIn);
  72 |     | 
  73 |     |         IERC20(address(tokenIn)).safeTransferFrom(msg.sender, address(this), amountIn);
  74 |     |         mim.safeTransfer(recipient, amount);
  75 |     | 
  76 |     |         emit Swap(msg.sender, tokenIn, amountIn, amount, recipient);
  77 |     | 
  78 |     |         return amount;
  79 |     |     }
  80 |     | 
  81 |     |     function getMimAmountOut(IStargatePool tokenIn, uint256 amountIn) public view returns (uint256) {
  82 |     |         if (address(pools[tokenIn].oracle) == address(0)) {
  83 |     |             revert ErrInvalidToken(address(tokenIn));
  84 |     |         }
  85 |     | 
  86 |     |         uint256 mimUsd = uint256(mimOracle.latestAnswer()); // 8 decimals
  87 |     | 
  88 |     |         /// @dev for oracleDecimalsMultipler = 14 and tokenIn is 6 decimals -> amountOut is 6 decimals
  89 |     |         uint256 amount = ((amountIn * 10 ** pools[tokenIn].oracleDecimalsMultipler) / pools[tokenIn].oracle.peekSpot("")) / mimUsd;
  90 |     |         return amount - ((amount * feeBps) / 10_000);
  91 |     |     }
  92 |     | 
  93 |     |     /*** Admin Functions ***/
  94 |     |     function setAllowedRedeemer(address redeemer, bool allowed) external onlyOwner {
  95 |     |         allowedRedeemers[redeemer] = allowed;
  96 |     |         emit AllowedRedeemerChanged(redeemer, allowed);
  97 |     |     }
  98 |     | 
  99 |     |     function setAllowedExecutor(address executor, bool allowed) external onlyOwner {
 100 |     |         allowedExecutors[executor] = allowed;
 101 |     |         emit AllowedExecutorChanged(executor, allowed);
 102 |     |     }
 103 |     | 
 104 |     |     function setFee(uint256 _feeBps) external onlyOwner {
 105 |     |         if (_feeBps > 10_000) {
 106 |     |             revert ErrInvalidFee(_feeBps);
 107 |     |         }
 108 |     |         emit FeeChanged(feeBps, _feeBps);
 109 |     |         feeBps = _feeBps;
 110 |     |     }
 111 |     | 
 112 |     |     function setPool(IStargatePool lp, uint16 poolId, IOracle oracle, uint80 oracleDecimalsMultipler) external onlyOwner {
 113 |     |         pools[lp] = PoolInfo({poolId: poolId, oracle: oracle, oracleDecimalsMultipler: oracleDecimalsMultipler});
 114 |     | 
 115 |     |         IERC20(address(lp)).safeApprove(address(stargateRouter), type(uint256).max);
 116 |     | 
 117 |     |         emit PoolChanged(lp, poolId, oracle);
 118 |     |     }
 119 |     | 
 120 |     |     function getMaximumInstantRedeemable(IStargatePool lp) public view returns (uint256 max) {
 121 |     |         uint256 totalLiquidity = lp.totalLiquidity();
 122 |     | 
 123 |     |         if (totalLiquidity > 0) {
 124 |     |             uint256 amountSD = lp.deltaCredit();
 125 |     |             max = (amountSD * lp.totalSupply()) / totalLiquidity;
 126 |     |         }
 127 |     |     }
 128 |     | 
 129 |     |     /// @param dstChainId the chainId to remove liquidity
 130 |     |     /// @param srcPoolId the source poolId
 131 |     |     /// @param dstPoolId the destination poolId
 132 |     |     /// @param amount quantity of LP tokens to redeem
 133 |     |     /// @param txParams adpater parameters
 134 |     |     /// https://layerzero.gitbook.io/docs/technical-reference/mainnet/supported-chain-ids
 135 |     |     function redeemLocal(
 136 |     |         uint16 dstChainId,
 137 |     |         uint256 srcPoolId,
 138 |     |         uint256 dstPoolId,
 139 |     |         uint256 amount,
 140 |     |         IStargateRouter.lzTxObj memory txParams
 141 |     |     ) external payable onlyAllowedExecutors {
 142 |     |         stargateRouter.redeemLocal{value: msg.value}(
 143 |     |             dstChainId,
 144 |     |             srcPoolId,
 145 |     |             dstPoolId,
 146 |     |             payable(msg.sender),
 147 |     |             amount,
 148 |     |             abi.encodePacked(address(this)),
 149 |     |             txParams
 150 |     |         );
 151 |     |     }
 152 |     | 
 153 |     |     function instantRedeemLocalMax(IStargatePool lp) external onlyAllowedExecutors {
 154 |     |         PoolInfo memory info = pools[lp];
 155 |     | 
 156 |     |         uint256 amount = IERC20(address(lp)).balanceOf(address(this));
 157 |     |         uint256 max = getMaximumInstantRedeemable(lp);
 158 |     | 
 159 |     |         stargateRouter.instantRedeemLocal(info.poolId, amount > max ? max : amount, address(this));
 160 |     |     }
 161 |     | 
 162 |     |     function instantRedeemLocal(IStargatePool lp, uint256 amount) external onlyAllowedExecutors {
 163 |     |         PoolInfo memory info = pools[lp];
 164 |     |         stargateRouter.instantRedeemLocal(info.poolId, amount, address(this));
 165 |     |     }
 166 |     | 
 167 |     |     /// @dev Swap internal tokens using an aggregator, for example, 1inch, 0x.
 168 |     |     function swapOnAggregator(address aggreagtorRouter, IERC20 tokenIn, bytes calldata data) external onlyAllowedExecutors {
 169 |     |         tokenIn.safeApprove(aggreagtorRouter, type(uint256).max);
 170 |     | 
 171 |     |         // solhint-disable-next-line avoid-low-level-calls
 172 |     |         (bool success, ) = aggreagtorRouter.call(data);
 173 |     |         if (!success) {
 174 |     |             revert ErrSwapFailed();
 175 |     |         }
 176 |     | 
 177 |     |         tokenIn.safeApprove(aggreagtorRouter, 0);
 178 |     |     }
 179 |     | 
 180 |     |     /*** Emergency Functions ***/
 181 |     |     function execute(address to, uint256 value, bytes calldata data) external onlyOwner returns (bool, bytes memory) {
 182 |     |         // solhint-disable-next-line avoid-low-level-calls
 183 |     |         (bool success, bytes memory result) = to.call{value: value}(data);
 184 |     | 
 185 |     |         return (success, result);
 186 |     |     }
 187 |     | 
 188 |     |     function rescueTokens(IERC20 token, address to, uint256 amount) external onlyOwner {
 189 |     |         token.safeTransfer(to, amount);
 190 |     |     }
 191 |     | }
 192 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/StrategyExecutor.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  5 |     | import {Address} from "openzeppelin-contracts/utils/Address.sol";
  6 |     | import {BaseStrategy} from "strategies/BaseStrategy.sol";
  7 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  8 |     | import {OperatableV2} from "mixins/OperatableV2.sol";
  9 |     | 
 10 |     | contract StrategyExecutor is OperatableV2 {
 11 |     |     using Address for address;
 12 |     | 
 13 |     |     uint256 public constant BIPS = 10_000;
 14 |     | 
 15 |     |     mapping(BaseStrategy => uint64) public lastExecution;
 16 |     | 
 17 |     |     constructor(address _owner) OperatableV2(_owner) {}
 18 |     | 
 19 |     |     function _run(
 20 |     |         BaseStrategy strategy,
 21 |     |         uint256 maxBentoBoxAmountIncreaseInBips,
 22 |     |         uint256 maxBentoBoxChangeAmountInBips,
 23 |     |         address[] calldata callees,
 24 |     |         bytes[] calldata data,
 25 |     |         bool postRebalanceEnabled
 26 |     |     ) private {
 27 |     |         IBentoBoxV1 bentoBox = strategy.bentoBox();
 28 |     |         IERC20 strategyToken = strategy.strategyToken();
 29 |     |         uint128 totals = bentoBox.totals(strategyToken).elastic;
 30 |     |         uint256 maxBalance = totals + ((totals * BIPS) / maxBentoBoxAmountIncreaseInBips);
 31 |     |         uint256 maxChangeAmount = (maxBalance * maxBentoBoxChangeAmountInBips) / BIPS;
 32 |     |         strategy.safeHarvest(maxBalance, true, maxChangeAmount, false);
 33 |     | 
 34 |     |         for (uint256 i = 0; i < data.length; i++) {
 35 |     |             callees[i].functionCall(data[i], "call failed");
 36 |     |         }
 37 |     | 
 38 |     |         // useful when the previous function calls adds back strategy token to rebalance
 39 |     |         if (postRebalanceEnabled) {
 40 |     |             strategy.safeHarvest(maxBalance, true, 0, false);
 41 |     |         }
 42 |     | 
 43 |     |         lastExecution[strategy] = uint64(block.timestamp);
 44 |     |     }
 45 |     | 
 46 |     |     function runMultiple(
 47 |     |         BaseStrategy[] calldata strategy,
 48 |     |         uint256[] calldata maxBentoBoxAmountIncreaseInBips,
 49 |     |         uint256[] calldata maxBentoBoxChangeAmountInBips,
 50 |     |         address[][] calldata callees,
 51 |     |         bytes[][] calldata data,
 52 |     |         bool[] calldata postRebalanceEnabled
 53 |     |     ) external onlyOperators {
 54 |     |         for (uint256 i = 0; i < strategy.length; i++) {
 55 |     |             _run(
 56 |     |                 strategy[i],
 57 |     |                 maxBentoBoxAmountIncreaseInBips[i],
 58 |     |                 maxBentoBoxChangeAmountInBips[i],
 59 |     |                 callees[i],
 60 |     |                 data[i],
 61 |     |                 postRebalanceEnabled[i]
 62 |     |             );
 63 |     |         }
 64 |     |     }
 65 |     | 
 66 |     |     function run(
 67 |     |         BaseStrategy strategy,
 68 |     |         uint256 maxBentoBoxAmountIncreaseInBips,
 69 |     |         uint256 maxBentoBoxChangeAmountInBips,
 70 |     |         address[] calldata callees,
 71 |     |         bytes[] calldata calls,
 72 |     |         bool postRebalanceEnabled
 73 |     |     ) external onlyOperators {
 74 |     |         _run(strategy, maxBentoBoxAmountIncreaseInBips, maxBentoBoxChangeAmountInBips, callees, calls, postRebalanceEnabled);
 75 |     |     }
 76 |     | }
 77 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/TriCryptoUpdator.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {Operatable} from "mixins/Operatable.sol";
  5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  7 |     | import {IAggregator} from "interfaces/IAggregator.sol";
  8 |     | import {SafeApproveLib} from "libraries/SafeApproveLib.sol";
  9 |     | 
 10 |     | interface ITriCryptoWithExchange {
 11 |     |     function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;
 12 |     | 
 13 |     |     function last_prices(uint256 i) external view returns (uint256);
 14 |     | }
 15 |     | 
 16 |     | contract TriCryptoUpdator is Operatable {
 17 |     |     using BoringERC20 for IERC20;
 18 |     |     using SafeApproveLib for IERC20;
 19 |     | 
 20 |     |     address public tricrypto = 0xD51a44d3FaE010294C616388b506AcdA1bfAAE46;
 21 |     |     IAggregator private WETH_ORACLE = IAggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
 22 |     |     IAggregator private BTC_ORACLE = IAggregator(0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);
 23 |     | 
 24 |     |     uint256 private constant TRADE_AMOUNT = 1e5;
 25 |     | 
 26 |     |     IERC20 constant USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);
 27 |     |     IERC20 constant WBTC = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);
 28 |     |     IERC20 constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
 29 |     | 
 30 |     |     constructor() {
 31 |     |         USDT.safeApprove(tricrypto, type(uint256).max);
 32 |     |         WETH.safeApprove(tricrypto, type(uint256).max);
 33 |     |         WBTC.safeApprove(tricrypto, type(uint256).max);
 34 |     |     }
 35 |     | 
 36 |     |     function trade() external onlyOperators {
 37 |     |         ITriCryptoWithExchange(tricrypto).exchange(0, 1, TRADE_AMOUNT, 0);
 38 |     |         ITriCryptoWithExchange(tricrypto).exchange(1, 2, WBTC.balanceOf(address(this)), 0);
 39 |     |         ITriCryptoWithExchange(tricrypto).exchange(2, 0, WETH.balanceOf(address(this)), 0);
 40 |     |     }
 41 |     | 
 42 |     |     function checker() external view returns (bool canExec, bytes memory execPayload) {
 43 |     |         canExec = false;
 44 |     | 
 45 |     |         uint256 chainLinkPriceBtc = uint256(BTC_ORACLE.latestAnswer());
 46 |     |         uint256 chainLinkPriceEth = uint256(WETH_ORACLE.latestAnswer());
 47 |     | 
 48 |     |         uint256 curvePriceBTC = ITriCryptoWithExchange(tricrypto).last_prices(0) / 1e12;
 49 |     |         uint256 curvePriceETH = ITriCryptoWithExchange(tricrypto).last_prices(1) / 1e12;
 50 |     | 
 51 |     |         if (
 52 |     |             curvePriceETH * 95 > chainLinkPriceEth ||
 53 |     |             curvePriceETH * 105 < chainLinkPriceEth ||
 54 |     |             curvePriceBTC * 95 > chainLinkPriceBtc ||
 55 |     |             curvePriceBTC * 105 < chainLinkPriceBtc
 56 |     |         ) {
 57 |     |             canExec = true;
 58 |     |         }
 59 |     | 
 60 |     |         execPayload = abi.encodeCall(TriCryptoUpdator.trade, ());
 61 |     |     }
 62 |     | }
 63 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/precrime/BaseOFTV2View.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import {ILzBaseOFTV2, ILzApp, ILzEndpoint, IOFTV2View} from "interfaces/ILayerZero.sol";
  6 |     | import {BytesLib} from "libraries/BytesLib.sol";
  7 |     | import {IERC20, BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  8 |     | 
  9 |     | abstract contract BaseOFTV2View is IOFTV2View {
 10 |     |     error ErrNotTrustedRemote();
 11 |     |     error ErrInvalidPathLength();
 12 |     | 
 13 |     |     using BytesLib for bytes;
 14 |     |     using BoringERC20 for IERC20;
 15 |     | 
 16 |     |     ILzApp public immutable oft;
 17 |     |     IERC20 public immutable token;
 18 |     |     ILzEndpoint public immutable endpoint;
 19 |     | 
 20 |     |     /// @notice Local decimals to shared decimals rate
 21 |     |     uint public immutable ld2sdRate;
 22 |     | 
 23 |     |     constructor(address _oft) {
 24 |     |         oft = ILzApp(_oft);
 25 |     |         token = IERC20(address(ILzBaseOFTV2(_oft).innerToken()));
 26 |     |         endpoint = ILzApp(_oft).lzEndpoint();
 27 |     | 
 28 |     |         uint8 decimals = token.safeDecimals();
 29 |     |         uint8 sharedDecimals = ILzBaseOFTV2(_oft).sharedDecimals();
 30 |     |         ld2sdRate = 10 ** (decimals - sharedDecimals);
 31 |     |     }
 32 |     | 
 33 |     |     function _decodePayload(bytes memory _payload) internal view returns (uint) {
 34 |     |         uint64 amountSD = _payload.toUint64(33);
 35 |     |         return amountSD * ld2sdRate;
 36 |     |     }
 37 |     | 
 38 |     |     function getInboundNonce(uint16 _srcChainId) external view virtual returns (uint64) {
 39 |     |         bytes memory path = oft.trustedRemoteLookup(_srcChainId);
 40 |     |         return endpoint.getInboundNonce(_srcChainId, path);
 41 |     |     }
 42 |     | 
 43 |     |     function _isPacketFromTrustedRemote(uint16 _srcChainId, bytes32 _srcAddress) internal view returns (bool) {
 44 |     |         bytes memory path = oft.trustedRemoteLookup(_srcChainId);
 45 |     |         uint pathLength = path.length;
 46 |     | 
 47 |     |         // EVM - EVM path length 40 (address + address)
 48 |     |         // EVM - non-EVM path length 52 (bytes32 + address)
 49 |     |         if (pathLength != 40 && pathLength != 52) {
 50 |     |             revert ErrInvalidPathLength();
 51 |     |         }
 52 |     | 
 53 |     |         // path format: remote + local
 54 |     |         path = path.slice(0, pathLength - 20);
 55 |     | 
 56 |     |         uint remoteAddressLength = path.length;
 57 |     |         uint mask = (2 ** (remoteAddressLength * 8)) - 1;
 58 |     |         bytes32 remoteUaAddress;
 59 |     | 
 60 |     |         assembly {
 61 |     |             remoteUaAddress := and(mload(add(path, remoteAddressLength)), mask)
 62 |     |         }
 63 |     | 
 64 |     |         return remoteUaAddress == _srcAddress;
 65 |     |     }
 66 |     | 
 67 |     |     function lzReceive(
 68 |     |         uint16 _srcChainId,
 69 |     |         bytes32 _scrAddress,
 70 |     |         bytes memory _payload,
 71 |     |         uint _totalSupply
 72 |     |     ) external view virtual returns (uint);
 73 |     | 
 74 |     |     function getCurrentState() external view virtual returns (uint);
 75 |     | 
 76 |     |     function isProxy() external view virtual returns (bool);
 77 |     | }
 78 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/precrime/IndirectOFTV2View.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import {BaseOFTV2View} from "periphery/precrime/BaseOFTV2View.sol";
  6 |     | import {LzProxyOFTV2} from "tokens/LzProxyOFTV2.sol";
  7 |     | 
  8 |     | contract IndirectOFTV2View is BaseOFTV2View {
  9 |     |     constructor(address _oft) BaseOFTV2View(_oft) {}
 10 |     | 
 11 |     |     function lzReceive(
 12 |     |         uint16 _srcChainId,
 13 |     |         bytes32 _scrAddress,
 14 |     |         bytes memory _payload,
 15 |     |         uint _totalSupply
 16 |     |     ) external view override returns (uint) {
 17 |     |         if (!_isPacketFromTrustedRemote(_srcChainId, _scrAddress)) {
 18 |     |             revert ErrNotTrustedRemote();
 19 |     |         }
 20 |     |     
 21 |     |         uint amount = _decodePayload(_payload);
 22 |     |         return _totalSupply + amount;
 23 |     |     }
 24 |     | 
 25 |     |     function isProxy() external pure override returns (bool) {
 26 |     |         return false;
 27 |     |     }
 28 |     | 
 29 |     |     function getCurrentState() external view override returns (uint) {
 30 |     |         return token.totalSupply();
 31 |     |     }
 32 |     | }
 33 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/precrime/PreCrimeView.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import {IOFTV2View, IPreCrimeView} from "interfaces/ILayerZero.sol";
   5 |     | import {Owned} from "solmate/auth/Owned.sol";
   6 |     | 
   7 |     | contract PreCrimeView is IPreCrimeView, Owned {
   8 |     |     error ErrInvalidSize();
   9 |     | 
  10 |     |     uint16 public constant CONFIG_VERSION = 1;
  11 |     | 
  12 |     |     //---------------- error code ----------------------
  13 |     |     // --- UA scope code ---
  14 |     |     uint16 public constant CODE_SUCCESS = 0; // success
  15 |     |     uint16 public constant CODE_PRECRIME_FAILURE = 1; // !!! crimes found
  16 |     | 
  17 |     |     // --- protocol scope error code ---
  18 |     |     // simualte
  19 |     |     uint16 public constant CODE_PACKETS_OVERSIZE = 2; // packets number bigger then max size
  20 |     |     uint16 public constant CODE_PACKETS_UNSORTED = 3; // packets are unsorted, need backfill and keep order
  21 |     |     // precrime
  22 |     |     uint16 public constant CODE_MISS_SIMULATE_RESULT = 4; // miss simulation result
  23 |     | 
  24 |     |     /**
  25 |     |      * @dev 10000 - 20000 is for view mode, 20000 - 30000 is for precrime inherit mode
  26 |     |      */
  27 |     |     uint16 public constant PRECRIME_VERSION = 10001;
  28 |     | 
  29 |     |     /// @notice a view for OFTV2 or ProxyOFTV2
  30 |     |     IOFTV2View public immutable oftView;
  31 |     | 
  32 |     |     uint16 public localChainId;
  33 |     |     uint16[] public remoteChainIds;
  34 |     |     bytes32[] public remotePrecrimeAddresses;
  35 |     |     uint64 public maxBatchSize;
  36 |     | 
  37 |     |     constructor(address _owner, uint16 _localChainId, address _oftView, uint64 _maxSize) Owned(_owner) {
  38 |     |         localChainId = _localChainId;
  39 |     |         oftView = IOFTV2View(_oftView);
  40 |     |         maxBatchSize = _maxSize;
  41 |     |     }
  42 |     | 
  43 |     |     function setRemotePrecrimeAddresses(uint16[] memory _remoteChainIds, bytes32[] memory _remotePrecrimeAddresses) public onlyOwner {
  44 |     |         if (_remoteChainIds.length != _remotePrecrimeAddresses.length) {
  45 |     |             revert ErrInvalidSize();
  46 |     |         }
  47 |     | 
  48 |     |         remoteChainIds = _remoteChainIds;
  49 |     |         remotePrecrimeAddresses = _remotePrecrimeAddresses;
  50 |     |     }
  51 |     | 
  52 |     |     function setMaxBatchSize(uint64 _maxSize) public onlyOwner {
  53 |     |         maxBatchSize = _maxSize;
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev get precrime config,
  58 |     |      * @param _packets packets
  59 |     |      * @return configation bytes
  60 |     |      */
  61 |     |     function getConfig(Packet[] calldata _packets) external view virtual override returns (bytes memory) {
  62 |     |         (uint16[] memory remoteChains, bytes32[] memory remoteAddresses) = _remotePrecrimeAddress(_packets);
  63 |     |         return
  64 |     |             abi.encodePacked(
  65 |     |                 CONFIG_VERSION,
  66 |     |                 //---- max packets size for simulate batch ---
  67 |     |                 _maxBatchSize(),
  68 |     |                 //------------- remote precrimes -------------
  69 |     |                 remoteChains.length,
  70 |     |                 remoteChains,
  71 |     |                 remoteAddresses
  72 |     |             );
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev
  77 |     |      * @param _simulation all simulation results from difference chains
  78 |     |      * @return code     precrime result code; check out the error code definition
  79 |     |      * @return reason   error reason
  80 |     |      */
  81 |     |     function precrime(
  82 |     |         Packet[] calldata _packets,
  83 |     |         bytes[] calldata _simulation
  84 |     |     ) external view override returns (uint16 code, bytes memory reason) {
  85 |     |         bytes[] memory originSimulateResult = new bytes[](_simulation.length);
  86 |     |         uint16[] memory chainIds = new uint16[](_simulation.length);
  87 |     |         for (uint256 i = 0; i < _simulation.length; i++) {
  88 |     |             (uint16 chainId, bytes memory simulateResult) = abi.decode(_simulation[i], (uint16, bytes));
  89 |     |             chainIds[i] = chainId;
  90 |     |             originSimulateResult[i] = simulateResult;
  91 |     |         }
  92 |     | 
  93 |     |         (code, reason) = _checkResultsCompleteness(_packets, chainIds);
  94 |     |         if (code != CODE_SUCCESS) {
  95 |     |             return (code, reason);
  96 |     |         }
  97 |     | 
  98 |     |         (code, reason) = _precrime(originSimulateResult);
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev simulate run cross chain packets and get a simulation result for precrime later
 103 |     |      * @param _packets packets, the packets item should group by srcChainId, srcAddress, then sort by nonce
 104 |     |      * @return code   simulation result code; see the error code defination
 105 |     |      * @return data the result is use for precrime params
 106 |     |      */
 107 |     |     function simulate(Packet[] calldata _packets) external view override returns (uint16 code, bytes memory data) {
 108 |     |         // params check
 109 |     |         (code, data) = _checkPacketsMaxSizeAndNonceOrder(_packets);
 110 |     |         if (code != CODE_SUCCESS) {
 111 |     |             return (code, data);
 112 |     |         }
 113 |     | 
 114 |     |         (code, data) = _simulate(_packets);
 115 |     |         if (code == CODE_SUCCESS) {
 116 |     |             data = abi.encode(localChainId, data); // add localChainId to the header
 117 |     |         }
 118 |     |     }
 119 |     | 
 120 |     |     function version() external pure override returns (uint16) {
 121 |     |         return PRECRIME_VERSION;
 122 |     |     }
 123 |     | 
 124 |     |     function _checkPacketsMaxSizeAndNonceOrder(Packet[] calldata _packets) internal view returns (uint16 code, bytes memory reason) {
 125 |     |         uint64 maxSize = _maxBatchSize();
 126 |     |         if (_packets.length > maxSize) {
 127 |     |             return (CODE_PACKETS_OVERSIZE, abi.encodePacked("packets size exceed limited"));
 128 |     |         }
 129 |     | 
 130 |     |         // check packets nonce, sequence order
 131 |     |         // packets should group by srcChainId and srcAddress, then sort by nonce ascending
 132 |     |         if (_packets.length > 0) {
 133 |     |             uint16 srcChainId;
 134 |     |             bytes32 srcAddress;
 135 |     |             uint64 nonce;
 136 |     |             for (uint256 i = 0; i < _packets.length; i++) {
 137 |     |                 Packet memory packet = _packets[i];
 138 |     |                 // start from a new chain packet or a new source UA
 139 |     |                 if (packet.srcChainId != srcChainId || packet.srcAddress != srcAddress) {
 140 |     |                     srcChainId = packet.srcChainId;
 141 |     |                     srcAddress = packet.srcAddress;
 142 |     |                     nonce = packet.nonce;
 143 |     |                     uint64 nextInboundNonce = _getInboundNonce(packet) + 1;
 144 |     |                     // the first packet's nonce must equal to dst InboundNonce+1
 145 |     |                     if (nonce != nextInboundNonce) {
 146 |     |                         return (CODE_PACKETS_UNSORTED, abi.encodePacked("skipped inboundNonce forbidden"));
 147 |     |                     }
 148 |     |                 } else {
 149 |     |                     // the following packet's nonce add 1 in order
 150 |     |                     if (packet.nonce != ++nonce) {
 151 |     |                         return (CODE_PACKETS_UNSORTED, abi.encodePacked("unsorted packets"));
 152 |     |                     }
 153 |     |                 }
 154 |     |             }
 155 |     |         }
 156 |     |         return (CODE_SUCCESS, "");
 157 |     |     }
 158 |     | 
 159 |     |     function _checkResultsCompleteness(
 160 |     |         Packet[] calldata _packets,
 161 |     |         uint16[] memory _resultChainIds
 162 |     |     ) internal view returns (uint16 code, bytes memory reason) {
 163 |     |         // check if all remote result included
 164 |     |         if (_packets.length > 0) {
 165 |     |             (uint16[] memory remoteChains, ) = _remotePrecrimeAddress(_packets);
 166 |     |             for (uint256 i = 0; i < remoteChains.length; i++) {
 167 |     |                 bool resultChainIdChecked;
 168 |     |                 for (uint256 j = 0; j < _resultChainIds.length; j++) {
 169 |     |                     if (_resultChainIds[j] == remoteChains[i]) {
 170 |     |                         resultChainIdChecked = true;
 171 |     |                         break;
 172 |     |                     }
 173 |     |                 }
 174 |     |                 if (!resultChainIdChecked) {
 175 |     |                     return (CODE_MISS_SIMULATE_RESULT, "missing remote simulation result");
 176 |     |                 }
 177 |     |             }
 178 |     |         }
 179 |     |         // check if local result included
 180 |     |         bool localChainIdResultChecked;
 181 |     |         for (uint256 j = 0; j < _resultChainIds.length; j++) {
 182 |     |             if (_resultChainIds[j] == localChainId) {
 183 |     |                 localChainIdResultChecked = true;
 184 |     |                 break;
 185 |     |             }
 186 |     |         }
 187 |     |         if (!localChainIdResultChecked) {
 188 |     |             return (CODE_MISS_SIMULATE_RESULT, "missing local simulation result");
 189 |     |         }
 190 |     | 
 191 |     |         return (CODE_SUCCESS, "");
 192 |     |     }
 193 |     | 
 194 |     |     /**
 195 |     |      * @dev UA execute the logic by _packets, and return simulation result for precrime. would revert state after returned result.
 196 |     |      * @param _packets packets
 197 |     |      * @return code
 198 |     |      * @return result
 199 |     |      */
 200 |     |     function _simulate(Packet[] calldata _packets) internal view returns (uint16, bytes memory) {
 201 |     |         uint totalSupply = oftView.getCurrentState();
 202 |     | 
 203 |     |         for (uint i = 0; i < _packets.length; i++) {
 204 |     |             Packet memory packet = _packets[i];
 205 |     |             totalSupply = oftView.lzReceive(packet.srcChainId, packet.srcAddress, packet.payload, totalSupply);
 206 |     |         }
 207 |     | 
 208 |     |         return (CODE_SUCCESS, abi.encode(SimulationResult({chainTotalSupply: totalSupply, isProxy: oftView.isProxy()})));
 209 |     |     }
 210 |     | 
 211 |     |     /**
 212 |     |      * @dev
 213 |     |      * @param _simulation all simulation results from difference chains
 214 |     |      * @return code     precrime result code; check out the error code defination
 215 |     |      * @return reason   error reason
 216 |     |      */
 217 |     |     function _precrime(bytes[] memory _simulation) internal pure returns (uint16 code, bytes memory reason) {
 218 |     |         uint totalLocked = 0;
 219 |     |         uint totalMinted = 0;
 220 |     | 
 221 |     |         for (uint i = 0; i < _simulation.length; i++) {
 222 |     |             SimulationResult memory result = abi.decode(_simulation[i], (SimulationResult));
 223 |     |             if (result.isProxy) {
 224 |     |                 if (totalLocked > 0) {
 225 |     |                     return (CODE_PRECRIME_FAILURE, "more than one proxy simulation");
 226 |     |                 }
 227 |     |                 totalLocked = result.chainTotalSupply;
 228 |     |             } else {
 229 |     |                 totalMinted += result.chainTotalSupply;
 230 |     |             }
 231 |     |         }
 232 |     | 
 233 |     |         if (totalMinted > totalLocked) {
 234 |     |             return (CODE_PRECRIME_FAILURE, "total minted > total locked");
 235 |     |         }
 236 |     | 
 237 |     |         return (CODE_SUCCESS, "");
 238 |     |     }
 239 |     | 
 240 |     |     /**
 241 |     |      * @dev Always returns all remote chain ids and precrime addresses
 242 |     |      */
 243 |     |     function _remotePrecrimeAddress(
 244 |     |         Packet[] calldata
 245 |     |     ) internal view returns (uint16[] memory chainIds, bytes32[] memory precrimeAddresses) {
 246 |     |         return (remoteChainIds, remotePrecrimeAddresses);
 247 |     |     }
 248 |     | 
 249 |     |     /**
 250 |     |      * @dev max batch size for simulate
 251 |     |      */
 252 |     |     function _maxBatchSize() internal view virtual returns (uint64) {
 253 |     |         return maxBatchSize;
 254 |     |     }
 255 |     | 
 256 |     |     /**
 257 |     |      * get srcChain & srcAddress InboundNonce by packet
 258 |     |      */
 259 |     |     function _getInboundNonce(Packet memory _packet) internal view returns (uint64) {
 260 |     |         return oftView.getInboundNonce(_packet.srcChainId);
 261 |     |     }
 262 |     | }
 263 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/periphery/precrime/ProxyOFTV2View.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import {BaseOFTV2View} from "periphery/precrime/BaseOFTV2View.sol";
  6 |     | import {LzProxyOFTV2} from "tokens/LzProxyOFTV2.sol";
  7 |     | 
  8 |     | contract ProxyOFTV2View is BaseOFTV2View {
  9 |     |     error ErrTransferAmountExceedsLockedAmount();
 10 |     | 
 11 |     |     constructor(address _oft) BaseOFTV2View(_oft) {}
 12 |     | 
 13 |     |     function lzReceive(
 14 |     |         uint16 _srcChainId,
 15 |     |         bytes32 _scrAddress,
 16 |     |         bytes memory _payload,
 17 |     |         uint _totalSupply // totalSupply is the locked amount inside ProxyOFTV2
 18 |     |     ) external view override returns (uint) {
 19 |     |         if(!_isPacketFromTrustedRemote(_srcChainId, _scrAddress)) {
 20 |     |             revert ErrNotTrustedRemote();
 21 |     |         }
 22 |     | 
 23 |     |         uint amount = _decodePayload(_payload);
 24 |     | 
 25 |     |         if (amount > _totalSupply) {
 26 |     |             revert ErrTransferAmountExceedsLockedAmount();
 27 |     |         }
 28 |     | 
 29 |     |         return _totalSupply - amount;
 30 |     |     }
 31 |     | 
 32 |     |     function isProxy() external pure override returns (bool) {
 33 |     |         return true;
 34 |     |     }
 35 |     | 
 36 |     |     function getCurrentState() external view override returns (uint) {
 37 |     |         return LzProxyOFTV2(address(oft)).innerToken().balanceOf(address(oft));
 38 |     |     }
 39 |     | }
 40 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/staking/LockingMultiRewards.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {OperatableV2} from "mixins/OperatableV2.sol";
   5 |     | import {Pausable} from "openzeppelin-contracts/security/Pausable.sol";
   6 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
   7 |     | import {MathLib} from "libraries/MathLib.sol";
   8 |     | 
   9 |     | /// @notice A staking contract that distributes multiple rewards to stakers.
  10 |     | /// Stakers can lock their tokens for a period of time to get a boost on their rewards.
  11 |     | /// @author Based from Curve Finance's MultiRewards contract https://github.com/curvefi/multi-rewards/blob/master/contracts/MultiRewards.sol
  12 |     | /// @author Based from Ellipsis Finance's EpsStaker https://github.com/ellipsis-finance/ellipsis/blob/master/contracts/EpsStaker.sol
  13 |     | /// @author Based from Convex Finance's CvxLockerV2 https://github.com/convex-eth/platform/blob/main/contracts/contracts/CvxLockerV2.sol
  14 |     | contract LockingMultiRewards is OperatableV2, Pausable {
  15 |     |     using SafeTransferLib for address;
  16 |     | 
  17 |     |     event LogRewardAdded(uint256 reward);
  18 |     |     event LogStaked(address indexed user, uint256 amount);
  19 |     |     event LogLocked(address indexed user, uint256 amount, uint256 unlockTime, uint256 lockCount);
  20 |     |     event LogUnlocked(address indexed user, uint256 amount, uint256 index);
  21 |     |     event LogLockIndexChanged(address indexed user, uint256 fromIndex, uint256 toIndex);
  22 |     |     event LogWithdrawn(address indexed user, uint256 amount);
  23 |     |     event LogRewardLockCreated(address indexed user, uint256 unlockTime);
  24 |     |     event LogRewardLocked(address indexed user, address indexed rewardsToken, uint256 reward);
  25 |     |     event LogRewardPaid(address indexed user, address indexed rewardsToken, uint256 reward);
  26 |     |     event LogRewardsDurationUpdated(address token, uint256 newDuration);
  27 |     |     event LogRecovered(address token, uint256 amount);
  28 |     |     event LogSetMinLockAmount(uint256 previous, uint256 current);
  29 |     | 
  30 |     |     error ErrZeroAmount();
  31 |     |     error ErrRewardAlreadyExists();
  32 |     |     error ErrInvalidTokenAddress();
  33 |     |     error ErrMaxUserLocksExceeded();
  34 |     |     error ErrNotExpired();
  35 |     |     error ErrInvalidUser();
  36 |     |     error ErrLockAmountTooSmall();
  37 |     |     error ErrLengthMismatch();
  38 |     |     error ErrNoLocks();
  39 |     |     error ErrLockNotExpired();
  40 |     |     error ErrMaxRewardsExceeded();
  41 |     |     error ErrSkimmingTooMuch();
  42 |     |     error ErrInvalidLockIndex();
  43 |     |     error ErrNotEnoughReward();
  44 |     |     error ErrInvalidDurationRatio();
  45 |     |     error ErrInvalidBoostMultiplier();
  46 |     |     error ErrInvalidLockDuration();
  47 |     |     error ErrInvalidRewardDuration();
  48 |     |     error ErrInsufficientRemainingTime();
  49 |     | 
  50 |     |     struct Reward {
  51 |     |         uint256 periodFinish;
  52 |     |         uint256 rewardRate;
  53 |     |         uint256 rewardPerTokenStored;
  54 |     |         bool exists;
  55 |     |         uint248 lastUpdateTime;
  56 |     |     }
  57 |     | 
  58 |     |     struct Balances {
  59 |     |         uint256 unlocked;
  60 |     |         uint256 locked;
  61 |     |     }
  62 |     | 
  63 |     |     struct LockedBalance {
  64 |     |         uint256 amount;
  65 |     |         uint256 unlockTime;
  66 |     |     }
  67 |     | 
  68 |     |     struct RewardLockItem {
  69 |     |         address token;
  70 |     |         uint256 amount;
  71 |     |     }
  72 |     | 
  73 |     |     struct RewardLock {
  74 |     |         RewardLockItem[] items;
  75 |     |         uint256 unlockTime;
  76 |     |     }
  77 |     | 
  78 |     |     uint256 internal constant BIPS = 10_000;
  79 |     |     uint256 internal constant MAX_NUM_REWARDS = 5;
  80 |     |     uint256 internal constant MIN_LOCK_DURATION = 1 weeks;
  81 |     |     uint256 internal constant MIN_REWARDS_DURATION = 1 days;
  82 |     | 
  83 |     |     uint256 public immutable maxLocks;
  84 |     |     uint256 public immutable lockingBoostMultiplerInBips;
  85 |     |     uint256 public immutable rewardsDuration;
  86 |     |     uint256 public immutable lockDuration;
  87 |     |     address public immutable stakingToken;
  88 |     | 
  89 |     |     mapping(address token => Reward info) internal _rewardData;
  90 |     |     mapping(address user => Balances balances) internal _balances;
  91 |     |     mapping(address user => LockedBalance[] locks) internal _userLocks;
  92 |     |     mapping(address user => RewardLock rewardLock) internal _userRewardLock;
  93 |     | 
  94 |     |     mapping(address user => mapping(address token => uint256 amount)) public userRewardPerTokenPaid;
  95 |     |     mapping(address user => mapping(address token => uint256 amount)) public rewards;
  96 |     |     mapping(address user => uint256 index) public lastLockIndex;
  97 |     | 
  98 |     |     address[] public rewardTokens;
  99 |     | 
 100 |     |     uint256 public lockedSupply; // all locked boosted deposits
 101 |     |     uint256 public unlockedSupply; // all unlocked unboosted deposits
 102 |     |     uint256 public minLockAmount; // minimum amount allowed to lock
 103 |     |     uint256 public stakingTokenBalance; // total staking token balance
 104 |     | 
 105 |     |     ///
 106 |     |     /// @dev Constructor
 107 |     |     /// @param _stakingToken The token that is being staked
 108 |     |     /// @param _owner The owner of the contract
 109 |     |     /// @param _lockingBoostMultiplerInBips The multiplier for the locking boost. 30000 means if you stake 100, you get 300 locked
 110 |     |     /// @param _rewardsDuration The duration of the rewards period in seconds, should be 7 days by default.
 111 |     |     /// @param _lockDuration The duration of the lock period in seconds, should be 13 weeks by default.
 112 |     |     constructor(
 113 |     |         address _stakingToken,
 114 |     |         uint256 _lockingBoostMultiplerInBips,
 115 |     |         uint256 _rewardsDuration,
 116 |     |         uint256 _lockDuration,
 117 |     |         address _owner
 118 |     |     ) OperatableV2(_owner) {
 119 |     |         if (_lockingBoostMultiplerInBips <= BIPS) {
 120 |     |             revert ErrInvalidBoostMultiplier();
 121 |     |         }
 122 |     | 
 123 |     |         if (_lockDuration < MIN_LOCK_DURATION) {
 124 |     |             revert ErrInvalidLockDuration();
 125 |     |         }
 126 |     | 
 127 |     |         if (_rewardsDuration < MIN_REWARDS_DURATION) {
 128 |     |             revert ErrInvalidRewardDuration();
 129 |     |         }
 130 |     | 
 131 |     |         if (_lockDuration % _rewardsDuration != 0) {
 132 |     |             revert ErrInvalidDurationRatio();
 133 |     |         }
 134 |     | 
 135 |     |         stakingToken = _stakingToken;
 136 |     |         lockingBoostMultiplerInBips = _lockingBoostMultiplerInBips;
 137 |     |         rewardsDuration = _rewardsDuration;
 138 |     |         lockDuration = _lockDuration;
 139 |     | 
 140 |     |         // kocks are combined into the same `rewardsDuration` epoch. So, if
 141 |     |         // a user stake with locking every `rewardsDuration` this should reach the
 142 |     |         // maximum number of possible simultaneous because the first lock gets expired,
 143 |     |         // freeing up a slot.
 144 |     |         maxLocks = _lockDuration / _rewardsDuration;
 145 |     |     }
 146 |     | 
 147 |     |     /// @notice Stakes the given amount of tokens for the given user.
 148 |     |     /// @param amount The amount of tokens to stake
 149 |     |     /// @param lock_ If true, the tokens will be locked for the lock duration for a reward boost
 150 |     |     function stake(uint256 amount, bool lock_) public whenNotPaused {
 151 |     |         _stakeFor(msg.sender, amount, lock_);
 152 |     |     }
 153 |     | 
 154 |     |     /// @notice Locks an existing unlocked balance.
 155 |     |     function lock(uint256 amount) public whenNotPaused {
 156 |     |         if (amount == 0) {
 157 |     |             revert ErrZeroAmount();
 158 |     |         }
 159 |     | 
 160 |     |         _updateRewardsForUser(msg.sender);
 161 |     | 
 162 |     |         _balances[msg.sender].unlocked -= amount;
 163 |     |         unlockedSupply -= amount;
 164 |     | 
 165 |     |         _createLock(msg.sender, amount);
 166 |     |     }
 167 |     | 
 168 |     |     /// @notice Withdraws the given amount of unlocked tokens for the given user.
 169 |     |     /// @param amount The amount of unlocked tokens to withdraw
 170 |     |     function withdraw(uint256 amount) public virtual {
 171 |     |         if (amount == 0) {
 172 |     |             revert ErrZeroAmount();
 173 |     |         }
 174 |     | 
 175 |     |         _updateRewardsForUser(msg.sender);
 176 |     | 
 177 |     |         _balances[msg.sender].unlocked -= amount;
 178 |     |         unlockedSupply -= amount;
 179 |     | 
 180 |     |         stakingToken.safeTransfer(msg.sender, amount);
 181 |     |         stakingTokenBalance -= amount;
 182 |     | 
 183 |     |         emit LogWithdrawn(msg.sender, amount);
 184 |     |     }
 185 |     | 
 186 |     |     function withdrawWithRewards(uint256 amount) public virtual {
 187 |     |         withdraw(amount);
 188 |     |         _getRewards(msg.sender);
 189 |     |     }
 190 |     | 
 191 |     |     function getRewards() public virtual {
 192 |     |         _updateRewardsForUser(msg.sender);
 193 |     |         _getRewards(msg.sender);
 194 |     |     }
 195 |     | 
 196 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 197 |     |     /// VIEWS
 198 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 199 |     |     function rewardData(address token) external view returns (Reward memory) {
 200 |     |         return _rewardData[token];
 201 |     |     }
 202 |     | 
 203 |     |     function rewardsForDuration(address rewardToken) external view returns (uint256) {
 204 |     |         return _rewardData[rewardToken].rewardRate * rewardsDuration;
 205 |     |     }
 206 |     | 
 207 |     |     function rewardTokensLength() external view returns (uint256) {
 208 |     |         return rewardTokens.length;
 209 |     |     }
 210 |     | 
 211 |     |     function balances(address user) external view returns (Balances memory) {
 212 |     |         return _balances[user];
 213 |     |     }
 214 |     | 
 215 |     |     function userRewardLock(address user) external view returns (RewardLock memory) {
 216 |     |         return _userRewardLock[user];
 217 |     |     }
 218 |     | 
 219 |     |     function userLocks(address user) external view returns (LockedBalance[] memory) {
 220 |     |         return _userLocks[user];
 221 |     |     }
 222 |     | 
 223 |     |     function userLocksLength(address user) external view returns (uint256) {
 224 |     |         return _userLocks[user].length;
 225 |     |     }
 226 |     | 
 227 |     |     function locked(address user) external view returns (uint256) {
 228 |     |         return _balances[user].locked;
 229 |     |     }
 230 |     | 
 231 |     |     function unlocked(address user) external view returns (uint256) {
 232 |     |         return _balances[user].unlocked;
 233 |     |     }
 234 |     | 
 235 |     |     function totalSupply() public view returns (uint256) {
 236 |     |         return unlockedSupply + ((lockedSupply * lockingBoostMultiplerInBips) / BIPS);
 237 |     |     }
 238 |     | 
 239 |     |     function balanceOf(address user) public view returns (uint256) {
 240 |     |         Balances storage bal = _balances[user];
 241 |     |         return bal.unlocked + ((bal.locked * lockingBoostMultiplerInBips) / BIPS);
 242 |     |     }
 243 |     | 
 244 |     |     /// @dev Calculates when the next unlock event will occur given the current epoch.
 245 |     |     /// It ensures that the unlock timing coincides with the intervals at which rewards are distributed.
 246 |     |     /// If the current time is within an ongoing reward interval, the function establishes the
 247 |     |     /// unlock period to begin at the next epoch.
 248 |     |     /// So, if you stake at week 1 + 4 days, you will be able to unlock at the end of week 14.
 249 |     |     // |    week -1   |    week 1    |    week 2    |      ...     |    week 13   |    week 14   |
 250 |     |     // |--------------|--------------|--------------|--------------|--------------|--------------|
 251 |     |     // |                   ^ block.timestamp                                      |
 252 |     |     // |                             ^ lock starts (adjusted)                                    ^ unlock ends (nextUnlockTime)
 253 |     |     function nextUnlockTime() public view returns (uint256) {
 254 |     |         return nextEpoch() + lockDuration;
 255 |     |     }
 256 |     | 
 257 |     |     function epoch() public view returns (uint256) {
 258 |     |         return (block.timestamp / rewardsDuration) * rewardsDuration;
 259 |     |     }
 260 |     | 
 261 |     |     function nextEpoch() public view returns (uint256) {
 262 |     |         return epoch() + rewardsDuration;
 263 |     |     }
 264 |     | 
 265 |     |     function remainingEpochTime() public view returns (uint256) {
 266 |     |         return nextEpoch() - block.timestamp;
 267 |     |     }
 268 |     | 
 269 |     |     function lastTimeRewardApplicable(address rewardToken) public view returns (uint256) {
 270 |     |         return MathLib.min(block.timestamp, _rewardData[rewardToken].periodFinish);
 271 |     |     }
 272 |     | 
 273 |     |     function rewardPerToken(address rewardToken) public view returns (uint256) {
 274 |     |         return _rewardPerToken(rewardToken, lastTimeRewardApplicable(rewardToken), totalSupply());
 275 |     |     }
 276 |     | 
 277 |     |     function _rewardPerToken(address rewardToken, uint256 lastTimeRewardApplicable_, uint256 totalSupply_) public view returns (uint256) {
 278 |     |         if (totalSupply_ == 0) {
 279 |     |             return _rewardData[rewardToken].rewardPerTokenStored;
 280 |     |         }
 281 |     | 
 282 |     |         uint256 timeElapsed = lastTimeRewardApplicable_ - _rewardData[rewardToken].lastUpdateTime;
 283 |     |         uint256 pendingRewardsPerToken = (timeElapsed * _rewardData[rewardToken].rewardRate * 1e18) / totalSupply_;
 284 |     | 
 285 |     |         return _rewardData[rewardToken].rewardPerTokenStored + pendingRewardsPerToken;
 286 |     |     }
 287 |     | 
 288 |     |     function earned(address user, address rewardToken) public view returns (uint256) {
 289 |     |         return _earned(user, balanceOf(user), rewardToken, rewardPerToken(rewardToken));
 290 |     |     }
 291 |     | 
 292 |     |     function _earned(address user, uint256 balance_, address rewardToken, uint256 rewardPerToken_) internal view returns (uint256) {
 293 |     |         uint256 pendingUserRewardsPerToken = rewardPerToken_ - userRewardPerTokenPaid[user][rewardToken];
 294 |     |         return ((balance_ * pendingUserRewardsPerToken) / 1e18) + rewards[user][rewardToken];
 295 |     |     }
 296 |     | 
 297 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 298 |     |     /// ADMIN
 299 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 300 |     |     function addReward(address rewardToken) public virtual onlyOwner {
 301 |     |         _addReward(rewardToken);
 302 |     |     }
 303 |     | 
 304 |     |     function setMinLockAmount(uint256 _minLockAmount) external onlyOwner {
 305 |     |         emit LogSetMinLockAmount(minLockAmount, _minLockAmount);
 306 |     |         minLockAmount = _minLockAmount;
 307 |     |     }
 308 |     | 
 309 |     |     /// @notice This function can recover any token except for the staking token beyond the balance necessary for rewards.
 310 |     |     /// WARNING: Use this function with caution to ensure it does not affect the reward mechanism.
 311 |     |     function recover(address tokenAddress, uint256 tokenAmount) external onlyOwner {
 312 |     |         // In case it's the staking token, allow to skim the excess
 313 |     |         if (tokenAddress == stakingToken && tokenAmount > stakingToken.balanceOf(address(this)) - stakingTokenBalance) {
 314 |     |             revert ErrSkimmingTooMuch();
 315 |     |         }
 316 |     | 
 317 |     |         tokenAddress.safeTransfer(owner, tokenAmount);
 318 |     |         emit LogRecovered(tokenAddress, tokenAmount);
 319 |     |     }
 320 |     | 
 321 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 322 |     |     /// EMERGENCY FUNCTIONS
 323 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 324 |     |     function pause() external onlyOwner {
 325 |     |         _pause();
 326 |     |     }
 327 |     | 
 328 |     |     function unpause() external onlyOwner {
 329 |     |         _unpause();
 330 |     |     }
 331 |     | 
 332 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 333 |     |     /// OPERATORS
 334 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 335 |     |     
 336 |     |     function stakeFor(address account, uint256 amount, bool lock_) external onlyOperators {
 337 |     |         _stakeFor(account, amount, lock_);
 338 |     |     }
 339 |     |     
 340 |     |     /// @notice Distribute new rewards to the stakers
 341 |     |     /// @param rewardToken The address of the reward token
 342 |     |     /// @param amount The amount of reward tokens to distribute
 343 |     |     /// @param minRemainingTime The minimum remaining time for the current reward period
 344 |     |     /// Used to avoid distributing rewards on a lower period than the expected one.
 345 |     |     /// Example: If the reward period is 7 days, and there are 2 days left, `minRemainingTime` higher than
 346 |     |     /// 2 days will revert the transaction.
 347 |     |     /// To ignore this check, set `minRemainingTime` to 0.
 348 |     |     function notifyRewardAmount(address rewardToken, uint256 amount, uint minRemainingTime) public onlyOperators {
 349 |     |         if (!_rewardData[rewardToken].exists) {
 350 |     |             revert ErrInvalidTokenAddress();
 351 |     |         }
 352 |     | 
 353 |     |         _updateRewards();
 354 |     |         rewardToken.safeTransferFrom(msg.sender, address(this), amount);
 355 |     | 
 356 |     |         Reward storage reward = _rewardData[rewardToken];
 357 |     | 
 358 |     |         uint256 _nextEpoch = nextEpoch();
 359 |     |         uint256 _remainingRewardTime = _nextEpoch - block.timestamp;
 360 |     | 
 361 |     |         if (_remainingRewardTime < minRemainingTime) {
 362 |     |             revert ErrInsufficientRemainingTime();
 363 |     |         }
 364 |     | 
 365 |     |         // Take the remainder of the current rewards and add it to the amount for the next period
 366 |     |         if (block.timestamp < reward.periodFinish) {
 367 |     |             amount += _remainingRewardTime * reward.rewardRate;
 368 |     |         }
 369 |     | 
 370 |     |         // avoid `rewardRate` being 0
 371 |     |         if (amount < _remainingRewardTime) {
 372 |     |             revert ErrNotEnoughReward();
 373 |     |         }
 374 |     | 
 375 |     |         reward.rewardRate = amount / _remainingRewardTime;
 376 |     |         reward.lastUpdateTime = uint248(block.timestamp);
 377 |     |         reward.periodFinish = _nextEpoch;
 378 |     | 
 379 |     |         emit LogRewardAdded(amount);
 380 |     |     }
 381 |     | 
 382 |     |     /// @notice Updates the balances of the given user and lock indexes
 383 |     |     // Should be called once a `rewardDuration` (for example, every week)
 384 |     |     function processExpiredLocks(address[] memory users, uint256[] calldata lockIndexes) external onlyOperators {
 385 |     |         if (users.length != lockIndexes.length) {
 386 |     |             revert ErrLengthMismatch();
 387 |     |         }
 388 |     | 
 389 |     |         _updateRewardsForUsers(users);
 390 |     | 
 391 |     |         // Release all expired users' locks
 392 |     |         for (uint256 i; i < users.length; ) {
 393 |     |             address user = users[i];
 394 |     |             Balances storage bal = _balances[user];
 395 |     |             LockedBalance[] storage locks = _userLocks[user];
 396 |     | 
 397 |     |             if (locks.length == 0) {
 398 |     |                 revert ErrNoLocks();
 399 |     |             }
 400 |     | 
 401 |     |             uint256 index = lockIndexes[i];
 402 |     | 
 403 |     |             // Prevents processing `lastLockIndex` out of order
 404 |     |             if (index == lastLockIndex[user] && locks.length > 1) {
 405 |     |                 revert ErrInvalidLockIndex();
 406 |     |             }
 407 |     | 
 408 |     |             // prohibit releasing non-expired locks
 409 |     |             if (locks[index].unlockTime > block.timestamp) {
 410 |     |                 revert ErrLockNotExpired();
 411 |     |             }
 412 |     | 
 413 |     |             uint256 amount = locks[index].amount;
 414 |     |             uint256 lastIndex = locks.length - 1;
 415 |     | 
 416 |     |             /// Last lock index changed place with the one we just swapped.
 417 |     |             if (lastLockIndex[user] == lastIndex) {
 418 |     |                 lastLockIndex[user] = index;
 419 |     |             }
 420 |     | 
 421 |     |             if (index != lastIndex) {
 422 |     |                 locks[index] = locks[lastIndex];
 423 |     |                 emit LogLockIndexChanged(user, lastIndex, index);
 424 |     |             }
 425 |     | 
 426 |     |             locks.pop();
 427 |     | 
 428 |     |             unlockedSupply += amount;
 429 |     |             lockedSupply -= amount;
 430 |     | 
 431 |     |             bal.unlocked += amount;
 432 |     |             bal.locked -= amount;
 433 |     | 
 434 |     |             emit LogUnlocked(user, amount, index);
 435 |     | 
 436 |     |             unchecked {
 437 |     |                 ++i;
 438 |     |             }
 439 |     |         }
 440 |     |     }
 441 |     | 
 442 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 443 |     |     /// INTERNALS
 444 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 445 |     |     function _stakeFor(address account, uint256 amount, bool lock_) internal {
 446 |     |         if (amount == 0) {
 447 |     |             revert ErrZeroAmount();
 448 |     |         }
 449 |     | 
 450 |     |         // This staking contract isn't using balanceOf, so it's safe to transfer immediately
 451 |     |         stakingToken.safeTransferFrom(msg.sender, address(this), amount);
 452 |     |         stakingTokenBalance += amount;
 453 |     | 
 454 |     |         _updateRewardsForUser(account);
 455 |     | 
 456 |     |         if (lock_) {
 457 |     |             _createLock(account, amount);
 458 |     |         } else {
 459 |     |             _balances[account].unlocked += amount;
 460 |     |             unlockedSupply += amount;
 461 |     | 
 462 |     |             emit LogStaked(account, amount);
 463 |     |         }
 464 |     |     }
 465 |     | 
 466 |     |     function _addReward(address rewardToken) internal {
 467 |     |         if (rewardToken == address(0)) {
 468 |     |             revert ErrInvalidTokenAddress();
 469 |     |         }
 470 |     | 
 471 |     |         if (_rewardData[rewardToken].exists) {
 472 |     |             revert ErrRewardAlreadyExists();
 473 |     |         }
 474 |     | 
 475 |     |         if (rewardTokens.length == MAX_NUM_REWARDS) {
 476 |     |             revert ErrMaxRewardsExceeded();
 477 |     |         }
 478 |     | 
 479 |     |         rewardTokens.push(rewardToken);
 480 |     |         _rewardData[rewardToken].exists = true;
 481 |     |     }
 482 |     | 
 483 |     |     function _createLock(address user, uint256 amount) internal {
 484 |     |         Balances storage bal = _balances[user];
 485 |     |         uint256 _nextUnlockTime = nextUnlockTime();
 486 |     |         uint256 _lastLockIndex = lastLockIndex[user];
 487 |     |         uint256 lockCount = _userLocks[user].length;
 488 |     | 
 489 |     |         bal.locked += amount;
 490 |     |         lockedSupply += amount;
 491 |     | 
 492 |     |         // Add to current lock if it's the same unlock time or the first one
 493 |     |         // userLocks is sorted by unlockTime, so the last lock is the most recent one
 494 |     |         if (lockCount == 0 || _userLocks[user][_lastLockIndex].unlockTime < _nextUnlockTime) {
 495 |     |             // Limit the number of locks per user to avoid too much gas costs per user
 496 |     |             // when looping through the locks
 497 |     |             if (lockCount == maxLocks) {
 498 |     |                 revert ErrMaxUserLocksExceeded();
 499 |     |             }
 500 |     | 
 501 |     |             if (amount < minLockAmount) {
 502 |     |                 revert ErrLockAmountTooSmall();
 503 |     |             }
 504 |     | 
 505 |     |             _userLocks[user].push(LockedBalance({amount: amount, unlockTime: _nextUnlockTime}));
 506 |     |             lastLockIndex[user] = lockCount;
 507 |     | 
 508 |     |             unchecked {
 509 |     |                 ++lockCount;
 510 |     |             }
 511 |     |         }
 512 |     |         /// It's the same reward period, so we just add the amount to the current lock
 513 |     |         else {
 514 |     |             _userLocks[user][_lastLockIndex].amount += amount;
 515 |     |         }
 516 |     | 
 517 |     |         emit LogLocked(user, amount, _nextUnlockTime, lockCount);
 518 |     |     }
 519 |     | 
 520 |     |     /// @dev Update the global accumulated rewards from the last update to this point,
 521 |     |     /// in relation with the `totalSupply`
 522 |     |     ///
 523 |     |     /// The idea is to allow everyone that are currently part of that supply to get their allocated
 524 |     |     /// reward share.
 525 |     |     ///
 526 |     |     /// Each user's reward share is taking in account when `rewards[user][token] = _earned(...)`
 527 |     |     /// is called. And only updated when a user is interacting with `stake`, `lock`, `withdraw`
 528 |     |     /// or `getRewards`.
 529 |     |     ///
 530 |     |     /// Otherwise, if it's yet-to-be-updated, it's going to get considered as part of the pending
 531 |     |     /// yet-to-receive rewards in the `earned` function.
 532 |     |     function _updateRewardsGlobal(address token_, uint256 totalSupply_) internal returns (uint256 rewardPerToken_) {
 533 |     |         uint256 lastTimeRewardApplicable_ = lastTimeRewardApplicable(token_);
 534 |     |         rewardPerToken_ = _rewardPerToken(token_, lastTimeRewardApplicable_, totalSupply_);
 535 |     | 
 536 |     |         _rewardData[token_].rewardPerTokenStored = rewardPerToken_;
 537 |     |         _rewardData[token_].lastUpdateTime = uint248(lastTimeRewardApplicable_); // safe to cast as this will never overflow
 538 |     |     }
 539 |     | 
 540 |     |     function _udpateUserRewards(address user_, uint256 balance_, address token_, uint256 rewardPerToken_) internal {
 541 |     |         rewards[user_][token_] = _earned(user_, balance_, token_, rewardPerToken_);
 542 |     |         userRewardPerTokenPaid[user_][token_] = rewardPerToken_;
 543 |     |     }
 544 |     | 
 545 |     |     /// @dev Simplest version of updating rewards. Mainly used by `notifyRewardAmount`.
 546 |     |     /// where we don't need to update any particular user but the global state for
 547 |     |     /// each reward tokens only.
 548 |     |     function _updateRewards() internal {
 549 |     |         uint256 totalSupply_ = totalSupply();
 550 |     | 
 551 |     |         for (uint256 i; i < rewardTokens.length; ) {
 552 |     |             _updateRewardsGlobal(rewardTokens[i], totalSupply_);
 553 |     |             unchecked {
 554 |     |                 ++i;
 555 |     |             }
 556 |     |         }
 557 |     |     }
 558 |     | 
 559 |     |     /// @dev More gas efficient version of `_updateRewards` when we
 560 |     |     /// only need to update the rewards for a single user.
 561 |     |     function _updateRewardsForUser(address user) internal {
 562 |     |         uint256 balance = balanceOf(user);
 563 |     |         uint256 totalSupply_ = totalSupply();
 564 |     | 
 565 |     |         for (uint256 i; i < rewardTokens.length; ) {
 566 |     |             address token = rewardTokens[i];
 567 |     |             _udpateUserRewards(user, balance, token, _updateRewardsGlobal(token, totalSupply_));
 568 |     | 
 569 |     |             unchecked {
 570 |     |                 ++i;
 571 |     |             }
 572 |     |         }
 573 |     |     }
 574 |     | 
 575 |     |     /// @dev `_updateRewardsForUser` for multiple users.
 576 |     |     function _updateRewardsForUsers(address[] memory users) internal {
 577 |     |         uint256 totalSupply_ = totalSupply();
 578 |     | 
 579 |     |         for (uint256 i; i < rewardTokens.length; ) {
 580 |     |             address token = rewardTokens[i];
 581 |     |             uint256 rewardPerToken_ = _updateRewardsGlobal(token, totalSupply_);
 582 |     | 
 583 |     |             // Record each user's rewards
 584 |     |             for (uint256 j; j < users.length; ) {
 585 |     |                 address user = users[j];
 586 |     |                 _udpateUserRewards(user, balanceOf(user), token, rewardPerToken_);
 587 |     | 
 588 |     |                 unchecked {
 589 |     |                     ++j;
 590 |     |                 }
 591 |     |             }
 592 |     | 
 593 |     |             unchecked {
 594 |     |                 ++i;
 595 |     |             }
 596 |     |         }
 597 |     |     }
 598 |     | 
 599 |     |     /// @notice Claim unlocked rewards or create a new reward lock that
 600 |     |     // makes them available the next epoch
 601 |     |     function _getRewards(address user) internal {
 602 |     |         RewardLock storage _rewardLock = _userRewardLock[user];
 603 |     | 
 604 |     |         // first ever lock is always expired because `unlockTime` is 0
 605 |     |         // unlock time is aligned to epoch
 606 |     |         bool expired = _rewardLock.unlockTime <= block.timestamp;
 607 |     | 
 608 |     |         // cache the length here since the loop will be modifying the array
 609 |     |         uint256 rewardItemLength = _rewardLock.items.length;
 610 |     | 
 611 |     |         // expired lock
 612 |     |         // existing lock items will be reused
 613 |     |         if (expired) {
 614 |     |             _rewardLock.unlockTime = nextEpoch();
 615 |     |             emit LogRewardLockCreated(user, _rewardLock.unlockTime);
 616 |     |         }
 617 |     | 
 618 |     |         for (uint256 i; i < rewardTokens.length; ) {
 619 |     |             address rewardToken = rewardTokens[i];
 620 |     |             uint256 rewardAmount = rewards[user][rewardToken];
 621 |     | 
 622 |     |             // in all scenario, reset the reward amount immediately
 623 |     |             rewards[user][rewardToken] = 0;
 624 |     | 
 625 |     |             // don't assume the rewardTokens array is always the same length as the items array
 626 |     |             // as new reward tokens can be added by the owner
 627 |     |             if (i < rewardItemLength) {
 628 |     |                 RewardLockItem storage item = _rewardLock.items[i];
 629 |     | 
 630 |     |                 // expired lock, claim existing unlocked rewards if any
 631 |     |                 if (expired) {
 632 |     |                     uint256 amount = item.amount;
 633 |     | 
 634 |     |                     // since this current lock is expired and that item index
 635 |     |                     // matches the reward index, override the current amount
 636 |     |                     // with the new locked amount.
 637 |     |                     item.amount = rewardAmount;
 638 |     | 
 639 |     |                     // use cached amount
 640 |     |                     if (amount > 0) {
 641 |     |                         rewardToken.safeTransfer(user, amount);
 642 |     |                         emit LogRewardPaid(user, rewardToken, amount);
 643 |     |                     }
 644 |     |                 } else {
 645 |     |                     // not expired, just add to the existing lock
 646 |     |                     item.amount += rewardAmount;
 647 |     |                 }
 648 |     |             }
 649 |     |             // new reward token, create a new lock item
 650 |     |             // could mean it's adding to an existing lock or creating a new one
 651 |     |             else {
 652 |     |                 _userRewardLock[user].items.push(RewardLockItem({token: rewardToken, amount: rewardAmount}));
 653 |     |             }
 654 |     | 
 655 |     |             emit LogRewardLocked(user, rewardToken, rewardAmount);
 656 |     | 
 657 |     |             unchecked {
 658 |     |                 ++i;
 659 |     |             }
 660 |     |         }
 661 |     |     }
 662 |     | }
 663 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/staking/MultiRewards.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {OperatableV2} from "mixins/OperatableV2.sol";
   5 |     | import {Pausable} from "openzeppelin-contracts/security/Pausable.sol";
   6 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
   7 |     | import {MathLib} from "libraries/MathLib.sol";
   8 |     | 
   9 |     | /// @notice A staking contract that distributes multiple rewards to stakers.
  10 |     | /// @author Modified from Curve Finance's MultiRewards contract
  11 |     | /// https://github.com/curvefi/multi-rewards/blob/master/contracts/MultiRewards.sol
  12 |     | contract MultiRewards is OperatableV2, Pausable {
  13 |     |     using SafeTransferLib for address;
  14 |     | 
  15 |     |     event LogRewardAdded(uint256 reward);
  16 |     |     event LogStaked(address indexed user, uint256 amount);
  17 |     |     event LogWithdrawn(address indexed user, uint256 amount);
  18 |     |     event LogRewardPaid(address indexed user, address indexed rewardsToken, uint256 reward);
  19 |     |     event LogRewardsDurationUpdated(address token, uint256 newDuration);
  20 |     |     event LogRecovered(address token, uint256 amount);
  21 |     | 
  22 |     |     error ErrZeroAmount();
  23 |     |     error ErrZeroDuration();
  24 |     |     error ErrRewardAlreadyAdded();
  25 |     |     error ErrRewardPeriodStillActive();
  26 |     |     error ErrInvalidTokenAddress();
  27 |     | 
  28 |     |     struct Reward {
  29 |     |         uint256 rewardsDuration;
  30 |     |         uint256 periodFinish;
  31 |     |         uint256 rewardRate;
  32 |     |         uint256 lastUpdateTime;
  33 |     |         uint256 rewardPerTokenStored;
  34 |     |     }
  35 |     | 
  36 |     |     address public immutable stakingToken;
  37 |     | 
  38 |     |     mapping(address token => Reward info) private _rewardData;
  39 |     |     mapping(address user => uint256 amount) public balanceOf;
  40 |     |     mapping(address user => mapping(address token => uint256 amount)) public userRewardPerTokenPaid;
  41 |     |     mapping(address user => mapping(address token => uint256 amount)) public rewards;
  42 |     | 
  43 |     |     address[] public rewardTokens;
  44 |     |     uint256 public totalSupply;
  45 |     | 
  46 |     |     constructor(address _stakingToken, address _owner) OperatableV2(_owner) {
  47 |     |         stakingToken = _stakingToken;
  48 |     |     }
  49 |     | 
  50 |     |     function stake(uint256 amount) public virtual whenNotPaused {
  51 |     |         if (amount == 0) {
  52 |     |             revert ErrZeroAmount();
  53 |     |         }
  54 |     | 
  55 |     |         _updateRewards(msg.sender);
  56 |     |         totalSupply += amount;
  57 |     |         balanceOf[msg.sender] += amount;
  58 |     | 
  59 |     |         stakingToken.safeTransferFrom(msg.sender, address(this), amount);
  60 |     |         emit LogStaked(msg.sender, amount);
  61 |     |     }
  62 |     | 
  63 |     |     function withdraw(uint256 amount) public virtual {
  64 |     |         if (amount == 0) {
  65 |     |             revert ErrZeroAmount();
  66 |     |         }
  67 |     | 
  68 |     |         _updateRewards(msg.sender);
  69 |     |         totalSupply -= amount;
  70 |     |         balanceOf[msg.sender] -= amount;
  71 |     | 
  72 |     |         stakingToken.safeTransfer(msg.sender, amount);
  73 |     |         emit LogWithdrawn(msg.sender, amount);
  74 |     |     }
  75 |     | 
  76 |     |     function getRewards() public virtual {
  77 |     |         _updateRewards(msg.sender);
  78 |     | 
  79 |     |         for (uint256 i; i < rewardTokens.length; ) {
  80 |     |             address rewardToken = rewardTokens[i];
  81 |     |             uint256 reward = rewards[msg.sender][rewardToken];
  82 |     | 
  83 |     |             if (reward > 0) {
  84 |     |                 rewards[msg.sender][rewardToken] = 0;
  85 |     |                 rewardToken.safeTransfer(msg.sender, reward);
  86 |     | 
  87 |     |                 emit LogRewardPaid(msg.sender, rewardToken, reward);
  88 |     |             }
  89 |     | 
  90 |     |             unchecked {
  91 |     |                 ++i;
  92 |     |             }
  93 |     |         }
  94 |     |     }
  95 |     | 
  96 |     |     function exit() public virtual {
  97 |     |         withdraw(balanceOf[msg.sender]);
  98 |     |         getRewards();
  99 |     |     }
 100 |     | 
 101 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 102 |     |     /// VIEWS
 103 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 104 |     |     function rewardData(address token) external view returns (Reward memory) {
 105 |     |         return _rewardData[token];
 106 |     |     }
 107 |     | 
 108 |     |     function lastTimeRewardApplicable(address rewardToken) public view returns (uint256) {
 109 |     |         return MathLib.min(block.timestamp, _rewardData[rewardToken].periodFinish);
 110 |     |     }
 111 |     | 
 112 |     |     function rewardPerToken(address rewardToken) public view returns (uint256) {
 113 |     |         if (totalSupply == 0) {
 114 |     |             return _rewardData[rewardToken].rewardPerTokenStored;
 115 |     |         }
 116 |     | 
 117 |     |         uint256 timeElapsed = lastTimeRewardApplicable(rewardToken) - _rewardData[rewardToken].lastUpdateTime;
 118 |     |         uint256 pendingRewardsPerToken = (timeElapsed * _rewardData[rewardToken].rewardRate * 1e18) / totalSupply;
 119 |     | 
 120 |     |         return _rewardData[rewardToken].rewardPerTokenStored + pendingRewardsPerToken;
 121 |     |     }
 122 |     | 
 123 |     |     function earned(address user, address rewardToken) public view returns (uint256) {
 124 |     |         uint256 pendingUserRewardsPerToken = rewardPerToken(rewardToken) - userRewardPerTokenPaid[user][rewardToken];
 125 |     | 
 126 |     |         return ((balanceOf[user] * pendingUserRewardsPerToken) / 1e18) + rewards[user][rewardToken];
 127 |     |     }
 128 |     | 
 129 |     |     function getRewardForDuration(address rewardToken) external view returns (uint256) {
 130 |     |         return _rewardData[rewardToken].rewardRate * _rewardData[rewardToken].rewardsDuration;
 131 |     |     }
 132 |     | 
 133 |     |     function getRewardTokenLength() external view returns (uint256) {
 134 |     |         return rewardTokens.length;
 135 |     |     }
 136 |     | 
 137 |     |     function isSupportedReward(address rewardToken) external view returns (bool) {
 138 |     |         return _rewardData[rewardToken].rewardsDuration != 0;
 139 |     |     }
 140 |     | 
 141 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 142 |     |     /// ADMIN
 143 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 144 |     |     function addReward(address rewardToken, uint256 _rewardsDuration) public onlyOwner {
 145 |     |         if (rewardToken == address(0)) {
 146 |     |             revert ErrInvalidTokenAddress();
 147 |     |         }
 148 |     |         if (_rewardData[rewardToken].rewardsDuration != 0) {
 149 |     |             revert ErrRewardAlreadyAdded();
 150 |     |         }
 151 |     |         if (_rewardsDuration == 0) {
 152 |     |             revert ErrZeroDuration();
 153 |     |         }
 154 |     | 
 155 |     |         rewardTokens.push(rewardToken);
 156 |     |         _rewardData[rewardToken].rewardsDuration = _rewardsDuration;
 157 |     |     }
 158 |     | 
 159 |     |     function setRewardsDuration(address rewardToken, uint256 _rewardsDuration) external onlyOwner {
 160 |     |         if (block.timestamp <= _rewardData[rewardToken].periodFinish) {
 161 |     |             revert ErrRewardPeriodStillActive();
 162 |     |         }
 163 |     |         if (_rewardsDuration == 0) {
 164 |     |             revert ErrZeroDuration();
 165 |     |         }
 166 |     | 
 167 |     |         _rewardData[rewardToken].rewardsDuration = _rewardsDuration;
 168 |     |         emit LogRewardsDurationUpdated(rewardToken, _rewardData[rewardToken].rewardsDuration);
 169 |     |     }
 170 |     | 
 171 |     |     function recover(address tokenAddress, uint256 tokenAmount) external onlyOwner {
 172 |     |         if (tokenAddress == stakingToken) {
 173 |     |             revert ErrInvalidTokenAddress();
 174 |     |         }
 175 |     | 
 176 |     |         tokenAddress.safeTransfer(owner, tokenAmount);
 177 |     |         emit LogRecovered(tokenAddress, tokenAmount);
 178 |     |     }
 179 |     | 
 180 |     |     function pause() external onlyOwner {
 181 |     |         _pause();
 182 |     |     }
 183 |     | 
 184 |     |     function unpause() external onlyOwner {
 185 |     |         _unpause();
 186 |     |     }
 187 |     | 
 188 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 189 |     |     /// OPERATORS
 190 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 191 |     |     function notifyRewardAmount(address rewardToken, uint256 amount) external onlyOperators {
 192 |     |         if (_rewardData[rewardToken].rewardsDuration == 0) {
 193 |     |             revert ErrInvalidTokenAddress();
 194 |     |         }
 195 |     | 
 196 |     |         _updateRewards(address(0));
 197 |     |         rewardToken.safeTransferFrom(msg.sender, address(this), amount);
 198 |     | 
 199 |     |         // Take the remainder of the current rewards and add it to the amount for the next period
 200 |     |         if (block.timestamp < _rewardData[rewardToken].periodFinish) {
 201 |     |             amount += (_rewardData[rewardToken].periodFinish - block.timestamp) * _rewardData[rewardToken].rewardRate;
 202 |     |         }
 203 |     | 
 204 |     |         _rewardData[rewardToken].rewardRate = amount / _rewardData[rewardToken].rewardsDuration;
 205 |     |         _rewardData[rewardToken].lastUpdateTime = block.timestamp;
 206 |     |         _rewardData[rewardToken].periodFinish = block.timestamp + _rewardData[rewardToken].rewardsDuration;
 207 |     | 
 208 |     |         emit LogRewardAdded(amount);
 209 |     |     }
 210 |     | 
 211 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 212 |     |     /// INTERNALS
 213 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 214 |     |     function _updateRewards(address user) internal {
 215 |     |         for (uint256 i; i < rewardTokens.length; ) {
 216 |     |             address token = rewardTokens[i];
 217 |     | 
 218 |     |             _rewardData[token].rewardPerTokenStored = rewardPerToken(token);
 219 |     |             _rewardData[token].lastUpdateTime = lastTimeRewardApplicable(token);
 220 |     | 
 221 |     |             if (user != address(0)) {
 222 |     |                 rewards[user][token] = earned(user, token);
 223 |     |                 userRewardPerTokenPaid[user][token] = _rewardData[token].rewardPerTokenStored;
 224 |     |             }
 225 |     | 
 226 |     |             unchecked {
 227 |     |                 ++i;
 228 |     |             }
 229 |     |         }
 230 |     |     }
 231 |     | }
 232 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/staking/PrivateMultiRewardsStaking.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {OperatableV2} from "mixins/OperatableV2.sol";
  5 |     | import {Pausable} from "openzeppelin-contracts/security/Pausable.sol";
  6 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
  7 |     | import {MathLib} from "libraries/MathLib.sol";
  8 |     | import {MultiRewards} from "staking/MultiRewards.sol";
  9 |     | 
 10 |     | /// @notice Permissioned version of MultiRewards
 11 |     | contract PrivateMultiRewardsStaking is MultiRewards {
 12 |     |     event LogAuthorizedChanged(address indexed, bool);
 13 |     |     error ErrNotAuthorized();
 14 |     | 
 15 |     |     mapping(address => bool) public authorized;
 16 |     | 
 17 |     |     modifier onlyAuthorized() {
 18 |     |         if (!authorized[msg.sender]) {
 19 |     |             revert ErrNotAuthorized();
 20 |     |         }
 21 |     |         _;
 22 |     |     }
 23 |     | 
 24 |     |     constructor(address _stakingToken, address _owner) MultiRewards(_stakingToken, _owner) {}
 25 |     | 
 26 |     |     function stake(uint256 amount) public override onlyAuthorized {
 27 |     |         super.stake(amount);
 28 |     |     }
 29 |     | 
 30 |     |     function withdraw(uint256 amount) public override onlyAuthorized {
 31 |     |         super.withdraw(amount);
 32 |     |     }
 33 |     | 
 34 |     |     function getRewards() public override onlyAuthorized {
 35 |     |         super.getRewards();
 36 |     |     }
 37 |     | 
 38 |     |     function exit() public override onlyAuthorized {
 39 |     |         super.exit();
 40 |     |     }
 41 |     | 
 42 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 43 |     |     /// ADMIN
 44 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 45 |     |     function setAuthorized(address account, bool status) external onlyOwner {
 46 |     |         authorized[account] = status;
 47 |     |         emit LogAuthorizedChanged(account, status);
 48 |     |     }
 49 |     | }
 50 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/strategies/BaseStrategy.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | 
   3 |     | pragma solidity >=0.8.0;
   4 |     | 
   5 |     | import {BoringOwnable} from "BoringSolidity/BoringOwnable.sol";
   6 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   7 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
   8 |     | import {IStrategy} from "interfaces/IStrategy.sol";
   9 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  10 |     | 
  11 |     | abstract contract BaseStrategy is IStrategy, BoringOwnable {
  12 |     |     using BoringERC20 for IERC20;
  13 |     | 
  14 |     |     IERC20 public immutable strategyToken;
  15 |     |     IBentoBoxV1 public immutable bentoBox;
  16 |     | 
  17 |     |     bool public exited; /// @dev After bentobox 'exits' the strategy harvest, skim and withdraw functions can no loner be called
  18 |     |     uint256 public maxBentoBoxBalance; /// @dev Slippage protection when calling harvest
  19 |     |     mapping(address => bool) public strategyExecutors; /// @dev EOAs that can execute safeHarvest
  20 |     |     event LogSetStrategyExecutor(address indexed executor, bool allowed);
  21 |     | 
  22 |     |     /** @param _strategyToken Address of the underlying token the strategy invests.
  23 |     |         @param _bentoBox BentoBox address.
  24 |     |     */
  25 |     |     constructor(IERC20 _strategyToken, IBentoBoxV1 _bentoBox) {
  26 |     |         strategyToken = _strategyToken;
  27 |     |         bentoBox = _bentoBox;
  28 |     |     }
  29 |     | 
  30 |     |     //** Strategy implementation: override the following functions: */
  31 |     | 
  32 |     |     /// @notice Invests the underlying asset.
  33 |     |     /// @param amount The amount of tokens to invest.
  34 |     |     /// @dev Assume the contract's balance is greater than the amount
  35 |     |     function _skim(uint256 amount) internal virtual {}
  36 |     | 
  37 |     |     /// @notice Harvest any profits made and transfer them to address(this) or report a loss
  38 |     |     /// @param balance The amount of tokens that have been invested.
  39 |     |     /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.
  40 |     |     /// @dev amountAdded can be left at 0 when reporting profits (gas savings).
  41 |     |     /// amountAdded should not reflect any rewards or tokens the strategy received.
  42 |     |     /// Calcualte the amount added based on what the current deposit is worth.
  43 |     |     /// (The Base Strategy harvest function accounts for rewards).
  44 |     |     function _harvest(uint256 balance) internal virtual returns (int256 amountAdded) {}
  45 |     | 
  46 |     |     /// @dev Withdraw the requested amount of the underlying tokens to address(this).
  47 |     |     /// @param amount The requested amount we want to withdraw.
  48 |     |     function _withdraw(uint256 amount) internal virtual {}
  49 |     | 
  50 |     |     /// @notice Withdraw the maximum available amount of the invested assets to address(this).
  51 |     |     /// @dev This shouldn't revert (use try catch).
  52 |     |     function _exit() internal virtual {}
  53 |     | 
  54 |     |     /// @notice Claim any rewards reward tokens and optionally sell them for the underlying token.
  55 |     |     /// @dev Doesn't need to be implemented if we don't expect any rewards.
  56 |     |     function _harvestRewards() internal virtual {}
  57 |     | 
  58 |     |     //** End strategy implementation */
  59 |     | 
  60 |     |     modifier isActive() {
  61 |     |         require(!exited, "BentoBox Strategy: exited");
  62 |     |         _;
  63 |     |     }
  64 |     | 
  65 |     |     modifier onlyBentoBox() {
  66 |     |         require(msg.sender == address(bentoBox), "BentoBox Strategy: only BentoBox");
  67 |     |         _;
  68 |     |     }
  69 |     | 
  70 |     |     modifier onlyExecutor() {
  71 |     |         require(msg.sender == owner || strategyExecutors[msg.sender], "BentoBox Strategy: only Executors");
  72 |     |         _;
  73 |     |     }
  74 |     | 
  75 |     |     function setStrategyExecutor(address executor, bool value) external onlyOwner {
  76 |     |         strategyExecutors[executor] = value;
  77 |     |         emit LogSetStrategyExecutor(executor, value);
  78 |     |     }
  79 |     | 
  80 |     |     /// @inheritdoc IStrategy
  81 |     |     function skim(uint256 amount) external virtual override {
  82 |     |         _skim(amount);
  83 |     |     }
  84 |     | 
  85 |     |     /// @notice Harvest profits while preventing a sandwich attack exploit.
  86 |     |     /// @param maxBalance The maximum balance of the underlying token that is allowed to be in BentoBox.
  87 |     |     /// @param rebalance Whether BentoBox should rebalance the strategy assets to acheive it's target allocation.
  88 |     |     /// @param maxChangeAmount When rebalancing - the maximum amount that will be deposited to or withdrawn from a strategy to BentoBox.
  89 |     |     /// @param harvestRewards If we want to claim any accrued reward tokens
  90 |     |     /// @dev maxBalance can be set to 0 to keep the previous value.
  91 |     |     /// @dev maxChangeAmount can be set to 0 to allow for full rebalancing.
  92 |     |     function safeHarvest(uint256 maxBalance, bool rebalance, uint256 maxChangeAmount, bool harvestRewards) external onlyExecutor {
  93 |     |         _safeHarvest(maxBalance, rebalance, maxChangeAmount, harvestRewards);
  94 |     |     }
  95 |     | 
  96 |     |     function _safeHarvest(uint256 maxBalance, bool rebalance, uint256 maxChangeAmount, bool harvestRewards) internal {
  97 |     |         if (harvestRewards) {
  98 |     |             _harvestRewards();
  99 |     |         }
 100 |     | 
 101 |     |         if (maxBalance > 0) {
 102 |     |             maxBentoBoxBalance = maxBalance;
 103 |     |         }
 104 |     | 
 105 |     |         IBentoBoxV1(bentoBox).harvest(strategyToken, rebalance, maxChangeAmount);
 106 |     |     }
 107 |     | 
 108 |     |     /** @inheritdoc IStrategy
 109 |     |     @dev Only BentoBox can call harvest on this strategy.
 110 |     |     @dev Ensures that (1) the caller was this contract (called through the safeHarvest function)
 111 |     |         and (2) that we are not being frontrun by a large BentoBox deposit when harvesting profits. */
 112 |     |     function harvest(uint256 balance, address sender) external virtual override isActive onlyBentoBox returns (int256) {
 113 |     |         /** @dev Don't revert if conditions aren't met in order to allow
 114 |     |             BentoBox to continiue execution as it might need to do a rebalance. */
 115 |     | 
 116 |     |         if (sender == address(this) && IBentoBoxV1(bentoBox).totals(strategyToken).elastic <= maxBentoBoxBalance && balance > 0) {
 117 |     |             int256 amount = _harvest(balance);
 118 |     | 
 119 |     |             /** @dev Since harvesting of rewards is accounted for seperately we might also have
 120 |     |             some underlying tokens in the contract that the _harvest call doesn't report. 
 121 |     |             E.g. reward tokens that have been sold into the underlying tokens which are now sitting in the contract.
 122 |     |             Meaning the amount returned by the internal _harvest function isn't necessary the final profit/loss amount */
 123 |     | 
 124 |     |             uint256 contractBalance = strategyToken.balanceOf(address(this));
 125 |     | 
 126 |     |             if (amount >= 0) {
 127 |     |                 // _harvest reported a profit
 128 |     | 
 129 |     |                 if (contractBalance > 0) {
 130 |     |                     strategyToken.safeTransfer(address(bentoBox), contractBalance);
 131 |     |                 }
 132 |     | 
 133 |     |                 return int256(contractBalance);
 134 |     |             } else if (contractBalance > 0) {
 135 |     |                 // _harvest reported a loss but we have some tokens sitting in the contract
 136 |     | 
 137 |     |                 int256 diff = amount + int256(contractBalance);
 138 |     | 
 139 |     |                 if (diff > 0) {
 140 |     |                     // we still made some profit
 141 |     | 
 142 |     |                     /// @dev send the profit to BentoBox and reinvest the rest
 143 |     |                     strategyToken.safeTransfer(address(bentoBox), uint256(diff));
 144 |     |                     _skim(uint256(-amount));
 145 |     |                 } else {
 146 |     |                     // we made a loss but we have some tokens we can reinvest
 147 |     | 
 148 |     |                     _skim(contractBalance);
 149 |     |                 }
 150 |     | 
 151 |     |                 return diff;
 152 |     |             } else {
 153 |     |                 // we made a loss
 154 |     | 
 155 |     |                 return amount;
 156 |     |             }
 157 |     |         }
 158 |     | 
 159 |     |         return int256(0);
 160 |     |     }
 161 |     | 
 162 |     |     /// @inheritdoc IStrategy
 163 |     |     function withdraw(uint256 amount) external virtual override isActive onlyBentoBox returns (uint256 actualAmount) {
 164 |     |         _withdraw(amount);
 165 |     |         /// @dev Make sure we send and report the exact same amount of tokens by using balanceOf.
 166 |     |         actualAmount = strategyToken.balanceOf(address(this));
 167 |     |         strategyToken.safeTransfer(address(bentoBox), actualAmount);
 168 |     |     }
 169 |     | 
 170 |     |     /// @inheritdoc IStrategy
 171 |     |     /// @dev do not use isActive modifier here; allow bentobox to call strategy.exit() multiple times
 172 |     |     function exit(uint256 balance) external virtual override onlyBentoBox returns (int256 amountAdded) {
 173 |     |         _exit();
 174 |     |         /// @dev Check balance of token on the contract.
 175 |     |         uint256 actualBalance = strategyToken.balanceOf(address(this));
 176 |     |         /// @dev Calculate tokens added (or lost).
 177 |     |         amountAdded = int256(actualBalance) - int256(balance);
 178 |     |         /// @dev Transfer all tokens to bentoBox.
 179 |     |         strategyToken.safeTransfer(address(bentoBox), actualBalance);
 180 |     |         /// @dev Flag as exited, allowing the owner to manually deal with any amounts available later.
 181 |     |         exited = true;
 182 |     |     }
 183 |     | 
 184 |     |     /** @dev After exited, the owner can perform ANY call. This is to rescue any funds that didn't
 185 |     |         get released during exit or got earned afterwards due to vesting or airdrops, etc. */
 186 |     |     function afterExit(address to, uint256 value, bytes memory data) public onlyOwner returns (bool success) {
 187 |     |         require(exited, "BentoBox Strategy: not exited");
 188 |     | 
 189 |     |         // solhint-disable-next-line avoid-low-level-calls
 190 |     |         (success, ) = to.call{value: value}(data);
 191 |     |     }
 192 |     | }
 193 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/strategies/GmStrategy.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {Address} from "openzeppelin-contracts/utils/Address.sol";
   5 |     | import {BaseStrategy} from "./BaseStrategy.sol";
   6 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   7 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
   8 |     | import {FeeCollectable} from "mixins/FeeCollectable.sol";
   9 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
  10 |     | import {IGmxV2Deposit, IGmxV2ExchangeRouter, IGmxReader, IGmxV2EventUtils, IGmxDataStore, IGmxV2DepositHandler, IGmxV2DepositCallbackReceiver, IGmxV2Market} from "interfaces/IGmxV2.sol";
  11 |     | import {IMultiRewardsStaking} from "interfaces/IMultiRewardsStaking.sol";
  12 |     | 
  13 |     | contract GmStrategy is BaseStrategy, FeeCollectable, IGmxV2DepositCallbackReceiver {
  14 |     |     using SafeTransferLib for address;
  15 |     | 
  16 |     |     error ErrInsufficientAmountOut();
  17 |     |     error ErrExecuteDepositsDisabled();
  18 |     |     error ErrWrongUser();
  19 |     |     error ErrUnauthorized();
  20 |     |     error ErrInvalidToken();
  21 |     | 
  22 |     |     event LogCallbackGasLimitChanged(uint256 previous, uint256 current);
  23 |     |     event LogExchangeChanged(address indexed previous, address indexed current);
  24 |     |     event LogMarketMinted(uint256 total, uint256 strategyAmount, uint256 feeAmount);
  25 |     | 
  26 |     |     bytes32 public constant EXECUTE_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode("EXECUTE_DEPOSIT_FEATURE_DISABLED"));
  27 |     | 
  28 |     |     IGmxV2ExchangeRouter public immutable GMX_ROUTER;
  29 |     |     IGmxReader public immutable GMX_READER;
  30 |     |     IGmxDataStore public immutable DATASTORE;
  31 |     |     address public immutable DEPOSIT_VAULT;
  32 |     |     address public immutable SYNTHETICS_ROUTER;
  33 |     |     address public immutable REFUND_TO;
  34 |     |     address public immutable LONG_TOKEN;
  35 |     |     address public immutable SHORT_TOKEN;
  36 |     |     IMultiRewardsStaking public immutable STAKING;
  37 |     | 
  38 |     |     address public exchange;
  39 |     |     uint256 public callbackGasLimit = 2_000_000;
  40 |     |     bytes32 public orderKey;
  41 |     | 
  42 |     |     /// @dev Keep in memory the max balance once the GMX tokens are deposited
  43 |     |     uint256 private maxBalance;
  44 |     | 
  45 |     |     modifier onlyDepositHandler() {
  46 |     |         if (msg.sender != address(GMX_ROUTER.depositHandler())) {
  47 |     |             revert ErrUnauthorized();
  48 |     |         }
  49 |     |         _;
  50 |     |     }
  51 |     | 
  52 |     |     receive() external payable virtual {
  53 |     |         (bool success, ) = REFUND_TO.call{value: msg.value}("");
  54 |     | 
  55 |     |         // ignore failures
  56 |     |         if (!success) {
  57 |     |             return;
  58 |     |         }
  59 |     |     }
  60 |     | 
  61 |     |     constructor(
  62 |     |         address _strategyToken,
  63 |     |         IBentoBoxV1 _degenBox,
  64 |     |         IGmxV2ExchangeRouter _gmxRouter,
  65 |     |         IGmxReader _gmxReader,
  66 |     |         address _syntheticsRouter,
  67 |     |         address _refundTo,
  68 |     |         address _staking
  69 |     |     ) BaseStrategy(IERC20(_strategyToken), _degenBox) {
  70 |     |         assert(IMultiRewardsStaking(_staking).stakingToken() == _strategyToken);
  71 |     | 
  72 |     |         feeBips = 200; // 2%
  73 |     |         feeCollector = msg.sender;
  74 |     | 
  75 |     |         GMX_ROUTER = _gmxRouter;
  76 |     |         GMX_READER = _gmxReader;
  77 |     |         SYNTHETICS_ROUTER = _syntheticsRouter;
  78 |     |         DATASTORE = IGmxDataStore(_gmxRouter.dataStore());
  79 |     |         DEPOSIT_VAULT = IGmxV2DepositHandler(_gmxRouter.depositHandler()).depositVault();
  80 |     |         REFUND_TO = _refundTo;
  81 |     | 
  82 |     |         IGmxV2Market.Props memory props = GMX_READER.getMarket(address(DATASTORE), _strategyToken);
  83 |     |         LONG_TOKEN = props.longToken;
  84 |     |         SHORT_TOKEN = props.shortToken;
  85 |     | 
  86 |     |         STAKING = IMultiRewardsStaking(_staking);
  87 |     | 
  88 |     |         _strategyToken.safeApprove(address(_staking), type(uint256).max);
  89 |     |     }
  90 |     | 
  91 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
  92 |     |     /// EXECUTORS
  93 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
  94 |     | 
  95 |     |     /// @param _rewardToken Reward token from the staking contract
  96 |     |     /// @param _marketInputToken Same as _rewardToken when _swapData is empty,
  97 |     |     /// otherwise the token to use as market token input
  98 |     |     function run(
  99 |     |         address _rewardToken,
 100 |     |         address _marketInputToken,
 101 |     |         uint256 _marketMinOut,
 102 |     |         uint256 _executionFee,
 103 |     |         bytes memory _swapData,
 104 |     |         uint256 _maxBentoBoxAmountIncreaseInBips,
 105 |     |         uint256 _maxBentoBoxChangeAmountInBips
 106 |     |     ) external payable onlyExecutor {
 107 |     |         uint128 totals = bentoBox.totals(strategyToken).elastic;
 108 |     |         maxBalance = totals + ((totals * BIPS) / _maxBentoBoxAmountIncreaseInBips);
 109 |     |         uint256 maxChangeAmount = (maxBalance * _maxBentoBoxChangeAmountInBips) / BIPS;
 110 |     | 
 111 |     |         _safeHarvest(maxBalance, true, maxChangeAmount, false);
 112 |     |         _mintMarketTokens(_rewardToken, _marketInputToken, _marketMinOut, _executionFee, _swapData);
 113 |     |     }
 114 |     | 
 115 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 116 |     |     /// GMX CALLBACKS
 117 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 118 |     |     function afterDepositExecution(bytes32, IGmxV2Deposit.Props memory deposit, IGmxV2EventUtils.EventLogData memory) external override {
 119 |     |         // verify that the deposit was from this address
 120 |     |         if (deposit.addresses.account != address(this)) {
 121 |     |             revert ErrWrongUser();
 122 |     |         }
 123 |     | 
 124 |     |         uint256 total = strategyToken.balanceOf(address(this));
 125 |     |         (uint256 amountOut, uint256 feeAmount) = calculateFees(total);
 126 |     | 
 127 |     |         address(strategyToken).safeTransfer(feeCollector, feeAmount);
 128 |     |         emit LogMarketMinted(total, amountOut, feeAmount);
 129 |     | 
 130 |     |         _safeHarvest(maxBalance, true, 0, false);
 131 |     |     }
 132 |     | 
 133 |     |     function afterDepositCancellation(
 134 |     |         bytes32 key,
 135 |     |         IGmxV2Deposit.Props memory deposit,
 136 |     |         IGmxV2EventUtils.EventLogData memory eventData
 137 |     |     ) external override {}
 138 |     | 
 139 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 140 |     |     /// ADMIN
 141 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 142 |     |     function cancelOrder() external onlyOwner {
 143 |     |         GMX_ROUTER.cancelDeposit(orderKey);
 144 |     |     }
 145 |     | 
 146 |     |     function setTokenApproval(address _token, address _to, uint256 _amount) external onlyOwner {
 147 |     |         _token.safeApprove(_to, _amount);
 148 |     |     }
 149 |     | 
 150 |     |     function setCallbackGasLimit(uint256 _callbackGasLimit) external onlyOwner {
 151 |     |         emit LogCallbackGasLimitChanged(callbackGasLimit, _callbackGasLimit);
 152 |     |         callbackGasLimit = _callbackGasLimit;
 153 |     |     }
 154 |     | 
 155 |     |     function setExchange(address _exchange) external onlyOwner {
 156 |     |         emit LogExchangeChanged(exchange, _exchange);
 157 |     |         exchange = _exchange;
 158 |     |     }
 159 |     | 
 160 |     |     function rescueToken(address _token, uint256 _amount, address _to) external onlyOwner {
 161 |     |         if (_token == address(strategyToken)) {
 162 |     |             revert ErrInvalidToken();
 163 |     |         }
 164 |     | 
 165 |     |         _token.safeTransfer(_to, _amount);
 166 |     |     }
 167 |     | 
 168 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 169 |     |     /// VIEWS
 170 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 171 |     |     function isFeeOperator(address account) public view override returns (bool) {
 172 |     |         return account == owner;
 173 |     |     }
 174 |     | 
 175 |     |     function isDepositExecutionDisabled() public view returns (bool) {
 176 |     |         bytes32 depositExecutionDisabledKey = keccak256(abi.encode(EXECUTE_DEPOSIT_FEATURE_DISABLED, GMX_ROUTER.depositHandler()));
 177 |     |         return DATASTORE.getBool(depositExecutionDisabledKey);
 178 |     |     }
 179 |     | 
 180 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 181 |     |     /// INTERNALS
 182 |     |     //////////////////////////////////////////////////////////////////////////////////////////////
 183 |     |     function _mintMarketTokens(
 184 |     |         address _rewardToken,
 185 |     |         address _marketInputToken,
 186 |     |         uint256 _marketMinOut,
 187 |     |         uint256 _executionFee,
 188 |     |         bytes memory _swapData
 189 |     |     ) internal {
 190 |     |         if (isDepositExecutionDisabled()) {
 191 |     |             revert ErrExecuteDepositsDisabled();
 192 |     |         }
 193 |     | 
 194 |     |         // only allow rize staking rewards
 195 |     |         if (!STAKING.isSupportedReward(_rewardToken)) {
 196 |     |             revert ErrInvalidToken();
 197 |     |         }
 198 |     |     
 199 |     |         if (_swapData.length > 0) {
 200 |     |             Address.functionCall(exchange, _swapData);
 201 |     |         }
 202 |     | 
 203 |     |         GMX_ROUTER.sendWnt{value: _executionFee}(address(DEPOSIT_VAULT), _executionFee);
 204 |     |         GMX_ROUTER.sendTokens(_marketInputToken, address(DEPOSIT_VAULT), _marketInputToken.balanceOf(address(this)));
 205 |     | 
 206 |     |         address[] memory emptyPath = new address[](0);
 207 |     | 
 208 |     |         IGmxV2Deposit.CreateDepositParams memory params = IGmxV2Deposit.CreateDepositParams({
 209 |     |             receiver: address(this),
 210 |     |             callbackContract: address(this),
 211 |     |             uiFeeReceiver: address(0),
 212 |     |             market: address(strategyToken),
 213 |     |             initialLongToken: LONG_TOKEN,
 214 |     |             initialShortToken: SHORT_TOKEN,
 215 |     |             longTokenSwapPath: emptyPath,
 216 |     |             shortTokenSwapPath: emptyPath,
 217 |     |             minMarketTokens: _marketMinOut,
 218 |     |             shouldUnwrapNativeToken: false,
 219 |     |             executionFee: _executionFee,
 220 |     |             callbackGasLimit: callbackGasLimit
 221 |     |         });
 222 |     | 
 223 |     |         orderKey = GMX_ROUTER.createDeposit(params);
 224 |     |     }
 225 |     | 
 226 |     |     function _skim(uint256 amount) internal override {
 227 |     |         STAKING.stake(amount);
 228 |     |         STAKING.getRewards();
 229 |     |     }
 230 |     | 
 231 |     |     function _harvest(uint256) internal override returns (int256) {
 232 |     |         STAKING.getRewards();
 233 |     |         return int256(0);
 234 |     |     }
 235 |     | 
 236 |     |     function _withdraw(uint256 amount) internal override {
 237 |     |         STAKING.withdraw(amount);
 238 |     |         STAKING.getRewards();
 239 |     |     }
 240 |     | 
 241 |     |     function _exit() internal override {
 242 |     |         STAKING.exit();
 243 |     |     }
 244 |     | }
 245 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/strategies/MasterChefLPStrategy.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
   5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
   7 |     | import {UniswapV2Library, UniswapV2OneSided} from "libraries/UniswapV2Lib.sol";
   8 |     | import {IUniswapV2Pair, IUniswapV2Router01} from "interfaces/IUniswapV2.sol";
   9 |     | import {BaseStrategy} from "./BaseStrategy.sol";
  10 |     | 
  11 |     | interface IMasterChef {
  12 |     |     function deposit(uint256 _pid, uint256 _amount) external;
  13 |     | 
  14 |     |     function withdraw(uint256 _pid, uint256 _amount) external;
  15 |     | 
  16 |     |     function userInfo(uint256 _pid, address user) external view returns (uint256 amount, uint256 rewardDebt);
  17 |     | 
  18 |     |     function emergencyWithdraw(uint256 _pid) external;
  19 |     | }
  20 |     | 
  21 |     | contract MasterChefLPStrategy is BaseStrategy {
  22 |     |     using BoringERC20 for IERC20;
  23 |     | 
  24 |     |     error InvalidFeePercent();
  25 |     |     error InsupportedToken(address token);
  26 |     |     event LpMinted(uint256 total, uint256 strategyAmount, uint256 feeAmount);
  27 |     |     event RewardTokenUpdated(address token, bool enabled);
  28 |     |     event FeeChanged(uint256 previousFee, uint256 newFee, address previousFeeCollector, address newFeeCollector);
  29 |     | 
  30 |     |     IMasterChef public immutable masterchef;
  31 |     |     IUniswapV2Router01 public immutable router;
  32 |     |     uint256 public immutable pid;
  33 |     |     address public immutable token0;
  34 |     |     address public immutable token1;
  35 |     |     bytes32 internal immutable pairCodeHash;
  36 |     |     address public immutable factory;
  37 |     | 
  38 |     |     struct RewardTokenInfo {
  39 |     |         bool enabled;
  40 |     |         // When true, the _rewardToken will be swapped to the pair's token0 for one-sided liquidity providing, otherwise, the pair's token1.
  41 |     |         bool usePairToken0;
  42 |     |     }
  43 |     | 
  44 |     |     mapping(address => RewardTokenInfo) public rewardTokensInfo;
  45 |     | 
  46 |     |     address public feeCollector;
  47 |     |     uint8 public feePercent;
  48 |     | 
  49 |     |     constructor(
  50 |     |         IERC20 _strategyToken,
  51 |     |         IBentoBoxV1 _bentoBox,
  52 |     |         address _factory,
  53 |     |         IMasterChef _masterchef,
  54 |     |         uint256 _pid,
  55 |     |         IUniswapV2Router01 _router,
  56 |     |         bytes32 _pairCodeHash
  57 |     |     ) BaseStrategy(_strategyToken, _bentoBox) {
  58 |     |         factory = _factory;
  59 |     |         masterchef = _masterchef;
  60 |     |         pid = _pid;
  61 |     |         router = _router;
  62 |     |         pairCodeHash = _pairCodeHash;
  63 |     |         feeCollector = msg.sender;
  64 |     | 
  65 |     |         address _token0 = IUniswapV2Pair(address(_strategyToken)).token0();
  66 |     |         address _token1 = IUniswapV2Pair(address(_strategyToken)).token1();
  67 |     | 
  68 |     |         IERC20(_token0).approve(address(_router), type(uint256).max);
  69 |     |         IERC20(_token1).approve(address(_router), type(uint256).max);
  70 |     |         IERC20(_strategyToken).approve(address(_masterchef), type(uint256).max);
  71 |     | 
  72 |     |         token0 = _token0;
  73 |     |         token1 = _token1;
  74 |     |     }
  75 |     | 
  76 |     |     /// @param token The reward token to add
  77 |     |     /// @param usePairToken0 When true, the _rewardToken will be swapped to the pair's token0 for one-sided liquidity
  78 |     |     /// providing, otherwise, the pair's token1.
  79 |     |     function setRewardTokenInfo(address token, bool usePairToken0, bool enabled) external onlyOwner {
  80 |     |         rewardTokensInfo[token] = RewardTokenInfo(enabled, usePairToken0);
  81 |     |         emit RewardTokenUpdated(token, enabled);
  82 |     |     }
  83 |     | 
  84 |     |     function _skim(uint256 amount) internal virtual override {
  85 |     |         masterchef.deposit(pid, amount);
  86 |     |     }
  87 |     | 
  88 |     |     function _harvest(uint256) internal virtual override returns (int256) {
  89 |     |         masterchef.withdraw(pid, 0);
  90 |     |         return int256(0);
  91 |     |     }
  92 |     | 
  93 |     |     function _withdraw(uint256 amount) internal virtual override {
  94 |     |         masterchef.withdraw(pid, amount);
  95 |     |     }
  96 |     | 
  97 |     |     function _exit() internal virtual override {
  98 |     |         masterchef.emergencyWithdraw(pid);
  99 |     |     }
 100 |     | 
 101 |     |     function _swapRewards(address tokenIn, address tokenOut) private returns (uint256 amountOut) {
 102 |     |         uint256 amountIn = IERC20(tokenIn).balanceOf(address(this));
 103 |     |         IUniswapV2Pair pair = IUniswapV2Pair(address(UniswapV2Library.pairFor(factory, tokenIn, tokenOut, pairCodeHash)));
 104 |     |         (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();
 105 |     |         IERC20(tokenIn).safeTransfer(address(pair), amountIn);
 106 |     | 
 107 |     |         if (tokenIn == pair.token0()) {
 108 |     |             amountOut = UniswapV2Library.getAmountOut(amountIn, reserve0, reserve1);
 109 |     |             pair.swap(0, amountOut, address(this), "");
 110 |     |         } else {
 111 |     |             amountOut = UniswapV2Library.getAmountOut(amountIn, reserve1, reserve0);
 112 |     |             pair.swap(amountOut, 0, address(this), "");
 113 |     |         }
 114 |     |     }
 115 |     | 
 116 |     |     /// @notice Swap some tokens in the contract for the underlying and deposits them to address(this)
 117 |     |     function swapToLP(uint256 amountOutMin, address rewardToken) public onlyExecutor returns (uint256 amountOut) {
 118 |     |         RewardTokenInfo memory info = rewardTokensInfo[rewardToken];
 119 |     |         if (!info.enabled) {
 120 |     |             revert InsupportedToken(rewardToken);
 121 |     |         }
 122 |     | 
 123 |     |         address pairInputToken = info.usePairToken0 ? token0 : token1;
 124 |     |         uint256 tokenInAmount = _swapRewards(rewardToken, pairInputToken);
 125 |     |         uint256 amountStrategyLpBefore = strategyToken.balanceOf(address(this));
 126 |     |         (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(address(strategyToken)).getReserves();
 127 |     | 
 128 |     |         UniswapV2OneSided.AddLiquidityFromSingleTokenParams memory _addLiquidityFromSingleTokenParams = UniswapV2OneSided
 129 |     |             .AddLiquidityFromSingleTokenParams(
 130 |     |                 router,
 131 |     |                 IUniswapV2Pair(address(strategyToken)),
 132 |     |                 token0,
 133 |     |                 token1,
 134 |     |                 reserve0,
 135 |     |                 reserve1,
 136 |     |                 pairInputToken,
 137 |     |                 tokenInAmount,
 138 |     |                 address(this)
 139 |     |             );
 140 |     | 
 141 |     |         UniswapV2OneSided.addLiquidityFromSingleToken(_addLiquidityFromSingleTokenParams);
 142 |     | 
 143 |     |         uint256 total = IERC20(strategyToken).balanceOf(address(this)) - amountStrategyLpBefore;
 144 |     |         require(total >= amountOutMin, "InsufficientAmountOut");
 145 |     |         uint256 feeAmount = (total * feePercent) / 100;
 146 |     |         if (feeAmount > 0) {
 147 |     |             amountOut = total - feeAmount;
 148 |     |             IERC20(strategyToken).safeTransfer(feeCollector, feeAmount);
 149 |     |         }
 150 |     | 
 151 |     |         emit LpMinted(total, amountOut, feeAmount);
 152 |     |     }
 153 |     | 
 154 |     |     function setFeeParameters(address _feeCollector, uint8 _feePercent) external onlyOwner {
 155 |     |         if (feePercent > 100) {
 156 |     |             revert InvalidFeePercent();
 157 |     |         }
 158 |     | 
 159 |     |         uint256 previousFee = feePercent;
 160 |     |         address previousFeeCollector = feeCollector;
 161 |     | 
 162 |     |         feeCollector = _feeCollector;
 163 |     |         feePercent = _feePercent;
 164 |     | 
 165 |     |         emit FeeChanged(previousFee, _feePercent, previousFeeCollector, _feeCollector);
 166 |     |     }
 167 |     | }
 168 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/strategies/NegativeInterestStrategy.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
   5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
   7 |     | import {BaseStrategy} from "./BaseStrategy.sol";
   8 |     | 
   9 |     | contract NegativeInterestStrategy is BaseStrategy {
  10 |     |     using BoringERC20 for IERC20;
  11 |     | 
  12 |     |     error InsupportedToken();
  13 |     |     error InvalidInterestRate();
  14 |     |     error SwapFailed();
  15 |     |     error InsufficientAmountOut();
  16 |     |     error InvalidFeeTo();
  17 |     |     error InvalidMaxInterestPerSecond();
  18 |     |     error InvalidLerpParameters();
  19 |     | 
  20 |     |     event LogAccrue(uint256 accruedAmount);
  21 |     |     event LogInterestChanged(uint64 interestPerSecond);
  22 |     |     event LogInterestWithLerpChanged(uint64 startInterestPerSecond, uint64 targetInterestPerSecond, uint64 duration);
  23 |     |     event LogMaxStrategyExecutorInterestPerSecondChanged(uint256 previous, uint256 current);
  24 |     |     event FeeToChanged(address previous, address current);
  25 |     |     event SwapperChanged(address previous, address current);
  26 |     |     event Swap(uint256 amountIn, uint256 amountOut);
  27 |     |     event SwapTokenOutEnabled(IERC20 token, bool enabled);
  28 |     |     event SwapAndWithdrawFee(uint256 amountIn, uint256 amountOut, IERC20 tokenOut);
  29 |     |     event WithdrawFee(uint256 amount);
  30 |     |     event EmergencyExitEnabled(bool enabled);
  31 |     | 
  32 |     |     uint256 private constant WAD = 1e18;
  33 |     | 
  34 |     |     // Interest linear interpolation to destination in a given time
  35 |     |     // ex: 1% -> 13% in 30 days.
  36 |     |     struct InterestLerp {
  37 |     |         uint64 startTime;
  38 |     |         uint64 startInterestPerSecond;
  39 |     |         uint64 targetInterestPerSecond;
  40 |     |         uint64 duration;
  41 |     |     }
  42 |     | 
  43 |     |     // slot grouping
  44 |     |     uint128 public pendingFeeEarned;
  45 |     |     uint128 public pendingFeeEarnedAdjustement;
  46 |     | 
  47 |     |     // slot grouping
  48 |     |     uint64 public lastAccrued;
  49 |     |     uint64 public interestPerSecond;
  50 |     |     bool public emergencyExitEnabled;
  51 |     | 
  52 |     |     address public feeTo;
  53 |     |     address public swapper;
  54 |     |     uint256 public principal;
  55 |     |     mapping(IERC20 => bool) public swapTokenOutEnabled;
  56 |     |     InterestLerp public interestLerp;
  57 |     | 
  58 |     |     /// @dev This is the maximum interest per second that a strategy executor can set.
  59 |     |     uint256 maxStrategyExecutorInterestPerSecond;
  60 |     | 
  61 |     |     constructor(IERC20 _strategyToken, IERC20 _mim, IBentoBoxV1 _bentoBox, address _feeTo) BaseStrategy(_strategyToken, _bentoBox) {
  62 |     |         feeTo = _feeTo;
  63 |     |         swapTokenOutEnabled[_mim] = true;
  64 |     | 
  65 |     |         maxStrategyExecutorInterestPerSecond = getInterestPerSecond(1_000_000); // 1_000%
  66 |     | 
  67 |     |         emit LogMaxStrategyExecutorInterestPerSecondChanged(0, maxStrategyExecutorInterestPerSecond);
  68 |     |         emit FeeToChanged(address(0), _feeTo);
  69 |     |         emit SwapTokenOutEnabled(_mim, true);
  70 |     |     }
  71 |     | 
  72 |     |     function setMaxStrategyExecutorInterestPerSecond(uint256 _maxStrategyExecutorInterestPerSecond) public onlyOwner {
  73 |     |         emit LogMaxStrategyExecutorInterestPerSecondChanged(maxStrategyExecutorInterestPerSecond, _maxStrategyExecutorInterestPerSecond);
  74 |     |         maxStrategyExecutorInterestPerSecond = _maxStrategyExecutorInterestPerSecond;
  75 |     |     }
  76 |     | 
  77 |     |     /// @dev example: 200 is 2% interests
  78 |     |     function getInterestPerSecond(uint256 yearlyInterestBips) public pure returns (uint64 interestsPerSecond) {
  79 |     |         return uint64((yearlyInterestBips * 316880878) / 100); // 316880878 is the precomputed integral part of 1e18 / (36525 * 3600 * 24)
  80 |     |     }
  81 |     | 
  82 |     |     function getYearlyInterestBips() external view returns (uint256) {
  83 |     |         return (interestPerSecond * 100) / 316880878;
  84 |     |     }
  85 |     | 
  86 |     |     function _updateInterestPerSecond() private {
  87 |     |         if (interestLerp.duration == 0) {
  88 |     |             return;
  89 |     |         }
  90 |     | 
  91 |     |         /// @dev Adapted from https://github.com/makerdao/dss-lerp/blob/master/src/Lerp.sol
  92 |     |         if (block.timestamp < interestLerp.startTime + interestLerp.duration) {
  93 |     |             uint256 t = ((block.timestamp - interestLerp.startTime) * WAD) / interestLerp.duration;
  94 |     |             interestPerSecond = uint64(
  95 |     |                 (interestLerp.targetInterestPerSecond * t) /
  96 |     |                     WAD +
  97 |     |                     interestLerp.startInterestPerSecond -
  98 |     |                     (interestLerp.startInterestPerSecond * t) /
  99 |     |                     WAD
 100 |     |             );
 101 |     |         } else {
 102 |     |             interestPerSecond = interestLerp.targetInterestPerSecond;
 103 |     |             interestLerp.duration = 0;
 104 |     |         }
 105 |     |     }
 106 |     | 
 107 |     |     function skim(uint256) external override isActive onlyBentoBox {
 108 |     |         principal = availableAmount();
 109 |     |     }
 110 |     | 
 111 |     |     /// @dev accrue interest and report loss
 112 |     |     /// The interest linear interpolation used here is very basic: the more this function is called the smoother
 113 |     |     /// the interpolation.
 114 |     |     /// Meaning that if we're ramping from 1% to 13% in 30 days and that harvest is called only once on
 115 |     |     /// the 15th day, 1% interest will be used for these 15 days and then the next harvest will be around 7%.
 116 |     |     /// If we are calling it daily it will smoothly increase by steps of 0.4% (12% / 30 days)
 117 |     |     function harvest(uint256 balance, address sender) external virtual override isActive onlyBentoBox returns (int256) {
 118 |     |         if (sender == address(this) && balance > 0) {
 119 |     |             uint256 accrued = _accrue();
 120 |     | 
 121 |     |             // add the potential accrued interest collected from changing the interest rate, since
 122 |     |             // this didn't harvest & reported loss yet.
 123 |     |             accrued += pendingFeeEarnedAdjustement;
 124 |     |             pendingFeeEarnedAdjustement = 0;
 125 |     | 
 126 |     |             return -int256(accrued);
 127 |     |         }
 128 |     | 
 129 |     |         return int256(0);
 130 |     |     }
 131 |     | 
 132 |     |     function withdraw(uint256 amount) external override isActive onlyBentoBox returns (uint256 actualAmount) {
 133 |     |         uint256 maxAvailableAmount = availableAmount();
 134 |     | 
 135 |     |         if (maxAvailableAmount > 0) {
 136 |     |             actualAmount = amount > maxAvailableAmount ? maxAvailableAmount : amount;
 137 |     |             maxAvailableAmount -= actualAmount;
 138 |     |             strategyToken.safeTransfer(address(bentoBox), actualAmount);
 139 |     |         }
 140 |     | 
 141 |     |         principal = availableAmount();
 142 |     |     }
 143 |     | 
 144 |     |     function exit(uint256 amount) external override onlyBentoBox returns (int256 amountAdded) {
 145 |     |         // in case something wrong happen, we can exit and use `afterExit` once we've exited.
 146 |     |         if (emergencyExitEnabled) {
 147 |     |             exited = true;
 148 |     |             return int256(0);
 149 |     |         }
 150 |     | 
 151 |     |         _accrue();
 152 |     |         uint256 maxAvailableAmount = availableAmount();
 153 |     | 
 154 |     |         if (maxAvailableAmount > 0) {
 155 |     |             uint256 actualAmount = amount > maxAvailableAmount ? maxAvailableAmount : amount;
 156 |     |             amountAdded = int256(actualAmount) - int256(amount);
 157 |     | 
 158 |     |             if (actualAmount > 0) {
 159 |     |                 strategyToken.safeTransfer(address(bentoBox), actualAmount);
 160 |     |             }
 161 |     |         }
 162 |     | 
 163 |     |         principal = 0;
 164 |     |         exited = true;
 165 |     |     }
 166 |     | 
 167 |     |     function availableAmount() public view returns (uint256 amount) {
 168 |     |         uint256 balance = strategyToken.balanceOf(address(this));
 169 |     | 
 170 |     |         if (balance > pendingFeeEarned) {
 171 |     |             amount = balance - pendingFeeEarned;
 172 |     |         }
 173 |     |     }
 174 |     | 
 175 |     |     function withdrawFees() external onlyExecutor returns (uint256) {
 176 |     |         IERC20(strategyToken).safeTransfer(feeTo, pendingFeeEarned);
 177 |     | 
 178 |     |         emit WithdrawFee(pendingFeeEarned);
 179 |     |         pendingFeeEarned = 0;
 180 |     | 
 181 |     |         return pendingFeeEarned;
 182 |     |     }
 183 |     | 
 184 |     |     function swapAndwithdrawFees(uint256 amountOutMin, IERC20 tokenOut, bytes calldata data) external onlyExecutor returns (uint256) {
 185 |     |         if (!swapTokenOutEnabled[tokenOut]) {
 186 |     |             revert InsupportedToken();
 187 |     |         }
 188 |     | 
 189 |     |         uint256 amountInBefore = IERC20(strategyToken).balanceOf(address(this));
 190 |     |         uint256 amountOutBefore = tokenOut.balanceOf(address(this));
 191 |     | 
 192 |     |         (bool success, ) = swapper.call(data);
 193 |     |         if (!success) {
 194 |     |             revert SwapFailed();
 195 |     |         }
 196 |     | 
 197 |     |         uint256 amountOut = tokenOut.balanceOf(address(this)) - amountOutBefore;
 198 |     |         if (amountOut < amountOutMin) {
 199 |     |             revert InsufficientAmountOut();
 200 |     |         }
 201 |     | 
 202 |     |         uint256 amountIn = amountInBefore - IERC20(strategyToken).balanceOf(address(this));
 203 |     |         pendingFeeEarned -= uint128(amountIn);
 204 |     | 
 205 |     |         tokenOut.safeTransfer(feeTo, amountOut);
 206 |     |         emit SwapAndWithdrawFee(amountIn, amountOut, tokenOut);
 207 |     | 
 208 |     |         return amountOut;
 209 |     |     }
 210 |     | 
 211 |     |     function _accrue() private returns (uint128 interest) {
 212 |     |         if (lastAccrued == 0) {
 213 |     |             // we want to start accruing interests as soon as there's a deposited amount.
 214 |     |             if (principal > 0) {
 215 |     |                 lastAccrued = uint64(block.timestamp);
 216 |     |             }
 217 |     |             return 0;
 218 |     |         }
 219 |     | 
 220 |     |         // Number of seconds since accrue was called
 221 |     |         uint256 elapsedTime = block.timestamp - lastAccrued;
 222 |     |         if (elapsedTime == 0) {
 223 |     |             return 0;
 224 |     |         }
 225 |     | 
 226 |     |         lastAccrued = uint64(block.timestamp);
 227 |     | 
 228 |     |         if (principal == 0) {
 229 |     |             return 0;
 230 |     |         }
 231 |     | 
 232 |     |         // Accrue interest
 233 |     |         interest = uint128((principal * interestPerSecond * elapsedTime) / 1e18);
 234 |     |         pendingFeeEarned += interest;
 235 |     | 
 236 |     |         _updateInterestPerSecond();
 237 |     |         emit LogAccrue(interest);
 238 |     |     }
 239 |     | 
 240 |     |     function setFeeTo(address _feeTo) external onlyOwner {
 241 |     |         if (_feeTo == address(0)) {
 242 |     |             revert InvalidFeeTo();
 243 |     |         }
 244 |     | 
 245 |     |         emit FeeToChanged(feeTo, _feeTo);
 246 |     |         feeTo = _feeTo;
 247 |     |     }
 248 |     | 
 249 |     |     function setSwapper(address _swapper) external onlyOwner {
 250 |     |         if (swapper != address(0)) {
 251 |     |             strategyToken.approve(swapper, 0);
 252 |     |         }
 253 |     | 
 254 |     |         strategyToken.approve(_swapper, type(uint256).max);
 255 |     |         emit SwapperChanged(swapper, _swapper);
 256 |     |         swapper = _swapper;
 257 |     |     }
 258 |     | 
 259 |     |     function setSwapTokenOutEnabled(IERC20 token, bool enabled) external onlyOwner {
 260 |     |         swapTokenOutEnabled[token] = enabled;
 261 |     |         emit SwapTokenOutEnabled(token, enabled);
 262 |     |     }
 263 |     | 
 264 |     |     function setInterest(uint256 yearlyInterestBips) public onlyExecutor {
 265 |     |         _setInterestPerSecond(getInterestPerSecond(yearlyInterestBips));
 266 |     |     }
 267 |     | 
 268 |     |     function setInterestWithLerp(uint64 startYearlyInterestBips, uint64 targetYearlyInterestBips, uint64 duration) public onlyExecutor {
 269 |     |         _setInterestPerSecondWithLerp(
 270 |     |             getInterestPerSecond(startYearlyInterestBips),
 271 |     |             getInterestPerSecond(targetYearlyInterestBips),
 272 |     |             duration
 273 |     |         );
 274 |     |     }
 275 |     | 
 276 |     |     function setInterestPerSecond(uint64 _interestPerSecond) public onlyExecutor {
 277 |     |         _setInterestPerSecond(_interestPerSecond);
 278 |     |     }
 279 |     | 
 280 |     |     function setInterestPerSecondWithLerp(
 281 |     |         uint64 startInterestPerSecond,
 282 |     |         uint64 targetInterestPerSecond,
 283 |     |         uint64 duration
 284 |     |     ) public onlyExecutor {
 285 |     |         _setInterestPerSecondWithLerp(startInterestPerSecond, targetInterestPerSecond, duration);
 286 |     |     }
 287 |     | 
 288 |     |     function _setInterestPerSecond(uint64 _interestPerSecond) private {
 289 |     |         if (owner != msg.sender) {
 290 |     |             if (_interestPerSecond > maxStrategyExecutorInterestPerSecond) {
 291 |     |                 revert InvalidMaxInterestPerSecond();
 292 |     |             }
 293 |     |         }
 294 |     | 
 295 |     |         pendingFeeEarnedAdjustement += _accrue();
 296 |     |         interestPerSecond = _interestPerSecond;
 297 |     |         interestLerp.duration = 0;
 298 |     | 
 299 |     |         emit LogInterestChanged(interestPerSecond);
 300 |     |     }
 301 |     | 
 302 |     |     function _setInterestPerSecondWithLerp(uint64 startInterestPerSecond, uint64 targetInterestPerSecond, uint64 duration) private {
 303 |     |         if (owner != msg.sender) {
 304 |     |             if (
 305 |     |                 startInterestPerSecond > maxStrategyExecutorInterestPerSecond ||
 306 |     |                 targetInterestPerSecond > maxStrategyExecutorInterestPerSecond
 307 |     |             ) {
 308 |     |                 revert InvalidMaxInterestPerSecond();
 309 |     |             }
 310 |     |         }
 311 |     | 
 312 |     |         if (duration == 0 || duration > 365 days || targetInterestPerSecond <= startInterestPerSecond) {
 313 |     |             revert InvalidLerpParameters();
 314 |     |         }
 315 |     | 
 316 |     |         pendingFeeEarnedAdjustement += _accrue();
 317 |     |         interestPerSecond = startInterestPerSecond;
 318 |     |         interestLerp.duration = duration;
 319 |     |         interestLerp.startTime = uint64(block.timestamp);
 320 |     |         interestLerp.startInterestPerSecond = startInterestPerSecond;
 321 |     |         interestLerp.targetInterestPerSecond = targetInterestPerSecond;
 322 |     | 
 323 |     |         emit LogInterestWithLerpChanged(startInterestPerSecond, targetInterestPerSecond, duration);
 324 |     |     }
 325 |     | 
 326 |     |     function setEmergencyExitEnabled(bool _emergencyExitEnabled) external onlyOwner {
 327 |     |         emergencyExitEnabled = _emergencyExitEnabled;
 328 |     |         emit EmergencyExitEnabled(_emergencyExitEnabled);
 329 |     |     }
 330 |     | }
 331 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/strategies/StargateLPStrategy.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   5 |     | import {Address} from "openzeppelin-contracts/utils/Address.sol";
   6 |     | import {BaseStrategy} from "./BaseStrategy.sol";
   7 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
   8 |     | import {IStargateLPStaking, IStargatePool, IStargateRouter} from "interfaces/IStargate.sol";
   9 |     | import {FeeCollectable} from "mixins/FeeCollectable.sol";
  10 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
  11 |     | 
  12 |     | contract StargateLPStrategy is BaseStrategy, FeeCollectable {
  13 |     |     using SafeTransferLib for address;
  14 |     | 
  15 |     |     error ErrInsufficientAmountOut();
  16 |     | 
  17 |     |     event LogLpMinted(uint256 total, uint256 strategyAmount, uint256 feeAmount);
  18 |     |     event LogStargateSwapperChanged(address oldSwapper, address newSwapper);
  19 |     | 
  20 |     |     IStargateLPStaking public immutable staking;
  21 |     |     IStargateRouter public immutable router;
  22 |     |     address public immutable rewardToken;
  23 |     |     address public immutable underlyingToken;
  24 |     | 
  25 |     |     uint256 public immutable poolId;
  26 |     |     uint256 public immutable pid;
  27 |     |     address public stargateSwapper;
  28 |     | 
  29 |     |     constructor(
  30 |     |         IStargatePool _strategyToken,
  31 |     |         IBentoBoxV1 _bentoBox,
  32 |     |         IStargateRouter _router,
  33 |     |         IStargateLPStaking _staking,
  34 |     |         address _rewardToken,
  35 |     |         uint256 _pid
  36 |     |     ) BaseStrategy(IERC20(address(_strategyToken)), _bentoBox) {
  37 |     |         router = _router;
  38 |     |         staking = _staking;
  39 |     |         rewardToken = _rewardToken;
  40 |     |         pid = _pid;
  41 |     | 
  42 |     |         poolId = IStargatePool(address(_strategyToken)).poolId();
  43 |     |         address _underlyingToken = IStargatePool(address(_strategyToken)).token();
  44 |     | 
  45 |     |         feeBips = 150; // 1.5%
  46 |     |         feeCollector = msg.sender;
  47 |     | 
  48 |     |         IERC20(_underlyingToken).approve(address(_router), type(uint256).max);
  49 |     |         underlyingToken = _underlyingToken;
  50 |     | 
  51 |     |         IERC20(address(_strategyToken)).approve(address(_staking), type(uint256).max);
  52 |     |     }
  53 |     | 
  54 |     |     function _skim(uint256 amount) internal override {
  55 |     |         staking.deposit(pid, amount);
  56 |     |     }
  57 |     | 
  58 |     |     function _harvest(uint256) internal override returns (int256) {
  59 |     |         staking.withdraw(pid, 0);
  60 |     |         return int256(0);
  61 |     |     }
  62 |     | 
  63 |     |     function _withdraw(uint256 amount) internal override {
  64 |     |         staking.withdraw(pid, amount);
  65 |     |     }
  66 |     | 
  67 |     |     function _exit() internal override {
  68 |     |         staking.emergencyWithdraw(pid);
  69 |     |     }
  70 |     | 
  71 |     |     function swapToLP(uint256 amountOutMin, bytes calldata data) public onlyExecutor returns (uint256 amountOut) {
  72 |     |         // Current Stargate LP Amount
  73 |     |         uint256 amountStrategyLpBefore = IERC20(strategyToken).balanceOf(address(this));
  74 |     | 
  75 |     |         // rewardToken -> Pool underlying Token (USDT, USDC...)
  76 |     |         Address.functionCall(stargateSwapper, data);
  77 |     | 
  78 |     |         // Pool underlying Token in this contract
  79 |     |         uint256 underlyingTokenAmount = underlyingToken.balanceOf(address(this));
  80 |     | 
  81 |     |         // Underlying Token -> Stargate Pool LP
  82 |     |         router.addLiquidity(poolId, underlyingTokenAmount, address(this));
  83 |     | 
  84 |     |         uint256 total = IERC20(strategyToken).balanceOf(address(this)) - amountStrategyLpBefore;
  85 |     | 
  86 |     |         if (total < amountOutMin) {
  87 |     |             revert ErrInsufficientAmountOut();
  88 |     |         }
  89 |     | 
  90 |     |         uint256 feeAmount;
  91 |     |         (amountOut, feeAmount) = calculateFees(total);
  92 |     | 
  93 |     |         address(strategyToken).safeTransfer(feeCollector, feeAmount);
  94 |     | 
  95 |     |         emit LogLpMinted(total, amountOut, feeAmount);
  96 |     |     }
  97 |     | 
  98 |     |     function setStargateSwapper(address _stargateSwapper) external onlyOwner {
  99 |     |         address previousStargateSwapper = address(stargateSwapper);
 100 |     | 
 101 |     |         if (previousStargateSwapper != address(0)) {
 102 |     |             rewardToken.safeApprove(previousStargateSwapper, 0);
 103 |     |         }
 104 |     | 
 105 |     |         stargateSwapper = _stargateSwapper;
 106 |     | 
 107 |     |         if (_stargateSwapper != address(0)) {
 108 |     |             rewardToken.safeApprove(_stargateSwapper, type(uint256).max);
 109 |     |         }
 110 |     | 
 111 |     |         emit LogStargateSwapperChanged(previousStargateSwapper, _stargateSwapper);
 112 |     |     }
 113 |     | 
 114 |     |     function isFeeOperator(address account) public view override returns (bool) {
 115 |     |         return account == owner;
 116 |     |     }
 117 |     | }
 118 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/ConvexWrapperLevSwapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // solhint-disable avoid-low-level-calls
  3 |     | pragma solidity >=0.8.0;
  4 |     | 
  5 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
  6 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  7 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  8 |     | import {CurveLevSwapper} from "swappers/CurveLevSwapper.sol";
  9 |     | import {IConvexWrapper} from "interfaces/IConvexWrapper.sol";
 10 |     | import {CurvePoolInterfaceType} from "interfaces/ICurvePool.sol";
 11 |     | 
 12 |     | contract ConvexWrapperLevSwapper is CurveLevSwapper {
 13 |     |     using SafeTransferLib for address;
 14 |     | 
 15 |     |     IConvexWrapper public immutable wrapper;
 16 |     | 
 17 |     |     constructor(
 18 |     |         IBentoBoxV1 _bentoBox,
 19 |     |         IConvexWrapper _wrapper,
 20 |     |         address _mim,
 21 |     |         CurvePoolInterfaceType _curvePoolInterfaceType,
 22 |     |         address _curvePool,
 23 |     |         address _curvePoolDepositor /* Optional Curve Deposit Zapper */,
 24 |     |         address[] memory _poolTokens,
 25 |     |         address _zeroXExchangeProxy
 26 |     |     )
 27 |     |         CurveLevSwapper(
 28 |     |             _bentoBox,
 29 |     |             _wrapper.curveToken(),
 30 |     |             _mim,
 31 |     |             _curvePoolInterfaceType,
 32 |     |             _curvePool,
 33 |     |             _curvePoolDepositor,
 34 |     |             _poolTokens,
 35 |     |             _zeroXExchangeProxy
 36 |     |         )
 37 |     |     {
 38 |     |         wrapper = _wrapper;
 39 |     |         curveToken.safeApprove(address(_wrapper), type(uint256).max);
 40 |     |     }
 41 |     | 
 42 |     |     function depositInBentoBox(uint256 amount, address recipient) internal override returns (uint256 shareReturned) {
 43 |     |         // CurveLP -> Convex Wrapper LP
 44 |     |         wrapper.deposit(amount, address(bentoBox));
 45 |     | 
 46 |     |         (, shareReturned) = bentoBox.deposit(IERC20(address(wrapper)), address(bentoBox), recipient, amount, 0);
 47 |     |     }
 48 |     | }
 49 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/ConvexWrapperSwapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // solhint-disable avoid-low-level-calls
  3 |     | pragma solidity >=0.8.0;
  4 |     | 
  5 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
  6 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  7 |     | import {CurveSwapper} from "swappers/CurveSwapper.sol";
  8 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  9 |     | import {IConvexWrapper} from "interfaces/IConvexWrapper.sol";
 10 |     | import {CurvePoolInterfaceType} from "interfaces/ICurvePool.sol";
 11 |     | 
 12 |     | contract ConvexWrapperSwapper is CurveSwapper {
 13 |     |     using SafeTransferLib for address;
 14 |     | 
 15 |     |     IConvexWrapper public immutable wrapper;
 16 |     | 
 17 |     |     constructor(
 18 |     |         IBentoBoxV1 _bentoBox,
 19 |     |         IConvexWrapper _wrapper,
 20 |     |         address _mim,
 21 |     |         CurvePoolInterfaceType _curvePoolInterfaceType,
 22 |     |         address _curvePool,
 23 |     |         address _curvePoolDepositor /* Optional Curve Deposit Zapper */,
 24 |     |         address[] memory _poolTokens,
 25 |     |         address _zeroXExchangeProxy
 26 |     |     )
 27 |     |         CurveSwapper(
 28 |     |             _bentoBox,
 29 |     |             _wrapper.curveToken(),
 30 |     |             _mim,
 31 |     |             _curvePoolInterfaceType,
 32 |     |             _curvePool,
 33 |     |             _curvePoolDepositor,
 34 |     |             _poolTokens,
 35 |     |             _zeroXExchangeProxy
 36 |     |         )
 37 |     |     {
 38 |     |         wrapper = _wrapper;
 39 |     |         if (_curvePoolDepositor != address(0)) {
 40 |     |             address curveToken = wrapper.curveToken();
 41 |     |             curveToken.safeApprove(_curvePoolDepositor, type(uint256).max);
 42 |     |         }
 43 |     |     }
 44 |     | 
 45 |     |     function withdrawFromBentoBox(uint256 shareFrom) internal override returns (uint256 amount) {
 46 |     |         (amount, ) = bentoBox.withdraw(IERC20(address(wrapper)), address(this), address(this), 0, shareFrom);
 47 |     | 
 48 |     |         // ConvexWrapper -> CurveLP token
 49 |     |         wrapper.withdrawAndUnwrap(amount);
 50 |     |     }
 51 |     | }
 52 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/CurveLevSwapper.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // solhint-disable avoid-low-level-calls
   3 |     | pragma solidity >=0.8.0;
   4 |     | 
   5 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
   6 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   7 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
   8 |     | import {ILevSwapperV2} from "interfaces/ILevSwapperV2.sol";
   9 |     | import {ICurvePool, CurvePoolInterfaceType, ICurve3PoolZapper} from "interfaces/ICurvePool.sol";
  10 |     | 
  11 |     | contract CurveLevSwapper is ILevSwapperV2 {
  12 |     |     using SafeTransferLib for address;
  13 |     | 
  14 |     |     error ErrSwapFailed();
  15 |     |     error ErrUnsupportedCurvePool();
  16 |     |     error ErrUnsupportedCurvePoolLength();
  17 |     | 
  18 |     |     IBentoBoxV1 public immutable bentoBox;
  19 |     |     address public immutable curveToken;
  20 |     |     address public immutable mim;
  21 |     |     CurvePoolInterfaceType public immutable curvePoolInterfaceType;
  22 |     |     address public immutable zeroXExchangeProxy;
  23 |     |     address public immutable curvePool;
  24 |     |     address public immutable curvePoolDepositor;
  25 |     |     uint256 public immutable curvePoolCoinsLength;
  26 |     | 
  27 |     |     constructor(
  28 |     |         IBentoBoxV1 _bentoBox,
  29 |     |         address _curveToken,
  30 |     |         address _mim,
  31 |     |         CurvePoolInterfaceType _curvePoolInterfaceType,
  32 |     |         address _curvePool,
  33 |     |         address _curvePoolDepositor /* Optional Curve Deposit Zapper */,
  34 |     |         address[] memory _poolTokens,
  35 |     |         address _zeroXExchangeProxy
  36 |     |     ) {
  37 |     |         bentoBox = _bentoBox;
  38 |     |         curveToken = _curveToken;
  39 |     |         mim = _mim;
  40 |     |         zeroXExchangeProxy = _zeroXExchangeProxy;
  41 |     |         curvePoolCoinsLength = _poolTokens.length;
  42 |     |         curvePoolInterfaceType = _curvePoolInterfaceType;
  43 |     |         curvePool = _curvePool;
  44 |     | 
  45 |     |         _mim.safeApprove(_zeroXExchangeProxy, type(uint256).max);
  46 |     | 
  47 |     |         address depositor = _curvePool;
  48 |     | 
  49 |     |         if (_curvePoolDepositor != address(0)) {
  50 |     |             depositor = _curvePoolDepositor;
  51 |     |         }
  52 |     | 
  53 |     |         for (uint256 i = 0; i < _poolTokens.length; i++) {
  54 |     |             _poolTokens[i].safeApprove(address(depositor), type(uint256).max);
  55 |     |         }
  56 |     | 
  57 |     |         curvePoolDepositor = depositor;
  58 |     |     }
  59 |     | 
  60 |     |     function depositInBentoBox(uint256 amount, address recipient) internal virtual returns (uint256 shareReturned) {
  61 |     |         (, shareReturned) = bentoBox.deposit(IERC20(curveToken), address(bentoBox), recipient, amount, 0);
  62 |     |     }
  63 |     | 
  64 |     |     /// @inheritdoc ILevSwapperV2
  65 |     |     function swap(
  66 |     |         address recipient,
  67 |     |         uint256 shareToMin,
  68 |     |         uint256 shareFrom,
  69 |     |         bytes calldata data
  70 |     |     ) external override returns (uint256 extraShare, uint256 shareReturned) {
  71 |     |         (address underlyingToken, uint256 poolIndex, bytes memory swapData) = abi.decode(data, (address, uint256, bytes));
  72 |     |         bentoBox.withdraw(IERC20(mim), address(this), address(this), 0, shareFrom);
  73 |     | 
  74 |     |         // Optional MIM -> Asset
  75 |     |         if (swapData.length != 0) {
  76 |     |             (bool success, ) = zeroXExchangeProxy.call(swapData);
  77 |     |             if (!success) {
  78 |     |                 revert ErrSwapFailed();
  79 |     |             }
  80 |     | 
  81 |     |             // Refund remaining underlying balance to the recipient
  82 |     |             mim.safeTransfer(recipient, mim.balanceOf(address(this)));
  83 |     |         }
  84 |     | 
  85 |     |         // Asset -> Curve LP
  86 |     |         if (curvePoolInterfaceType == CurvePoolInterfaceType.ICURVE_3POOL_ZAPPER) {
  87 |     |             _addLiquidityUsing3PoolZapper(underlyingToken, poolIndex);
  88 |     |         } else if (
  89 |     |             curvePoolInterfaceType == CurvePoolInterfaceType.ICURVE_POOL ||
  90 |     |             curvePoolInterfaceType == CurvePoolInterfaceType.IFACTORY_POOL ||
  91 |     |             curvePoolInterfaceType == CurvePoolInterfaceType.ITRICRYPTO_POOL
  92 |     |         ) {
  93 |     |             _addLiquidityCurvePool(underlyingToken, poolIndex);
  94 |     |         } else {
  95 |     |             revert ErrUnsupportedCurvePool();
  96 |     |         }
  97 |     | 
  98 |     |         uint256 _amount = curveToken.balanceOf(address(this));
  99 |     |         shareReturned = depositInBentoBox(_amount, recipient);
 100 |     |         extraShare = shareReturned - shareToMin;
 101 |     |     }
 102 |     | 
 103 |     |     function _addLiquidityUsing3PoolZapper(address underlyingToken, uint256 poolIndex) internal {
 104 |     |         uint256[4] memory amounts;
 105 |     |         amounts[poolIndex] = underlyingToken.balanceOf(address(this));
 106 |     |         ICurve3PoolZapper(curvePoolDepositor).add_liquidity(curvePool, amounts, 0);
 107 |     |     }
 108 |     | 
 109 |     |     function _addLiquidityCurvePool(address underlyingToken, uint256 poolIndex) internal {
 110 |     |         if (curvePoolCoinsLength == 2) {
 111 |     |             uint256[2] memory amounts;
 112 |     |             amounts[poolIndex] = underlyingToken.balanceOf(address(this));
 113 |     |             ICurvePool(curvePoolDepositor).add_liquidity(amounts, 0);
 114 |     |         } else if (curvePoolCoinsLength == 3) {
 115 |     |             uint256[3] memory amounts;
 116 |     |             amounts[poolIndex] = underlyingToken.balanceOf(address(this));
 117 |     |             ICurvePool(curvePoolDepositor).add_liquidity(amounts, 0);
 118 |     |         } else if (curvePoolCoinsLength == 4) {
 119 |     |             uint256[4] memory amounts;
 120 |     |             amounts[poolIndex] = underlyingToken.balanceOf(address(this));
 121 |     |             ICurvePool(curvePoolDepositor).add_liquidity(amounts, 0);
 122 |     |         } else {
 123 |     |             revert ErrUnsupportedCurvePoolLength();
 124 |     |         }
 125 |     |     }
 126 |     | }
 127 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/CurveSwapper.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // solhint-disable avoid-low-level-calls
   3 |     | pragma solidity >=0.8.0;
   4 |     | 
   5 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
   6 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   7 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
   8 |     | import {ISwapperV2} from "interfaces/ISwapperV2.sol";
   9 |     | import {ICurvePool, CurvePoolInterfaceType, ITriCrypto, ICurve3PoolZapper, IFactoryPool} from "interfaces/ICurvePool.sol";
  10 |     | 
  11 |     | contract CurveSwapper is ISwapperV2 {
  12 |     |     using SafeTransferLib for address;
  13 |     | 
  14 |     |     error ErrSwapFailed();
  15 |     |     error ErrTokenNotSupported();
  16 |     |     error ErrUnsupportedCurvePool();
  17 |     | 
  18 |     |     CurvePoolInterfaceType public immutable curvePoolInterfaceType;
  19 |     |     IBentoBoxV1 public immutable bentoBox;
  20 |     |     address public immutable curveToken;
  21 |     |     address public immutable mim;
  22 |     |     address public immutable exchange;
  23 |     |     address public immutable curvePool;
  24 |     |     address public immutable curvePoolDepositor;
  25 |     |     uint256 public immutable curvePoolCoinsLength;
  26 |     | 
  27 |     |     constructor(
  28 |     |         IBentoBoxV1 _bentoBox,
  29 |     |         address _curveToken,
  30 |     |         address _mim,
  31 |     |         CurvePoolInterfaceType _curvePoolInterfaceType,
  32 |     |         address _curvePool,
  33 |     |         address _curvePoolDepositor /* Optional Curve Deposit Zapper */,
  34 |     |         address[] memory _poolTokens,
  35 |     |         address _exchange
  36 |     |     ) {
  37 |     |         bentoBox = _bentoBox;
  38 |     |         curveToken = _curveToken;
  39 |     |         mim = _mim;
  40 |     |         curvePoolInterfaceType = _curvePoolInterfaceType;
  41 |     |         curvePool = _curvePool;
  42 |     |         exchange = _exchange;
  43 |     |         curvePoolCoinsLength = _poolTokens.length;
  44 |     | 
  45 |     |         address depositor = _curvePool;
  46 |     | 
  47 |     |         if (_curvePoolDepositor != address(0)) {
  48 |     |             depositor = _curvePoolDepositor;
  49 |     |         }
  50 |     | 
  51 |     |         curvePoolDepositor = depositor;
  52 |     | 
  53 |     |         for (uint256 i = 0; i < _poolTokens.length; i++) {
  54 |     |             _poolTokens[i].safeApprove(_exchange, type(uint256).max);
  55 |     |         }
  56 |     | 
  57 |     |         mim.safeApprove(address(_bentoBox), type(uint256).max);
  58 |     |     }
  59 |     | 
  60 |     |     function withdrawFromBentoBox(uint256 shareFrom) internal virtual returns (uint256 amount) {
  61 |     |         (amount, ) = bentoBox.withdraw(IERC20(curveToken), address(this), address(this), 0, shareFrom);
  62 |     |     }
  63 |     | 
  64 |     |     /// @inheritdoc ISwapperV2
  65 |     |     function swap(
  66 |     |         address,
  67 |     |         address,
  68 |     |         address recipient,
  69 |     |         uint256 shareToMin,
  70 |     |         uint256 shareFrom,
  71 |     |         bytes calldata data
  72 |     |     ) public override returns (uint256 extraShare, uint256 shareReturned) {
  73 |     |         (uint256 poolIndex, bytes memory swapData) = abi.decode(data, (uint256, bytes));
  74 |     |         uint256 amount = withdrawFromBentoBox(shareFrom);
  75 |     | 
  76 |     |         // CurveLP token -> underlyingToken
  77 |     |         if (curvePoolInterfaceType == CurvePoolInterfaceType.ICURVE_POOL) {
  78 |     |             ICurvePool(curvePoolDepositor).remove_liquidity_one_coin(amount, int128(uint128(poolIndex)), uint256(0));
  79 |     |         } else if (curvePoolInterfaceType == CurvePoolInterfaceType.ICURVE_3POOL_ZAPPER) {
  80 |     |             ICurve3PoolZapper(curvePoolDepositor).remove_liquidity_one_coin(curvePool, amount, int128(uint128(poolIndex)), uint256(0));
  81 |     |         } else if (curvePoolInterfaceType == CurvePoolInterfaceType.IFACTORY_POOL) {
  82 |     |             IFactoryPool(curvePoolDepositor).remove_liquidity_one_coin(amount, poolIndex, uint256(0));
  83 |     |         } else if (curvePoolInterfaceType == CurvePoolInterfaceType.ITRICRYPTO_POOL) {
  84 |     |             ITriCrypto(curvePoolDepositor).remove_liquidity_one_coin(amount, poolIndex, uint256(0));
  85 |     |         } else {
  86 |     |             revert ErrUnsupportedCurvePool();
  87 |     |         }
  88 |     | 
  89 |     |         // Optional underlyingToken -> MIM
  90 |     |         if (swapData.length != 0) {
  91 |     |             (bool success, ) = exchange.call(swapData);
  92 |     |             if (!success) {
  93 |     |                 revert ErrSwapFailed();
  94 |     |             }
  95 |     | 
  96 |     |             // Refund remaining underlying balance to the recipient
  97 |     |             address underlyingToken = ICurvePool(curvePool).coins(poolIndex);
  98 |     |             underlyingToken.safeTransfer(recipient, underlyingToken.balanceOf(address(this)));
  99 |     |         }
 100 |     | 
 101 |     |         (, shareReturned) = bentoBox.deposit(IERC20(mim), address(this), recipient, mim.balanceOf(address(this)), 0);
 102 |     |         extraShare = shareReturned - shareToMin;
 103 |     |     }
 104 |     | }
 105 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/ERC4626LevSwapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // solhint-disable avoid-low-level-calls
  3 |     | pragma solidity >=0.8.0;
  4 |     | 
  5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  7 |     | import {SafeApproveLib} from "libraries/SafeApproveLib.sol";
  8 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  9 |     | import {ILevSwapperV2} from "interfaces/ILevSwapperV2.sol";
 10 |     | import {IERC4626} from "interfaces/IERC4626.sol";
 11 |     | import {IGmxGlpRewardRouter, IGmxVault} from "interfaces/IGmxV1.sol";
 12 |     | 
 13 |     | contract ERC4626LevSwapper is ILevSwapperV2 {
 14 |     |     using BoringERC20 for IERC20;
 15 |     |     using SafeApproveLib for IERC20;
 16 |     | 
 17 |     |     error ErrSwapFailed();
 18 |     | 
 19 |     |     IBentoBoxV1 public immutable bentoBox;
 20 |     |     IERC20 public immutable mim;
 21 |     |     IERC20 public immutable token;
 22 |     |     IERC4626 public immutable vault;
 23 |     |     address public immutable zeroXExchangeProxy;
 24 |     | 
 25 |     |     constructor(IBentoBoxV1 _bentoBox, IERC4626 _vault, IERC20 _mim, address _zeroXExchangeProxy) {
 26 |     |         bentoBox = _bentoBox;
 27 |     |         vault = _vault;
 28 |     |         mim = _mim;
 29 |     |         zeroXExchangeProxy = _zeroXExchangeProxy;
 30 |     | 
 31 |     |         IERC20 _token = _vault.asset();
 32 |     |         token = _token;
 33 |     | 
 34 |     |         _token.approve(address(_vault), type(uint256).max);
 35 |     |         _mim.approve(_zeroXExchangeProxy, type(uint256).max);
 36 |     |     }
 37 |     | 
 38 |     |     /// @inheritdoc ILevSwapperV2
 39 |     |     function swap(
 40 |     |         address recipient,
 41 |     |         uint256 shareToMin,
 42 |     |         uint256 shareFrom,
 43 |     |         bytes calldata swapData
 44 |     |     ) external override returns (uint256 extraShare, uint256 shareReturned) {
 45 |     |         bentoBox.withdraw(mim, address(this), address(this), 0, shareFrom);
 46 |     | 
 47 |     |         // MIM -> Asset
 48 |     |         (bool success, ) = zeroXExchangeProxy.call(swapData);
 49 |     |         if (!success) {
 50 |     |             revert ErrSwapFailed();
 51 |     |         }
 52 |     | 
 53 |     |         uint256 _amount = token.balanceOf(address(this));
 54 |     |         _amount = vault.deposit(_amount, address(bentoBox));
 55 |     | 
 56 |     |         (, shareReturned) = bentoBox.deposit(IERC20(address(vault)), address(bentoBox), recipient, _amount, 0);
 57 |     | 
 58 |     |         extraShare = shareReturned - shareToMin;
 59 |     |     }
 60 |     | }
 61 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/ERC4626Swapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // solhint-disable avoid-low-level-calls
  3 |     | pragma solidity >=0.8.0;
  4 |     | 
  5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  7 |     | import {SafeApproveLib} from "libraries/SafeApproveLib.sol";
  8 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  9 |     | import {ISwapperV2} from "interfaces/ISwapperV2.sol";
 10 |     | import {IGmxGlpRewardRouter, IGmxVault} from "interfaces/IGmxV1.sol";
 11 |     | import {IERC4626} from "interfaces/IERC4626.sol";
 12 |     | 
 13 |     | contract ERC4626Swapper is ISwapperV2 {
 14 |     |     using BoringERC20 for IERC20;
 15 |     |     using SafeApproveLib for IERC20;
 16 |     | 
 17 |     |     error ErrSwapFailed();
 18 |     |     error ErrTokenNotSupported(IERC20);
 19 |     | 
 20 |     |     IBentoBoxV1 public immutable bentoBox;
 21 |     |     IERC4626 public immutable vault;
 22 |     |     IERC20 public immutable mim;
 23 |     |     IERC20 public immutable asset;
 24 |     |     address public immutable zeroXExchangeProxy;
 25 |     | 
 26 |     |     constructor(IBentoBoxV1 _bentoBox, IERC4626 _vault, IERC20 _mim, address _zeroXExchangeProxy) {
 27 |     |         bentoBox = _bentoBox;
 28 |     |         vault = _vault;
 29 |     |         mim = _mim;
 30 |     |         zeroXExchangeProxy = _zeroXExchangeProxy;
 31 |     | 
 32 |     |         IERC20 _asset = _vault.asset();
 33 |     |         asset = _asset;
 34 |     | 
 35 |     |         _asset.safeApprove(_zeroXExchangeProxy, type(uint256).max);
 36 |     |         mim.approve(address(_bentoBox), type(uint256).max);
 37 |     |     }
 38 |     | 
 39 |     |     /// @inheritdoc ISwapperV2
 40 |     |     function swap(
 41 |     |         address,
 42 |     |         address,
 43 |     |         address recipient,
 44 |     |         uint256 shareToMin,
 45 |     |         uint256 shareFrom,
 46 |     |         bytes calldata swapData
 47 |     |     ) public override returns (uint256 extraShare, uint256 shareReturned) {
 48 |     |         (uint256 amount, ) = bentoBox.withdraw(IERC20(address(vault)), address(this), address(this), 0, shareFrom);
 49 |     |         amount = IERC4626(address(vault)).redeem(amount, address(this), address(this));
 50 |     | 
 51 |     |         // Asset -> MIM
 52 |     |         (bool success, ) = zeroXExchangeProxy.call(swapData);
 53 |     |         if (!success) {
 54 |     |             revert ErrSwapFailed();
 55 |     |         }
 56 |     | 
 57 |     |         (, shareReturned) = bentoBox.deposit(mim, address(this), recipient, mim.balanceOf(address(this)), 0);
 58 |     |         extraShare = shareReturned - shareToMin;
 59 |     |     }
 60 |     | }
 61 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/MagicCurveLpLevSwapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // solhint-disable avoid-low-level-calls
  3 |     | pragma solidity >=0.8.0;
  4 |     | 
  5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  7 |     | import {SafeApproveLib} from "libraries/SafeApproveLib.sol";
  8 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  9 |     | import {CurveLevSwapper} from "swappers/CurveLevSwapper.sol";
 10 |     | import {IERC4626} from "interfaces/IERC4626.sol";
 11 |     | import {ICurvePool, CurvePoolInterfaceType} from "interfaces/ICurvePool.sol";
 12 |     | 
 13 |     | contract MagicCurveLpLevSwapper is CurveLevSwapper {
 14 |     |     using BoringERC20 for IERC20;
 15 |     |     using SafeApproveLib for IERC20;
 16 |     | 
 17 |     |     IERC4626 public immutable vault;
 18 |     | 
 19 |     |     constructor(
 20 |     |         IBentoBoxV1 _bentoBox,
 21 |     |         IERC4626 _vault,
 22 |     |         address _mim,
 23 |     |         CurvePoolInterfaceType _curvePoolInterfaceType,
 24 |     |         address _curvePool,CurvePoolInterfaceType,
 25 |     |         address _curvePoolDepositor /* Optional Curve Deposit Zapper */,
 26 |     |         address[] memory _poolTokens,
 27 |     |         address _exchange
 28 |     |     )
 29 |     |         CurveLevSwapper(
 30 |     |             _bentoBox,
 31 |     |             address(_vault.asset()),
 32 |     |             _mim,
 33 |     |             _curvePoolInterfaceType,
 34 |     |             _curvePool,
 35 |     |             _curvePoolDepositor,
 36 |     |             _poolTokens,
 37 |     |             _exchange
 38 |     |         )
 39 |     |     {
 40 |     |         vault = _vault;
 41 |     |         IERC20(curveToken).safeApprove(address(_vault), type(uint256).max);
 42 |     |     }
 43 |     | 
 44 |     |     function depositInBentoBox(uint256 amount, address recipient) internal override returns (uint256 shareReturned) {
 45 |     |         // CurveLP -> MagicCurveLP
 46 |     |         amount = vault.deposit(amount, address(bentoBox));
 47 |     | 
 48 |     |         (, shareReturned) = bentoBox.deposit(IERC20(address(vault)), address(bentoBox), recipient, amount, 0);
 49 |     |     }
 50 |     | }
 51 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/MagicCurveLpSwapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // solhint-disable avoid-low-level-calls
  3 |     | pragma solidity >=0.8.0;
  4 |     | 
  5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  7 |     | import {CurveSwapper} from "swappers/CurveSwapper.sol";
  8 |     | import {SafeApproveLib} from "libraries/SafeApproveLib.sol";
  9 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
 10 |     | import {IERC4626} from "interfaces/IERC4626.sol";
 11 |     | import {ICurvePool, CurvePoolInterfaceType} from "interfaces/ICurvePool.sol";
 12 |     | 
 13 |     | contract MagicCurveLpSwapper is CurveSwapper {
 14 |     |     using BoringERC20 for IERC20;
 15 |     |     using SafeApproveLib for IERC20;
 16 |     | 
 17 |     |     IERC4626 public immutable vault;
 18 |     | 
 19 |     |     constructor(
 20 |     |         IBentoBoxV1 _bentoBox,
 21 |     |         IERC4626 _vault,
 22 |     |         address _mim,
 23 |     |         CurvePoolInterfaceType _curvePoolInterfaceType,
 24 |     |         address _curvePool,
 25 |     |         address _curvePoolDepositor /* Optional Curve Deposit Zapper */,
 26 |     |         address[] memory _poolTokens,
 27 |     |         address _exchange
 28 |     |     )
 29 |     |         CurveSwapper(
 30 |     |             _bentoBox,
 31 |     |             address(_vault.asset()),
 32 |     |             _mim,
 33 |     |             _curvePoolInterfaceType,
 34 |     |             _curvePool,
 35 |     |             _curvePoolDepositor,
 36 |     |             _poolTokens,
 37 |     |             _exchange
 38 |     |         )
 39 |     |     {
 40 |     |         vault = _vault;
 41 |     |         if (_curvePoolDepositor != address(0)) {
 42 |     |             IERC20 curveToken = _vault.asset();
 43 |     |             curveToken.safeApprove(_curvePoolDepositor, type(uint256).max);
 44 |     |         }
 45 |     |     }
 46 |     | 
 47 |     |     function withdrawFromBentoBox(uint256 shareFrom) internal override returns (uint256 amount) {
 48 |     |         (amount, ) = bentoBox.withdraw(IERC20(address(vault)), address(this), address(this), 0, shareFrom);
 49 |     | 
 50 |     |         // MagicCurveLP -> CurveLP
 51 |     |         amount = vault.redeem(amount, address(this), address(this));
 52 |     |     }
 53 |     | }
 54 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/MagicGlpLevSwapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // solhint-disable avoid-low-level-calls
  3 |     | pragma solidity >=0.8.0;
  4 |     | 
  5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  7 |     | import {SafeApproveLib} from "libraries/SafeApproveLib.sol";
  8 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  9 |     | import {ILevSwapperV2} from "interfaces/ILevSwapperV2.sol";
 10 |     | import {IERC4626} from "interfaces/IERC4626.sol";
 11 |     | import {IGmxGlpRewardRouter, IGmxVault} from "interfaces/IGmxV1.sol";
 12 |     | 
 13 |     | contract MagicGlpLevSwapper is ILevSwapperV2 {
 14 |     |     using BoringERC20 for IERC20;
 15 |     |     using SafeApproveLib for IERC20;
 16 |     | 
 17 |     |     error ErrSwapFailed();
 18 |     |     error ErrTokenNotSupported(IERC20);
 19 |     | 
 20 |     |     IBentoBoxV1 public immutable bentoBox;
 21 |     |     IERC20 public immutable mim;
 22 |     |     IERC20 public immutable magicGLP;
 23 |     |     IGmxGlpRewardRouter public immutable glpRewardRouter;
 24 |     |     IERC20 public immutable sGLP;
 25 |     |     address public immutable zeroXExchangeProxy;
 26 |     |     IGmxVault public immutable gmxVault;
 27 |     | 
 28 |     |     constructor(
 29 |     |         IBentoBoxV1 _bentoBox,
 30 |     |         IGmxVault _gmxVault,
 31 |     |         IERC20 _magicGLP,
 32 |     |         IERC20 _mim,
 33 |     |         IERC20 _sGLP,
 34 |     |         address glpManager,
 35 |     |         IGmxGlpRewardRouter _glpRewardRouter,
 36 |     |         address _zeroXExchangeProxy
 37 |     |     ) {
 38 |     |         bentoBox = _bentoBox;
 39 |     |         gmxVault = _gmxVault;
 40 |     |         magicGLP = _magicGLP;
 41 |     |         mim = _mim;
 42 |     |         sGLP = _sGLP;
 43 |     |         glpRewardRouter = _glpRewardRouter;
 44 |     |         zeroXExchangeProxy = _zeroXExchangeProxy;
 45 |     | 
 46 |     |         uint256 len = _gmxVault.allWhitelistedTokensLength();
 47 |     |         for (uint256 i = 0; i < len; i++) {
 48 |     |             IERC20 token = IERC20(_gmxVault.allWhitelistedTokens(i));
 49 |     |             if (token == mim) continue;
 50 |     |             token.safeApprove(glpManager, type(uint256).max);
 51 |     |         }
 52 |     | 
 53 |     |         _sGLP.approve(address(_magicGLP), type(uint256).max);
 54 |     |         _mim.approve(_zeroXExchangeProxy, type(uint256).max);
 55 |     |     }
 56 |     | 
 57 |     |     /// @inheritdoc ILevSwapperV2
 58 |     |     function swap(
 59 |     |         address recipient,
 60 |     |         uint256 shareToMin,
 61 |     |         uint256 shareFrom,
 62 |     |         bytes calldata data
 63 |     |     ) external override returns (uint256 extraShare, uint256 shareReturned) {
 64 |     |         (bytes memory swapData, IERC20 token) = abi.decode(data, (bytes, IERC20));
 65 |     | 
 66 |     |         bentoBox.withdraw(mim, address(this), address(this), 0, shareFrom);
 67 |     | 
 68 |     |         // MIM -> Token
 69 |     |         (bool success, ) = zeroXExchangeProxy.call(swapData);
 70 |     |         if (!success) {
 71 |     |             revert ErrSwapFailed();
 72 |     |         }
 73 |     | 
 74 |     |         uint256 _amount = token.balanceOf(address(this));
 75 |     | 
 76 |     |         _amount = glpRewardRouter.mintAndStakeGlp(address(token), _amount, 0, 0);
 77 |     |         _amount = IERC4626(address(magicGLP)).deposit(_amount, address(bentoBox));
 78 |     | 
 79 |     |         (, shareReturned) = bentoBox.deposit(magicGLP, address(bentoBox), recipient, _amount, 0);
 80 |     | 
 81 |     |         extraShare = shareReturned - shareToMin;
 82 |     |     }
 83 |     | }
 84 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/MagicGlpSwapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // solhint-disable avoid-low-level-calls
  3 |     | pragma solidity >=0.8.0;
  4 |     | 
  5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  7 |     | import {SafeApproveLib} from "libraries/SafeApproveLib.sol";
  8 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  9 |     | import {ISwapperV2} from "interfaces/ISwapperV2.sol";
 10 |     | import {IGmxGlpRewardRouter, IGmxVault} from "interfaces/IGmxV1.sol";
 11 |     | import {IERC4626} from "interfaces/IERC4626.sol";
 12 |     | 
 13 |     | contract MagicGlpSwapper is ISwapperV2 {
 14 |     |     using BoringERC20 for IERC20;
 15 |     |     using SafeApproveLib for IERC20;
 16 |     | 
 17 |     |     error ErrSwapFailed();
 18 |     |     error ErrTokenNotSupported(IERC20);
 19 |     | 
 20 |     |     IBentoBoxV1 public immutable bentoBox;
 21 |     |     IERC20 public immutable magicGlp;
 22 |     |     IERC20 public immutable mim;
 23 |     |     IERC20 public immutable sGLP;
 24 |     |     IGmxGlpRewardRouter public immutable glpRewardRouter;
 25 |     |     address public immutable zeroXExchangeProxy;
 26 |     |     IGmxVault public immutable gmxVault;
 27 |     | 
 28 |     |     constructor(
 29 |     |         IBentoBoxV1 _bentoBox,
 30 |     |         IGmxVault _gmxVault,
 31 |     |         IERC20 _magicGlp,
 32 |     |         IERC20 _mim,
 33 |     |         IERC20 _sGLP,
 34 |     |         IGmxGlpRewardRouter _glpRewardRouter,
 35 |     |         address _zeroXExchangeProxy
 36 |     |     ) {
 37 |     |         bentoBox = _bentoBox;
 38 |     |         gmxVault = _gmxVault;
 39 |     |         magicGlp = _magicGlp;
 40 |     |         mim = _mim;
 41 |     |         sGLP = _sGLP;
 42 |     |         glpRewardRouter = _glpRewardRouter;
 43 |     |         zeroXExchangeProxy = _zeroXExchangeProxy;
 44 |     | 
 45 |     |         uint256 len = _gmxVault.allWhitelistedTokensLength();
 46 |     |         for (uint256 i = 0; i < len; i++) {
 47 |     |             IERC20 token = IERC20(_gmxVault.allWhitelistedTokens(i));
 48 |     |             if (token == mim) continue;
 49 |     |             token.safeApprove(_zeroXExchangeProxy, type(uint256).max);
 50 |     |         }
 51 |     | 
 52 |     |         mim.approve(address(_bentoBox), type(uint256).max);
 53 |     |     }
 54 |     | 
 55 |     |     /// @inheritdoc ISwapperV2
 56 |     |     function swap(
 57 |     |         address,
 58 |     |         address,
 59 |     |         address recipient,
 60 |     |         uint256 shareToMin,
 61 |     |         uint256 shareFrom,
 62 |     |         bytes calldata data
 63 |     |     ) public override returns (uint256 extraShare, uint256 shareReturned) {
 64 |     |         (bytes memory swapData, IERC20 token) = abi.decode(data, (bytes, IERC20));
 65 |     | 
 66 |     |         (uint256 amount, ) = bentoBox.withdraw(IERC20(address(magicGlp)), address(this), address(this), 0, shareFrom);
 67 |     |         amount = IERC4626(address(magicGlp)).redeem(amount, address(this), address(this));
 68 |     | 
 69 |     |         glpRewardRouter.unstakeAndRedeemGlp(address(token), amount, 0, address(this));
 70 |     | 
 71 |     |         // Token -> MIM
 72 |     |         (bool success, ) = zeroXExchangeProxy.call(swapData);
 73 |     |         if (!success) {
 74 |     |             revert ErrSwapFailed();
 75 |     |         }
 76 |     | 
 77 |     |         // we can expect dust from both gmx and 0x
 78 |     |         token.safeTransfer(recipient, token.balanceOf(address(this)));
 79 |     | 
 80 |     |         (, shareReturned) = bentoBox.deposit(mim, address(this), recipient, mim.balanceOf(address(this)), 0);
 81 |     |         extraShare = shareReturned - shareToMin;
 82 |     |     }
 83 |     | }
 84 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/StargateCurveSwapper.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   5 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
   6 |     | import {BoringOwnable} from "BoringSolidity/BoringOwnable.sol";
   7 |     | import {Address} from "openzeppelin-contracts/utils/Address.sol";
   8 |     | import {SafeApproveLib} from "libraries/SafeApproveLib.sol";
   9 |     | import {IStargatePool, IStargateRouter} from "interfaces/IStargate.sol";
  10 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  11 |     | import {ISwapperV1} from "interfaces/ISwapperV1.sol";
  12 |     | import {ICurvePool} from "interfaces/ICurvePool.sol";
  13 |     | 
  14 |     | interface IStargateLpMimPool {
  15 |     |     function swapForMim(IStargatePool tokenIn, uint256 amountIn, address recipient) external returns (uint256);
  16 |     | }
  17 |     | 
  18 |     | /// @notice Liquidation Swapper for Stargate LP using Curve
  19 |     | contract StargateCurveSwapper is ISwapperV1, BoringOwnable {
  20 |     |     using BoringERC20 for IERC20;
  21 |     |     using SafeApproveLib for IERC20;
  22 |     |     using Address for address;
  23 |     | 
  24 |     |     event MimPoolChanged(IStargateLpMimPool previousPool, IStargateLpMimPool pool);
  25 |     | 
  26 |     |     IBentoBoxV1 public immutable degenBox;
  27 |     |     IStargatePool public immutable pool;
  28 |     |     IStargateRouter public immutable stargateRouter;
  29 |     |     ICurvePool public immutable curvePool;
  30 |     |     int128 public immutable curvePoolI;
  31 |     |     int128 public immutable curvePoolJ;
  32 |     |     uint16 public immutable poolId;
  33 |     |     IERC20 public immutable underlyingPoolToken;
  34 |     |     IERC20 public immutable mim;
  35 |     | 
  36 |     |     IStargateLpMimPool public mimPool;
  37 |     | 
  38 |     |     constructor(
  39 |     |         IBentoBoxV1 _degenBox,
  40 |     |         IStargatePool _pool,
  41 |     |         uint16 _poolId,
  42 |     |         IStargateRouter _stargateRouter,
  43 |     |         ICurvePool _curvePool,
  44 |     |         int128 _curvePoolI,
  45 |     |         int128 _curvePoolJ
  46 |     |     ) {
  47 |     |         degenBox = _degenBox;
  48 |     |         pool = _pool;
  49 |     |         poolId = _poolId;
  50 |     |         stargateRouter = _stargateRouter;
  51 |     |         curvePool = _curvePool;
  52 |     |         curvePoolI = _curvePoolI;
  53 |     |         curvePoolJ = _curvePoolJ;
  54 |     |         mim = IERC20(_curvePool.coins(uint128(_curvePoolJ)));
  55 |     | 
  56 |     |         underlyingPoolToken = IERC20(_pool.token());
  57 |     |         underlyingPoolToken.safeApprove(address(_curvePool), type(uint256).max);
  58 |     |     }
  59 |     | 
  60 |     |     function setMimPool(IStargateLpMimPool _mimPool) external onlyOwner {
  61 |     |         if (address(mimPool) != address(0)) {
  62 |     |             IERC20(address(pool)).safeApprove(address(_mimPool), 0);
  63 |     |         }
  64 |     | 
  65 |     |         if (address(_mimPool) != address(0)) {
  66 |     |             IERC20(address(pool)).safeApprove(address(_mimPool), type(uint256).max);
  67 |     |         }
  68 |     | 
  69 |     |         emit MimPoolChanged(mimPool, _mimPool);
  70 |     |         mimPool = _mimPool;
  71 |     |     }
  72 |     | 
  73 |     |     /// @inheritdoc ISwapperV1
  74 |     |     function swap(
  75 |     |         address,
  76 |     |         address,
  77 |     |         address recipient,
  78 |     |         uint256 shareToMin,
  79 |     |         uint256 shareFrom
  80 |     |     ) public override returns (uint256 extraShare, uint256 shareReturned) {
  81 |     |         degenBox.withdraw(IERC20(address(pool)), address(this), address(this), 0, shareFrom);
  82 |     | 
  83 |     |         // use the full balance so it's easier to check if everything has been redeemed.
  84 |     |         uint256 amount = IERC20(address(pool)).balanceOf(address(this));
  85 |     |         uint256 mimAmount;
  86 |     | 
  87 |     |         // Stargate Pool LP -> Underlying Token
  88 |     |         stargateRouter.instantRedeemLocal(poolId, amount, address(this));
  89 |     | 
  90 |     |         // Use mim pool to swap the remaining lp
  91 |     |         if (address(mimPool) != address(0)) {
  92 |     |             // Remaining lp amount
  93 |     |             amount = IERC20(address(pool)).balanceOf(address(this));
  94 |     | 
  95 |     |             if (amount > 0) {
  96 |     |                 mimAmount += mimPool.swapForMim(pool, amount, address(degenBox));
  97 |     |             }
  98 |     |         } else {
  99 |     |             require(IERC20(address(pool)).balanceOf(address(this)) == 0, "Cannot fully redeem");
 100 |     |         }
 101 |     | 
 102 |     |         // Stargate Pool Underlying Token -> MIM
 103 |     |         mimAmount += curvePool.exchange_underlying(
 104 |     |             curvePoolI,
 105 |     |             curvePoolJ,
 106 |     |             underlyingPoolToken.balanceOf(address(this)),
 107 |     |             0,
 108 |     |             address(degenBox)
 109 |     |         );
 110 |     | 
 111 |     |         (, shareReturned) = degenBox.deposit(mim, address(degenBox), recipient, mimAmount, 0);
 112 |     |         extraShare = shareReturned - shareToMin;
 113 |     |     }
 114 |     | }
 115 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/StargateLPLevSwapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // solhint-disable avoid-low-level-calls
  3 |     | pragma solidity >=0.8.0;
  4 |     | 
  5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  7 |     | import {IUniswapV2Pair} from "interfaces/IUniswapV2.sol";
  8 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  9 |     | import {ILevSwapperV2} from "interfaces/ILevSwapperV2.sol";
 10 |     | import {IStargatePool, IStargateRouter} from "interfaces/IStargate.sol";
 11 |     | import {SafeApproveLib} from "libraries/SafeApproveLib.sol";
 12 |     | 
 13 |     | /// @notice LP leverage swapper for Stargate LP using Matcha/0x aggregator
 14 |     | contract StargateLPLevSwapper is ILevSwapperV2 {
 15 |     |     using BoringERC20 for IERC20;
 16 |     |     using SafeApproveLib for IERC20;
 17 |     | 
 18 |     |     error ErrSwapFailed();
 19 |     | 
 20 |     |     IBentoBoxV1 public immutable bentoBox;
 21 |     |     IStargatePool public immutable pool;
 22 |     |     IERC20 public immutable mim;
 23 |     |     IERC20 public immutable underlyingToken;
 24 |     |     IStargateRouter public immutable stargateRouter;
 25 |     |     address public immutable zeroXExchangeProxy;
 26 |     |     uint256 public immutable poolId;
 27 |     | 
 28 |     |     constructor(
 29 |     |         IBentoBoxV1 _bentoBox,
 30 |     |         IStargatePool _pool,
 31 |     |         uint256 _poolId,
 32 |     |         IStargateRouter _stargateRouter,
 33 |     |         IERC20 _mim,
 34 |     |         address _zeroXExchangeProxy
 35 |     |     ) {
 36 |     |         bentoBox = _bentoBox;
 37 |     |         pool = _pool;
 38 |     |         poolId = _poolId;
 39 |     |         mim = _mim;
 40 |     |         stargateRouter = _stargateRouter;
 41 |     |         zeroXExchangeProxy = _zeroXExchangeProxy;
 42 |     |         IERC20 _underlyingToken = IERC20(_pool.token());
 43 |     |         underlyingToken = _underlyingToken;
 44 |     | 
 45 |     |         _underlyingToken.safeApprove(address(_stargateRouter), type(uint256).max);
 46 |     |         _pool.approve(address(_bentoBox), type(uint256).max);
 47 |     |         _mim.approve(_zeroXExchangeProxy, type(uint256).max);
 48 |     |     }
 49 |     | 
 50 |     |     /// @inheritdoc ILevSwapperV2
 51 |     |     function swap(
 52 |     |         address recipient,
 53 |     |         uint256 shareToMin,
 54 |     |         uint256 shareFrom,
 55 |     |         bytes calldata swapData
 56 |     |     ) external override returns (uint256 extraShare, uint256 shareReturned) {
 57 |     |         bentoBox.withdraw(mim, address(this), address(this), 0, shareFrom);
 58 |     | 
 59 |     |         // MIM -> underlyingToken
 60 |     |         (bool success, ) = zeroXExchangeProxy.call(swapData);
 61 |     |         if (!success) {
 62 |     |             revert ErrSwapFailed();
 63 |     |         }
 64 |     | 
 65 |     |         // Underlying Token -> Stargate Pool LP
 66 |     |         stargateRouter.addLiquidity(poolId, underlyingToken.balanceOf(address(this)), address(this));
 67 |     |         uint256 amount = pool.balanceOf(address(this));
 68 |     | 
 69 |     |         (, shareReturned) = bentoBox.deposit(IERC20(address(pool)), address(this), recipient, amount, 0);
 70 |     |         extraShare = shareReturned - shareToMin;
 71 |     |     }
 72 |     | }
 73 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/StargateLPSwapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // solhint-disable avoid-low-level-calls
  3 |     | pragma solidity >=0.8.0;
  4 |     | 
  5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  7 |     | import {IUniswapV2Pair} from "interfaces/IUniswapV2.sol";
  8 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  9 |     | import {ISwapperV2} from "interfaces/ISwapperV2.sol";
 10 |     | import {IStargatePool, IStargateRouter} from "interfaces/IStargate.sol";
 11 |     | import {SafeApproveLib} from "libraries/SafeApproveLib.sol";
 12 |     | 
 13 |     | /// @notice LP liquidation/deleverage swapper for Stargate LPs using Matcha/0x aggregator
 14 |     | contract StargateLPSwapper is ISwapperV2 {
 15 |     |     using BoringERC20 for IERC20;
 16 |     |     using SafeApproveLib for IERC20;
 17 |     | 
 18 |     |     error ErrSwapFailed();
 19 |     | 
 20 |     |     IBentoBoxV1 public immutable bentoBox;
 21 |     |     IStargatePool public immutable pool;
 22 |     |     IERC20 public immutable mim;
 23 |     |     IERC20 public immutable underlyingToken;
 24 |     |     IStargateRouter public immutable stargateRouter;
 25 |     |     address public immutable zeroXExchangeProxy;
 26 |     |     uint16 public immutable poolId;
 27 |     | 
 28 |     |     constructor(
 29 |     |         IBentoBoxV1 _bentoBox,
 30 |     |         IStargatePool _pool,
 31 |     |         uint16 _poolId,
 32 |     |         IStargateRouter _stargateRouter,
 33 |     |         IERC20 _mim,
 34 |     |         address _zeroXExchangeProxy
 35 |     |     ) {
 36 |     |         bentoBox = _bentoBox;
 37 |     |         pool = _pool;
 38 |     |         poolId = _poolId;
 39 |     |         mim = _mim;
 40 |     |         stargateRouter = _stargateRouter;
 41 |     |         zeroXExchangeProxy = _zeroXExchangeProxy;
 42 |     |         underlyingToken = IERC20(_pool.token());
 43 |     | 
 44 |     |         underlyingToken.safeApprove(_zeroXExchangeProxy, type(uint256).max);
 45 |     |         mim.approve(address(_bentoBox), type(uint256).max);
 46 |     |     }
 47 |     | 
 48 |     |     /// @inheritdoc ISwapperV2
 49 |     |     function swap(
 50 |     |         address,
 51 |     |         address,
 52 |     |         address recipient,
 53 |     |         uint256 shareToMin,
 54 |     |         uint256 shareFrom,
 55 |     |         bytes calldata swapData
 56 |     |     ) public override returns (uint256 extraShare, uint256 shareReturned) {
 57 |     |         bentoBox.withdraw(IERC20(address(pool)), address(this), address(this), 0, shareFrom);
 58 |     | 
 59 |     |         // use the full balance so it's easier to check if everything has been redeemed.
 60 |     |         uint256 amount = IERC20(address(pool)).balanceOf(address(this));
 61 |     | 
 62 |     |         // Stargate Pool LP -> Underlying Token
 63 |     |         stargateRouter.instantRedeemLocal(poolId, amount, address(this));
 64 |     |         require(IERC20(address(pool)).balanceOf(address(this)) == 0, "Cannot fully redeem");
 65 |     | 
 66 |     |         // underlying -> MIM
 67 |     |         (bool success, ) = zeroXExchangeProxy.call(swapData);
 68 |     |         if (!success) {
 69 |     |             revert ErrSwapFailed();
 70 |     |         }
 71 |     | 
 72 |     |         // Refund remaining underlying balance to the recipient
 73 |     |         underlyingToken.safeTransfer(recipient, underlyingToken.balanceOf(address(this)));
 74 |     | 
 75 |     |         (, shareReturned) = bentoBox.deposit(mim, address(this), recipient, mim.balanceOf(address(this)), 0);
 76 |     |         extraShare = shareReturned - shareToMin;
 77 |     |     }
 78 |     | }
 79 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/TokenLevSwapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // solhint-disable avoid-low-level-calls
  3 |     | pragma solidity >=0.8.0;
  4 |     | 
  5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  7 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  8 |     | import {ILevSwapperV2} from "interfaces/ILevSwapperV2.sol";
  9 |     | 
 10 |     | /// @notice token leverage swapper for tokens using Matcha/0x aggregator
 11 |     | contract TokenLevSwapper is ILevSwapperV2 {
 12 |     |     using BoringERC20 for IERC20;
 13 |     | 
 14 |     |     error ErrSwapFailed();
 15 |     | 
 16 |     |     IBentoBoxV1 public immutable bentoBox;
 17 |     |     IERC20 public immutable mim;
 18 |     |     IERC20 public immutable token;
 19 |     |     address public immutable zeroXExchangeProxy;
 20 |     | 
 21 |     |     constructor(IBentoBoxV1 _bentoBox, IERC20 _token, IERC20 _mim, address _zeroXExchangeProxy) {
 22 |     |         bentoBox = _bentoBox;
 23 |     |         token = _token;
 24 |     |         mim = _mim;
 25 |     |         zeroXExchangeProxy = _zeroXExchangeProxy;
 26 |     |         _token.approve(address(_bentoBox), type(uint256).max);
 27 |     |         _mim.approve(_zeroXExchangeProxy, type(uint256).max);
 28 |     |     }
 29 |     | 
 30 |     |     /// @inheritdoc ILevSwapperV2
 31 |     |     function swap(
 32 |     |         address recipient,
 33 |     |         uint256 shareToMin,
 34 |     |         uint256 shareFrom,
 35 |     |         bytes calldata swapData
 36 |     |     ) external override returns (uint256 extraShare, uint256 shareReturned) {
 37 |     |         bentoBox.withdraw(mim, address(this), address(this), 0, shareFrom);
 38 |     | 
 39 |     |         // MIM -> token
 40 |     |         (bool success, ) = zeroXExchangeProxy.call(swapData);
 41 |     |         if (!success) {
 42 |     |             revert ErrSwapFailed();
 43 |     |         }
 44 |     | 
 45 |     |         // Refund remaining mim balance to the recipient
 46 |     |         uint256 balance = mim.balanceOf(address(this));
 47 |     |         if (balance > 0) {
 48 |     |             mim.safeTransfer(recipient, balance);
 49 |     |         }
 50 |     | 
 51 |     |         (, shareReturned) = bentoBox.deposit(token, address(this), recipient, token.balanceOf(address(this)), 0);
 52 |     |         extraShare = shareReturned - shareToMin;
 53 |     |     }
 54 |     | }
 55 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/TokenSwapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // solhint-disable avoid-low-level-calls
  3 |     | pragma solidity >=0.8.0;
  4 |     | 
  5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  7 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  8 |     | import {ISwapperV2} from "interfaces/ISwapperV2.sol";
  9 |     | 
 10 |     | /// @notice token liquidation/deleverage swapper for tokens using Matcha/0x aggregator
 11 |     | contract TokenSwapper is ISwapperV2 {
 12 |     |     using BoringERC20 for IERC20;
 13 |     | 
 14 |     |     error ErrSwapFailed();
 15 |     | 
 16 |     |     IBentoBoxV1 public immutable bentoBox;
 17 |     |     IERC20 public immutable token;
 18 |     |     IERC20 public immutable mim;
 19 |     |     address public immutable zeroXExchangeProxy;
 20 |     | 
 21 |     |     constructor(IBentoBoxV1 _bentoBox, IERC20 _token, IERC20 _mim, address _zeroXExchangeProxy) {
 22 |     |         bentoBox = _bentoBox;
 23 |     |         token = _token;
 24 |     |         mim = _mim;
 25 |     |         zeroXExchangeProxy = _zeroXExchangeProxy;
 26 |     |         _token.approve(_zeroXExchangeProxy, type(uint256).max);
 27 |     |         mim.approve(address(_bentoBox), type(uint256).max);
 28 |     |     }
 29 |     | 
 30 |     |     /// @inheritdoc ISwapperV2
 31 |     |     function swap(
 32 |     |         address,
 33 |     |         address,
 34 |     |         address recipient,
 35 |     |         uint256 shareToMin,
 36 |     |         uint256 shareFrom,
 37 |     |         bytes calldata swapData
 38 |     |     ) public override returns (uint256 extraShare, uint256 shareReturned) {
 39 |     |         bentoBox.withdraw(IERC20(address(token)), address(this), address(this), 0, shareFrom);
 40 |     | 
 41 |     |         // token -> MIM
 42 |     |         (bool success, ) = zeroXExchangeProxy.call(swapData);
 43 |     |         if (!success) {
 44 |     |             revert ErrSwapFailed();
 45 |     |         }
 46 |     | 
 47 |     |         // Refund remaining balance to the recipient
 48 |     |         uint256 balance = token.balanceOf(address(this));
 49 |     |         if (balance > 0) {
 50 |     |             token.safeTransfer(recipient, balance);
 51 |     |         }
 52 |     | 
 53 |     |         (, shareReturned) = bentoBox.deposit(mim, address(this), recipient, mim.balanceOf(address(this)), 0);
 54 |     |         extraShare = shareReturned - shareToMin;
 55 |     |     }
 56 |     | }
 57 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/UniswapLikeLPLevSwapper.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // solhint-disable avoid-low-level-calls
   3 |     | pragma solidity >=0.8.0;
   4 |     | 
   5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
   7 |     | import {IUniswapV2Pair, IUniswapV2Router01} from "interfaces/IUniswapV2.sol";
   8 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
   9 |     | import {ILevSwapperV2} from "interfaces/ILevSwapperV2.sol";
  10 |     | import {UniswapV2OneSided} from "libraries/UniswapV2Lib.sol";
  11 |     | 
  12 |     | /// @notice Generic LP leverage swapper for Uniswap like compatible DEX using Matcha/0x aggregator
  13 |     | contract UniswapLikeLPLevSwapper is ILevSwapperV2 {
  14 |     |     using BoringERC20 for IERC20;
  15 |     | 
  16 |     |     error ErrToken0SwapFailed();
  17 |     |     error ErrToken1SwapFailed();
  18 |     | 
  19 |     |     IBentoBoxV1 public immutable bentoBox;
  20 |     |     IUniswapV2Pair public immutable pair;
  21 |     |     IUniswapV2Router01 public immutable router;
  22 |     |     IERC20 public immutable mim;
  23 |     |     IERC20 public immutable token0;
  24 |     |     IERC20 public immutable token1;
  25 |     | 
  26 |     |     address public immutable zeroXExchangeProxy;
  27 |     | 
  28 |     |     constructor(IBentoBoxV1 _bentoBox, IUniswapV2Router01 _router, IUniswapV2Pair _pair, IERC20 _mim, address _zeroXExchangeProxy) {
  29 |     |         bentoBox = _bentoBox;
  30 |     |         router = _router;
  31 |     |         pair = _pair;
  32 |     |         mim = _mim;
  33 |     |         zeroXExchangeProxy = _zeroXExchangeProxy;
  34 |     | 
  35 |     |         IERC20 _token0 = IERC20(_pair.token0());
  36 |     |         IERC20 _token1 = IERC20(_pair.token1());
  37 |     |         token0 = _token0;
  38 |     |         token1 = _token1;
  39 |     | 
  40 |     |         _token0.approve(address(_router), type(uint256).max);
  41 |     |         _token1.approve(address(_router), type(uint256).max);
  42 |     |         _mim.approve(_zeroXExchangeProxy, type(uint256).max);
  43 |     |     }
  44 |     | 
  45 |     |     /// @inheritdoc ILevSwapperV2
  46 |     |     function swap(
  47 |     |         address recipient,
  48 |     |         uint256 shareToMin,
  49 |     |         uint256 shareFrom,
  50 |     |         bytes calldata data
  51 |     |     ) external override returns (uint256 extraShare, uint256 shareReturned) {
  52 |     |         // 0: MIM -> token0
  53 |     |         // 1: MIM -> token1
  54 |     |         (bytes[] memory swapData, uint256 minOneSideableAmount0, uint256 minOneSideableAmount1) = abi.decode(
  55 |     |             data,
  56 |     |             (bytes[], uint256, uint256)
  57 |     |         );
  58 |     | 
  59 |     |         bentoBox.withdraw(mim, address(this), address(this), 0, shareFrom);
  60 |     | 
  61 |     |         // MIM -> token0
  62 |     |         (bool success, ) = zeroXExchangeProxy.call(swapData[0]);
  63 |     |         if (!success) {
  64 |     |             revert ErrToken0SwapFailed();
  65 |     |         }
  66 |     | 
  67 |     |         // MIM -> token1
  68 |     |         (success, ) = zeroXExchangeProxy.call(swapData[1]);
  69 |     |         if (!success) {
  70 |     |             revert ErrToken1SwapFailed();
  71 |     |         }
  72 |     | 
  73 |     |         uint256 liquidity;
  74 |     | 
  75 |     |         {
  76 |     |             (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();
  77 |     | 
  78 |     |             UniswapV2OneSided.AddLiquidityAndOneSideRemainingParams memory params = UniswapV2OneSided.AddLiquidityAndOneSideRemainingParams(
  79 |     |                 router,
  80 |     |                 pair,
  81 |     |                 address(token0),
  82 |     |                 address(token1),
  83 |     |                 reserve0,
  84 |     |                 reserve1,
  85 |     |                 token0.balanceOf(address(this)),
  86 |     |                 token1.balanceOf(address(this)),
  87 |     |                 minOneSideableAmount0,
  88 |     |                 minOneSideableAmount1,
  89 |     |                 address(bentoBox)
  90 |     |             );
  91 |     | 
  92 |     |             (, , liquidity) = UniswapV2OneSided.addLiquidityAndOneSideRemaining(params);
  93 |     |         }
  94 |     | 
  95 |     |         (, shareReturned) = bentoBox.deposit(IERC20(address(pair)), address(bentoBox), recipient, liquidity, 0);
  96 |     |         extraShare = shareReturned - shareToMin;
  97 |     |     }
  98 |     | }
  99 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/UniswapLikeLPSwapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // solhint-disable avoid-low-level-calls
  3 |     | pragma solidity >=0.8.0;
  4 |     | 
  5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
  7 |     | import {IUniswapV2Pair} from "interfaces/IUniswapV2.sol";
  8 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  9 |     | import {ISwapperV2} from "interfaces/ISwapperV2.sol";
 10 |     | 
 11 |     | /// @notice Generic LP liquidation/deleverage swapper for Uniswap like compatible DEX using Matcha/0x aggregator
 12 |     | contract UniswapLikeLPSwapper is ISwapperV2 {
 13 |     |     using BoringERC20 for IERC20;
 14 |     | 
 15 |     |     error ErrToken0SwapFailed();
 16 |     |     error ErrToken1SwapFailed();
 17 |     | 
 18 |     |     IBentoBoxV1 public immutable bentoBox;
 19 |     |     IUniswapV2Pair public immutable pair;
 20 |     |     IERC20 public immutable mim;
 21 |     | 
 22 |     |     address public immutable zeroXExchangeProxy;
 23 |     | 
 24 |     |     constructor(IBentoBoxV1 _bentoBox, IUniswapV2Pair _pair, IERC20 _mim, address _zeroXExchangeProxy) {
 25 |     |         bentoBox = _bentoBox;
 26 |     |         pair = _pair;
 27 |     |         mim = _mim;
 28 |     |         zeroXExchangeProxy = _zeroXExchangeProxy;
 29 |     | 
 30 |     |         IERC20(pair.token0()).approve(_zeroXExchangeProxy, type(uint256).max);
 31 |     |         IERC20(pair.token1()).approve(_zeroXExchangeProxy, type(uint256).max);
 32 |     | 
 33 |     |         mim.approve(address(_bentoBox), type(uint256).max);
 34 |     |     }
 35 |     | 
 36 |     |     /// @inheritdoc ISwapperV2
 37 |     |     function swap(
 38 |     |         address,
 39 |     |         address,
 40 |     |         address recipient,
 41 |     |         uint256 shareToMin,
 42 |     |         uint256 shareFrom,
 43 |     |         bytes calldata data
 44 |     |     ) public override returns (uint256 extraShare, uint256 shareReturned) {
 45 |     |         // 0: token0 -> MIM
 46 |     |         // 1: token1 -> MIM
 47 |     |         bytes[] memory swapData = abi.decode(data, (bytes[]));
 48 |     | 
 49 |     |         (uint256 amountFrom, ) = bentoBox.withdraw(IERC20(address(pair)), address(this), address(this), 0, shareFrom);
 50 |     | 
 51 |     |         pair.transfer(address(pair), amountFrom);
 52 |     |         pair.burn(address(this));
 53 |     | 
 54 |     |         // token0 -> MIM
 55 |     |         (bool success, ) = zeroXExchangeProxy.call(swapData[0]);
 56 |     |         if (!success) {
 57 |     |             revert ErrToken0SwapFailed();
 58 |     |         }
 59 |     | 
 60 |     |         // token1 -> MIM
 61 |     |         (success, ) = zeroXExchangeProxy.call(swapData[1]);
 62 |     |         if (!success) {
 63 |     |             revert ErrToken1SwapFailed();
 64 |     |         }
 65 |     | 
 66 |     |         (, shareReturned) = bentoBox.deposit(mim, address(this), recipient, mim.balanceOf(address(this)), 0);
 67 |     |         extraShare = shareReturned - shareToMin;
 68 |     |     }
 69 |     | }
 70 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/YearnCurveLevSwapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // solhint-disable avoid-low-level-calls
  3 |     | pragma solidity >=0.8.0;
  4 |     | 
  5 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
  6 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  7 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  8 |     | import {CurveLevSwapper} from "swappers/CurveLevSwapper.sol";
  9 |     | import {IYearnVault} from "interfaces/IYearnVault.sol";
 10 |     | import {ICurvePool, CurvePoolInterfaceType} from "interfaces/ICurvePool.sol";
 11 |     | 
 12 |     | contract YearnCurveLevSwapper is CurveLevSwapper {
 13 |     |     using SafeTransferLib for address;
 14 |     | 
 15 |     |     IYearnVault public immutable wrapper;
 16 |     | 
 17 |     |     constructor(
 18 |     |         IBentoBoxV1 _bentoBox,
 19 |     |         IYearnVault _wrapper,
 20 |     |         address _mim,
 21 |     |         CurvePoolInterfaceType _curvePoolInterfaceType,
 22 |     |         address _curvePool,
 23 |     |         address _curvePoolDepositor /* Optional Curve Deposit Zapper */,
 24 |     |         address[] memory _poolTokens,
 25 |     |         address _zeroXExchangeProxy
 26 |     |     )
 27 |     |         CurveLevSwapper(
 28 |     |             _bentoBox,
 29 |     |             _wrapper.token(),
 30 |     |             _mim,
 31 |     |             _curvePoolInterfaceType,
 32 |     |             _curvePool,
 33 |     |             _curvePoolDepositor,
 34 |     |             _poolTokens,
 35 |     |             _zeroXExchangeProxy
 36 |     |         )
 37 |     |     {
 38 |     |         wrapper = _wrapper;
 39 |     |         curveToken.safeApprove(address(_wrapper), type(uint256).max);
 40 |     |     }
 41 |     | 
 42 |     |     function depositInBentoBox(uint256 amount, address recipient) internal override returns (uint256 shareReturned) {
 43 |     |         // CurveLP -> Yearn Vault
 44 |     |         amount = wrapper.deposit(amount, address(bentoBox));
 45 |     | 
 46 |     |         (, shareReturned) = bentoBox.deposit(IERC20(address(wrapper)), address(bentoBox), recipient, amount, 0);
 47 |     |     }
 48 |     | }
 49 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/swappers/YearnCurveSwapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // solhint-disable avoid-low-level-calls
  3 |     | pragma solidity >=0.8.0;
  4 |     | 
  5 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
  6 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  7 |     | import {CurveSwapper} from "swappers/CurveSwapper.sol";
  8 |     | import {IBentoBoxV1} from "interfaces/IBentoBoxV1.sol";
  9 |     | import {IYearnVault} from "interfaces/IYearnVault.sol";
 10 |     | import {CurvePoolInterfaceType} from "interfaces/ICurvePool.sol";
 11 |     | 
 12 |     | contract YearnCurveSwapper is CurveSwapper {
 13 |     |     using SafeTransferLib for address;
 14 |     | 
 15 |     |     IYearnVault public immutable wrapper;
 16 |     | 
 17 |     |     constructor(
 18 |     |         IBentoBoxV1 _bentoBox,
 19 |     |         IYearnVault _wrapper,
 20 |     |         address _mim,
 21 |     |         CurvePoolInterfaceType _curvePoolInterfaceType,
 22 |     |         address _curvePool,
 23 |     |         address _curvePoolDepositor /* Optional Curve Deposit Zapper */,
 24 |     |         address[] memory _poolTokens,
 25 |     |         address _zeroXExchangeProxy
 26 |     |     )
 27 |     |         CurveSwapper(
 28 |     |             _bentoBox,
 29 |     |             _wrapper.token(),
 30 |     |             _mim,
 31 |     |             _curvePoolInterfaceType,
 32 |     |             _curvePool,
 33 |     |             _curvePoolDepositor,
 34 |     |             _poolTokens,
 35 |     |             _zeroXExchangeProxy
 36 |     |         )
 37 |     |     {
 38 |     |         wrapper = _wrapper;
 39 |     |         if (_curvePoolDepositor != address(0)) {
 40 |     |             address curveToken = wrapper.token();
 41 |     |             curveToken.safeApprove(_curvePoolDepositor, type(uint256).max);
 42 |     |         }
 43 |     |     }
 44 |     | 
 45 |     |     function withdrawFromBentoBox(uint256 shareFrom) internal override returns (uint256 amount) {
 46 |     |         (amount, ) = bentoBox.withdraw(IERC20(address(wrapper)), address(this), address(this), 0, shareFrom);
 47 |     | 
 48 |     |         // Yearn Vault -> CurveLP token
 49 |     |         amount = wrapper.withdraw();
 50 |     |     }
 51 |     | }
 52 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/tokens/ERC4626.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   5 |     | import {ERC20, ERC20WithSupply} from "BoringSolidity/ERC20.sol";
   6 |     | import {BoringERC20} from "BoringSolidity/libraries/BoringERC20.sol";
   7 |     | import {FixedPointMathLib} from "solmate/utils/FixedPointMathLib.sol";
   8 |     | import {IERC4626} from "interfaces/IERC4626.sol";
   9 |     | 
  10 |     | /// @notice Adapted from Solmate ERC4626
  11 |     | /// @notice Minimal ERC4626 tokenized Vault implementation.
  12 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)
  13 |     | contract ERC4626 is IERC4626, ERC20WithSupply {
  14 |     |     using BoringERC20 for ERC20;
  15 |     |     using FixedPointMathLib for uint256;
  16 |     | 
  17 |     |     error ErrZeroAssets();
  18 |     |     error ErrZeroShares();
  19 |     | 
  20 |     |     string public name;
  21 |     |     string public symbol;
  22 |     |     ERC20 public _asset;
  23 |     |     uint256 internal _totalAssets;
  24 |     | 
  25 |     |     function asset() external view returns (IERC20) {
  26 |     |         return _asset;
  27 |     |     }
  28 |     | 
  29 |     |     function decimals() external view returns (uint8) {
  30 |     |         return _asset.safeDecimals();
  31 |     |     }
  32 |     | 
  33 |     |     function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {
  34 |     |         // Check for rounding error since we round down in previewDeposit.
  35 |     |         if ((shares = previewDeposit(assets)) == 0) {
  36 |     |             revert ErrZeroShares();
  37 |     |         }
  38 |     | 
  39 |     |         // Need to transfer before minting or ERC777s could reenter.
  40 |     |         _asset.safeTransferFrom(msg.sender, address(this), assets);
  41 |     | 
  42 |     |         unchecked {
  43 |     |             _totalAssets += assets;
  44 |     |         }
  45 |     | 
  46 |     |         _mint(receiver, shares);
  47 |     |         emit Deposit(msg.sender, receiver, assets, shares);
  48 |     | 
  49 |     |         _afterDeposit(assets, shares);
  50 |     |     }
  51 |     | 
  52 |     |     function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {
  53 |     |         assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.
  54 |     | 
  55 |     |         // Need to transfer before minting or ERC777s could reenter.
  56 |     |         _asset.safeTransferFrom(msg.sender, address(this), assets);
  57 |     | 
  58 |     |         unchecked {
  59 |     |             _totalAssets += assets;
  60 |     |         }
  61 |     | 
  62 |     |         _mint(receiver, shares);
  63 |     |         emit Deposit(msg.sender, receiver, assets, shares);
  64 |     | 
  65 |     |         _afterDeposit(assets, shares);
  66 |     |     }
  67 |     | 
  68 |     |     function withdraw(
  69 |     |         uint256 assets,
  70 |     |         address receiver,
  71 |     |         address owner
  72 |     |     ) public virtual returns (uint256 shares) {
  73 |     |         shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.
  74 |     | 
  75 |     |         if (msg.sender != owner) {
  76 |     |             uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.
  77 |     | 
  78 |     |             if (allowed != type(uint256).max) {
  79 |     |                 allowance[owner][msg.sender] = allowed - shares;
  80 |     |             }
  81 |     |         }
  82 |     | 
  83 |     |         _beforeWithdraw(assets, shares);
  84 |     |         _burn(owner, shares);
  85 |     |         emit Withdraw(msg.sender, receiver, owner, assets, shares);
  86 |     |         _asset.safeTransfer(receiver, assets);
  87 |     | 
  88 |     |         unchecked {
  89 |     |             _totalAssets -= assets;
  90 |     |         }
  91 |     |     }
  92 |     | 
  93 |     |     function redeem(
  94 |     |         uint256 shares,
  95 |     |         address receiver,
  96 |     |         address owner
  97 |     |     ) public virtual returns (uint256 assets) {
  98 |     |         if (msg.sender != owner) {
  99 |     |             uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.
 100 |     |             if (allowed != type(uint256).max) {
 101 |     |                 allowance[owner][msg.sender] = allowed - shares;
 102 |     |             }
 103 |     |         }
 104 |     | 
 105 |     |         // Check for rounding error since we round down in previewRedeem.
 106 |     |         if ((assets = previewRedeem(shares)) == 0) {
 107 |     |             revert ErrZeroAssets();
 108 |     |         }
 109 |     | 
 110 |     |         _beforeWithdraw(assets, shares);
 111 |     |         _burn(owner, shares);
 112 |     |         emit Withdraw(msg.sender, receiver, owner, assets, shares);
 113 |     |         _asset.safeTransfer(receiver, assets);
 114 |     | 
 115 |     |         unchecked {
 116 |     |             _totalAssets -= assets;
 117 |     |         }
 118 |     |     }
 119 |     | 
 120 |     |     function totalAssets() public view virtual returns (uint256) {
 121 |     |         return _totalAssets;
 122 |     |     }
 123 |     | 
 124 |     |     function convertToShares(uint256 assets) public view virtual returns (uint256) {
 125 |     |         uint256 supply = totalSupply;
 126 |     |         return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());
 127 |     |     }
 128 |     | 
 129 |     |     function convertToAssets(uint256 shares) public view virtual returns (uint256) {
 130 |     |         uint256 supply = totalSupply;
 131 |     |         return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);
 132 |     |     }
 133 |     | 
 134 |     |     function previewDeposit(uint256 assets) public view virtual returns (uint256) {
 135 |     |         return convertToShares(assets);
 136 |     |     }
 137 |     | 
 138 |     |     function previewMint(uint256 shares) public view virtual returns (uint256) {
 139 |     |         uint256 supply = totalSupply;
 140 |     |         return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);
 141 |     |     }
 142 |     | 
 143 |     |     function previewWithdraw(uint256 assets) public view virtual returns (uint256) {
 144 |     |         uint256 supply = totalSupply;
 145 |     |         return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());
 146 |     |     }
 147 |     | 
 148 |     |     function previewRedeem(uint256 shares) public view virtual returns (uint256) {
 149 |     |         return convertToAssets(shares);
 150 |     |     }
 151 |     | 
 152 |     |     function maxDeposit(address) public view virtual returns (uint256) {
 153 |     |         return type(uint256).max;
 154 |     |     }
 155 |     | 
 156 |     |     function maxMint(address) public view virtual returns (uint256) {
 157 |     |         return type(uint256).max;
 158 |     |     }
 159 |     | 
 160 |     |     function maxWithdraw(address owner) public view virtual returns (uint256) {
 161 |     |         return convertToAssets(balanceOf[owner]);
 162 |     |     }
 163 |     | 
 164 |     |     function maxRedeem(address owner) public view virtual returns (uint256) {
 165 |     |         return balanceOf[owner];
 166 |     |     }
 167 |     | 
 168 |     |     function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}
 169 |     | 
 170 |     |     function _afterDeposit(uint256 assets, uint256 shares) internal virtual {}
 171 |     | }
 172 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/tokens/LzBaseOFTV2.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import {IERC165} from "openzeppelin-contracts/utils/introspection/IERC165.sol";
   6 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
   7 |     | import {ILzOFTV2, ILzFeeHandler} from "interfaces/ILayerZero.sol";
   8 |     | import {LzOFTCoreV2} from "tokens/LzOFTCoreV2.sol";
   9 |     | import {ERC165} from "openzeppelin-contracts/utils/introspection/ERC165.sol";
  10 |     | import {SafeERC20} from "openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol";
  11 |     | import {ReentrancyGuard} from "solmate/utils/ReentrancyGuard.sol";
  12 |     | 
  13 |     | abstract contract LzBaseOFTV2 is LzOFTCoreV2, ERC165, ReentrancyGuard, ILzOFTV2 {
  14 |     |     using SafeERC20 for IERC20;
  15 |     | 
  16 |     |     error ErrFeeCollectingFailed();
  17 |     | 
  18 |     |     event LogFeeHandlerChanged(ILzFeeHandler previous, ILzFeeHandler current);
  19 |     | 
  20 |     |     ILzFeeHandler public feeHandler;
  21 |     | 
  22 |     |     constructor(uint8 _sharedDecimals, address _lzEndpoint, address _owner) LzOFTCoreV2(_sharedDecimals, _lzEndpoint, _owner) {}
  23 |     | 
  24 |     |     /************************************************************************
  25 |     |      * public functions
  26 |     |      ************************************************************************/
  27 |     |     function sendFrom(
  28 |     |         address _from,
  29 |     |         uint16 _dstChainId,
  30 |     |         bytes32 _toAddress,
  31 |     |         uint _amount,
  32 |     |         LzCallParams calldata _callParams
  33 |     |     ) public payable virtual override nonReentrant {
  34 |     |         uint _valueAfterFees = _handleFees();
  35 |     | 
  36 |     |         _send(
  37 |     |             _from,
  38 |     |             _dstChainId,
  39 |     |             _toAddress,
  40 |     |             _amount,
  41 |     |             _callParams.refundAddress,
  42 |     |             _callParams.zroPaymentAddress,
  43 |     |             _callParams.adapterParams,
  44 |     |             _valueAfterFees
  45 |     |         );
  46 |     |     }
  47 |     | 
  48 |     |     function sendAndCall(
  49 |     |         address _from,
  50 |     |         uint16 _dstChainId,
  51 |     |         bytes32 _toAddress,
  52 |     |         uint _amount,
  53 |     |         bytes calldata _payload,
  54 |     |         uint64 _dstGasForCall,
  55 |     |         LzCallParams calldata _callParams
  56 |     |     ) public payable virtual override nonReentrant {
  57 |     |         uint _valueAfterFees = _handleFees();
  58 |     | 
  59 |     |         _sendAndCall(
  60 |     |             _from,
  61 |     |             _dstChainId,
  62 |     |             _toAddress,
  63 |     |             _amount,
  64 |     |             _payload,
  65 |     |             _dstGasForCall,
  66 |     |             _callParams.refundAddress,
  67 |     |             _callParams.zroPaymentAddress,
  68 |     |             _callParams.adapterParams,
  69 |     |             _valueAfterFees
  70 |     |         );
  71 |     |     }
  72 |     | 
  73 |     |     function _handleFees() internal returns (uint256 adjustedValue) {
  74 |     |         adjustedValue = msg.value;
  75 |     | 
  76 |     |         if (address(feeHandler) != address(0)) {
  77 |     |             uint256 fee = feeHandler.getFee();
  78 |     | 
  79 |     |             // let it revert when the value is not enough to cover the fees
  80 |     |             adjustedValue -= fee;
  81 |     | 
  82 |     |             // collect the native fee, calling the `receive` function on the fee handler
  83 |     |             (bool success, ) = address(feeHandler).call{value: fee}("");
  84 |     |             if (!success) {
  85 |     |                 revert ErrFeeCollectingFailed();
  86 |     |             }
  87 |     |         }
  88 |     |     }
  89 |     | 
  90 |     |     /************************************************************************
  91 |     |      * public view functions
  92 |     |      ************************************************************************/
  93 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
  94 |     |         return interfaceId == type(ILzOFTV2).interfaceId || super.supportsInterface(interfaceId);
  95 |     |     }
  96 |     | 
  97 |     |     function estimateSendFee(
  98 |     |         uint16 _dstChainId,
  99 |     |         bytes32 _toAddress,
 100 |     |         uint _amount,
 101 |     |         bool _useZro,
 102 |     |         bytes calldata _adapterParams
 103 |     |     ) public view virtual override returns (uint nativeFee, uint zroFee) {
 104 |     |         (nativeFee, zroFee) = _estimateSendFee(_dstChainId, _toAddress, _amount, _useZro, _adapterParams);
 105 |     |         if (address(feeHandler) != address(0)) {
 106 |     |             nativeFee += feeHandler.getFee();
 107 |     |         }
 108 |     |     }
 109 |     | 
 110 |     |     function estimateSendAndCallFee(
 111 |     |         uint16 _dstChainId,
 112 |     |         bytes32 _toAddress,
 113 |     |         uint _amount,
 114 |     |         bytes calldata _payload,
 115 |     |         uint64 _dstGasForCall,
 116 |     |         bool _useZro,
 117 |     |         bytes calldata _adapterParams
 118 |     |     ) public view virtual override returns (uint nativeFee, uint zroFee) {
 119 |     |         (nativeFee, zroFee) = _estimateSendAndCallFee(_dstChainId, _toAddress, _amount, _dstGasForCall, _payload, _useZro, _adapterParams);
 120 |     |         if (address(feeHandler) != address(0)) {
 121 |     |             nativeFee += feeHandler.getFee();
 122 |     |         }
 123 |     |     }
 124 |     | 
 125 |     |     function circulatingSupply() public view virtual override returns (uint);
 126 |     | 
 127 |     |     function token() public view virtual override returns (address);
 128 |     | 
 129 |     |     function setFeeHandler(ILzFeeHandler _feeHandler) public virtual onlyOwner {
 130 |     |         emit LogFeeHandlerChanged(feeHandler, _feeHandler);
 131 |     |         feeHandler = _feeHandler;
 132 |     |     }
 133 |     | }
 134 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/tokens/LzIndirectOFTV2.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import {IERC20} from "BoringSolidity/interfaces/IERC20.sol";
  6 |     | import {IMintableBurnable} from "interfaces/IMintableBurnable.sol";
  7 |     | import {LzBaseOFTV2} from "tokens/LzBaseOFTV2.sol";
  8 |     | import {SafeERC20} from "openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol";
  9 |     | 
 10 |     | contract LzIndirectOFTV2 is LzBaseOFTV2 {
 11 |     |     using SafeERC20 for IERC20;
 12 |     |     IMintableBurnable public immutable minterBurner;
 13 |     |     IERC20 public immutable innerToken;
 14 |     |     uint public immutable ld2sdRate;
 15 |     | 
 16 |     |     constructor(
 17 |     |         address _token,
 18 |     |         IMintableBurnable _minterBurner,
 19 |     |         uint8 _sharedDecimals,
 20 |     |         address _lzEndpoint,
 21 |     |         address _owner
 22 |     |     ) LzBaseOFTV2(_sharedDecimals, _lzEndpoint, _owner) {
 23 |     |         innerToken = IERC20(_token);
 24 |     |         minterBurner = _minterBurner;
 25 |     | 
 26 |     |         (bool success, bytes memory data) = _token.staticcall(abi.encodeWithSignature("decimals()"));
 27 |     |         require(success, "IndirectOFT: failed to get token decimals");
 28 |     |         uint8 decimals = abi.decode(data, (uint8));
 29 |     | 
 30 |     |         require(_sharedDecimals <= decimals, "IndirectOFT: sharedDecimals must be <= decimals");
 31 |     |         ld2sdRate = 10 ** (decimals - _sharedDecimals);
 32 |     |     }
 33 |     | 
 34 |     |     /************************************************************************
 35 |     |      * public functions
 36 |     |      ************************************************************************/
 37 |     |     function circulatingSupply() public view virtual override returns (uint) {
 38 |     |         return innerToken.totalSupply();
 39 |     |     }
 40 |     | 
 41 |     |     function token() public view virtual override returns (address) {
 42 |     |         return address(innerToken);
 43 |     |     }
 44 |     | 
 45 |     |     /************************************************************************
 46 |     |      * internal functions
 47 |     |      ************************************************************************/
 48 |     |     function _debitFrom(address _from, uint16, bytes32, uint _amount) internal virtual override returns (uint) {
 49 |     |         require(_from == msg.sender, "IndirectOFT: owner is not send caller");
 50 |     | 
 51 |     |         minterBurner.burn(_from, _amount);
 52 |     | 
 53 |     |         return _amount;
 54 |     |     }
 55 |     | 
 56 |     |     function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns (uint) {
 57 |     |         minterBurner.mint(_toAddress, _amount);
 58 |     | 
 59 |     |         return _amount;
 60 |     |     }
 61 |     | 
 62 |     |     function _ld2sdRate() internal view virtual override returns (uint) {
 63 |     |         return ld2sdRate;
 64 |     |     }
 65 |     | }
 66 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/tokens/LzOFTCoreV2.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {LzNonblockingApp} from "mixins/LzNonblockingApp.sol";
   5 |     | import {ExcessivelySafeCall} from "ExcessivelySafeCall/ExcessivelySafeCall.sol";
   6 |     | import {ILzCommonOFT, ILzOFTReceiverV2} from "interfaces/ILayerZero.sol";
   7 |     | import {BytesLib} from "libraries/BytesLib.sol";
   8 |     | 
   9 |     | abstract contract LzOFTCoreV2 is LzNonblockingApp {
  10 |     |     using BytesLib for bytes;
  11 |     |     using ExcessivelySafeCall for address;
  12 |     | 
  13 |     |     uint public constant NO_EXTRA_GAS = 0;
  14 |     | 
  15 |     |     // packet type
  16 |     |     uint8 public constant PT_SEND = 0;
  17 |     |     uint8 public constant PT_SEND_AND_CALL = 1;
  18 |     | 
  19 |     |     uint8 public immutable sharedDecimals;
  20 |     | 
  21 |     |     bool public useCustomAdapterParams;
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev Emitted when `_amount` tokens are moved from the `_sender` to (`_dstChainId`, `_toAddress`)
  25 |     |      * `_nonce` is the outbound nonce
  26 |     |      */
  27 |     |     event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes32 indexed _toAddress, uint _amount);
  28 |     | 
  29 |     |     /**
  30 |     |      * @dev Emitted when `_amount` tokens are received from `_srcChainId` into the `_toAddress` on the local chain.
  31 |     |      * `_nonce` is the inbound nonce.
  32 |     |      */
  33 |     |     event ReceiveFromChain(uint16 indexed _srcChainId, address indexed _to, uint _amount);
  34 |     | 
  35 |     |     event SetUseCustomAdapterParams(bool _useCustomAdapterParams);
  36 |     | 
  37 |     |     event CallOFTReceivedSuccess(uint16 indexed _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _hash);
  38 |     | 
  39 |     |     event NonContractAddress(address _address);
  40 |     | 
  41 |     |     // _sharedDecimals should be the minimum decimals on all chains
  42 |     |     constructor(uint8 _sharedDecimals, address _lzEndpoint, address _owner) LzNonblockingApp(_lzEndpoint, _owner) {
  43 |     |         sharedDecimals = _sharedDecimals;
  44 |     |     }
  45 |     | 
  46 |     |     function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {
  47 |     |         useCustomAdapterParams = _useCustomAdapterParams;
  48 |     |         emit SetUseCustomAdapterParams(_useCustomAdapterParams);
  49 |     |     }
  50 |     | 
  51 |     |     /************************************************************************
  52 |     |      * internal functions
  53 |     |      ************************************************************************/
  54 |     |     function _estimateSendFee(
  55 |     |         uint16 _dstChainId,
  56 |     |         bytes32 _toAddress,
  57 |     |         uint _amount,
  58 |     |         bool _useZro,
  59 |     |         bytes memory _adapterParams
  60 |     |     ) internal view virtual returns (uint nativeFee, uint zroFee) {
  61 |     |         // mock the payload for sendFrom()
  62 |     |         bytes memory payload = _encodeSendPayload(_toAddress, _ld2sd(_amount));
  63 |     |         return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);
  64 |     |     }
  65 |     | 
  66 |     |     function _estimateSendAndCallFee(
  67 |     |         uint16 _dstChainId,
  68 |     |         bytes32 _toAddress,
  69 |     |         uint _amount,
  70 |     |         uint64 _dstGasForCall,
  71 |     |         bytes memory _payload,
  72 |     |         bool _useZro,
  73 |     |         bytes memory _adapterParams
  74 |     |     ) internal view virtual returns (uint nativeFee, uint zroFee) {
  75 |     |         // mock the payload for sendAndCall()
  76 |     |         bytes memory payload = _encodeSendAndCallPayload(msg.sender, _toAddress, _ld2sd(_amount), _payload, _dstGasForCall);
  77 |     |         return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);
  78 |     |     }
  79 |     | 
  80 |     |     function _nonblockingLzReceive(
  81 |     |         uint16 _srcChainId,
  82 |     |         bytes memory _srcAddress,
  83 |     |         uint64 _nonce,
  84 |     |         bytes memory _payload,
  85 |     |         bool retry
  86 |     |     ) internal virtual override {
  87 |     |         uint8 packetType = _payload.toUint8(0);
  88 |     | 
  89 |     |         if (packetType == PT_SEND) {
  90 |     |             _sendAck(_srcChainId, _srcAddress, _nonce, _payload);
  91 |     |         } else if (packetType == PT_SEND_AND_CALL) {
  92 |     |             _sendAndCallAck(_srcChainId, _srcAddress, _nonce, _payload, retry);
  93 |     |         } else {
  94 |     |             revert("OFTCore: unknown packet type");
  95 |     |         }
  96 |     |     }
  97 |     | 
  98 |     |     function _send(
  99 |     |         address _from,
 100 |     |         uint16 _dstChainId,
 101 |     |         bytes32 _toAddress,
 102 |     |         uint _amount,
 103 |     |         address payable _refundAddress,
 104 |     |         address _zroPaymentAddress,
 105 |     |         bytes memory _adapterParams,
 106 |     |         uint256 value
 107 |     |     ) internal virtual returns (uint amount) {
 108 |     |         _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, 0);
 109 |     | 
 110 |     |         (amount, ) = _removeDust(_amount);
 111 |     |         amount = _debitFrom(_from, _dstChainId, _toAddress, amount); // amount returned should not have dust
 112 |     | 
 113 |     |         bytes memory lzPayload = _encodeSendPayload(_toAddress, _ld2sd(amount));
 114 |     |         _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, value);
 115 |     | 
 116 |     |         emit SendToChain(_dstChainId, _from, _toAddress, amount);
 117 |     |     }
 118 |     | 
 119 |     |     function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {
 120 |     |         (address to, uint64 amountSD) = _decodeSendPayload(_payload);
 121 |     |         if (to == address(0)) {
 122 |     |             to = address(0xdead);
 123 |     |         }
 124 |     | 
 125 |     |         uint amount = _sd2ld(amountSD);
 126 |     |         amount = _creditTo(_srcChainId, to, amount);
 127 |     | 
 128 |     |         emit ReceiveFromChain(_srcChainId, to, amount);
 129 |     |     }
 130 |     | 
 131 |     |     function _sendAndCall(
 132 |     |         address _from,
 133 |     |         uint16 _dstChainId,
 134 |     |         bytes32 _toAddress,
 135 |     |         uint _amount,
 136 |     |         bytes memory _payload,
 137 |     |         uint64 _dstGasForCall,
 138 |     |         address payable _refundAddress,
 139 |     |         address _zroPaymentAddress,
 140 |     |         bytes memory _adapterParams,
 141 |     |         uint256 value
 142 |     |     ) internal virtual returns (uint amount) {
 143 |     |         _checkAdapterParams(_dstChainId, PT_SEND_AND_CALL, _adapterParams, _dstGasForCall);
 144 |     | 
 145 |     |         (amount, ) = _removeDust(_amount);
 146 |     |         amount = _debitFrom(_from, _dstChainId, _toAddress, amount);
 147 |     | 
 148 |     |         // encode the msg.sender into the payload instead of _from
 149 |     |         bytes memory lzPayload = _encodeSendAndCallPayload(msg.sender, _toAddress, _ld2sd(amount), _payload, _dstGasForCall);
 150 |     |         _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, value);
 151 |     | 
 152 |     |         emit SendToChain(_dstChainId, _from, _toAddress, amount);
 153 |     |     }
 154 |     | 
 155 |     |     function _sendAndCallAck(
 156 |     |         uint16 _srcChainId,
 157 |     |         bytes memory _srcAddress,
 158 |     |         uint64 _nonce,
 159 |     |         bytes memory _payload,
 160 |     |         bool retry
 161 |     |     ) internal virtual {
 162 |     |         bytes32 from;
 163 |     |         address to;
 164 |     |         uint amount;
 165 |     |         uint gas;
 166 |     |         bytes memory payloadForCall;
 167 |     | 
 168 |     |         {
 169 |     |             uint64 amountSD;
 170 |     |             uint64 gasForCall;
 171 |     |             (from, to, amountSD, payloadForCall, gasForCall) = _decodeSendAndCallPayload(_payload);
 172 |     | 
 173 |     |             amount = _sd2ld(amountSD);
 174 |     | 
 175 |     |             // send
 176 |     |             amount = _creditTo(_srcChainId, to, amount);
 177 |     |             emit ReceiveFromChain(_srcChainId, to, amount);
 178 |     | 
 179 |     |             gas = retry ? gasleft() : gasForCall;
 180 |     |         }
 181 |     | 
 182 |     |         // call, using low level call to not revert on EOA
 183 |     |         (bool success, bytes memory result) = address(to).excessivelySafeCall(
 184 |     |             gas,
 185 |     |             150,
 186 |     |             abi.encodeWithSelector(ILzOFTReceiverV2.onOFTReceived.selector, _srcChainId, _srcAddress, _nonce, from, amount, payloadForCall)
 187 |     |         );
 188 |     | 
 189 |     |         if (success) {
 190 |     |             bytes32 hash = keccak256(_payload);
 191 |     |             emit CallOFTReceivedSuccess(_srcChainId, _srcAddress, _nonce, hash);
 192 |     |         } else {
 193 |     |             if (!success) {
 194 |     |                 // If call reverts
 195 |     |                 // If there is return data, the call reverted without a reason or a custom error.
 196 |     |                 if (result.length == 0) revert("OFTCore: call reverted without a reason");
 197 |     |                 assembly {
 198 |     |                     // We use Yul's revert() to bubble up errors from the target contract.
 199 |     |                     revert(add(32, result), mload(result))
 200 |     |                 }
 201 |     |             }
 202 |     |         }
 203 |     |     }
 204 |     | 
 205 |     |     function _isContract(address _account) internal view returns (bool) {
 206 |     |         return _account.code.length > 0;
 207 |     |     }
 208 |     | 
 209 |     |     function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {
 210 |     |         if (useCustomAdapterParams) {
 211 |     |             _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);
 212 |     |         } else {
 213 |     |             require(_adapterParams.length == 0, "OFTCore: _adapterParams must be empty.");
 214 |     |         }
 215 |     |     }
 216 |     | 
 217 |     |     function _ld2sd(uint _amount) internal view virtual returns (uint64) {
 218 |     |         uint amountSD = _amount / _ld2sdRate();
 219 |     |         require(amountSD <= type(uint64).max, "OFTCore: amountSD overflow");
 220 |     |         return uint64(amountSD);
 221 |     |     }
 222 |     | 
 223 |     |     function _sd2ld(uint64 _amountSD) internal view virtual returns (uint) {
 224 |     |         return _amountSD * _ld2sdRate();
 225 |     |     }
 226 |     | 
 227 |     |     function _removeDust(uint _amount) internal view virtual returns (uint amountAfter, uint dust) {
 228 |     |         dust = _amount % _ld2sdRate();
 229 |     |         amountAfter = _amount - dust;
 230 |     |     }
 231 |     | 
 232 |     |     function _encodeSendPayload(bytes32 _toAddress, uint64 _amountSD) internal view virtual returns (bytes memory) {
 233 |     |         return abi.encodePacked(PT_SEND, _toAddress, _amountSD);
 234 |     |     }
 235 |     | 
 236 |     |     function _decodeSendPayload(bytes memory _payload) internal view virtual returns (address to, uint64 amountSD) {
 237 |     |         require(_payload.toUint8(0) == PT_SEND && _payload.length == 41, "OFTCore: invalid payload");
 238 |     | 
 239 |     |         to = _payload.toAddress(13); // drop the first 12 bytes of bytes32
 240 |     |         amountSD = _payload.toUint64(33);
 241 |     |     }
 242 |     | 
 243 |     |     function _encodeSendAndCallPayload(
 244 |     |         address _from,
 245 |     |         bytes32 _toAddress,
 246 |     |         uint64 _amountSD,
 247 |     |         bytes memory _payload,
 248 |     |         uint64 _dstGasForCall
 249 |     |     ) internal view virtual returns (bytes memory) {
 250 |     |         return abi.encodePacked(PT_SEND_AND_CALL, _toAddress, _amountSD, _addressToBytes32(_from), _dstGasForCall, _payload);
 251 |     |     }
 252 |     | 
 253 |     |     function _decodeSendAndCallPayload(
 254 |     |         bytes memory _payload
 255 |     |     ) internal view virtual returns (bytes32 from, address to, uint64 amountSD, bytes memory payload, uint64 dstGasForCall) {
 256 |     |         require(_payload.toUint8(0) == PT_SEND_AND_CALL, "OFTCore: invalid payload");
 257 |     | 
 258 |     |         to = _payload.toAddress(13); // drop the first 12 bytes of bytes32
 259 |     |         amountSD = _payload.toUint64(33);
 260 |     |         from = _payload.toBytes32(41);
 261 |     |         dstGasForCall = _payload.toUint64(73);
 262 |     |         payload = _payload.slice(81, _payload.length - 81);
 263 |     |     }
 264 |     | 
 265 |     |     function _addressToBytes32(address _address) internal pure virtual returns (bytes32) {
 266 |     |         return bytes32(uint(uint160(_address)));
 267 |     |     }
 268 |     | 
 269 |     |     function _debitFrom(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount) internal virtual returns (uint);
 270 |     | 
 271 |     |     function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns (uint);
 272 |     | 
 273 |     |     function _ld2sdRate() internal view virtual returns (uint);
 274 |     | }
 275 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/tokens/LzProxyOFTV2.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {LzBaseOFTV2} from "tokens/LzBaseOFTV2.sol";
  5 |     | import {SafeERC20, IERC20} from "openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol";
  6 |     | 
  7 |     | contract LzProxyOFTV2 is LzBaseOFTV2 {
  8 |     |     using SafeERC20 for IERC20;
  9 |     | 
 10 |     |     IERC20 public immutable innerToken;
 11 |     |     uint public immutable ld2sdRate;
 12 |     | 
 13 |     |     constructor(
 14 |     |         address _token,
 15 |     |         uint8 _sharedDecimals,
 16 |     |         address _lzEndpoint,
 17 |     |         address _owner
 18 |     |     ) LzBaseOFTV2(_sharedDecimals, _lzEndpoint, _owner) {
 19 |     |         innerToken = IERC20(_token);
 20 |     | 
 21 |     |         (bool success, bytes memory data) = _token.staticcall(abi.encodeWithSignature("decimals()"));
 22 |     |         require(success, "ProxyOFT: failed to get token decimals");
 23 |     |         uint8 decimals = abi.decode(data, (uint8));
 24 |     | 
 25 |     |         require(_sharedDecimals <= decimals, "ProxyOFT: sharedDecimals must be <= decimals");
 26 |     |         ld2sdRate = 10 ** (decimals - _sharedDecimals);
 27 |     |     }
 28 |     | 
 29 |     |     /************************************************************************
 30 |     |      * public functions
 31 |     |      ************************************************************************/
 32 |     |     function circulatingSupply() public view virtual override returns (uint) {
 33 |     |         return innerToken.totalSupply() - innerToken.balanceOf(address(this));
 34 |     |     }
 35 |     | 
 36 |     |     function token() public view virtual override returns (address) {
 37 |     |         return address(innerToken);
 38 |     |     }
 39 |     | 
 40 |     |     /************************************************************************
 41 |     |      * internal functions
 42 |     |      ************************************************************************/
 43 |     |     function _debitFrom(address _from, uint16, bytes32, uint _amount) internal virtual override returns (uint) {
 44 |     |         require(_from == msg.sender, "ProxyOFT: owner is not send caller");
 45 |     | 
 46 |     |         innerToken.safeTransferFrom(_from, address(this), _amount);
 47 |     | 
 48 |     |         return _amount;
 49 |     |     }
 50 |     | 
 51 |     |     function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns (uint) {
 52 |     |         innerToken.safeTransfer(_toAddress, _amount);
 53 |     |         return _amount;
 54 |     |     }
 55 |     | 
 56 |     |     function _ld2sdRate() internal view virtual override returns (uint) {
 57 |     |         return ld2sdRate;
 58 |     |     }
 59 |     | }
 60 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/tokens/MagicCurveLp.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {ERC20} from "BoringSolidity/ERC20.sol";
  5 |     | import {Proxy} from "openzeppelin-contracts/proxy/Proxy.sol";
  6 |     | import {Address} from "openzeppelin-contracts/utils/Address.sol";
  7 |     | import {ERC4626} from "./ERC4626.sol";
  8 |     | import {IMagicCurveLpRewardHandler} from "interfaces/IMagicCurveLpRewardHandler.sol";
  9 |     | import {Operatable} from "mixins/Operatable.sol";
 10 |     | 
 11 |     | contract MagicCurveLpData is ERC4626, Operatable {
 12 |     |     error ErrPrivateFunction();
 13 |     |     IMagicCurveLpRewardHandler public rewardHandler;
 14 |     | }
 15 |     | 
 16 |     | contract MagicCurveLp is MagicCurveLpData, Proxy {
 17 |     |     using Address for address;
 18 |     | 
 19 |     |     event LogRewardHandlerChanged(IMagicCurveLpRewardHandler indexed previous, IMagicCurveLpRewardHandler indexed current);
 20 |     | 
 21 |     |     constructor(ERC20 __asset, string memory _name, string memory _symbol) {
 22 |     |         _asset = __asset;
 23 |     |         name = _name;
 24 |     |         symbol = _symbol;
 25 |     |     }
 26 |     | 
 27 |     |     function setRewardHandler(IMagicCurveLpRewardHandler _rewardHandler) external onlyOwner {
 28 |     |         emit LogRewardHandlerChanged(rewardHandler, _rewardHandler);
 29 |     |         rewardHandler = _rewardHandler;
 30 |     |     }
 31 |     | 
 32 |     |     function _afterDeposit(uint256 assets, uint256 /* shares */) internal override {
 33 |     |         address(rewardHandler).functionDelegateCall(abi.encodeWithSelector(IMagicCurveLpRewardHandler.stakeAsset.selector, assets));
 34 |     |     }
 35 |     | 
 36 |     |     function _beforeWithdraw(uint256 assets, uint256 /* shares */) internal override {
 37 |     |         address(rewardHandler).functionDelegateCall(abi.encodeWithSelector(IMagicCurveLpRewardHandler.unstakeAsset.selector, assets));
 38 |     |     }
 39 |     | 
 40 |     |     function _fallback() internal override {
 41 |     |         if (rewardHandler.isPrivateDelegateFunction(msg.sig)) {
 42 |     |             revert ErrPrivateFunction();
 43 |     |         }
 44 |     | 
 45 |     |         _delegate(_implementation());
 46 |     |     }
 47 |     | 
 48 |     |     function _implementation() internal view override returns (address) {
 49 |     |         return address(rewardHandler);
 50 |     |     }
 51 |     | }
 52 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/tokens/MagicGlp.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {ERC20} from "BoringSolidity/ERC20.sol";
  5 |     | import {BoringOwnable} from "BoringSolidity/BoringOwnable.sol";
  6 |     | import {ERC4626} from "tokens/ERC4626.sol";
  7 |     | 
  8 |     | contract MagicGlpData is ERC4626, BoringOwnable {
  9 |     |     error ErrNotStrategyExecutor(address);
 10 |     | 
 11 |     |     address public rewardHandler;
 12 |     |     mapping(address => bool) public strategyExecutors;
 13 |     | 
 14 |     |     modifier onlyStrategyExecutor() {
 15 |     |         if (msg.sender != owner && !strategyExecutors[msg.sender]) {
 16 |     |             revert ErrNotStrategyExecutor(msg.sender);
 17 |     |         }
 18 |     |         _;
 19 |     |     }
 20 |     | }
 21 |     | 
 22 |     | /// @dev Vault version of the GLP Wrapper, auto compound yield increase shares value
 23 |     | contract MagicGlp is MagicGlpData {
 24 |     |     event LogRewardHandlerChanged(address indexed previous, address indexed current);
 25 |     |     event LogStrategyExecutorChanged(address indexed executor, bool allowed);
 26 |     |     event LogStakedGlpChanged(ERC20 indexed previous, ERC20 indexed current);
 27 |     | 
 28 |     |     constructor(
 29 |     |         ERC20 __asset,
 30 |     |         string memory _name,
 31 |     |         string memory _symbol
 32 |     |     ) {
 33 |     |         _asset = __asset;
 34 |     |         name = _name;
 35 |     |         symbol = _symbol;
 36 |     |     }
 37 |     | 
 38 |     |     function setStrategyExecutor(address executor, bool value) external onlyOwner {
 39 |     |         strategyExecutors[executor] = value;
 40 |     |         emit LogStrategyExecutorChanged(executor, value);
 41 |     |     }
 42 |     | 
 43 |     |     function setRewardHandler(address _rewardHandler) external onlyOwner {
 44 |     |         emit LogRewardHandlerChanged(rewardHandler, _rewardHandler);
 45 |     |         rewardHandler = _rewardHandler;
 46 |     |     }
 47 |     | 
 48 |     |     function setStakedGlp(ERC20 _sGlp) external onlyOwner {
 49 |     |         emit LogStakedGlpChanged(_asset, _sGlp);
 50 |     |         _asset = _sGlp;
 51 |     |     }
 52 |     | 
 53 |     |     // Forward unknown function calls to the reward handler.
 54 |     |     fallback() external {
 55 |     |         _delegate(rewardHandler);
 56 |     |     }
 57 |     | 
 58 |     |     /**
 59 |     |      * From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Proxy.sol
 60 |     |      *
 61 |     |      * @dev Delegates the current call to `implementation`.
 62 |     |      *
 63 |     |      * This function does not return to its internal call site, it will return directly to the external caller.
 64 |     |      */
 65 |     |     function _delegate(address implementation) private {
 66 |     |         assembly {
 67 |     |             // Copy msg.data. We take full control of memory in this inline assembly
 68 |     |             // block because it will not return to Solidity code. We overwrite the
 69 |     |             // Solidity scratch pad at memory position 0.
 70 |     |             calldatacopy(0, 0, calldatasize())
 71 |     | 
 72 |     |             // Call the implementation.
 73 |     |             // out and outsize are 0 because we don't know the size yet.
 74 |     |             let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
 75 |     | 
 76 |     |             // Copy the returned data.
 77 |     |             returndatacopy(0, 0, returndatasize())
 78 |     | 
 79 |     |             switch result
 80 |     |             // delegatecall returns 0 on error.
 81 |     |             case 0 {
 82 |     |                 revert(0, returndatasize())
 83 |     |             }
 84 |     |             default {
 85 |     |                 return(0, returndatasize())
 86 |     |             }
 87 |     |         }
 88 |     |     }
 89 |     | }
 90 |     | 

/Users/owenthurm/Desktop/abracadabra-money-contracts-fuzz-public/src/tokens/MintableBurnableERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {ERC20} from "solmate/tokens/ERC20.sol";
  5 |     | import {OperatableV2} from "mixins/OperatableV2.sol";
  6 |     | import {IMintableBurnable} from "interfaces/IMintableBurnable.sol";
  7 |     | 
  8 |     | /// @title MintableBurnableERC20
  9 |     | /// @notice MintableBurnableERC20 is an ERC20 token with mint, burn functions.
 10 |     | /// In this context, operators are allowed minters and burners.
 11 |     | contract MintableBurnableERC20 is ERC20, OperatableV2, IMintableBurnable {
 12 |     |     constructor(
 13 |     |         address _owner,
 14 |     |         string memory name_,
 15 |     |         string memory symbol_,
 16 |     |         uint8 decimals_
 17 |     |     ) ERC20(name_, symbol_, decimals_) OperatableV2(_owner) {}
 18 |     | 
 19 |     |     function burn(address from, uint256 amount) external onlyOperators returns (bool) {
 20 |     |         _burn(from, amount);
 21 |     |         return true;
 22 |     |     }
 23 |     | 
 24 |     |     function mint(address to, uint256 amount) external onlyOperators returns (bool) {
 25 |     |         _mint(to, amount);
 26 |     |         return true;
 27 |     |     }
 28 |     | }

